module GitHub_v3_REST_API exposing (Accepted, ActionsBillingUsage, ActionsCacheList, ActionsCacheUsageByRepository, ActionsCacheUsageOrgEnterprise, ActionsCanApprovePullRequestReviews, ActionsDefaultWorkflowPermissions, ActionsEnabled, ActionsEnterprisePermissions, ActionsGetDefaultWorkflowPermissions, ActionsOrganizationPermissions, ActionsPublicKey, ActionsRepositoryPermissions, ActionsRunnerLabels, ActionsRunnerLabelsReadonly, ActionsSecret, ActionsSetDefaultWorkflowPermissions, ActionsWorkflowAccessToRepository, Actor, AddedToProjectIssueEvent, AdvancedSecurityActiveCommitters, AdvancedSecurityActiveCommittersRepository, AdvancedSecurityActiveCommittersUser, AlertCreatedAt, AlertDismissedAt, AlertFixedAt, AlertHtmlUrl, AlertInstancesUrl, AlertNumber, AlertUpdatedAt, AlertUrl, AllowedActions, ApiOverview, AppPermissions, Artifact, AssignedIssueEvent, AuthenticationToken, AuthorAssociation, Authorization, AutoMerge, Autolink, BadRequest, BaseGist, BasicError, Blob, BranchProtection, BranchRestrictionPolicy, BranchShort, BranchWithProtection, CheckAnnotation, CheckRun, CheckSuite, CheckSuitePreference, CloneTraffic, CodeFrequencyStat, CodeOfConduct, CodeOfConductSimple, CodeScanningAlert, CodeScanningAlertClassification, CodeScanningAlertDismissedComment, CodeScanningAlertDismissedReason, CodeScanningAlertEnvironment, CodeScanningAlertInstance, CodeScanningAlertItems, CodeScanningAlertLocation, CodeScanningAlertRule, CodeScanningAlertRuleSummary, CodeScanningAlertSetState, CodeScanningAlertState, CodeScanningAnalysis, CodeScanningAnalysisAnalysisKey, CodeScanningAnalysisCategory, CodeScanningAnalysisCommitSha, CodeScanningAnalysisCreatedAt, CodeScanningAnalysisDeletion, CodeScanningAnalysisEnvironment, CodeScanningAnalysisSarifFile, CodeScanningAnalysisSarifId, CodeScanningAnalysisTool, CodeScanningAnalysisToolGuid, CodeScanningAnalysisToolName, CodeScanningAnalysisToolVersion, CodeScanningAnalysisUrl, CodeScanningCodeqlDatabase, CodeScanningForbiddenRead, CodeScanningForbiddenWrite, CodeScanningOrganizationAlertItems, CodeScanningRef, CodeScanningSarifsReceipt, CodeScanningSarifsStatus, CodeSearchResultItem, CodeownersErrors, Codespace, CodespaceExportDetails, CodespaceMachine, CodespacesOrgSecret, CodespacesPublicKey, CodespacesSecret, CodespacesUserPublicKey, Collaborator, CombinedBillingUsage, CombinedCommitStatus, Commit, CommitActivity, CommitComment, CommitComparison, CommitSearchResultItem, CommunityHealthFile, CommunityProfile, Conflict, ContentDirectory, ContentFile, ContentSubmodule, ContentSymlink, ContentTraffic, ContentTree, Contributor, ContributorActivity, ConvertedNoteToIssueIssueEvent, DemilestonedIssueEvent, DependabotAlert, DependabotAlertPackage, DependabotAlertSecurityAdvisory, DependabotAlertSecurityVulnerability, DependabotPublicKey, DependabotSecret, Dependency, DependencyGraphDiff, DeployKey, Deployment, DeploymentBranchPolicy, DeploymentBranchPolicyNamePattern, DeploymentBranchPolicySettings, DeploymentReviewerType, DeploymentSimple, DeploymentStatus, DiffEntry, Email, EmptyObject, EnabledOrganizations, EnabledRepositories, Enterprise, Environment, EnvironmentApprovals, Event, Feed, FileCommit, Forbidden, ForbiddenGist, FullRepository, GistComment, GistCommit, GistHistory, GistSimple, GitCommit, GitRef, GitTag, GitTree, GitUser, GitignoreTemplate, Gone, GpgKey, Hook, HookDelivery, HookDeliveryItem, HookResponse, Hovercard, Import, Installation, InstallationToken, Integration, InteractionExpiry, InteractionGroup, InteractionLimit, InteractionLimitResponse, InternalError, Issue, IssueComment, IssueEvent, IssueEventDismissedReview, IssueEventForIssue, IssueEventLabel, IssueEventMilestone, IssueEventProjectCard, IssueEventRename, IssueSearchResultItem, Job, Key, KeySimple, Label, LabelSearchResultItem, LabeledIssueEvent, Language, License, LicenseContent, LicenseSimple, Link, LinkWithType, LockedIssueEvent, Manifest, MarketplaceAccount, MarketplaceListingPlan, MarketplacePurchase, MergedUpstream, Metadata, Migration, Milestone, MilestonedIssueEvent, MinimalRepository, MovedColumnInProjectIssueEvent, MovedPermanently, NotFound, Nullable(..), OrgHook, OrgMembership, OrganizationActionsSecret, OrganizationCustomRepositoryRole, OrganizationDependabotSecret, OrganizationFineGrainedPermission, OrganizationFull, OrganizationInvitation, OrganizationSecretScanningAlert, OrganizationSimple, Package, PackageVersion, PackagesBillingUsage, Page, PageBuild, PageBuildStatus, PageDeployment, PagesHealthCheck, PagesHttpsCertificate, PagesSourceHash, ParticipationStats, PendingDeployment, PorterAuthor, PorterLargeFile, PrivateUser, Project, ProjectCard, ProjectCollaboratorPermission, ProjectColumn, ProtectedBranch, ProtectedBranchAdminEnforced, ProtectedBranchPullRequestReview, ProtectedBranchRequiredStatusCheck, PublicUser, PullRequest, PullRequestMergeResult, PullRequestMinimal, PullRequestReview, PullRequestReviewComment, PullRequestReviewRequest, PullRequestSimple, RateLimit, RateLimitOverview, Reaction, ReactionRollup, ReferencedWorkflow, ReferrerTraffic, Release, ReleaseAsset, ReleaseNotesContent, RemovedFromProjectIssueEvent, RenamedIssueEvent, RepoCodespacesSecret, RepoSearchResultItem, Repository, RepositoryCollaboratorPermission, RepositoryInvitation, RepositorySubscription, RequiresAuthentication, ReviewComment, ReviewDismissedIssueEvent, ReviewRequestRemovedIssueEvent, ReviewRequestedIssueEvent, Root, Runner, RunnerApplication, RunnerGroupsEnterprise, RunnerGroupsOrg, RunnerLabel, ScimError, ScopedInstallation, SearchResultTextMatches, SecretScanningAlert, SecretScanningAlertResolution, SecretScanningAlertResolutionComment, SecretScanningAlertState, SecretScanningLocation, SecretScanningLocationCommit, SecurityAndAnalysis, SelectedActions, SelectedActionsUrl, ServerStatistics, ServiceUnavailable, ShortBlob, ShortBranch, SimpleCommit, SimpleCommitStatus, SimpleInstallation, SimpleRepository, SimpleUser, Snapshot, SshSigningKey, Stargazer, StarredRepository, StateChangeIssueEvent, Status, StatusCheckPolicy, Tag, TagProtection, Team, TeamDiscussion, TeamDiscussionComment, TeamFull, TeamMembership, TeamOrganization, TeamProject, TeamRepository, TeamSimple, TemporaryRedirect, Thread, ThreadSubscription, TimelineAssignedIssueEvent, TimelineCommentEvent, TimelineCommitCommentedEvent, TimelineCommittedEvent, TimelineCrossReferencedEvent, TimelineIssueEvents, TimelineLineCommentedEvent, TimelineReviewedEvent, TimelineUnassignedIssueEvent, Topic, TopicSearchResultItem, Traffic, UnassignedIssueEvent, UnlabeledIssueEvent, UserMarketplacePurchase, UserSearchResultItem, ValidationError, ValidationErrorSimple, ValidationFailed, ValidationFailedSimple, Verification, ViewTraffic, WaitTimer, WebhookConfig, WebhookConfigContentType, WebhookConfigInsecureSsl, WebhookConfigSecret, WebhookConfigUrl, WebhookDependabotAlertCreated, WebhookDependabotAlertDismissed, WebhookDependabotAlertFixed, WebhookDependabotAlertReintroduced, WebhookDependabotAlertReopened, WebhookMergeGroupChecksRequested, Workflow, WorkflowRun, WorkflowRunUsage, WorkflowUsage, actionsAddCustomLabelsToSelfHostedRunnerForOrg, actionsAddCustomLabelsToSelfHostedRunnerForRepo, actionsAddSelectedRepoToOrgSecret, actionsAddSelfHostedRunnerToGroupForOrg, actionsApproveWorkflowRun, actionsCancelWorkflowRun, actionsCreateOrUpdateEnvironmentSecret, actionsCreateOrUpdateOrgSecret, actionsCreateOrUpdateRepoSecret, actionsCreateRegistrationTokenForOrg, actionsCreateRegistrationTokenForRepo, actionsCreateRemoveTokenForOrg, actionsCreateRemoveTokenForRepo, actionsCreateSelfHostedRunnerGroupForOrg, actionsCreateWorkflowDispatch, actionsDeleteActionsCacheById, actionsDeleteActionsCacheByKey, actionsDeleteArtifact, actionsDeleteEnvironmentSecret, actionsDeleteOrgSecret, actionsDeleteRepoSecret, actionsDeleteSelfHostedRunnerFromOrg, actionsDeleteSelfHostedRunnerFromRepo, actionsDeleteSelfHostedRunnerGroupFromOrg, actionsDeleteWorkflowRun, actionsDeleteWorkflowRunLogs, actionsDisableSelectedRepositoryGithubActionsOrganization, actionsDisableWorkflow, actionsEnableSelectedRepositoryGithubActionsOrganization, actionsEnableWorkflow, actionsGetActionsCacheList, actionsGetActionsCacheUsage, actionsGetActionsCacheUsageByRepoForOrg, actionsGetActionsCacheUsageForEnterprise, actionsGetActionsCacheUsageForOrg, actionsGetAllowedActionsOrganization, actionsGetAllowedActionsRepository, actionsGetArtifact, actionsGetEnvironmentPublicKey, actionsGetEnvironmentSecret, actionsGetGithubActionsDefaultWorkflowPermissionsEnterprise, actionsGetGithubActionsDefaultWorkflowPermissionsOrganization, actionsGetGithubActionsDefaultWorkflowPermissionsRepository, actionsGetGithubActionsPermissionsOrganization, actionsGetGithubActionsPermissionsRepository, actionsGetJobForWorkflowRun, actionsGetOrgPublicKey, actionsGetOrgSecret, actionsGetPendingDeploymentsForRun, actionsGetRepoPublicKey, actionsGetRepoSecret, actionsGetReviewsForRun, actionsGetSelfHostedRunnerForOrg, actionsGetSelfHostedRunnerForRepo, actionsGetSelfHostedRunnerGroupForOrg, actionsGetWorkflow, actionsGetWorkflowAccessToRepository, actionsGetWorkflowRun, actionsGetWorkflowRunAttempt, actionsGetWorkflowRunUsage, actionsGetWorkflowUsage, actionsListArtifactsForRepo, actionsListEnvironmentSecrets, actionsListJobsForWorkflowRun, actionsListJobsForWorkflowRunAttempt, actionsListLabelsForSelfHostedRunnerForOrg, actionsListLabelsForSelfHostedRunnerForRepo, actionsListOrgSecrets, actionsListRepoAccessToSelfHostedRunnerGroupInOrg, actionsListRepoSecrets, actionsListRepoWorkflows, actionsListRunnerApplicationsForOrg, actionsListRunnerApplicationsForRepo, actionsListSelectedReposForOrgSecret, actionsListSelectedRepositoriesEnabledGithubActionsOrganization, actionsListSelfHostedRunnerGroupsForOrg, actionsListSelfHostedRunnersForOrg, actionsListSelfHostedRunnersForRepo, actionsListSelfHostedRunnersInGroupForOrg, actionsListWorkflowRunArtifacts, actionsListWorkflowRuns, actionsListWorkflowRunsForRepo, actionsReRunJobForWorkflowRun, actionsReRunWorkflow, actionsReRunWorkflowFailedJobs, actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg, actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo, actionsRemoveCustomLabelFromSelfHostedRunnerForOrg, actionsRemoveCustomLabelFromSelfHostedRunnerForRepo, actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg, actionsRemoveSelectedRepoFromOrgSecret, actionsRemoveSelfHostedRunnerFromGroupForOrg, actionsReviewPendingDeploymentsForRun, actionsSetAllowedActionsOrganization, actionsSetAllowedActionsRepository, actionsSetCustomLabelsForSelfHostedRunnerForOrg, actionsSetCustomLabelsForSelfHostedRunnerForRepo, actionsSetGithubActionsDefaultWorkflowPermissionsEnterprise, actionsSetGithubActionsDefaultWorkflowPermissionsOrganization, actionsSetGithubActionsDefaultWorkflowPermissionsRepository, actionsSetGithubActionsPermissionsOrganization, actionsSetGithubActionsPermissionsRepository, actionsSetRepoAccessToSelfHostedRunnerGroupInOrg, actionsSetSelectedReposForOrgSecret, actionsSetSelectedRepositoriesEnabledGithubActionsOrganization, actionsSetSelfHostedRunnersInGroupForOrg, actionsSetWorkflowAccessToRepository, actionsUpdateSelfHostedRunnerGroupForOrg, activityCheckRepoIsStarredByAuthenticatedUser, activityDeleteRepoSubscription, activityDeleteThreadSubscription, activityGetFeeds, activityGetRepoSubscription, activityGetThread, activityGetThreadSubscriptionForAuthenticatedUser, activityListEventsForAuthenticatedUser, activityListNotificationsForAuthenticatedUser, activityListOrgEventsForAuthenticatedUser, activityListPublicEvents, activityListPublicEventsForRepoNetwork, activityListPublicEventsForUser, activityListPublicOrgEvents, activityListReceivedEventsForUser, activityListReceivedPublicEventsForUser, activityListRepoEvents, activityListRepoNotificationsForAuthenticatedUser, activityListReposStarredByAuthenticatedUser, activityListReposStarredByUser, activityListReposWatchedByUser, activityListStargazersForRepo, activityListWatchedReposForAuthenticatedUser, activityListWatchersForRepo, activityMarkNotificationsAsRead, activityMarkRepoNotificationsAsRead, activityMarkThreadAsRead, activitySetRepoSubscription, activitySetThreadSubscription, activityStarRepoForAuthenticatedUser, activityUnstarRepoForAuthenticatedUser, appsAddRepoToInstallationForAuthenticatedUser, appsCheckToken, appsCreateFromManifest, appsCreateInstallationAccessToken, appsDeleteAuthorization, appsDeleteInstallation, appsDeleteToken, appsGetAuthenticated, appsGetBySlug, appsGetInstallation, appsGetOrgInstallation, appsGetRepoInstallation, appsGetSubscriptionPlanForAccount, appsGetSubscriptionPlanForAccountStubbed, appsGetUserInstallation, appsGetWebhookConfigForApp, appsGetWebhookDelivery, appsListAccountsForPlan, appsListAccountsForPlanStubbed, appsListInstallationReposForAuthenticatedUser, appsListInstallations, appsListInstallationsForAuthenticatedUser, appsListPlans, appsListPlansStubbed, appsListReposAccessibleToInstallation, appsListSubscriptionsForAuthenticatedUser, appsListSubscriptionsForAuthenticatedUserStubbed, appsListWebhookDeliveries, appsRedeliverWebhookDelivery, appsRemoveRepoFromInstallationForAuthenticatedUser, appsResetToken, appsRevokeInstallationAccessToken, appsScopeToken, appsSuspendInstallation, appsUnsuspendInstallation, appsUpdateWebhookConfigForApp, billingGetGithubActionsBillingOrg, billingGetGithubActionsBillingUser, billingGetGithubAdvancedSecurityBillingGhe, billingGetGithubAdvancedSecurityBillingOrg, billingGetGithubPackagesBillingOrg, billingGetGithubPackagesBillingUser, billingGetSharedStorageBillingOrg, billingGetSharedStorageBillingUser, checksCreate, checksCreateSuite, checksGet, checksGetSuite, checksListAnnotations, checksListForRef, checksListForSuite, checksListSuitesForRef, checksRerequestRun, checksRerequestSuite, checksSetSuitesPreferences, checksUpdate, codeScanningDeleteAnalysis, codeScanningGetAlert, codeScanningGetAnalysis, codeScanningGetCodeqlDatabase, codeScanningGetSarif, codeScanningListAlertInstances, codeScanningListAlertsForEnterprise, codeScanningListAlertsForOrg, codeScanningListAlertsForRepo, codeScanningListCodeqlDatabases, codeScanningListRecentAnalyses, codeScanningUpdateAlert, codeScanningUploadSarif, codesOfConductGetAllCodesOfConduct, codesOfConductGetConductCode, codespacesAddRepositoryForSecretForAuthenticatedUser, codespacesAddSelectedRepoToOrgSecret, codespacesCodespaceMachinesForAuthenticatedUser, codespacesCreateForAuthenticatedUser, codespacesCreateOrUpdateOrgSecret, codespacesCreateOrUpdateRepoSecret, codespacesCreateOrUpdateSecretForAuthenticatedUser, codespacesCreateWithPrForAuthenticatedUser, codespacesCreateWithRepoForAuthenticatedUser, codespacesDeleteForAuthenticatedUser, codespacesDeleteFromOrganization, codespacesDeleteOrgSecret, codespacesDeleteRepoSecret, codespacesDeleteSecretForAuthenticatedUser, codespacesExportForAuthenticatedUser, codespacesGetCodespacesForUserInOrg, codespacesGetExportDetailsForAuthenticatedUser, codespacesGetForAuthenticatedUser, codespacesGetOrgPublicKey, codespacesGetOrgSecret, codespacesGetPublicKeyForAuthenticatedUser, codespacesGetRepoPublicKey, codespacesGetRepoSecret, codespacesGetSecretForAuthenticatedUser, codespacesListDevcontainersInRepositoryForAuthenticatedUser, codespacesListForAuthenticatedUser, codespacesListInOrganization, codespacesListInRepositoryForAuthenticatedUser, codespacesListOrgSecrets, codespacesListRepoSecrets, codespacesListRepositoriesForSecretForAuthenticatedUser, codespacesListSecretsForAuthenticatedUser, codespacesListSelectedReposForOrgSecret, codespacesPreFlightWithRepoForAuthenticatedUser, codespacesRemoveRepositoryForSecretForAuthenticatedUser, codespacesRemoveSelectedRepoFromOrgSecret, codespacesRepoMachinesForAuthenticatedUser, codespacesSetCodespacesBilling, codespacesSetRepositoriesForSecretForAuthenticatedUser, codespacesSetSelectedReposForOrgSecret, codespacesStartForAuthenticatedUser, codespacesStopForAuthenticatedUser, codespacesStopInOrganization, codespacesUpdateForAuthenticatedUser, decodeAccepted, decodeActionsBillingUsage, decodeActionsCacheList, decodeActionsCacheUsageByRepository, decodeActionsCacheUsageOrgEnterprise, decodeActionsCanApprovePullRequestReviews, decodeActionsDefaultWorkflowPermissions, decodeActionsEnabled, decodeActionsEnterprisePermissions, decodeActionsGetDefaultWorkflowPermissions, decodeActionsOrganizationPermissions, decodeActionsPublicKey, decodeActionsRepositoryPermissions, decodeActionsRunnerLabels, decodeActionsRunnerLabelsReadonly, decodeActionsSecret, decodeActionsSetDefaultWorkflowPermissions, decodeActionsWorkflowAccessToRepository, decodeActor, decodeAddedToProjectIssueEvent, decodeAdvancedSecurityActiveCommitters, decodeAdvancedSecurityActiveCommittersRepository, decodeAdvancedSecurityActiveCommittersUser, decodeAlertCreatedAt, decodeAlertDismissedAt, decodeAlertFixedAt, decodeAlertHtmlUrl, decodeAlertInstancesUrl, decodeAlertNumber, decodeAlertUpdatedAt, decodeAlertUrl, decodeAllowedActions, decodeApiOverview, decodeAppPermissions, decodeArtifact, decodeAssignedIssueEvent, decodeAuthenticationToken, decodeAuthorAssociation, decodeAuthorization, decodeAutoMerge, decodeAutolink, decodeBadRequest, decodeBaseGist, decodeBasicError, decodeBlob, decodeBranchProtection, decodeBranchRestrictionPolicy, decodeBranchShort, decodeBranchWithProtection, decodeCheckAnnotation, decodeCheckRun, decodeCheckSuite, decodeCheckSuitePreference, decodeCloneTraffic, decodeCodeFrequencyStat, decodeCodeOfConduct, decodeCodeOfConductSimple, decodeCodeScanningAlert, decodeCodeScanningAlertClassification, decodeCodeScanningAlertDismissedComment, decodeCodeScanningAlertDismissedReason, decodeCodeScanningAlertEnvironment, decodeCodeScanningAlertInstance, decodeCodeScanningAlertItems, decodeCodeScanningAlertLocation, decodeCodeScanningAlertRule, decodeCodeScanningAlertRuleSummary, decodeCodeScanningAlertSetState, decodeCodeScanningAlertState, decodeCodeScanningAnalysis, decodeCodeScanningAnalysisAnalysisKey, decodeCodeScanningAnalysisCategory, decodeCodeScanningAnalysisCommitSha, decodeCodeScanningAnalysisCreatedAt, decodeCodeScanningAnalysisDeletion, decodeCodeScanningAnalysisEnvironment, decodeCodeScanningAnalysisSarifFile, decodeCodeScanningAnalysisSarifId, decodeCodeScanningAnalysisTool, decodeCodeScanningAnalysisToolGuid, decodeCodeScanningAnalysisToolName, decodeCodeScanningAnalysisToolVersion, decodeCodeScanningAnalysisUrl, decodeCodeScanningCodeqlDatabase, decodeCodeScanningForbiddenRead, decodeCodeScanningForbiddenWrite, decodeCodeScanningOrganizationAlertItems, decodeCodeScanningRef, decodeCodeScanningSarifsReceipt, decodeCodeScanningSarifsStatus, decodeCodeSearchResultItem, decodeCodeownersErrors, decodeCodespace, decodeCodespaceExportDetails, decodeCodespaceMachine, decodeCodespacesOrgSecret, decodeCodespacesPublicKey, decodeCodespacesSecret, decodeCodespacesUserPublicKey, decodeCollaborator, decodeCombinedBillingUsage, decodeCombinedCommitStatus, decodeCommit, decodeCommitActivity, decodeCommitComment, decodeCommitComparison, decodeCommitSearchResultItem, decodeCommunityHealthFile, decodeCommunityProfile, decodeConflict, decodeContentDirectory, decodeContentFile, decodeContentSubmodule, decodeContentSymlink, decodeContentTraffic, decodeContentTree, decodeContributor, decodeContributorActivity, decodeConvertedNoteToIssueIssueEvent, decodeDemilestonedIssueEvent, decodeDependabotAlert, decodeDependabotAlertPackage, decodeDependabotAlertSecurityAdvisory, decodeDependabotAlertSecurityVulnerability, decodeDependabotPublicKey, decodeDependabotSecret, decodeDependency, decodeDependencyGraphDiff, decodeDeployKey, decodeDeployment, decodeDeploymentBranchPolicy, decodeDeploymentBranchPolicyNamePattern, decodeDeploymentBranchPolicySettings, decodeDeploymentReviewerType, decodeDeploymentSimple, decodeDeploymentStatus, decodeDiffEntry, decodeEmail, decodeEmptyObject, decodeEnabledOrganizations, decodeEnabledRepositories, decodeEnterprise, decodeEnvironment, decodeEnvironmentApprovals, decodeEvent, decodeFeed, decodeFileCommit, decodeForbidden, decodeForbiddenGist, decodeFullRepository, decodeGistComment, decodeGistCommit, decodeGistHistory, decodeGistSimple, decodeGitCommit, decodeGitRef, decodeGitTag, decodeGitTree, decodeGitUser, decodeGitignoreTemplate, decodeGone, decodeGpgKey, decodeHook, decodeHookDelivery, decodeHookDeliveryItem, decodeHookResponse, decodeHovercard, decodeImport, decodeInstallation, decodeInstallationToken, decodeIntegration, decodeInteractionExpiry, decodeInteractionGroup, decodeInteractionLimit, decodeInteractionLimitResponse, decodeInternalError, decodeIssue, decodeIssueComment, decodeIssueEvent, decodeIssueEventDismissedReview, decodeIssueEventForIssue, decodeIssueEventLabel, decodeIssueEventMilestone, decodeIssueEventProjectCard, decodeIssueEventRename, decodeIssueSearchResultItem, decodeJob, decodeKey, decodeKeySimple, decodeLabel, decodeLabelSearchResultItem, decodeLabeledIssueEvent, decodeLanguage, decodeLicense, decodeLicenseContent, decodeLicenseSimple, decodeLink, decodeLinkWithType, decodeLockedIssueEvent, decodeManifest, decodeMarketplaceAccount, decodeMarketplaceListingPlan, decodeMarketplacePurchase, decodeMergedUpstream, decodeMetadata, decodeMigration, decodeMilestone, decodeMilestonedIssueEvent, decodeMinimalRepository, decodeMovedColumnInProjectIssueEvent, decodeMovedPermanently, decodeNotFound, decodeOrgHook, decodeOrgMembership, decodeOrganizationActionsSecret, decodeOrganizationCustomRepositoryRole, decodeOrganizationDependabotSecret, decodeOrganizationFineGrainedPermission, decodeOrganizationFull, decodeOrganizationInvitation, decodeOrganizationSecretScanningAlert, decodeOrganizationSimple, decodePackage, decodePackageVersion, decodePackagesBillingUsage, decodePage, decodePageBuild, decodePageBuildStatus, decodePageDeployment, decodePagesHealthCheck, decodePagesHttpsCertificate, decodePagesSourceHash, decodeParticipationStats, decodePendingDeployment, decodePorterAuthor, decodePorterLargeFile, decodePrivateUser, decodeProject, decodeProjectCard, decodeProjectCollaboratorPermission, decodeProjectColumn, decodeProtectedBranch, decodeProtectedBranchAdminEnforced, decodeProtectedBranchPullRequestReview, decodeProtectedBranchRequiredStatusCheck, decodePublicUser, decodePullRequest, decodePullRequestMergeResult, decodePullRequestMinimal, decodePullRequestReview, decodePullRequestReviewComment, decodePullRequestReviewRequest, decodePullRequestSimple, decodeRateLimit, decodeRateLimitOverview, decodeReaction, decodeReactionRollup, decodeReferencedWorkflow, decodeReferrerTraffic, decodeRelease, decodeReleaseAsset, decodeReleaseNotesContent, decodeRemovedFromProjectIssueEvent, decodeRenamedIssueEvent, decodeRepoCodespacesSecret, decodeRepoSearchResultItem, decodeRepository, decodeRepositoryCollaboratorPermission, decodeRepositoryInvitation, decodeRepositorySubscription, decodeRequiresAuthentication, decodeReviewComment, decodeReviewDismissedIssueEvent, decodeReviewRequestRemovedIssueEvent, decodeReviewRequestedIssueEvent, decodeRoot, decodeRunner, decodeRunnerApplication, decodeRunnerGroupsEnterprise, decodeRunnerGroupsOrg, decodeRunnerLabel, decodeScimError, decodeScopedInstallation, decodeSearchResultTextMatches, decodeSecretScanningAlert, decodeSecretScanningAlertResolution, decodeSecretScanningAlertResolutionComment, decodeSecretScanningAlertState, decodeSecretScanningLocation, decodeSecretScanningLocationCommit, decodeSecurityAndAnalysis, decodeSelectedActions, decodeSelectedActionsUrl, decodeServerStatistics, decodeServiceUnavailable, decodeShortBlob, decodeShortBranch, decodeSimpleCommit, decodeSimpleCommitStatus, decodeSimpleInstallation, decodeSimpleRepository, decodeSimpleUser, decodeSnapshot, decodeSshSigningKey, decodeStargazer, decodeStarredRepository, decodeStateChangeIssueEvent, decodeStatus, decodeStatusCheckPolicy, decodeTag, decodeTagProtection, decodeTeam, decodeTeamDiscussion, decodeTeamDiscussionComment, decodeTeamFull, decodeTeamMembership, decodeTeamOrganization, decodeTeamProject, decodeTeamRepository, decodeTeamSimple, decodeTemporaryRedirect, decodeThread, decodeThreadSubscription, decodeTimelineAssignedIssueEvent, decodeTimelineCommentEvent, decodeTimelineCommitCommentedEvent, decodeTimelineCommittedEvent, decodeTimelineCrossReferencedEvent, decodeTimelineIssueEvents, decodeTimelineLineCommentedEvent, decodeTimelineReviewedEvent, decodeTimelineUnassignedIssueEvent, decodeTopic, decodeTopicSearchResultItem, decodeTraffic, decodeUnassignedIssueEvent, decodeUnlabeledIssueEvent, decodeUserMarketplacePurchase, decodeUserSearchResultItem, decodeValidationError, decodeValidationErrorSimple, decodeValidationFailed, decodeValidationFailedSimple, decodeVerification, decodeViewTraffic, decodeWaitTimer, decodeWebhookConfig, decodeWebhookConfigContentType, decodeWebhookConfigInsecureSsl, decodeWebhookConfigSecret, decodeWebhookConfigUrl, decodeWebhookDependabotAlertCreated, decodeWebhookDependabotAlertDismissed, decodeWebhookDependabotAlertFixed, decodeWebhookDependabotAlertReintroduced, decodeWebhookDependabotAlertReopened, decodeWebhookMergeGroupChecksRequested, decodeWorkflow, decodeWorkflowRun, decodeWorkflowRunUsage, decodeWorkflowUsage, dependabotAddSelectedRepoToOrgSecret, dependabotCreateOrUpdateOrgSecret, dependabotCreateOrUpdateRepoSecret, dependabotDeleteOrgSecret, dependabotDeleteRepoSecret, dependabotGetAlert, dependabotGetOrgPublicKey, dependabotGetOrgSecret, dependabotGetRepoPublicKey, dependabotGetRepoSecret, dependabotListAlertsForRepo, dependabotListOrgSecrets, dependabotListRepoSecrets, dependabotListSelectedReposForOrgSecret, dependabotRemoveSelectedRepoFromOrgSecret, dependabotSetSelectedReposForOrgSecret, dependabotUpdateAlert, dependencyGraphCreateRepositorySnapshot, dependencyGraphDiffRange, emojisGet, encodeAccepted, encodeActionsBillingUsage, encodeActionsCacheList, encodeActionsCacheUsageByRepository, encodeActionsCacheUsageOrgEnterprise, encodeActionsCanApprovePullRequestReviews, encodeActionsDefaultWorkflowPermissions, encodeActionsEnabled, encodeActionsEnterprisePermissions, encodeActionsGetDefaultWorkflowPermissions, encodeActionsOrganizationPermissions, encodeActionsPublicKey, encodeActionsRepositoryPermissions, encodeActionsRunnerLabels, encodeActionsRunnerLabelsReadonly, encodeActionsSecret, encodeActionsSetDefaultWorkflowPermissions, encodeActionsWorkflowAccessToRepository, encodeActor, encodeAddedToProjectIssueEvent, encodeAdvancedSecurityActiveCommitters, encodeAdvancedSecurityActiveCommittersRepository, encodeAdvancedSecurityActiveCommittersUser, encodeAlertCreatedAt, encodeAlertDismissedAt, encodeAlertFixedAt, encodeAlertHtmlUrl, encodeAlertInstancesUrl, encodeAlertNumber, encodeAlertUpdatedAt, encodeAlertUrl, encodeAllowedActions, encodeApiOverview, encodeAppPermissions, encodeArtifact, encodeAssignedIssueEvent, encodeAuthenticationToken, encodeAuthorAssociation, encodeAuthorization, encodeAutoMerge, encodeAutolink, encodeBadRequest, encodeBaseGist, encodeBasicError, encodeBlob, encodeBranchProtection, encodeBranchRestrictionPolicy, encodeBranchShort, encodeBranchWithProtection, encodeCheckAnnotation, encodeCheckRun, encodeCheckSuite, encodeCheckSuitePreference, encodeCloneTraffic, encodeCodeFrequencyStat, encodeCodeOfConduct, encodeCodeOfConductSimple, encodeCodeScanningAlert, encodeCodeScanningAlertClassification, encodeCodeScanningAlertDismissedComment, encodeCodeScanningAlertDismissedReason, encodeCodeScanningAlertEnvironment, encodeCodeScanningAlertInstance, encodeCodeScanningAlertItems, encodeCodeScanningAlertLocation, encodeCodeScanningAlertRule, encodeCodeScanningAlertRuleSummary, encodeCodeScanningAlertSetState, encodeCodeScanningAlertState, encodeCodeScanningAnalysis, encodeCodeScanningAnalysisAnalysisKey, encodeCodeScanningAnalysisCategory, encodeCodeScanningAnalysisCommitSha, encodeCodeScanningAnalysisCreatedAt, encodeCodeScanningAnalysisDeletion, encodeCodeScanningAnalysisEnvironment, encodeCodeScanningAnalysisSarifFile, encodeCodeScanningAnalysisSarifId, encodeCodeScanningAnalysisTool, encodeCodeScanningAnalysisToolGuid, encodeCodeScanningAnalysisToolName, encodeCodeScanningAnalysisToolVersion, encodeCodeScanningAnalysisUrl, encodeCodeScanningCodeqlDatabase, encodeCodeScanningForbiddenRead, encodeCodeScanningForbiddenWrite, encodeCodeScanningOrganizationAlertItems, encodeCodeScanningRef, encodeCodeScanningSarifsReceipt, encodeCodeScanningSarifsStatus, encodeCodeSearchResultItem, encodeCodeownersErrors, encodeCodespace, encodeCodespaceExportDetails, encodeCodespaceMachine, encodeCodespacesOrgSecret, encodeCodespacesPublicKey, encodeCodespacesSecret, encodeCodespacesUserPublicKey, encodeCollaborator, encodeCombinedBillingUsage, encodeCombinedCommitStatus, encodeCommit, encodeCommitActivity, encodeCommitComment, encodeCommitComparison, encodeCommitSearchResultItem, encodeCommunityHealthFile, encodeCommunityProfile, encodeConflict, encodeContentDirectory, encodeContentFile, encodeContentSubmodule, encodeContentSymlink, encodeContentTraffic, encodeContentTree, encodeContributor, encodeContributorActivity, encodeConvertedNoteToIssueIssueEvent, encodeDemilestonedIssueEvent, encodeDependabotAlert, encodeDependabotAlertPackage, encodeDependabotAlertSecurityAdvisory, encodeDependabotAlertSecurityVulnerability, encodeDependabotPublicKey, encodeDependabotSecret, encodeDependency, encodeDependencyGraphDiff, encodeDeployKey, encodeDeployment, encodeDeploymentBranchPolicy, encodeDeploymentBranchPolicyNamePattern, encodeDeploymentBranchPolicySettings, encodeDeploymentReviewerType, encodeDeploymentSimple, encodeDeploymentStatus, encodeDiffEntry, encodeEmail, encodeEmptyObject, encodeEnabledOrganizations, encodeEnabledRepositories, encodeEnterprise, encodeEnvironment, encodeEnvironmentApprovals, encodeEvent, encodeFeed, encodeFileCommit, encodeForbidden, encodeForbiddenGist, encodeFullRepository, encodeGistComment, encodeGistCommit, encodeGistHistory, encodeGistSimple, encodeGitCommit, encodeGitRef, encodeGitTag, encodeGitTree, encodeGitUser, encodeGitignoreTemplate, encodeGone, encodeGpgKey, encodeHook, encodeHookDelivery, encodeHookDeliveryItem, encodeHookResponse, encodeHovercard, encodeImport, encodeInstallation, encodeInstallationToken, encodeIntegration, encodeInteractionExpiry, encodeInteractionGroup, encodeInteractionLimit, encodeInteractionLimitResponse, encodeInternalError, encodeIssue, encodeIssueComment, encodeIssueEvent, encodeIssueEventDismissedReview, encodeIssueEventForIssue, encodeIssueEventLabel, encodeIssueEventMilestone, encodeIssueEventProjectCard, encodeIssueEventRename, encodeIssueSearchResultItem, encodeJob, encodeKey, encodeKeySimple, encodeLabel, encodeLabelSearchResultItem, encodeLabeledIssueEvent, encodeLanguage, encodeLicense, encodeLicenseContent, encodeLicenseSimple, encodeLink, encodeLinkWithType, encodeLockedIssueEvent, encodeManifest, encodeMarketplaceAccount, encodeMarketplaceListingPlan, encodeMarketplacePurchase, encodeMergedUpstream, encodeMetadata, encodeMigration, encodeMilestone, encodeMilestonedIssueEvent, encodeMinimalRepository, encodeMovedColumnInProjectIssueEvent, encodeMovedPermanently, encodeNotFound, encodeOrgHook, encodeOrgMembership, encodeOrganizationActionsSecret, encodeOrganizationCustomRepositoryRole, encodeOrganizationDependabotSecret, encodeOrganizationFineGrainedPermission, encodeOrganizationFull, encodeOrganizationInvitation, encodeOrganizationSecretScanningAlert, encodeOrganizationSimple, encodePackage, encodePackageVersion, encodePackagesBillingUsage, encodePage, encodePageBuild, encodePageBuildStatus, encodePageDeployment, encodePagesHealthCheck, encodePagesHttpsCertificate, encodePagesSourceHash, encodeParticipationStats, encodePendingDeployment, encodePorterAuthor, encodePorterLargeFile, encodePrivateUser, encodeProject, encodeProjectCard, encodeProjectCollaboratorPermission, encodeProjectColumn, encodeProtectedBranch, encodeProtectedBranchAdminEnforced, encodeProtectedBranchPullRequestReview, encodeProtectedBranchRequiredStatusCheck, encodePublicUser, encodePullRequest, encodePullRequestMergeResult, encodePullRequestMinimal, encodePullRequestReview, encodePullRequestReviewComment, encodePullRequestReviewRequest, encodePullRequestSimple, encodeRateLimit, encodeRateLimitOverview, encodeReaction, encodeReactionRollup, encodeReferencedWorkflow, encodeReferrerTraffic, encodeRelease, encodeReleaseAsset, encodeReleaseNotesContent, encodeRemovedFromProjectIssueEvent, encodeRenamedIssueEvent, encodeRepoCodespacesSecret, encodeRepoSearchResultItem, encodeRepository, encodeRepositoryCollaboratorPermission, encodeRepositoryInvitation, encodeRepositorySubscription, encodeRequiresAuthentication, encodeReviewComment, encodeReviewDismissedIssueEvent, encodeReviewRequestRemovedIssueEvent, encodeReviewRequestedIssueEvent, encodeRoot, encodeRunner, encodeRunnerApplication, encodeRunnerGroupsEnterprise, encodeRunnerGroupsOrg, encodeRunnerLabel, encodeScimError, encodeScopedInstallation, encodeSearchResultTextMatches, encodeSecretScanningAlert, encodeSecretScanningAlertResolution, encodeSecretScanningAlertResolutionComment, encodeSecretScanningAlertState, encodeSecretScanningLocation, encodeSecretScanningLocationCommit, encodeSecurityAndAnalysis, encodeSelectedActions, encodeSelectedActionsUrl, encodeServerStatistics, encodeServiceUnavailable, encodeShortBlob, encodeShortBranch, encodeSimpleCommit, encodeSimpleCommitStatus, encodeSimpleInstallation, encodeSimpleRepository, encodeSimpleUser, encodeSnapshot, encodeSshSigningKey, encodeStargazer, encodeStarredRepository, encodeStateChangeIssueEvent, encodeStatus, encodeStatusCheckPolicy, encodeTag, encodeTagProtection, encodeTeam, encodeTeamDiscussion, encodeTeamDiscussionComment, encodeTeamFull, encodeTeamMembership, encodeTeamOrganization, encodeTeamProject, encodeTeamRepository, encodeTeamSimple, encodeTemporaryRedirect, encodeThread, encodeThreadSubscription, encodeTimelineAssignedIssueEvent, encodeTimelineCommentEvent, encodeTimelineCommitCommentedEvent, encodeTimelineCommittedEvent, encodeTimelineCrossReferencedEvent, encodeTimelineIssueEvents, encodeTimelineLineCommentedEvent, encodeTimelineReviewedEvent, encodeTimelineUnassignedIssueEvent, encodeTopic, encodeTopicSearchResultItem, encodeTraffic, encodeUnassignedIssueEvent, encodeUnlabeledIssueEvent, encodeUserMarketplacePurchase, encodeUserSearchResultItem, encodeValidationError, encodeValidationErrorSimple, encodeValidationFailed, encodeValidationFailedSimple, encodeVerification, encodeViewTraffic, encodeWaitTimer, encodeWebhookConfig, encodeWebhookConfigContentType, encodeWebhookConfigInsecureSsl, encodeWebhookConfigSecret, encodeWebhookConfigUrl, encodeWebhookDependabotAlertCreated, encodeWebhookDependabotAlertDismissed, encodeWebhookDependabotAlertFixed, encodeWebhookDependabotAlertReintroduced, encodeWebhookDependabotAlertReopened, encodeWebhookMergeGroupChecksRequested, encodeWorkflow, encodeWorkflowRun, encodeWorkflowRunUsage, encodeWorkflowUsage, enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterprise, enterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise, enterpriseAdminAddSelfHostedRunnerToGroupForEnterprise, enterpriseAdminCreateRegistrationTokenForEnterprise, enterpriseAdminCreateRemoveTokenForEnterprise, enterpriseAdminCreateSelfHostedRunnerGroupForEnterprise, enterpriseAdminDeleteSelfHostedRunnerFromEnterprise, enterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise, enterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise, enterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise, enterpriseAdminGetAllowedActionsEnterprise, enterpriseAdminGetGithubActionsPermissionsEnterprise, enterpriseAdminGetSelfHostedRunnerForEnterprise, enterpriseAdminGetSelfHostedRunnerGroupForEnterprise, enterpriseAdminGetServerStatistics, enterpriseAdminListLabelsForSelfHostedRunnerForEnterprise, enterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise, enterpriseAdminListRunnerApplicationsForEnterprise, enterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise, enterpriseAdminListSelfHostedRunnerGroupsForEnterprise, enterpriseAdminListSelfHostedRunnersForEnterprise, enterpriseAdminListSelfHostedRunnersInGroupForEnterprise, enterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterprise, enterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterprise, enterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise, enterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise, enterpriseAdminSetAllowedActionsEnterprise, enterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterprise, enterpriseAdminSetGithubActionsPermissionsEnterprise, enterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise, enterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise, enterpriseAdminSetSelfHostedRunnersInGroupForEnterprise, enterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise, gistsCheckIsStarred, gistsCreate, gistsCreateComment, gistsDelete, gistsDeleteComment, gistsFork, gistsGet, gistsGetComment, gistsGetRevision, gistsList, gistsListComments, gistsListCommits, gistsListForUser, gistsListForks, gistsListPublic, gistsListStarred, gistsStar, gistsUnstar, gistsUpdate, gistsUpdateComment, gitCreateBlob, gitCreateCommit, gitCreateRef, gitCreateTag, gitCreateTree, gitDeleteRef, gitGetBlob, gitGetCommit, gitGetRef, gitGetTag, gitGetTree, gitListMatchingRefs, gitUpdateRef, gitignoreGetAllTemplates, gitignoreGetTemplate, interactionsGetRestrictionsForAuthenticatedUser, interactionsGetRestrictionsForOrg, interactionsGetRestrictionsForRepo, interactionsRemoveRestrictionsForAuthenticatedUser, interactionsRemoveRestrictionsForOrg, interactionsRemoveRestrictionsForRepo, interactionsSetRestrictionsForAuthenticatedUser, interactionsSetRestrictionsForOrg, interactionsSetRestrictionsForRepo, issuesAddAssignees, issuesAddLabels, issuesCheckUserCanBeAssigned, issuesCreate, issuesCreateComment, issuesCreateLabel, issuesCreateMilestone, issuesDeleteComment, issuesDeleteLabel, issuesDeleteMilestone, issuesGet, issuesGetComment, issuesGetEvent, issuesGetLabel, issuesGetMilestone, issuesList, issuesListAssignees, issuesListComments, issuesListCommentsForRepo, issuesListEvents, issuesListEventsForRepo, issuesListEventsForTimeline, issuesListForAuthenticatedUser, issuesListForOrg, issuesListForRepo, issuesListLabelsForMilestone, issuesListLabelsForRepo, issuesListLabelsOnIssue, issuesListMilestones, issuesLock, issuesRemoveAllLabels, issuesRemoveAssignees, issuesRemoveLabel, issuesSetLabels, issuesUnlock, issuesUpdate, issuesUpdateComment, issuesUpdateLabel, issuesUpdateMilestone, licensesGet, licensesGetAllCommonlyUsed, licensesGetForRepo, markdownRender, markdownRenderRaw, metaGet, metaGetOctocat, metaGetZen, metaRoot, migrationsCancelImport, migrationsDeleteArchiveForAuthenticatedUser, migrationsDeleteArchiveForOrg, migrationsGetCommitAuthors, migrationsGetImportStatus, migrationsGetLargeFiles, migrationsGetStatusForAuthenticatedUser, migrationsGetStatusForOrg, migrationsListForAuthenticatedUser, migrationsListForOrg, migrationsListReposForAuthenticatedUser, migrationsListReposForOrg, migrationsMapCommitAuthor, migrationsSetLfsPreference, migrationsStartForAuthenticatedUser, migrationsStartForOrg, migrationsStartImport, migrationsUnlockRepoForAuthenticatedUser, migrationsUnlockRepoForOrg, migrationsUpdateImport, orgsAddSecurityManagerTeam, orgsBlockUser, orgsCancelInvitation, orgsCheckBlockedUser, orgsCheckMembershipForUser, orgsCheckPublicMembershipForUser, orgsConvertMemberToOutsideCollaborator, orgsCreateCustomRole, orgsCreateInvitation, orgsCreateWebhook, orgsDeleteCustomRole, orgsDeleteWebhook, orgsEnableOrDisableSecurityProductOnAllOrgRepos, orgsGet, orgsGetMembershipForAuthenticatedUser, orgsGetMembershipForUser, orgsGetWebhook, orgsGetWebhookConfigForOrg, orgsGetWebhookDelivery, orgsList, orgsListAppInstallations, orgsListBlockedUsers, orgsListCustomRoles, orgsListFailedInvitations, orgsListFineGrainedPermissions, orgsListForAuthenticatedUser, orgsListForUser, orgsListInvitationTeams, orgsListMembers, orgsListMembershipsForAuthenticatedUser, orgsListOutsideCollaborators, orgsListPendingInvitations, orgsListPublicMembers, orgsListSecurityManagerTeams, orgsListWebhookDeliveries, orgsListWebhooks, orgsPingWebhook, orgsRedeliverWebhookDelivery, orgsRemoveMember, orgsRemoveMembershipForUser, orgsRemoveOutsideCollaborator, orgsRemovePublicMembershipForAuthenticatedUser, orgsRemoveSecurityManagerTeam, orgsSetMembershipForUser, orgsSetPublicMembershipForAuthenticatedUser, orgsUnblockUser, orgsUpdate, orgsUpdateCustomRole, orgsUpdateMembershipForAuthenticatedUser, orgsUpdateWebhook, orgsUpdateWebhookConfigForOrg, packagesDeletePackageForAuthenticatedUser, packagesDeletePackageForOrg, packagesDeletePackageForUser, packagesDeletePackageVersionForAuthenticatedUser, packagesDeletePackageVersionForOrg, packagesDeletePackageVersionForUser, packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser, packagesGetAllPackageVersionsForPackageOwnedByOrg, packagesGetAllPackageVersionsForPackageOwnedByUser, packagesGetPackageForAuthenticatedUser, packagesGetPackageForOrganization, packagesGetPackageForUser, packagesGetPackageVersionForAuthenticatedUser, packagesGetPackageVersionForOrganization, packagesGetPackageVersionForUser, packagesListPackagesForAuthenticatedUser, packagesListPackagesForOrganization, packagesListPackagesForUser, packagesRestorePackageForAuthenticatedUser, packagesRestorePackageForOrg, packagesRestorePackageForUser, packagesRestorePackageVersionForAuthenticatedUser, packagesRestorePackageVersionForOrg, packagesRestorePackageVersionForUser, projectsAddCollaborator, projectsCreateCard, projectsCreateColumn, projectsCreateForAuthenticatedUser, projectsCreateForOrg, projectsCreateForRepo, projectsDelete, projectsDeleteCard, projectsDeleteColumn, projectsGet, projectsGetCard, projectsGetColumn, projectsGetPermissionForUser, projectsListCards, projectsListCollaborators, projectsListColumns, projectsListForOrg, projectsListForRepo, projectsListForUser, projectsMoveCard, projectsMoveColumn, projectsRemoveCollaborator, projectsUpdate, projectsUpdateCard, projectsUpdateColumn, pullsCheckIfMerged, pullsCreate, pullsCreateReplyForReviewComment, pullsCreateReview, pullsCreateReviewComment, pullsDeletePendingReview, pullsDeleteReviewComment, pullsDismissReview, pullsGet, pullsGetReview, pullsGetReviewComment, pullsList, pullsListCommentsForReview, pullsListCommits, pullsListFiles, pullsListRequestedReviewers, pullsListReviewComments, pullsListReviewCommentsForRepo, pullsListReviews, pullsMerge, pullsRemoveRequestedReviewers, pullsRequestReviewers, pullsSubmitReview, pullsUpdate, pullsUpdateBranch, pullsUpdateReview, pullsUpdateReviewComment, rateLimitGet, reactionsCreateForCommitComment, reactionsCreateForIssue, reactionsCreateForIssueComment, reactionsCreateForPullRequestReviewComment, reactionsCreateForRelease, reactionsCreateForTeamDiscussionCommentInOrg, reactionsCreateForTeamDiscussionCommentLegacy, reactionsCreateForTeamDiscussionInOrg, reactionsCreateForTeamDiscussionLegacy, reactionsDeleteForCommitComment, reactionsDeleteForIssue, reactionsDeleteForIssueComment, reactionsDeleteForPullRequestComment, reactionsDeleteForRelease, reactionsDeleteForTeamDiscussion, reactionsDeleteForTeamDiscussionComment, reactionsListForCommitComment, reactionsListForIssue, reactionsListForIssueComment, reactionsListForPullRequestReviewComment, reactionsListForRelease, reactionsListForTeamDiscussionCommentInOrg, reactionsListForTeamDiscussionCommentLegacy, reactionsListForTeamDiscussionInOrg, reactionsListForTeamDiscussionLegacy, reposAcceptInvitationForAuthenticatedUser, reposAddAppAccessRestrictions, reposAddCollaborator, reposAddStatusCheckContexts, reposAddTeamAccessRestrictions, reposAddUserAccessRestrictions, reposCheckCollaborator, reposCheckVulnerabilityAlerts, reposCodeownersErrors, reposCompareCommits, reposCreateAutolink, reposCreateCommitComment, reposCreateCommitSignatureProtection, reposCreateCommitStatus, reposCreateDeployKey, reposCreateDeployment, reposCreateDeploymentBranchPolicy, reposCreateDeploymentStatus, reposCreateDispatchEvent, reposCreateForAuthenticatedUser, reposCreateFork, reposCreateInOrg, reposCreateOrUpdateEnvironment, reposCreateOrUpdateFileContents, reposCreatePagesDeployment, reposCreatePagesSite, reposCreateRelease, reposCreateTagProtection, reposCreateUsingTemplate, reposCreateWebhook, reposDeclineInvitationForAuthenticatedUser, reposDelete, reposDeleteAccessRestrictions, reposDeleteAdminBranchProtection, reposDeleteAnEnvironment, reposDeleteAutolink, reposDeleteBranchProtection, reposDeleteCommitComment, reposDeleteCommitSignatureProtection, reposDeleteDeployKey, reposDeleteDeployment, reposDeleteDeploymentBranchPolicy, reposDeleteFile, reposDeleteInvitation, reposDeletePagesSite, reposDeletePullRequestReviewProtection, reposDeleteRelease, reposDeleteReleaseAsset, reposDeleteTagProtection, reposDeleteWebhook, reposDisableAutomatedSecurityFixes, reposDisableLfsForRepo, reposDisableVulnerabilityAlerts, reposEnableAutomatedSecurityFixes, reposEnableLfsForRepo, reposEnableVulnerabilityAlerts, reposGenerateReleaseNotes, reposGet, reposGetAccessRestrictions, reposGetAdminBranchProtection, reposGetAllEnvironments, reposGetAllStatusCheckContexts, reposGetAllTopics, reposGetAppsWithAccessToProtectedBranch, reposGetAutolink, reposGetBranch, reposGetBranchProtection, reposGetClones, reposGetCodeFrequencyStats, reposGetCollaboratorPermissionLevel, reposGetCombinedStatusForRef, reposGetCommit, reposGetCommitActivityStats, reposGetCommitComment, reposGetCommitSignatureProtection, reposGetCommunityProfileMetrics, reposGetContent, reposGetContributorsStats, reposGetDeployKey, reposGetDeployment, reposGetDeploymentBranchPolicy, reposGetDeploymentStatus, reposGetEnvironment, reposGetLatestPagesBuild, reposGetLatestRelease, reposGetPages, reposGetPagesBuild, reposGetPagesHealthCheck, reposGetParticipationStats, reposGetPullRequestReviewProtection, reposGetPunchCardStats, reposGetReadme, reposGetReadmeInDirectory, reposGetRelease, reposGetReleaseAsset, reposGetReleaseByTag, reposGetStatusChecksProtection, reposGetTeamsWithAccessToProtectedBranch, reposGetTopPaths, reposGetTopReferrers, reposGetUsersWithAccessToProtectedBranch, reposGetViews, reposGetWebhook, reposGetWebhookConfigForRepo, reposGetWebhookDelivery, reposListAutolinks, reposListBranches, reposListBranchesForHeadCommit, reposListCollaborators, reposListCommentsForCommit, reposListCommitCommentsForRepo, reposListCommitStatusesForRef, reposListCommits, reposListContributors, reposListDeployKeys, reposListDeploymentBranchPolicies, reposListDeploymentStatuses, reposListDeployments, reposListForAuthenticatedUser, reposListForOrg, reposListForUser, reposListForks, reposListInvitations, reposListInvitationsForAuthenticatedUser, reposListLanguages, reposListPagesBuilds, reposListPublic, reposListPullRequestsAssociatedWithCommit, reposListReleaseAssets, reposListReleases, reposListTagProtection, reposListTags, reposListTeams, reposListWebhookDeliveries, reposListWebhooks, reposMerge, reposMergeUpstream, reposPingWebhook, reposRedeliverWebhookDelivery, reposRemoveAppAccessRestrictions, reposRemoveCollaborator, reposRemoveStatusCheckContexts, reposRemoveStatusCheckProtection, reposRemoveTeamAccessRestrictions, reposRemoveUserAccessRestrictions, reposRenameBranch, reposReplaceAllTopics, reposRequestPagesBuild, reposSetAdminBranchProtection, reposSetAppAccessRestrictions, reposSetStatusCheckContexts, reposSetTeamAccessRestrictions, reposSetUserAccessRestrictions, reposTestPushWebhook, reposTransfer, reposUpdate, reposUpdateBranchProtection, reposUpdateCommitComment, reposUpdateDeploymentBranchPolicy, reposUpdateInformationAboutPagesSite, reposUpdateInvitation, reposUpdatePullRequestReviewProtection, reposUpdateRelease, reposUpdateReleaseAsset, reposUpdateStatusCheckProtection, reposUpdateWebhook, reposUpdateWebhookConfigForRepo, reposUploadReleaseAsset, searchCode, searchCommits, searchIssuesAndPullRequests, searchLabels, searchRepos, searchTopics, searchUsers, secretScanningGetAlert, secretScanningListAlertsForEnterprise, secretScanningListAlertsForOrg, secretScanningListAlertsForRepo, secretScanningListLocationsForAlert, secretScanningUpdateAlert, teamsAddMemberLegacy, teamsAddOrUpdateMembershipForUserInOrg, teamsAddOrUpdateMembershipForUserLegacy, teamsAddOrUpdateProjectPermissionsInOrg, teamsAddOrUpdateProjectPermissionsLegacy, teamsAddOrUpdateRepoPermissionsInOrg, teamsAddOrUpdateRepoPermissionsLegacy, teamsCheckPermissionsForProjectInOrg, teamsCheckPermissionsForProjectLegacy, teamsCheckPermissionsForRepoInOrg, teamsCheckPermissionsForRepoLegacy, teamsCreate, teamsCreateDiscussionCommentInOrg, teamsCreateDiscussionCommentLegacy, teamsCreateDiscussionInOrg, teamsCreateDiscussionLegacy, teamsDeleteDiscussionCommentInOrg, teamsDeleteDiscussionCommentLegacy, teamsDeleteDiscussionInOrg, teamsDeleteDiscussionLegacy, teamsDeleteInOrg, teamsDeleteLegacy, teamsGetByName, teamsGetDiscussionCommentInOrg, teamsGetDiscussionCommentLegacy, teamsGetDiscussionInOrg, teamsGetDiscussionLegacy, teamsGetLegacy, teamsGetMemberLegacy, teamsGetMembershipForUserInOrg, teamsGetMembershipForUserLegacy, teamsList, teamsListChildInOrg, teamsListChildLegacy, teamsListDiscussionCommentsInOrg, teamsListDiscussionCommentsLegacy, teamsListDiscussionsInOrg, teamsListDiscussionsLegacy, teamsListForAuthenticatedUser, teamsListMembersInOrg, teamsListMembersLegacy, teamsListPendingInvitationsInOrg, teamsListPendingInvitationsLegacy, teamsListProjectsInOrg, teamsListProjectsLegacy, teamsListReposInOrg, teamsListReposLegacy, teamsRemoveMemberLegacy, teamsRemoveMembershipForUserInOrg, teamsRemoveMembershipForUserLegacy, teamsRemoveProjectInOrg, teamsRemoveProjectLegacy, teamsRemoveRepoInOrg, teamsRemoveRepoLegacy, teamsUpdateDiscussionCommentInOrg, teamsUpdateDiscussionCommentLegacy, teamsUpdateDiscussionInOrg, teamsUpdateDiscussionLegacy, teamsUpdateInOrg, teamsUpdateLegacy, usersAddEmailForAuthenticatedUser, usersBlock, usersCheckBlocked, usersCheckFollowingForUser, usersCheckPersonIsFollowedByAuthenticated, usersCreateGpgKeyForAuthenticatedUser, usersCreatePublicSshKeyForAuthenticatedUser, usersCreateSshSigningKeyForAuthenticatedUser, usersDeleteEmailForAuthenticatedUser, usersDeleteGpgKeyForAuthenticatedUser, usersDeletePublicSshKeyForAuthenticatedUser, usersDeleteSshSigningKeyForAuthenticatedUser, usersFollow, usersGetAuthenticated, usersGetByUsername, usersGetContextForUser, usersGetGpgKeyForAuthenticatedUser, usersGetPublicSshKeyForAuthenticatedUser, usersGetSshSigningKeyForAuthenticatedUser, usersList, usersListBlockedByAuthenticatedUser, usersListEmailsForAuthenticatedUser, usersListFollowedByAuthenticatedUser, usersListFollowersForAuthenticatedUser, usersListFollowersForUser, usersListFollowingForUser, usersListGpgKeysForAuthenticatedUser, usersListGpgKeysForUser, usersListPublicEmailsForAuthenticatedUser, usersListPublicKeysForUser, usersListPublicSshKeysForAuthenticatedUser, usersListSshSigningKeysForAuthenticatedUser, usersListSshSigningKeysForUser, usersSetPrimaryEmailVisibilityForAuthenticatedUser, usersUnblock, usersUnfollow, usersUpdateAuthenticated)

{-| 
## Request functions

@docs metaGetZen, activityListReposWatchedByUser, activityListReposStarredByUser, usersListSshSigningKeysForUser, billingGetSharedStorageBillingUser, billingGetGithubPackagesBillingUser, billingGetGithubActionsBillingUser, reposListForUser, activityListReceivedPublicEventsForUser, activityListReceivedEventsForUser, projectsListForUser, packagesRestorePackageVersionForUser, packagesDeletePackageVersionForUser, packagesGetPackageVersionForUser, packagesGetAllPackageVersionsForPackageOwnedByUser, packagesRestorePackageForUser, packagesDeletePackageForUser, packagesGetPackageForUser, packagesListPackagesForUser, orgsListForUser, usersListPublicKeysForUser, appsGetUserInstallation, usersGetContextForUser, usersListGpgKeysForUser, gistsListForUser, usersCheckFollowingForUser, usersListFollowingForUser, usersListFollowersForUser, activityListPublicEventsForUser, activityListOrgEventsForAuthenticatedUser, activityListEventsForAuthenticatedUser, usersGetByUsername, usersList, teamsListForAuthenticatedUser, activityListWatchedReposForAuthenticatedUser, activityUnstarRepoForAuthenticatedUser, activityStarRepoForAuthenticatedUser, activityCheckRepoIsStarredByAuthenticatedUser, activityListReposStarredByAuthenticatedUser, usersDeleteSshSigningKeyForAuthenticatedUser, usersGetSshSigningKeyForAuthenticatedUser, usersCreateSshSigningKeyForAuthenticatedUser, usersListSshSigningKeysForAuthenticatedUser, reposDeclineInvitationForAuthenticatedUser, reposAcceptInvitationForAuthenticatedUser, reposListInvitationsForAuthenticatedUser, reposCreateForAuthenticatedUser, reposListForAuthenticatedUser, usersListPublicEmailsForAuthenticatedUser, projectsCreateForAuthenticatedUser, packagesRestorePackageVersionForAuthenticatedUser, packagesDeletePackageVersionForAuthenticatedUser, packagesGetPackageVersionForAuthenticatedUser, packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser, packagesRestorePackageForAuthenticatedUser, packagesDeletePackageForAuthenticatedUser, packagesGetPackageForAuthenticatedUser, packagesListPackagesForAuthenticatedUser, orgsListForAuthenticatedUser, migrationsListReposForAuthenticatedUser, migrationsUnlockRepoForAuthenticatedUser, migrationsDeleteArchiveForAuthenticatedUser, migrationsGetStatusForAuthenticatedUser, migrationsStartForAuthenticatedUser, migrationsListForAuthenticatedUser, orgsUpdateMembershipForAuthenticatedUser, orgsGetMembershipForAuthenticatedUser, orgsListMembershipsForAuthenticatedUser, appsListSubscriptionsForAuthenticatedUserStubbed, appsListSubscriptionsForAuthenticatedUser, usersDeletePublicSshKeyForAuthenticatedUser, usersGetPublicSshKeyForAuthenticatedUser, usersCreatePublicSshKeyForAuthenticatedUser, usersListPublicSshKeysForAuthenticatedUser, issuesListForAuthenticatedUser, interactionsRemoveRestrictionsForAuthenticatedUser, interactionsSetRestrictionsForAuthenticatedUser, interactionsGetRestrictionsForAuthenticatedUser, appsRemoveRepoFromInstallationForAuthenticatedUser, appsAddRepoToInstallationForAuthenticatedUser, appsListInstallationReposForAuthenticatedUser, appsListInstallationsForAuthenticatedUser, usersDeleteGpgKeyForAuthenticatedUser, usersGetGpgKeyForAuthenticatedUser, usersCreateGpgKeyForAuthenticatedUser, usersListGpgKeysForAuthenticatedUser, usersUnfollow, usersFollow, usersCheckPersonIsFollowedByAuthenticated, usersListFollowedByAuthenticatedUser, usersListFollowersForAuthenticatedUser, usersDeleteEmailForAuthenticatedUser, usersAddEmailForAuthenticatedUser, usersListEmailsForAuthenticatedUser, usersSetPrimaryEmailVisibilityForAuthenticatedUser, codespacesStopForAuthenticatedUser, codespacesStartForAuthenticatedUser, codespacesCodespaceMachinesForAuthenticatedUser, codespacesGetExportDetailsForAuthenticatedUser, codespacesExportForAuthenticatedUser, codespacesDeleteForAuthenticatedUser, codespacesUpdateForAuthenticatedUser, codespacesGetForAuthenticatedUser, codespacesRemoveRepositoryForSecretForAuthenticatedUser, codespacesAddRepositoryForSecretForAuthenticatedUser, codespacesSetRepositoriesForSecretForAuthenticatedUser, codespacesListRepositoriesForSecretForAuthenticatedUser, codespacesDeleteSecretForAuthenticatedUser, codespacesCreateOrUpdateSecretForAuthenticatedUser, codespacesGetSecretForAuthenticatedUser, codespacesGetPublicKeyForAuthenticatedUser, codespacesListSecretsForAuthenticatedUser, codespacesCreateForAuthenticatedUser, codespacesListForAuthenticatedUser, usersUnblock, usersBlock, usersCheckBlocked, usersListBlockedByAuthenticatedUser, usersUpdateAuthenticated, usersGetAuthenticated, teamsListChildLegacy, teamsRemoveRepoLegacy, teamsAddOrUpdateRepoPermissionsLegacy, teamsCheckPermissionsForRepoLegacy, teamsListReposLegacy, teamsRemoveProjectLegacy, teamsAddOrUpdateProjectPermissionsLegacy, teamsCheckPermissionsForProjectLegacy, teamsListProjectsLegacy, teamsRemoveMembershipForUserLegacy, teamsAddOrUpdateMembershipForUserLegacy, teamsGetMembershipForUserLegacy, teamsRemoveMemberLegacy, teamsAddMemberLegacy, teamsGetMemberLegacy, teamsListMembersLegacy, teamsListPendingInvitationsLegacy, reactionsCreateForTeamDiscussionLegacy, reactionsListForTeamDiscussionLegacy, reactionsCreateForTeamDiscussionCommentLegacy, reactionsListForTeamDiscussionCommentLegacy, teamsDeleteDiscussionCommentLegacy, teamsUpdateDiscussionCommentLegacy, teamsGetDiscussionCommentLegacy, teamsCreateDiscussionCommentLegacy, teamsListDiscussionCommentsLegacy, teamsDeleteDiscussionLegacy, teamsUpdateDiscussionLegacy, teamsGetDiscussionLegacy, teamsCreateDiscussionLegacy, teamsListDiscussionsLegacy, teamsDeleteLegacy, teamsUpdateLegacy, teamsGetLegacy, searchUsers, searchTopics, searchRepos, searchLabels, searchIssuesAndPullRequests, searchCommits, searchCode, actionsDeleteEnvironmentSecret, actionsCreateOrUpdateEnvironmentSecret, actionsGetEnvironmentSecret, actionsGetEnvironmentPublicKey, actionsListEnvironmentSecrets, reposListPublic, reposCreateUsingTemplate, reposDisableVulnerabilityAlerts, reposEnableVulnerabilityAlerts, reposCheckVulnerabilityAlerts, reposTransfer, reposGetViews, reposGetTopReferrers, reposGetTopPaths, reposGetClones, reposReplaceAllTopics, reposGetAllTopics, reposListTeams, reposDeleteTagProtection, reposCreateTagProtection, reposListTagProtection, reposListTags, activityDeleteRepoSubscription, activitySetRepoSubscription, activityGetRepoSubscription, activityListWatchersForRepo, reposCreateCommitStatus, reposGetPunchCardStats, reposGetParticipationStats, reposGetContributorsStats, reposGetCommitActivityStats, reposGetCodeFrequencyStats, activityListStargazersForRepo, secretScanningListLocationsForAlert, secretScanningUpdateAlert, secretScanningGetAlert, secretScanningListAlertsForRepo, reactionsDeleteForRelease, reactionsCreateForRelease, reactionsListForRelease, reposUploadReleaseAsset, reposListReleaseAssets, reposDeleteRelease, reposUpdateRelease, reposGetRelease, reposGetReleaseByTag, reposGetLatestRelease, reposGenerateReleaseNotes, reposDeleteReleaseAsset, reposUpdateReleaseAsset, reposGetReleaseAsset, reposCreateRelease, reposListReleases, reposGetReadmeInDirectory, reposGetReadme, pullsUpdateBranch, pullsSubmitReview, pullsDismissReview, pullsListCommentsForReview, pullsDeletePendingReview, pullsUpdateReview, pullsGetReview, pullsCreateReview, pullsListReviews, pullsRemoveRequestedReviewers, pullsRequestReviewers, pullsListRequestedReviewers, pullsMerge, pullsCheckIfMerged, pullsListFiles, pullsListCommits, pullsCreateReplyForReviewComment, pullsCreateReviewComment, pullsListReviewComments, codespacesCreateWithPrForAuthenticatedUser, pullsUpdate, pullsGet, reactionsDeleteForPullRequestComment, reactionsCreateForPullRequestReviewComment, reactionsListForPullRequestReviewComment, pullsDeleteReviewComment, pullsUpdateReviewComment, pullsGetReviewComment, pullsListReviewCommentsForRepo, pullsCreate, pullsList, projectsCreateForRepo, projectsListForRepo, reposGetPagesHealthCheck, reposCreatePagesDeployment, reposGetPagesBuild, reposGetLatestPagesBuild, reposRequestPagesBuild, reposListPagesBuilds, reposDeletePagesSite, reposUpdateInformationAboutPagesSite, reposCreatePagesSite, reposGetPages, activityMarkRepoNotificationsAsRead, activityListRepoNotificationsForAuthenticatedUser, issuesListLabelsForMilestone, issuesDeleteMilestone, issuesUpdateMilestone, issuesGetMilestone, issuesCreateMilestone, issuesListMilestones, reposMerge, reposMergeUpstream, licensesGetForRepo, reposDisableLfsForRepo, reposEnableLfsForRepo, reposListLanguages, issuesDeleteLabel, issuesUpdateLabel, issuesGetLabel, issuesCreateLabel, issuesListLabelsForRepo, reposDeleteDeployKey, reposGetDeployKey, reposCreateDeployKey, reposListDeployKeys, issuesListEventsForTimeline, reactionsDeleteForIssue, reactionsCreateForIssue, reactionsListForIssue, issuesUnlock, issuesLock, issuesRemoveLabel, issuesRemoveAllLabels, issuesSetLabels, issuesAddLabels, issuesListLabelsOnIssue, issuesListEvents, issuesCreateComment, issuesListComments, issuesRemoveAssignees, issuesAddAssignees, issuesUpdate, issuesGet, issuesGetEvent, issuesListEventsForRepo, reactionsDeleteForIssueComment, reactionsCreateForIssueComment, reactionsListForIssueComment, issuesDeleteComment, issuesUpdateComment, issuesGetComment, issuesListCommentsForRepo, issuesCreate, issuesListForRepo, reposDeleteInvitation, reposUpdateInvitation, reposListInvitations, interactionsRemoveRestrictionsForRepo, interactionsSetRestrictionsForRepo, interactionsGetRestrictionsForRepo, appsGetRepoInstallation, migrationsSetLfsPreference, migrationsGetLargeFiles, migrationsMapCommitAuthor, migrationsGetCommitAuthors, migrationsCancelImport, migrationsUpdateImport, migrationsStartImport, migrationsGetImportStatus, reposTestPushWebhook, reposPingWebhook, reposRedeliverWebhookDelivery, reposGetWebhookDelivery, reposListWebhookDeliveries, reposUpdateWebhookConfigForRepo, reposGetWebhookConfigForRepo, reposDeleteWebhook, reposUpdateWebhook, reposGetWebhook, reposCreateWebhook, reposListWebhooks, gitGetTree, gitCreateTree, gitGetTag, gitCreateTag, gitDeleteRef, gitUpdateRef, gitCreateRef, gitGetRef, gitListMatchingRefs, gitGetCommit, gitCreateCommit, gitGetBlob, gitCreateBlob, reposCreateFork, reposListForks, activityListRepoEvents, reposDeleteDeploymentBranchPolicy, reposUpdateDeploymentBranchPolicy, reposGetDeploymentBranchPolicy, reposCreateDeploymentBranchPolicy, reposListDeploymentBranchPolicies, reposDeleteAnEnvironment, reposCreateOrUpdateEnvironment, reposGetEnvironment, reposGetAllEnvironments, reposCreateDispatchEvent, reposGetDeploymentStatus, reposCreateDeploymentStatus, reposListDeploymentStatuses, reposDeleteDeployment, reposGetDeployment, reposCreateDeployment, reposListDeployments, dependencyGraphCreateRepositorySnapshot, dependencyGraphDiffRange, dependabotDeleteRepoSecret, dependabotCreateOrUpdateRepoSecret, dependabotGetRepoSecret, dependabotGetRepoPublicKey, dependabotListRepoSecrets, dependabotUpdateAlert, dependabotGetAlert, dependabotListAlertsForRepo, reposListContributors, reposDeleteFile, reposCreateOrUpdateFileContents, reposGetContent, reposCompareCommits, reposGetCommunityProfileMetrics, reposListCommitStatusesForRef, reposGetCombinedStatusForRef, checksListSuitesForRef, checksListForRef, reposGetCommit, reposListPullRequestsAssociatedWithCommit, reposCreateCommitComment, reposListCommentsForCommit, reposListBranchesForHeadCommit, reposListCommits, reactionsDeleteForCommitComment, reactionsCreateForCommitComment, reactionsListForCommitComment, reposDeleteCommitComment, reposUpdateCommitComment, reposGetCommitComment, reposListCommitCommentsForRepo, reposGetCollaboratorPermissionLevel, reposRemoveCollaborator, reposAddCollaborator, reposCheckCollaborator, reposListCollaborators, codespacesDeleteRepoSecret, codespacesCreateOrUpdateRepoSecret, codespacesGetRepoSecret, codespacesGetRepoPublicKey, codespacesListRepoSecrets, codespacesPreFlightWithRepoForAuthenticatedUser, codespacesRepoMachinesForAuthenticatedUser, codespacesListDevcontainersInRepositoryForAuthenticatedUser, codespacesCreateWithRepoForAuthenticatedUser, codespacesListInRepositoryForAuthenticatedUser, reposCodeownersErrors, codeScanningGetSarif, codeScanningUploadSarif, codeScanningGetCodeqlDatabase, codeScanningListCodeqlDatabases, codeScanningDeleteAnalysis, codeScanningGetAnalysis, codeScanningListRecentAnalyses, codeScanningListAlertInstances, codeScanningUpdateAlert, codeScanningGetAlert, codeScanningListAlertsForRepo, checksRerequestSuite, checksListForSuite, checksGetSuite, checksSetSuitesPreferences, checksCreateSuite, checksRerequestRun, checksListAnnotations, checksUpdate, checksGet, checksCreate, reposRenameBranch, reposRemoveUserAccessRestrictions, reposSetUserAccessRestrictions, reposAddUserAccessRestrictions, reposGetUsersWithAccessToProtectedBranch, reposRemoveTeamAccessRestrictions, reposSetTeamAccessRestrictions, reposAddTeamAccessRestrictions, reposGetTeamsWithAccessToProtectedBranch, reposRemoveAppAccessRestrictions, reposSetAppAccessRestrictions, reposAddAppAccessRestrictions, reposGetAppsWithAccessToProtectedBranch, reposDeleteAccessRestrictions, reposGetAccessRestrictions, reposRemoveStatusCheckContexts, reposSetStatusCheckContexts, reposAddStatusCheckContexts, reposGetAllStatusCheckContexts, reposRemoveStatusCheckProtection, reposUpdateStatusCheckProtection, reposGetStatusChecksProtection, reposDeleteCommitSignatureProtection, reposCreateCommitSignatureProtection, reposGetCommitSignatureProtection, reposDeletePullRequestReviewProtection, reposUpdatePullRequestReviewProtection, reposGetPullRequestReviewProtection, reposDeleteAdminBranchProtection, reposSetAdminBranchProtection, reposGetAdminBranchProtection, reposDeleteBranchProtection, reposUpdateBranchProtection, reposGetBranchProtection, reposGetBranch, reposListBranches, reposDisableAutomatedSecurityFixes, reposEnableAutomatedSecurityFixes, reposDeleteAutolink, reposGetAutolink, reposCreateAutolink, reposListAutolinks, issuesCheckUserCanBeAssigned, issuesListAssignees, actionsGetWorkflowUsage, actionsListWorkflowRuns, actionsEnableWorkflow, actionsCreateWorkflowDispatch, actionsDisableWorkflow, actionsGetWorkflow, actionsListRepoWorkflows, actionsDeleteRepoSecret, actionsCreateOrUpdateRepoSecret, actionsGetRepoSecret, actionsGetRepoPublicKey, actionsListRepoSecrets, actionsGetWorkflowRunUsage, actionsReRunWorkflowFailedJobs, actionsReRunWorkflow, actionsReviewPendingDeploymentsForRun, actionsGetPendingDeploymentsForRun, actionsDeleteWorkflowRunLogs, actionsListJobsForWorkflowRun, actionsCancelWorkflowRun, actionsListJobsForWorkflowRunAttempt, actionsGetWorkflowRunAttempt, actionsListWorkflowRunArtifacts, actionsApproveWorkflowRun, actionsGetReviewsForRun, actionsDeleteWorkflowRun, actionsGetWorkflowRun, actionsListWorkflowRunsForRepo, actionsRemoveCustomLabelFromSelfHostedRunnerForRepo, actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo, actionsSetCustomLabelsForSelfHostedRunnerForRepo, actionsAddCustomLabelsToSelfHostedRunnerForRepo, actionsListLabelsForSelfHostedRunnerForRepo, actionsDeleteSelfHostedRunnerFromRepo, actionsGetSelfHostedRunnerForRepo, actionsCreateRemoveTokenForRepo, actionsCreateRegistrationTokenForRepo, actionsListRunnerApplicationsForRepo, actionsListSelfHostedRunnersForRepo, actionsSetGithubActionsDefaultWorkflowPermissionsRepository, actionsGetGithubActionsDefaultWorkflowPermissionsRepository, actionsSetAllowedActionsRepository, actionsGetAllowedActionsRepository, actionsSetWorkflowAccessToRepository, actionsGetWorkflowAccessToRepository, actionsSetGithubActionsPermissionsRepository, actionsGetGithubActionsPermissionsRepository, actionsReRunJobForWorkflowRun, actionsGetJobForWorkflowRun, actionsDeleteActionsCacheById, actionsDeleteActionsCacheByKey, actionsGetActionsCacheList, actionsGetActionsCacheUsage, actionsDeleteArtifact, actionsGetArtifact, actionsListArtifactsForRepo, reposDelete, reposUpdate, reposGet, rateLimitGet, projectsCreateColumn, projectsListColumns, projectsGetPermissionForUser, projectsRemoveCollaborator, projectsAddCollaborator, projectsListCollaborators, projectsDelete, projectsUpdate, projectsGet, projectsMoveColumn, projectsCreateCard, projectsListCards, projectsDeleteColumn, projectsUpdateColumn, projectsGetColumn, projectsMoveCard, projectsDeleteCard, projectsUpdateCard, projectsGetCard, orgsEnableOrDisableSecurityProductOnAllOrgRepos, teamsListChildInOrg, teamsRemoveRepoInOrg, teamsAddOrUpdateRepoPermissionsInOrg, teamsCheckPermissionsForRepoInOrg, teamsListReposInOrg, teamsRemoveProjectInOrg, teamsAddOrUpdateProjectPermissionsInOrg, teamsCheckPermissionsForProjectInOrg, teamsListProjectsInOrg, teamsRemoveMembershipForUserInOrg, teamsAddOrUpdateMembershipForUserInOrg, teamsGetMembershipForUserInOrg, teamsListMembersInOrg, teamsListPendingInvitationsInOrg, reactionsDeleteForTeamDiscussion, reactionsCreateForTeamDiscussionInOrg, reactionsListForTeamDiscussionInOrg, reactionsDeleteForTeamDiscussionComment, reactionsCreateForTeamDiscussionCommentInOrg, reactionsListForTeamDiscussionCommentInOrg, teamsDeleteDiscussionCommentInOrg, teamsUpdateDiscussionCommentInOrg, teamsGetDiscussionCommentInOrg, teamsCreateDiscussionCommentInOrg, teamsListDiscussionCommentsInOrg, teamsDeleteDiscussionInOrg, teamsUpdateDiscussionInOrg, teamsGetDiscussionInOrg, teamsCreateDiscussionInOrg, teamsListDiscussionsInOrg, teamsDeleteInOrg, teamsUpdateInOrg, teamsGetByName, teamsCreate, teamsList, billingGetSharedStorageBillingOrg, billingGetGithubPackagesBillingOrg, billingGetGithubAdvancedSecurityBillingOrg, billingGetGithubActionsBillingOrg, orgsRemoveSecurityManagerTeam, orgsAddSecurityManagerTeam, orgsListSecurityManagerTeams, secretScanningListAlertsForOrg, reposCreateInOrg, reposListForOrg, orgsRemovePublicMembershipForAuthenticatedUser, orgsSetPublicMembershipForAuthenticatedUser, orgsCheckPublicMembershipForUser, orgsListPublicMembers, projectsCreateForOrg, projectsListForOrg, packagesRestorePackageVersionForOrg, packagesDeletePackageVersionForOrg, packagesGetPackageVersionForOrganization, packagesGetAllPackageVersionsForPackageOwnedByOrg, packagesRestorePackageForOrg, packagesDeletePackageForOrg, packagesGetPackageForOrganization, packagesListPackagesForOrganization, orgsRemoveOutsideCollaborator, orgsConvertMemberToOutsideCollaborator, orgsListOutsideCollaborators, migrationsListReposForOrg, migrationsUnlockRepoForOrg, migrationsDeleteArchiveForOrg, migrationsGetStatusForOrg, migrationsStartForOrg, migrationsListForOrg, orgsRemoveMembershipForUser, orgsSetMembershipForUser, orgsGetMembershipForUser, codespacesStopInOrganization, codespacesDeleteFromOrganization, codespacesGetCodespacesForUserInOrg, orgsRemoveMember, orgsCheckMembershipForUser, orgsListMembers, issuesListForOrg, orgsListInvitationTeams, orgsCancelInvitation, orgsCreateInvitation, orgsListPendingInvitations, interactionsRemoveRestrictionsForOrg, interactionsSetRestrictionsForOrg, interactionsGetRestrictionsForOrg, orgsListAppInstallations, appsGetOrgInstallation, orgsPingWebhook, orgsRedeliverWebhookDelivery, orgsGetWebhookDelivery, orgsListWebhookDeliveries, orgsUpdateWebhookConfigForOrg, orgsGetWebhookConfigForOrg, orgsDeleteWebhook, orgsUpdateWebhook, orgsGetWebhook, orgsCreateWebhook, orgsListWebhooks, orgsListFineGrainedPermissions, orgsListFailedInvitations, activityListPublicOrgEvents, dependabotRemoveSelectedRepoFromOrgSecret, dependabotAddSelectedRepoToOrgSecret, dependabotSetSelectedReposForOrgSecret, dependabotListSelectedReposForOrgSecret, dependabotDeleteOrgSecret, dependabotCreateOrUpdateOrgSecret, dependabotGetOrgSecret, dependabotGetOrgPublicKey, dependabotListOrgSecrets, orgsDeleteCustomRole, orgsUpdateCustomRole, orgsCreateCustomRole, codespacesRemoveSelectedRepoFromOrgSecret, codespacesAddSelectedRepoToOrgSecret, codespacesSetSelectedReposForOrgSecret, codespacesListSelectedReposForOrgSecret, codespacesDeleteOrgSecret, codespacesCreateOrUpdateOrgSecret, codespacesGetOrgSecret, codespacesGetOrgPublicKey, codespacesListOrgSecrets, codespacesSetCodespacesBilling, codespacesListInOrganization, codeScanningListAlertsForOrg, orgsUnblockUser, orgsBlockUser, orgsCheckBlockedUser, orgsListBlockedUsers, actionsRemoveSelectedRepoFromOrgSecret, actionsAddSelectedRepoToOrgSecret, actionsSetSelectedReposForOrgSecret, actionsListSelectedReposForOrgSecret, actionsDeleteOrgSecret, actionsCreateOrUpdateOrgSecret, actionsGetOrgSecret, actionsGetOrgPublicKey, actionsListOrgSecrets, actionsRemoveCustomLabelFromSelfHostedRunnerForOrg, actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg, actionsSetCustomLabelsForSelfHostedRunnerForOrg, actionsAddCustomLabelsToSelfHostedRunnerForOrg, actionsListLabelsForSelfHostedRunnerForOrg, actionsDeleteSelfHostedRunnerFromOrg, actionsGetSelfHostedRunnerForOrg, actionsCreateRemoveTokenForOrg, actionsCreateRegistrationTokenForOrg, actionsListRunnerApplicationsForOrg, actionsListSelfHostedRunnersForOrg, actionsRemoveSelfHostedRunnerFromGroupForOrg, actionsAddSelfHostedRunnerToGroupForOrg, actionsSetSelfHostedRunnersInGroupForOrg, actionsListSelfHostedRunnersInGroupForOrg, actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg, actionsSetRepoAccessToSelfHostedRunnerGroupInOrg, actionsListRepoAccessToSelfHostedRunnerGroupInOrg, actionsDeleteSelfHostedRunnerGroupFromOrg, actionsUpdateSelfHostedRunnerGroupForOrg, actionsGetSelfHostedRunnerGroupForOrg, actionsCreateSelfHostedRunnerGroupForOrg, actionsListSelfHostedRunnerGroupsForOrg, actionsSetGithubActionsDefaultWorkflowPermissionsOrganization, actionsGetGithubActionsDefaultWorkflowPermissionsOrganization, actionsSetAllowedActionsOrganization, actionsGetAllowedActionsOrganization, actionsDisableSelectedRepositoryGithubActionsOrganization, actionsEnableSelectedRepositoryGithubActionsOrganization, actionsSetSelectedRepositoriesEnabledGithubActionsOrganization, actionsListSelectedRepositoriesEnabledGithubActionsOrganization, actionsSetGithubActionsPermissionsOrganization, actionsGetGithubActionsPermissionsOrganization, actionsGetActionsCacheUsageByRepoForOrg, actionsGetActionsCacheUsageForOrg, orgsUpdate, orgsGet, orgsListCustomRoles, orgsList, metaGetOctocat, activityDeleteThreadSubscription, activitySetThreadSubscription, activityGetThreadSubscriptionForAuthenticatedUser, activityMarkThreadAsRead, activityGetThread, activityMarkNotificationsAsRead, activityListNotificationsForAuthenticatedUser, activityListPublicEventsForRepoNetwork, metaGet, appsListAccountsForPlanStubbed, appsListPlansStubbed, appsGetSubscriptionPlanForAccountStubbed, appsListAccountsForPlan, appsListPlans, appsGetSubscriptionPlanForAccount, markdownRenderRaw, markdownRender, licensesGet, licensesGetAllCommonlyUsed, issuesList, appsRevokeInstallationAccessToken, appsListReposAccessibleToInstallation, gitignoreGetTemplate, gitignoreGetAllTemplates, gistsGetRevision, gistsUnstar, gistsStar, gistsCheckIsStarred, gistsFork, gistsListForks, gistsListCommits, gistsDeleteComment, gistsUpdateComment, gistsGetComment, gistsCreateComment, gistsListComments, gistsDelete, gistsUpdate, gistsGet, gistsListStarred, gistsListPublic, gistsCreate, gistsList, activityGetFeeds, activityListPublicEvents, billingGetGithubAdvancedSecurityBillingGhe, secretScanningListAlertsForEnterprise, codeScanningListAlertsForEnterprise, enterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterprise, enterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterprise, enterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterprise, enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterprise, enterpriseAdminListLabelsForSelfHostedRunnerForEnterprise, enterpriseAdminDeleteSelfHostedRunnerFromEnterprise, enterpriseAdminGetSelfHostedRunnerForEnterprise, enterpriseAdminCreateRemoveTokenForEnterprise, enterpriseAdminCreateRegistrationTokenForEnterprise, enterpriseAdminListRunnerApplicationsForEnterprise, enterpriseAdminListSelfHostedRunnersForEnterprise, enterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise, enterpriseAdminAddSelfHostedRunnerToGroupForEnterprise, enterpriseAdminSetSelfHostedRunnersInGroupForEnterprise, enterpriseAdminListSelfHostedRunnersInGroupForEnterprise, enterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise, enterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise, enterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise, enterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise, enterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise, enterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise, enterpriseAdminGetSelfHostedRunnerGroupForEnterprise, enterpriseAdminCreateSelfHostedRunnerGroupForEnterprise, enterpriseAdminListSelfHostedRunnerGroupsForEnterprise, actionsSetGithubActionsDefaultWorkflowPermissionsEnterprise, actionsGetGithubActionsDefaultWorkflowPermissionsEnterprise, enterpriseAdminSetAllowedActionsEnterprise, enterpriseAdminGetAllowedActionsEnterprise, enterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise, enterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise, enterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise, enterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise, enterpriseAdminSetGithubActionsPermissionsEnterprise, enterpriseAdminGetGithubActionsPermissionsEnterprise, actionsGetActionsCacheUsageForEnterprise, enterpriseAdminGetServerStatistics, emojisGet, codesOfConductGetConductCode, codesOfConductGetAllCodesOfConduct, appsGetBySlug, appsScopeToken, appsDeleteToken, appsResetToken, appsCheckToken, appsDeleteAuthorization, appsUnsuspendInstallation, appsSuspendInstallation, appsCreateInstallationAccessToken, appsDeleteInstallation, appsGetInstallation, appsListInstallations, appsRedeliverWebhookDelivery, appsGetWebhookDelivery, appsListWebhookDeliveries, appsUpdateWebhookConfigForApp, appsGetWebhookConfigForApp, appsCreateFromManifest, appsGetAuthenticated, metaRoot

## Types

@docs Accepted, ActionsRunnerLabels, ActionsRunnerLabelsReadonly, BadRequest, CodeScanningForbiddenRead, CodeScanningForbiddenWrite, Conflict, Forbidden, ForbiddenGist, Gone, InternalError, MovedPermanently, NotFound, RequiresAuthentication, ServiceUnavailable, TemporaryRedirect, ValidationFailed, ValidationFailedSimple, ActionsBillingUsage, ActionsCacheList, ActionsCacheUsageByRepository, ActionsCacheUsageOrgEnterprise, ActionsCanApprovePullRequestReviews, ActionsDefaultWorkflowPermissions, ActionsEnabled, ActionsEnterprisePermissions, ActionsGetDefaultWorkflowPermissions, ActionsOrganizationPermissions, ActionsPublicKey, ActionsRepositoryPermissions, ActionsSecret, ActionsSetDefaultWorkflowPermissions, ActionsWorkflowAccessToRepository, Actor, AddedToProjectIssueEvent, AdvancedSecurityActiveCommitters, AdvancedSecurityActiveCommittersRepository, AdvancedSecurityActiveCommittersUser, AlertCreatedAt, AlertDismissedAt, AlertFixedAt, AlertHtmlUrl, AlertInstancesUrl, AlertNumber, AlertUpdatedAt, AlertUrl, AllowedActions, ApiOverview, AppPermissions, Artifact, AssignedIssueEvent, AuthenticationToken, AuthorAssociation, Authorization, AutoMerge, Autolink, BaseGist, BasicError, Blob, BranchProtection, BranchRestrictionPolicy, BranchShort, BranchWithProtection, CheckAnnotation, CheckRun, CheckSuite, CheckSuitePreference, CloneTraffic, CodeFrequencyStat, CodeOfConduct, CodeOfConductSimple, CodeScanningAlert, CodeScanningAlertClassification, CodeScanningAlertDismissedComment, CodeScanningAlertDismissedReason, CodeScanningAlertEnvironment, CodeScanningAlertInstance, CodeScanningAlertItems, CodeScanningAlertLocation, CodeScanningAlertRule, CodeScanningAlertRuleSummary, CodeScanningAlertSetState, CodeScanningAlertState, CodeScanningAnalysis, CodeScanningAnalysisAnalysisKey, CodeScanningAnalysisCategory, CodeScanningAnalysisCommitSha, CodeScanningAnalysisCreatedAt, CodeScanningAnalysisDeletion, CodeScanningAnalysisEnvironment, CodeScanningAnalysisSarifFile, CodeScanningAnalysisSarifId, CodeScanningAnalysisTool, CodeScanningAnalysisToolGuid, CodeScanningAnalysisToolName, CodeScanningAnalysisToolVersion, CodeScanningAnalysisUrl, CodeScanningCodeqlDatabase, CodeScanningOrganizationAlertItems, CodeScanningRef, CodeScanningSarifsReceipt, CodeScanningSarifsStatus, CodeSearchResultItem, CodeownersErrors, Codespace, CodespaceExportDetails, CodespaceMachine, CodespacesOrgSecret, CodespacesPublicKey, CodespacesSecret, CodespacesUserPublicKey, Collaborator, CombinedBillingUsage, CombinedCommitStatus, Commit, CommitActivity, CommitComment, CommitComparison, CommitSearchResultItem, CommunityHealthFile, CommunityProfile, ContentDirectory, ContentFile, ContentSubmodule, ContentSymlink, ContentTraffic, ContentTree, Contributor, ContributorActivity, ConvertedNoteToIssueIssueEvent, DemilestonedIssueEvent, DependabotAlert, DependabotAlertPackage, DependabotAlertSecurityAdvisory, DependabotAlertSecurityVulnerability, DependabotPublicKey, DependabotSecret, Dependency, DependencyGraphDiff, DeployKey, Deployment, DeploymentBranchPolicy, DeploymentBranchPolicyNamePattern, DeploymentBranchPolicySettings, DeploymentReviewerType, DeploymentSimple, DeploymentStatus, DiffEntry, Email, EmptyObject, EnabledOrganizations, EnabledRepositories, Enterprise, Environment, EnvironmentApprovals, Event, Feed, FileCommit, FullRepository, GistComment, GistCommit, GistHistory, GistSimple, GitCommit, GitRef, GitTag, GitTree, GitUser, GitignoreTemplate, GpgKey, Hook, HookDelivery, HookDeliveryItem, HookResponse, Hovercard, Import, Installation, InstallationToken, Integration, InteractionExpiry, InteractionGroup, InteractionLimit, InteractionLimitResponse, Issue, IssueComment, IssueEvent, IssueEventDismissedReview, IssueEventForIssue, IssueEventLabel, IssueEventMilestone, IssueEventProjectCard, IssueEventRename, IssueSearchResultItem, Job, Key, KeySimple, Label, LabelSearchResultItem, LabeledIssueEvent, Language, License, LicenseContent, LicenseSimple, Link, LinkWithType, LockedIssueEvent, Manifest, MarketplaceAccount, MarketplaceListingPlan, MarketplacePurchase, MergedUpstream, Metadata, Migration, Milestone, MilestonedIssueEvent, MinimalRepository, MovedColumnInProjectIssueEvent, OrgHook, OrgMembership, OrganizationActionsSecret, OrganizationCustomRepositoryRole, OrganizationDependabotSecret, OrganizationFineGrainedPermission, OrganizationFull, OrganizationInvitation, OrganizationSecretScanningAlert, OrganizationSimple, Package, PackageVersion, PackagesBillingUsage, Page, PageBuild, PageBuildStatus, PageDeployment, PagesHealthCheck, PagesHttpsCertificate, PagesSourceHash, ParticipationStats, PendingDeployment, PorterAuthor, PorterLargeFile, PrivateUser, Project, ProjectCard, ProjectCollaboratorPermission, ProjectColumn, ProtectedBranch, ProtectedBranchAdminEnforced, ProtectedBranchPullRequestReview, ProtectedBranchRequiredStatusCheck, PublicUser, PullRequest, PullRequestMergeResult, PullRequestMinimal, PullRequestReview, PullRequestReviewComment, PullRequestReviewRequest, PullRequestSimple, RateLimit, RateLimitOverview, Reaction, ReactionRollup, ReferencedWorkflow, ReferrerTraffic, Release, ReleaseAsset, ReleaseNotesContent, RemovedFromProjectIssueEvent, RenamedIssueEvent, RepoCodespacesSecret, RepoSearchResultItem, Repository, RepositoryCollaboratorPermission, RepositoryInvitation, RepositorySubscription, ReviewComment, ReviewDismissedIssueEvent, ReviewRequestRemovedIssueEvent, ReviewRequestedIssueEvent, Root, Runner, RunnerApplication, RunnerGroupsEnterprise, RunnerGroupsOrg, RunnerLabel, ScimError, ScopedInstallation, SearchResultTextMatches, SecretScanningAlert, SecretScanningAlertResolution, SecretScanningAlertResolutionComment, SecretScanningAlertState, SecretScanningLocation, SecretScanningLocationCommit, SecurityAndAnalysis, SelectedActions, SelectedActionsUrl, ServerStatistics, ShortBlob, ShortBranch, SimpleCommit, SimpleCommitStatus, SimpleInstallation, SimpleRepository, SimpleUser, Snapshot, SshSigningKey, Stargazer, StarredRepository, StateChangeIssueEvent, Status, StatusCheckPolicy, Tag, TagProtection, Team, TeamDiscussion, TeamDiscussionComment, TeamFull, TeamMembership, TeamOrganization, TeamProject, TeamRepository, TeamSimple, Thread, ThreadSubscription, TimelineAssignedIssueEvent, TimelineCommentEvent, TimelineCommitCommentedEvent, TimelineCommittedEvent, TimelineCrossReferencedEvent, TimelineIssueEvents, TimelineLineCommentedEvent, TimelineReviewedEvent, TimelineUnassignedIssueEvent, Topic, TopicSearchResultItem, Traffic, UnassignedIssueEvent, UnlabeledIssueEvent, UserMarketplacePurchase, UserSearchResultItem, ValidationError, ValidationErrorSimple, Verification, ViewTraffic, WaitTimer, WebhookConfig, WebhookConfigContentType, WebhookConfigInsecureSsl, WebhookConfigSecret, WebhookConfigUrl, WebhookDependabotAlertCreated, WebhookDependabotAlertDismissed, WebhookDependabotAlertFixed, WebhookDependabotAlertReintroduced, WebhookDependabotAlertReopened, WebhookMergeGroupChecksRequested, Workflow, WorkflowRun, WorkflowRunUsage, WorkflowUsage, Nullable

## Encoders

@docs encodeAccepted, encodeActionsRunnerLabels, encodeActionsRunnerLabelsReadonly, encodeBadRequest, encodeCodeScanningForbiddenRead, encodeCodeScanningForbiddenWrite, encodeConflict, encodeForbidden, encodeForbiddenGist, encodeGone, encodeInternalError, encodeMovedPermanently, encodeNotFound, encodeRequiresAuthentication, encodeServiceUnavailable, encodeTemporaryRedirect, encodeValidationFailed, encodeValidationFailedSimple, encodeActionsBillingUsage, encodeActionsCacheList, encodeActionsCacheUsageByRepository, encodeActionsCacheUsageOrgEnterprise, encodeActionsCanApprovePullRequestReviews, encodeActionsDefaultWorkflowPermissions, encodeActionsEnabled, encodeActionsEnterprisePermissions, encodeActionsGetDefaultWorkflowPermissions, encodeActionsOrganizationPermissions, encodeActionsPublicKey, encodeActionsRepositoryPermissions, encodeActionsSecret, encodeActionsSetDefaultWorkflowPermissions, encodeActionsWorkflowAccessToRepository, encodeActor, encodeAddedToProjectIssueEvent, encodeAdvancedSecurityActiveCommitters, encodeAdvancedSecurityActiveCommittersRepository, encodeAdvancedSecurityActiveCommittersUser, encodeAlertCreatedAt, encodeAlertDismissedAt, encodeAlertFixedAt, encodeAlertHtmlUrl, encodeAlertInstancesUrl, encodeAlertNumber, encodeAlertUpdatedAt, encodeAlertUrl, encodeAllowedActions, encodeApiOverview, encodeAppPermissions, encodeArtifact, encodeAssignedIssueEvent, encodeAuthenticationToken, encodeAuthorAssociation, encodeAuthorization, encodeAutoMerge, encodeAutolink, encodeBaseGist, encodeBasicError, encodeBlob, encodeBranchProtection, encodeBranchRestrictionPolicy, encodeBranchShort, encodeBranchWithProtection, encodeCheckAnnotation, encodeCheckRun, encodeCheckSuite, encodeCheckSuitePreference, encodeCloneTraffic, encodeCodeFrequencyStat, encodeCodeOfConduct, encodeCodeOfConductSimple, encodeCodeScanningAlert, encodeCodeScanningAlertClassification, encodeCodeScanningAlertDismissedComment, encodeCodeScanningAlertDismissedReason, encodeCodeScanningAlertEnvironment, encodeCodeScanningAlertInstance, encodeCodeScanningAlertItems, encodeCodeScanningAlertLocation, encodeCodeScanningAlertRule, encodeCodeScanningAlertRuleSummary, encodeCodeScanningAlertSetState, encodeCodeScanningAlertState, encodeCodeScanningAnalysis, encodeCodeScanningAnalysisAnalysisKey, encodeCodeScanningAnalysisCategory, encodeCodeScanningAnalysisCommitSha, encodeCodeScanningAnalysisCreatedAt, encodeCodeScanningAnalysisDeletion, encodeCodeScanningAnalysisEnvironment, encodeCodeScanningAnalysisSarifFile, encodeCodeScanningAnalysisSarifId, encodeCodeScanningAnalysisTool, encodeCodeScanningAnalysisToolGuid, encodeCodeScanningAnalysisToolName, encodeCodeScanningAnalysisToolVersion, encodeCodeScanningAnalysisUrl, encodeCodeScanningCodeqlDatabase, encodeCodeScanningOrganizationAlertItems, encodeCodeScanningRef, encodeCodeScanningSarifsReceipt, encodeCodeScanningSarifsStatus, encodeCodeSearchResultItem, encodeCodeownersErrors, encodeCodespace, encodeCodespaceExportDetails, encodeCodespaceMachine, encodeCodespacesOrgSecret, encodeCodespacesPublicKey, encodeCodespacesSecret, encodeCodespacesUserPublicKey, encodeCollaborator, encodeCombinedBillingUsage, encodeCombinedCommitStatus, encodeCommit, encodeCommitActivity, encodeCommitComment, encodeCommitComparison, encodeCommitSearchResultItem, encodeCommunityHealthFile, encodeCommunityProfile, encodeContentDirectory, encodeContentFile, encodeContentSubmodule, encodeContentSymlink, encodeContentTraffic, encodeContentTree, encodeContributor, encodeContributorActivity, encodeConvertedNoteToIssueIssueEvent, encodeDemilestonedIssueEvent, encodeDependabotAlert, encodeDependabotAlertPackage, encodeDependabotAlertSecurityAdvisory, encodeDependabotAlertSecurityVulnerability, encodeDependabotPublicKey, encodeDependabotSecret, encodeDependency, encodeDependencyGraphDiff, encodeDeployKey, encodeDeployment, encodeDeploymentBranchPolicy, encodeDeploymentBranchPolicyNamePattern, encodeDeploymentBranchPolicySettings, encodeDeploymentReviewerType, encodeDeploymentSimple, encodeDeploymentStatus, encodeDiffEntry, encodeEmail, encodeEmptyObject, encodeEnabledOrganizations, encodeEnabledRepositories, encodeEnterprise, encodeEnvironment, encodeEnvironmentApprovals, encodeEvent, encodeFeed, encodeFileCommit, encodeFullRepository, encodeGistComment, encodeGistCommit, encodeGistHistory, encodeGistSimple, encodeGitCommit, encodeGitRef, encodeGitTag, encodeGitTree, encodeGitUser, encodeGitignoreTemplate, encodeGpgKey, encodeHook, encodeHookDelivery, encodeHookDeliveryItem, encodeHookResponse, encodeHovercard, encodeImport, encodeInstallation, encodeInstallationToken, encodeIntegration, encodeInteractionExpiry, encodeInteractionGroup, encodeInteractionLimit, encodeInteractionLimitResponse, encodeIssue, encodeIssueComment, encodeIssueEvent, encodeIssueEventDismissedReview, encodeIssueEventForIssue, encodeIssueEventLabel, encodeIssueEventMilestone, encodeIssueEventProjectCard, encodeIssueEventRename, encodeIssueSearchResultItem, encodeJob, encodeKey, encodeKeySimple, encodeLabel, encodeLabelSearchResultItem, encodeLabeledIssueEvent, encodeLanguage, encodeLicense, encodeLicenseContent, encodeLicenseSimple, encodeLink, encodeLinkWithType, encodeLockedIssueEvent, encodeManifest, encodeMarketplaceAccount, encodeMarketplaceListingPlan, encodeMarketplacePurchase, encodeMergedUpstream, encodeMetadata, encodeMigration, encodeMilestone, encodeMilestonedIssueEvent, encodeMinimalRepository, encodeMovedColumnInProjectIssueEvent, encodeOrgHook, encodeOrgMembership, encodeOrganizationActionsSecret, encodeOrganizationCustomRepositoryRole, encodeOrganizationDependabotSecret, encodeOrganizationFineGrainedPermission, encodeOrganizationFull, encodeOrganizationInvitation, encodeOrganizationSecretScanningAlert, encodeOrganizationSimple, encodePackage, encodePackageVersion, encodePackagesBillingUsage, encodePage, encodePageBuild, encodePageBuildStatus, encodePageDeployment, encodePagesHealthCheck, encodePagesHttpsCertificate, encodePagesSourceHash, encodeParticipationStats, encodePendingDeployment, encodePorterAuthor, encodePorterLargeFile, encodePrivateUser, encodeProject, encodeProjectCard, encodeProjectCollaboratorPermission, encodeProjectColumn, encodeProtectedBranch, encodeProtectedBranchAdminEnforced, encodeProtectedBranchPullRequestReview, encodeProtectedBranchRequiredStatusCheck, encodePublicUser, encodePullRequest, encodePullRequestMergeResult, encodePullRequestMinimal, encodePullRequestReview, encodePullRequestReviewComment, encodePullRequestReviewRequest, encodePullRequestSimple, encodeRateLimit, encodeRateLimitOverview, encodeReaction, encodeReactionRollup, encodeReferencedWorkflow, encodeReferrerTraffic, encodeRelease, encodeReleaseAsset, encodeReleaseNotesContent, encodeRemovedFromProjectIssueEvent, encodeRenamedIssueEvent, encodeRepoCodespacesSecret, encodeRepoSearchResultItem, encodeRepository, encodeRepositoryCollaboratorPermission, encodeRepositoryInvitation, encodeRepositorySubscription, encodeReviewComment, encodeReviewDismissedIssueEvent, encodeReviewRequestRemovedIssueEvent, encodeReviewRequestedIssueEvent, encodeRoot, encodeRunner, encodeRunnerApplication, encodeRunnerGroupsEnterprise, encodeRunnerGroupsOrg, encodeRunnerLabel, encodeScimError, encodeScopedInstallation, encodeSearchResultTextMatches, encodeSecretScanningAlert, encodeSecretScanningAlertResolution, encodeSecretScanningAlertResolutionComment, encodeSecretScanningAlertState, encodeSecretScanningLocation, encodeSecretScanningLocationCommit, encodeSecurityAndAnalysis, encodeSelectedActions, encodeSelectedActionsUrl, encodeServerStatistics, encodeShortBlob, encodeShortBranch, encodeSimpleCommit, encodeSimpleCommitStatus, encodeSimpleInstallation, encodeSimpleRepository, encodeSimpleUser, encodeSnapshot, encodeSshSigningKey, encodeStargazer, encodeStarredRepository, encodeStateChangeIssueEvent, encodeStatus, encodeStatusCheckPolicy, encodeTag, encodeTagProtection, encodeTeam, encodeTeamDiscussion, encodeTeamDiscussionComment, encodeTeamFull, encodeTeamMembership, encodeTeamOrganization, encodeTeamProject, encodeTeamRepository, encodeTeamSimple, encodeThread, encodeThreadSubscription, encodeTimelineAssignedIssueEvent, encodeTimelineCommentEvent, encodeTimelineCommitCommentedEvent, encodeTimelineCommittedEvent, encodeTimelineCrossReferencedEvent, encodeTimelineIssueEvents, encodeTimelineLineCommentedEvent, encodeTimelineReviewedEvent, encodeTimelineUnassignedIssueEvent, encodeTopic, encodeTopicSearchResultItem, encodeTraffic, encodeUnassignedIssueEvent, encodeUnlabeledIssueEvent, encodeUserMarketplacePurchase, encodeUserSearchResultItem, encodeValidationError, encodeValidationErrorSimple, encodeVerification, encodeViewTraffic, encodeWaitTimer, encodeWebhookConfig, encodeWebhookConfigContentType, encodeWebhookConfigInsecureSsl, encodeWebhookConfigSecret, encodeWebhookConfigUrl, encodeWebhookDependabotAlertCreated, encodeWebhookDependabotAlertDismissed, encodeWebhookDependabotAlertFixed, encodeWebhookDependabotAlertReintroduced, encodeWebhookDependabotAlertReopened, encodeWebhookMergeGroupChecksRequested, encodeWorkflow, encodeWorkflowRun, encodeWorkflowRunUsage, encodeWorkflowUsage

## Decoders

@docs decodeAccepted, decodeActionsRunnerLabels, decodeActionsRunnerLabelsReadonly, decodeBadRequest, decodeCodeScanningForbiddenRead, decodeCodeScanningForbiddenWrite, decodeConflict, decodeForbidden, decodeForbiddenGist, decodeGone, decodeInternalError, decodeMovedPermanently, decodeNotFound, decodeRequiresAuthentication, decodeServiceUnavailable, decodeTemporaryRedirect, decodeValidationFailed, decodeValidationFailedSimple, decodeActionsBillingUsage, decodeActionsCacheList, decodeActionsCacheUsageByRepository, decodeActionsCacheUsageOrgEnterprise, decodeActionsCanApprovePullRequestReviews, decodeActionsDefaultWorkflowPermissions, decodeActionsEnabled, decodeActionsEnterprisePermissions, decodeActionsGetDefaultWorkflowPermissions, decodeActionsOrganizationPermissions, decodeActionsPublicKey, decodeActionsRepositoryPermissions, decodeActionsSecret, decodeActionsSetDefaultWorkflowPermissions, decodeActionsWorkflowAccessToRepository, decodeActor, decodeAddedToProjectIssueEvent, decodeAdvancedSecurityActiveCommitters, decodeAdvancedSecurityActiveCommittersRepository, decodeAdvancedSecurityActiveCommittersUser, decodeAlertCreatedAt, decodeAlertDismissedAt, decodeAlertFixedAt, decodeAlertHtmlUrl, decodeAlertInstancesUrl, decodeAlertNumber, decodeAlertUpdatedAt, decodeAlertUrl, decodeAllowedActions, decodeApiOverview, decodeAppPermissions, decodeArtifact, decodeAssignedIssueEvent, decodeAuthenticationToken, decodeAuthorAssociation, decodeAuthorization, decodeAutoMerge, decodeAutolink, decodeBaseGist, decodeBasicError, decodeBlob, decodeBranchProtection, decodeBranchRestrictionPolicy, decodeBranchShort, decodeBranchWithProtection, decodeCheckAnnotation, decodeCheckRun, decodeCheckSuite, decodeCheckSuitePreference, decodeCloneTraffic, decodeCodeFrequencyStat, decodeCodeOfConduct, decodeCodeOfConductSimple, decodeCodeScanningAlert, decodeCodeScanningAlertClassification, decodeCodeScanningAlertDismissedComment, decodeCodeScanningAlertDismissedReason, decodeCodeScanningAlertEnvironment, decodeCodeScanningAlertInstance, decodeCodeScanningAlertItems, decodeCodeScanningAlertLocation, decodeCodeScanningAlertRule, decodeCodeScanningAlertRuleSummary, decodeCodeScanningAlertSetState, decodeCodeScanningAlertState, decodeCodeScanningAnalysis, decodeCodeScanningAnalysisAnalysisKey, decodeCodeScanningAnalysisCategory, decodeCodeScanningAnalysisCommitSha, decodeCodeScanningAnalysisCreatedAt, decodeCodeScanningAnalysisDeletion, decodeCodeScanningAnalysisEnvironment, decodeCodeScanningAnalysisSarifFile, decodeCodeScanningAnalysisSarifId, decodeCodeScanningAnalysisTool, decodeCodeScanningAnalysisToolGuid, decodeCodeScanningAnalysisToolName, decodeCodeScanningAnalysisToolVersion, decodeCodeScanningAnalysisUrl, decodeCodeScanningCodeqlDatabase, decodeCodeScanningOrganizationAlertItems, decodeCodeScanningRef, decodeCodeScanningSarifsReceipt, decodeCodeScanningSarifsStatus, decodeCodeSearchResultItem, decodeCodeownersErrors, decodeCodespace, decodeCodespaceExportDetails, decodeCodespaceMachine, decodeCodespacesOrgSecret, decodeCodespacesPublicKey, decodeCodespacesSecret, decodeCodespacesUserPublicKey, decodeCollaborator, decodeCombinedBillingUsage, decodeCombinedCommitStatus, decodeCommit, decodeCommitActivity, decodeCommitComment, decodeCommitComparison, decodeCommitSearchResultItem, decodeCommunityHealthFile, decodeCommunityProfile, decodeContentDirectory, decodeContentFile, decodeContentSubmodule, decodeContentSymlink, decodeContentTraffic, decodeContentTree, decodeContributor, decodeContributorActivity, decodeConvertedNoteToIssueIssueEvent, decodeDemilestonedIssueEvent, decodeDependabotAlert, decodeDependabotAlertPackage, decodeDependabotAlertSecurityAdvisory, decodeDependabotAlertSecurityVulnerability, decodeDependabotPublicKey, decodeDependabotSecret, decodeDependency, decodeDependencyGraphDiff, decodeDeployKey, decodeDeployment, decodeDeploymentBranchPolicy, decodeDeploymentBranchPolicyNamePattern, decodeDeploymentBranchPolicySettings, decodeDeploymentReviewerType, decodeDeploymentSimple, decodeDeploymentStatus, decodeDiffEntry, decodeEmail, decodeEmptyObject, decodeEnabledOrganizations, decodeEnabledRepositories, decodeEnterprise, decodeEnvironment, decodeEnvironmentApprovals, decodeEvent, decodeFeed, decodeFileCommit, decodeFullRepository, decodeGistComment, decodeGistCommit, decodeGistHistory, decodeGistSimple, decodeGitCommit, decodeGitRef, decodeGitTag, decodeGitTree, decodeGitUser, decodeGitignoreTemplate, decodeGpgKey, decodeHook, decodeHookDelivery, decodeHookDeliveryItem, decodeHookResponse, decodeHovercard, decodeImport, decodeInstallation, decodeInstallationToken, decodeIntegration, decodeInteractionExpiry, decodeInteractionGroup, decodeInteractionLimit, decodeInteractionLimitResponse, decodeIssue, decodeIssueComment, decodeIssueEvent, decodeIssueEventDismissedReview, decodeIssueEventForIssue, decodeIssueEventLabel, decodeIssueEventMilestone, decodeIssueEventProjectCard, decodeIssueEventRename, decodeIssueSearchResultItem, decodeJob, decodeKey, decodeKeySimple, decodeLabel, decodeLabelSearchResultItem, decodeLabeledIssueEvent, decodeLanguage, decodeLicense, decodeLicenseContent, decodeLicenseSimple, decodeLink, decodeLinkWithType, decodeLockedIssueEvent, decodeManifest, decodeMarketplaceAccount, decodeMarketplaceListingPlan, decodeMarketplacePurchase, decodeMergedUpstream, decodeMetadata, decodeMigration, decodeMilestone, decodeMilestonedIssueEvent, decodeMinimalRepository, decodeMovedColumnInProjectIssueEvent, decodeOrgHook, decodeOrgMembership, decodeOrganizationActionsSecret, decodeOrganizationCustomRepositoryRole, decodeOrganizationDependabotSecret, decodeOrganizationFineGrainedPermission, decodeOrganizationFull, decodeOrganizationInvitation, decodeOrganizationSecretScanningAlert, decodeOrganizationSimple, decodePackage, decodePackageVersion, decodePackagesBillingUsage, decodePage, decodePageBuild, decodePageBuildStatus, decodePageDeployment, decodePagesHealthCheck, decodePagesHttpsCertificate, decodePagesSourceHash, decodeParticipationStats, decodePendingDeployment, decodePorterAuthor, decodePorterLargeFile, decodePrivateUser, decodeProject, decodeProjectCard, decodeProjectCollaboratorPermission, decodeProjectColumn, decodeProtectedBranch, decodeProtectedBranchAdminEnforced, decodeProtectedBranchPullRequestReview, decodeProtectedBranchRequiredStatusCheck, decodePublicUser, decodePullRequest, decodePullRequestMergeResult, decodePullRequestMinimal, decodePullRequestReview, decodePullRequestReviewComment, decodePullRequestReviewRequest, decodePullRequestSimple, decodeRateLimit, decodeRateLimitOverview, decodeReaction, decodeReactionRollup, decodeReferencedWorkflow, decodeReferrerTraffic, decodeRelease, decodeReleaseAsset, decodeReleaseNotesContent, decodeRemovedFromProjectIssueEvent, decodeRenamedIssueEvent, decodeRepoCodespacesSecret, decodeRepoSearchResultItem, decodeRepository, decodeRepositoryCollaboratorPermission, decodeRepositoryInvitation, decodeRepositorySubscription, decodeReviewComment, decodeReviewDismissedIssueEvent, decodeReviewRequestRemovedIssueEvent, decodeReviewRequestedIssueEvent, decodeRoot, decodeRunner, decodeRunnerApplication, decodeRunnerGroupsEnterprise, decodeRunnerGroupsOrg, decodeRunnerLabel, decodeScimError, decodeScopedInstallation, decodeSearchResultTextMatches, decodeSecretScanningAlert, decodeSecretScanningAlertResolution, decodeSecretScanningAlertResolutionComment, decodeSecretScanningAlertState, decodeSecretScanningLocation, decodeSecretScanningLocationCommit, decodeSecurityAndAnalysis, decodeSelectedActions, decodeSelectedActionsUrl, decodeServerStatistics, decodeShortBlob, decodeShortBranch, decodeSimpleCommit, decodeSimpleCommitStatus, decodeSimpleInstallation, decodeSimpleRepository, decodeSimpleUser, decodeSnapshot, decodeSshSigningKey, decodeStargazer, decodeStarredRepository, decodeStateChangeIssueEvent, decodeStatus, decodeStatusCheckPolicy, decodeTag, decodeTagProtection, decodeTeam, decodeTeamDiscussion, decodeTeamDiscussionComment, decodeTeamFull, decodeTeamMembership, decodeTeamOrganization, decodeTeamProject, decodeTeamRepository, decodeTeamSimple, decodeThread, decodeThreadSubscription, decodeTimelineAssignedIssueEvent, decodeTimelineCommentEvent, decodeTimelineCommitCommentedEvent, decodeTimelineCommittedEvent, decodeTimelineCrossReferencedEvent, decodeTimelineIssueEvents, decodeTimelineLineCommentedEvent, decodeTimelineReviewedEvent, decodeTimelineUnassignedIssueEvent, decodeTopic, decodeTopicSearchResultItem, decodeTraffic, decodeUnassignedIssueEvent, decodeUnlabeledIssueEvent, decodeUserMarketplacePurchase, decodeUserSearchResultItem, decodeValidationError, decodeValidationErrorSimple, decodeVerification, decodeViewTraffic, decodeWaitTimer, decodeWebhookConfig, decodeWebhookConfigContentType, decodeWebhookConfigInsecureSsl, decodeWebhookConfigSecret, decodeWebhookConfigUrl, decodeWebhookDependabotAlertCreated, decodeWebhookDependabotAlertDismissed, decodeWebhookDependabotAlertFixed, decodeWebhookDependabotAlertReintroduced, decodeWebhookDependabotAlertReopened, decodeWebhookMergeGroupChecksRequested, decodeWorkflow, decodeWorkflowRun, decodeWorkflowRunUsage, decodeWorkflowUsage
-}


import Http
import Json.Decode
import Json.Decode.Extra
import Json.Encode
import Url.Builder


{-| Get Hypermedia links to resources accessible in GitHub's REST API -}
metaRoot : { toMsg : Result Http.Error Root -> msg } -> Cmd msg
metaRoot config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeRoot
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url = "https://api.github.com/"
        }


{-| Returns the GitHub App associated with the authentication credentials used. To see how many app installations are associated with this GitHub App, see the `installations_count` in the response. For more details about your app's installations, see the "[List installations for the authenticated app](https://docs.github.com/rest/reference/apps#list-installations-for-the-authenticated-app)" endpoint.

You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
-}
appsGetAuthenticated :
    { toMsg : Result Http.Error Integration -> msg } -> Cmd msg
appsGetAuthenticated config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeIntegration
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url = "https://api.github.com/app"
        }


{-| Use this endpoint to complete the handshake necessary when implementing the [GitHub App Manifest flow](https://docs.github.com/apps/building-github-apps/creating-github-apps-from-a-manifest/). When you create a GitHub App with the manifest flow, you receive a temporary `code` used to retrieve the GitHub App's `id`, `pem` (private key), and `webhook_secret`. -}
appsCreateFromManifest config =
    Http.request
        { method = "POST"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\client_id client_secret created_at description events external_url html_url id installations_count name node_id owner pem permissions slug updated_at webhook_secret ->
                      { client_id = client_id
                      , client_secret = client_secret
                      , created_at = created_at
                      , description = description
                      , events = events
                      , external_url = external_url
                      , html_url = html_url
                      , id = id
                      , installations_count = installations_count
                      , name = name
                      , node_id = node_id
                      , owner = owner
                      , pem = pem
                      , permissions = permissions
                      , slug = slug
                      , updated_at = updated_at
                      , webhook_secret = webhook_secret
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "client_id" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "client_secret" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "created_at" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "description"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.string
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "events"
                            (Json.Decode.list Json.Decode.string)
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "external_url" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "html_url" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "id" Json.Decode.int)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "installations_count" Json.Decode.int
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "name" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "node_id" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "owner"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present decodeSimpleUser
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "pem" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "permissions"
                            (Json.Decode.succeed
                              (\checks contents deployments issues metadata ->
                                  { checks = checks
                                  , contents = contents
                                  , deployments = deployments
                                  , issues = issues
                                  , metadata = metadata
                                  }
                              )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "checks"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "contents"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "deployments"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "issues"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "metadata"
                                        Json.Decode.string
                                    )
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "slug" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "updated_at" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "webhook_secret"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.string
                                , Json.Decode.null Null
                                ]
                            )
                        )
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{code}"
                config.params.code
                "https://api.github.com/app-manifests/{code}/conversions"
        }


{-| Returns the webhook configuration for a GitHub App. For more information about configuring a webhook for your app, see "[Creating a GitHub App](/developers/apps/creating-a-github-app)."

You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
-}
appsGetWebhookConfigForApp :
    { toMsg : Result Http.Error WebhookConfig -> msg } -> Cmd msg
appsGetWebhookConfigForApp config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeWebhookConfig
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url = "https://api.github.com/app/hook/config"
        }


{-| Updates the webhook configuration for a GitHub App. For more information about configuring a webhook for your app, see "[Creating a GitHub App](/developers/apps/creating-a-github-app)."

You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
-}
appsUpdateWebhookConfigForApp :
    { toMsg : Result Http.Error WebhookConfig -> msg
    , body :
        { content_type : WebhookConfigContentType
        , insecure_ssl : WebhookConfigInsecureSsl
        , secret : WebhookConfigSecret
        , url : WebhookConfigUrl
        }
    }
    -> Cmd msg
appsUpdateWebhookConfigForApp config =
    Http.request
        { method = "PATCH"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeWebhookConfig
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "content_type"
                           , encodeWebhookConfigContentType rec.content_type
                           )
                         , ( "insecure_ssl"
                           , encodeWebhookConfigInsecureSsl rec.insecure_ssl
                           )
                         , ( "secret", encodeWebhookConfigSecret rec.secret )
                         , ( "url", encodeWebhookConfigUrl rec.url )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url = "https://api.github.com/app/hook/config"
        }


{-| Returns a list of webhook deliveries for the webhook configured for a GitHub App.

You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
-}
appsListWebhookDeliveries :
    { toMsg : Result Http.Error (List HookDeliveryItem) -> msg
    , params : { per_page : Maybe Int, cursor : Maybe String }
    }
    -> Cmd msg
appsListWebhookDeliveries config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeHookDeliveryItem)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                "https://api.github.com/app/hook/deliveries"
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (Url.Builder.string "cursor")
                        config.params.cursor
                    ]
                )
        }


{-| Returns a delivery for the webhook configured for a GitHub App.

You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
-}
appsGetWebhookDelivery config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeHookDelivery
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{delivery_id}"
                config.params.delivery_id
                "https://api.github.com/app/hook/deliveries/{delivery_id}"
        }


{-| Redeliver a delivery for the webhook configured for a GitHub App.

You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
-}
appsRedeliverWebhookDelivery config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeAccepted
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{delivery_id}"
                config.params.delivery_id
                "https://api.github.com/app/hook/deliveries/{delivery_id}/attempts"
        }


{-| You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.

The permissions the installation has are included under the `permissions` key.
-}
appsListInstallations :
    { toMsg : Result Http.Error (List Installation) -> msg
    , params :
        { per_page : Maybe Int
        , page : Maybe Int
        , since : Maybe String
        , outdated : Maybe String
        }
    }
    -> Cmd msg
appsListInstallations config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeInstallation)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                "https://api.github.com/app/installations"
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    , Maybe.map (Url.Builder.string "since") config.params.since
                    , Maybe.map
                        (Url.Builder.string "outdated")
                        config.params.outdated
                    ]
                )
        }


{-| Enables an authenticated GitHub App to find an installation's information using the installation id.

You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
-}
appsGetInstallation config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeInstallation
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{installation_id}"
                config.params.installation_id
                "https://api.github.com/app/installations/{installation_id}"
        }


{-| Uninstalls a GitHub App on a user, organization, or business account. If you prefer to temporarily suspend an app's access to your account's resources, then we recommend the "[Suspend an app installation](https://docs.github.com/rest/reference/apps/#suspend-an-app-installation)" endpoint.

You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
-}
appsDeleteInstallation config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{installation_id}"
                config.params.installation_id
                "https://api.github.com/app/installations/{installation_id}"
        }


{-| Creates an installation access token that enables a GitHub App to make authenticated API requests for the app's installation on an organization or individual account. Installation tokens expire one hour from the time you create them. Using an expired token produces a status code of `401 - Unauthorized`, and requires creating a new installation token. By default the installation token has access to all repositories that the installation can access. To restrict the access to specific repositories, you can provide the `repository_ids` when creating the token. When you omit `repository_ids`, the response does not contain the `repositories` key.

You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
-}
appsCreateInstallationAccessToken config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeInstallationToken
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "permissions"
                           , encodeAppPermissions rec.permissions
                           )
                         , ( "repositories"
                           , Json.Encode.list Json.Encode.string
                                 rec.repositories
                           )
                         , ( "repository_ids"
                           , Json.Encode.list Json.Encode.int rec.repository_ids
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{installation_id}"
                config.params.installation_id
                "https://api.github.com/app/installations/{installation_id}/access_tokens"
        }


{-| Suspends a GitHub App on a user, organization, or business account, which blocks the app from accessing the account's resources. When a GitHub App is suspended, the app's access to the GitHub API or webhook events is blocked for that account.

You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
-}
appsSuspendInstallation config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{installation_id}"
                config.params.installation_id
                "https://api.github.com/app/installations/{installation_id}/suspended"
        }


{-| Removes a GitHub App installation suspension.

You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
-}
appsUnsuspendInstallation config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{installation_id}"
                config.params.installation_id
                "https://api.github.com/app/installations/{installation_id}/suspended"
        }


{-| OAuth application owners can revoke a grant for their OAuth application and a specific user. You must use [Basic Authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint, using the OAuth application's `client_id` and `client_secret` as the username and password. You must also provide a valid OAuth `access_token` as an input parameter and the grant for the token's owner will be deleted.
Deleting an OAuth application's grant will also delete all OAuth tokens associated with the application for the user. Once deleted, the application will have no access to the user's account and will no longer be listed on [the application authorizations settings screen within GitHub](https://github.com/settings/applications#authorized).
-}
appsDeleteAuthorization :
    { toMsg : Result Http.Error () -> msg
    , body : { access_token : String }
    , params : { client_id : String }
    }
    -> Cmd msg
appsDeleteAuthorization config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "access_token"
                           , Json.Encode.string rec.access_token
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{client_id}"
                config.params.client_id
                "https://api.github.com/applications/{client_id}/grant"
        }


{-| OAuth applications can use a special API method for checking OAuth token validity without exceeding the normal rate limits for failed login attempts. Authentication works differently with this particular endpoint. You must use [Basic Authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) to use this endpoint, where the username is the OAuth application `client_id` and the password is its `client_secret`. Invalid tokens will return `404 NOT FOUND`. -}
appsCheckToken :
    { toMsg : Result Http.Error Authorization -> msg
    , body : { access_token : String }
    , params : { client_id : String }
    }
    -> Cmd msg
appsCheckToken config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeAuthorization
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "access_token"
                           , Json.Encode.string rec.access_token
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{client_id}"
                config.params.client_id
                "https://api.github.com/applications/{client_id}/token"
        }


{-| OAuth applications can use this API method to reset a valid OAuth token without end-user involvement. Applications must save the "token" property in the response because changes take effect immediately. You must use [Basic Authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint, using the OAuth application's `client_id` and `client_secret` as the username and password. Invalid tokens will return `404 NOT FOUND`. -}
appsResetToken :
    { toMsg : Result Http.Error Authorization -> msg
    , body : { access_token : String }
    , params : { client_id : String }
    }
    -> Cmd msg
appsResetToken config =
    Http.request
        { method = "PATCH"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeAuthorization
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "access_token"
                           , Json.Encode.string rec.access_token
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{client_id}"
                config.params.client_id
                "https://api.github.com/applications/{client_id}/token"
        }


{-| OAuth application owners can revoke a single token for an OAuth application. You must use [Basic Authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint, using the OAuth application's `client_id` and `client_secret` as the username and password. -}
appsDeleteToken :
    { toMsg : Result Http.Error () -> msg
    , body : { access_token : String }
    , params : { client_id : String }
    }
    -> Cmd msg
appsDeleteToken config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "access_token"
                           , Json.Encode.string rec.access_token
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{client_id}"
                config.params.client_id
                "https://api.github.com/applications/{client_id}/token"
        }


{-| Use a non-scoped user-to-server OAuth access token to create a repository scoped and/or permission scoped user-to-server OAuth access token. You can specify which repositories the token can access and which permissions are granted to the token. You must use [Basic Authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint, using the OAuth application's `client_id` and `client_secret` as the username and password. Invalid tokens will return `404 NOT FOUND`. -}
appsScopeToken :
    { toMsg : Result Http.Error Authorization -> msg
    , body :
        { access_token : String
        , permissions : AppPermissions
        , repositories : List String
        , repository_ids : List Int
        , target : String
        , target_id : Int
        }
    , params : { client_id : String }
    }
    -> Cmd msg
appsScopeToken config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeAuthorization
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "access_token"
                           , Json.Encode.string rec.access_token
                           )
                         , ( "permissions"
                           , encodeAppPermissions rec.permissions
                           )
                         , ( "repositories"
                           , Json.Encode.list Json.Encode.string
                                 rec.repositories
                           )
                         , ( "repository_ids"
                           , Json.Encode.list Json.Encode.int rec.repository_ids
                           )
                         , ( "target", Json.Encode.string rec.target )
                         , ( "target_id", Json.Encode.int rec.target_id )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{client_id}"
                config.params.client_id
                "https://api.github.com/applications/{client_id}/token/scoped"
        }


{-| **Note**: The `:app_slug` is just the URL-friendly name of your GitHub App. You can find this on the settings page for your GitHub App (e.g., `https://github.com/settings/apps/:app_slug`).

If the GitHub App you specify is public, you can access this endpoint without authenticating. If the GitHub App you specify is private, you must authenticate with a [personal access token](https://docs.github.com/articles/creating-a-personal-access-token-for-the-command-line/) or an [installation access token](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation) to access this endpoint.
-}
appsGetBySlug :
    { toMsg : Result Http.Error Integration -> msg
    , params : { app_slug : String }
    }
    -> Cmd msg
appsGetBySlug config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeIntegration
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{app_slug}"
                config.params.app_slug
                "https://api.github.com/apps/{app_slug}"
        }


codesOfConductGetAllCodesOfConduct :
    { toMsg : Result Http.Error (List CodeOfConduct) -> msg } -> Cmd msg
codesOfConductGetAllCodesOfConduct config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeCodeOfConduct)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url = "https://api.github.com/codes_of_conduct"
        }


codesOfConductGetConductCode :
    { toMsg : Result Http.Error CodeOfConduct -> msg
    , params : { key : String }
    }
    -> Cmd msg
codesOfConductGetConductCode config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeCodeOfConduct
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{key}"
                config.params.key
                "https://api.github.com/codes_of_conduct/{key}"
        }


{-| Lists all the emojis available to use on GitHub. -}
emojisGet : { toMsg : Result Http.Error {} -> msg } -> Cmd msg
emojisGet config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.succeed {})
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url = "https://api.github.com/emojis"
        }


{-| Returns aggregate usage metrics for your GitHub Enterprise Server 3.5+ instance for a specified time period up to 365 days.

To use this endpoint, your GitHub Enterprise Server instance must be connected to GitHub Enterprise Cloud using GitHub Connect. You must enable Server Statistics, and for the API request provide your enterprise account name or organization name connected to the GitHub Enterprise Server. For more information, see "[Enabling Server Statistics for your enterprise](/admin/configuration/configuring-github-connect/enabling-server-statistics-for-your-enterprise)" in the GitHub Enterprise Server documentation.

You'll need to use a personal access token:
  - If you connected your GitHub Enterprise Server to an enterprise account and enabled Server Statistics, you'll need a personal access token with the `read:enterprise` permission.
  - If you connected your GitHub Enterprise Server to an organization account and enabled Server Statistics, you'll need a personal access token with the `read:org` permission.

For more information on creating a personal access token, see "[Creating a personal access token](/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token)."
-}
enterpriseAdminGetServerStatistics :
    { toMsg : Result Http.Error ServerStatistics -> msg
    , params :
        { enterprise_or_org : String
        , date_start : Maybe String
        , date_end : Maybe String
        }
    }
    -> Cmd msg
enterpriseAdminGetServerStatistics config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeServerStatistics
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{enterprise_or_org}"
                    config.params.enterprise_or_org
                    "https://api.github.com/enterprise-installation/{enterprise_or_org}/server-statistics"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (Url.Builder.string "date_start")
                        config.params.date_start
                    , Maybe.map
                        (Url.Builder.string "date_end")
                        config.params.date_end
                    ]
                )
        }


{-| Gets the total GitHub Actions cache usage for an enterprise.
The data fetched using this API is refreshed approximately every 5 minutes, so values returned from this endpoint may take at least 5 minutes to get updated.
You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
-}
actionsGetActionsCacheUsageForEnterprise :
    { toMsg : Result Http.Error ActionsCacheUsageOrgEnterprise -> msg
    , params : { enterprise : String }
    }
    -> Cmd msg
actionsGetActionsCacheUsageForEnterprise config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg decodeActionsCacheUsageOrgEnterprise
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{enterprise}"
                config.params.enterprise
                "https://api.github.com/enterprises/{enterprise}/actions/cache/usage"
        }


{-| Gets the GitHub Actions permissions policy for organizations and allowed actions and reusable workflows in an enterprise.

You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
-}
enterpriseAdminGetGithubActionsPermissionsEnterprise :
    { toMsg : Result Http.Error ActionsEnterprisePermissions -> msg
    , params : { enterprise : String }
    }
    -> Cmd msg
enterpriseAdminGetGithubActionsPermissionsEnterprise config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg decodeActionsEnterprisePermissions
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{enterprise}"
                config.params.enterprise
                "https://api.github.com/enterprises/{enterprise}/actions/permissions"
        }


{-| Sets the GitHub Actions permissions policy for organizations and allowed actions and reusable workflows in an enterprise.

You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
-}
enterpriseAdminSetGithubActionsPermissionsEnterprise :
    { toMsg : Result Http.Error () -> msg
    , body :
        { allowed_actions : AllowedActions
        , enabled_organizations : EnabledOrganizations
        }
    , params : { enterprise : String }
    }
    -> Cmd msg
enterpriseAdminSetGithubActionsPermissionsEnterprise config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "allowed_actions"
                           , encodeAllowedActions rec.allowed_actions
                           )
                         , ( "enabled_organizations"
                           , encodeEnabledOrganizations
                                 rec.enabled_organizations
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{enterprise}"
                config.params.enterprise
                "https://api.github.com/enterprises/{enterprise}/actions/permissions"
        }


{-| Lists the organizations that are selected to have GitHub Actions enabled in an enterprise. To use this endpoint, the enterprise permission policy for `enabled_organizations` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an enterprise](#set-github-actions-permissions-for-an-enterprise)."

You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
-}
enterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\organizations total_count ->
                      { organizations = organizations
                      , total_count = total_count
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "organizations"
                            (Json.Decode.list decodeOrganizationSimple)
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.float)
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{enterprise}"
                    config.params.enterprise
                    "https://api.github.com/enterprises/{enterprise}/actions/permissions/organizations"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Replaces the list of selected organizations that are enabled for GitHub Actions in an enterprise. To use this endpoint, the enterprise permission policy for `enabled_organizations` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an enterprise](#set-github-actions-permissions-for-an-enterprise)."

You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
-}
enterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise :
    { toMsg : Result Http.Error () -> msg
    , body : { selected_organization_ids : List Int }
    , params : { enterprise : String }
    }
    -> Cmd msg
enterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "selected_organization_ids"
                           , Json.Encode.list Json.Encode.int
                                 rec.selected_organization_ids
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{enterprise}"
                config.params.enterprise
                "https://api.github.com/enterprises/{enterprise}/actions/permissions/organizations"
        }


{-| Adds an organization to the list of selected organizations that are enabled for GitHub Actions in an enterprise. To use this endpoint, the enterprise permission policy for `enabled_organizations` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an enterprise](#set-github-actions-permissions-for-an-enterprise)."

You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
-}
enterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{org_id}"
                config.params.org_id
                (String.replace
                    "{enterprise}"
                    config.params.enterprise
                    "https://api.github.com/enterprises/{enterprise}/actions/permissions/organizations/{org_id}"
                )
        }


{-| Removes an organization from the list of selected organizations that are enabled for GitHub Actions in an enterprise. To use this endpoint, the enterprise permission policy for `enabled_organizations` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an enterprise](#set-github-actions-permissions-for-an-enterprise)."

You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
-}
enterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{org_id}"
                config.params.org_id
                (String.replace
                    "{enterprise}"
                    config.params.enterprise
                    "https://api.github.com/enterprises/{enterprise}/actions/permissions/organizations/{org_id}"
                )
        }


{-| Gets the selected actions and reusable workflows that are allowed in an enterprise. To use this endpoint, the enterprise permission policy for `allowed_actions` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an enterprise](#set-github-actions-permissions-for-an-enterprise)."

You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
-}
enterpriseAdminGetAllowedActionsEnterprise :
    { toMsg : Result Http.Error SelectedActions -> msg
    , params : { enterprise : String }
    }
    -> Cmd msg
enterpriseAdminGetAllowedActionsEnterprise config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeSelectedActions
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{enterprise}"
                config.params.enterprise
                "https://api.github.com/enterprises/{enterprise}/actions/permissions/selected-actions"
        }


{-| Sets the actions and reusable workflows that are allowed in an enterprise. To use this endpoint, the enterprise permission policy for `allowed_actions` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an enterprise](#set-github-actions-permissions-for-an-enterprise)."

You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
-}
enterpriseAdminSetAllowedActionsEnterprise :
    { toMsg : Result Http.Error () -> msg
    , body : SelectedActions
    , params : { enterprise : String }
    }
    -> Cmd msg
enterpriseAdminSetAllowedActionsEnterprise config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.jsonBody (encodeSelectedActions config.body)
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{enterprise}"
                config.params.enterprise
                "https://api.github.com/enterprises/{enterprise}/actions/permissions/selected-actions"
        }


{-| Gets the default workflow permissions granted to the `GITHUB_TOKEN` when running workflows in an enterprise,
as well as whether GitHub Actions can submit approving pull request reviews. For more information, see
"[Enforcing a policy for workflow permissions in your enterprise](https://docs.github.com/enterprise-cloud@latest/admin/policies/enforcing-policies-for-your-enterprise/enforcing-policies-for-github-actions-in-your-enterprise#enforcing-a-policy-for-workflow-permissions-in-your-enterprise)."

You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
GitHub Apps must have the `enterprise_administration:write` permission to use this endpoint.
-}
actionsGetGithubActionsDefaultWorkflowPermissionsEnterprise :
    { toMsg : Result Http.Error ActionsGetDefaultWorkflowPermissions -> msg
    , params : { enterprise : String }
    }
    -> Cmd msg
actionsGetGithubActionsDefaultWorkflowPermissionsEnterprise config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                decodeActionsGetDefaultWorkflowPermissions
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{enterprise}"
                config.params.enterprise
                "https://api.github.com/enterprises/{enterprise}/actions/permissions/workflow"
        }


{-| Sets the default workflow permissions granted to the `GITHUB_TOKEN` when running workflows in an enterprise, and sets
whether GitHub Actions can submit approving pull request reviews. For more information, see
"[Enforcing a policy for workflow permissions in your enterprise](https://docs.github.com/enterprise-cloud@latest/admin/policies/enforcing-policies-for-your-enterprise/enforcing-policies-for-github-actions-in-your-enterprise#enforcing-a-policy-for-workflow-permissions-in-your-enterprise)."

You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
GitHub Apps must have the `enterprise_administration:write` permission to use this endpoint.
-}
actionsSetGithubActionsDefaultWorkflowPermissionsEnterprise :
    { toMsg : Result Http.Error () -> msg
    , body : ActionsSetDefaultWorkflowPermissions
    , params : { enterprise : String }
    }
    -> Cmd msg
actionsSetGithubActionsDefaultWorkflowPermissionsEnterprise config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body =
            Http.jsonBody
                (encodeActionsSetDefaultWorkflowPermissions config.body)
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{enterprise}"
                config.params.enterprise
                "https://api.github.com/enterprises/{enterprise}/actions/permissions/workflow"
        }


{-| Lists all self-hosted runner groups for an enterprise.

You must authenticate using an access token with the `manage_runners:enterprise` scope to use this endpoint.
-}
enterpriseAdminListSelfHostedRunnerGroupsForEnterprise config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\runner_groups total_count ->
                      { runner_groups = runner_groups
                      , total_count = total_count
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "runner_groups"
                            (Json.Decode.list decodeRunnerGroupsEnterprise)
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.float)
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{enterprise}"
                    config.params.enterprise
                    "https://api.github.com/enterprises/{enterprise}/actions/runner-groups"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    , Maybe.map
                        (Url.Builder.string "visible_to_organization")
                        config.params.visible_to_organization
                    ]
                )
        }


{-| Creates a new self-hosted runner group for an enterprise.

You must authenticate using an access token with the `manage_runners:enterprise` scope to use this endpoint.
-}
enterpriseAdminCreateSelfHostedRunnerGroupForEnterprise :
    { toMsg : Result Http.Error RunnerGroupsEnterprise -> msg
    , body :
        { allows_public_repositories : Bool
        , name : String
        , restricted_to_workflows : Bool
        , runners : List Int
        , selected_organization_ids : List Int
        , selected_workflows : List String
        , visibility : String
        }
    , params : { enterprise : String }
    }
    -> Cmd msg
enterpriseAdminCreateSelfHostedRunnerGroupForEnterprise config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeRunnerGroupsEnterprise
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "allows_public_repositories"
                           , Json.Encode.bool rec.allows_public_repositories
                           )
                         , ( "name", Json.Encode.string rec.name )
                         , ( "restricted_to_workflows"
                           , Json.Encode.bool rec.restricted_to_workflows
                           )
                         , ( "runners"
                           , Json.Encode.list Json.Encode.int rec.runners
                           )
                         , ( "selected_organization_ids"
                           , Json.Encode.list Json.Encode.int
                                 rec.selected_organization_ids
                           )
                         , ( "selected_workflows"
                           , Json.Encode.list Json.Encode.string
                                 rec.selected_workflows
                           )
                         , ( "visibility", Json.Encode.string rec.visibility )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{enterprise}"
                config.params.enterprise
                "https://api.github.com/enterprises/{enterprise}/actions/runner-groups"
        }


{-| Gets a specific self-hosted runner group for an enterprise.

You must authenticate using an access token with the `manage_runners:enterprise` scope to use this endpoint.
-}
enterpriseAdminGetSelfHostedRunnerGroupForEnterprise config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeRunnerGroupsEnterprise
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{runner_group_id}"
                config.params.runner_group_id
                (String.replace
                    "{enterprise}"
                    config.params.enterprise
                    "https://api.github.com/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}"
                )
        }


{-| Updates the `name` and `visibility` of a self-hosted runner group in an enterprise.

You must authenticate using an access token with the `manage_runners:enterprise` scope to use this endpoint.
-}
enterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise config =
    Http.request
        { method = "PATCH"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeRunnerGroupsEnterprise
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "allows_public_repositories"
                           , Json.Encode.bool rec.allows_public_repositories
                           )
                         , ( "name", Json.Encode.string rec.name )
                         , ( "restricted_to_workflows"
                           , Json.Encode.bool rec.restricted_to_workflows
                           )
                         , ( "selected_workflows"
                           , Json.Encode.list Json.Encode.string
                                 rec.selected_workflows
                           )
                         , ( "visibility", Json.Encode.string rec.visibility )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{runner_group_id}"
                config.params.runner_group_id
                (String.replace
                    "{enterprise}"
                    config.params.enterprise
                    "https://api.github.com/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}"
                )
        }


{-| Deletes a self-hosted runner group for an enterprise.

You must authenticate using an access token with the `manage_runners:enterprise` scope to use this endpoint.
-}
enterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{runner_group_id}"
                config.params.runner_group_id
                (String.replace
                    "{enterprise}"
                    config.params.enterprise
                    "https://api.github.com/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}"
                )
        }


{-| Lists the organizations with access to a self-hosted runner group.

You must authenticate using an access token with the `manage_runners:enterprise` scope to use this endpoint.
-}
enterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\organizations total_count ->
                      { organizations = organizations
                      , total_count = total_count
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "organizations"
                            (Json.Decode.list decodeOrganizationSimple)
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.float)
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{runner_group_id}"
                    config.params.runner_group_id
                    (String.replace
                        "{enterprise}"
                        config.params.enterprise
                        "https://api.github.com/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Replaces the list of organizations that have access to a self-hosted runner configured in an enterprise.

You must authenticate using an access token with the `manage_runners:enterprise` scope to use this endpoint.
-}
enterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "selected_organization_ids"
                           , Json.Encode.list Json.Encode.int
                                 rec.selected_organization_ids
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{runner_group_id}"
                config.params.runner_group_id
                (String.replace
                    "{enterprise}"
                    config.params.enterprise
                    "https://api.github.com/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations"
                )
        }


{-| Adds an organization to the list of selected organizations that can access a self-hosted runner group. The runner group must have `visibility` set to `selected`. For more information, see "[Create a self-hosted runner group for an enterprise](#create-a-self-hosted-runner-group-for-an-enterprise)."

You must authenticate using an access token with the `manage_runners:enterprise` scope to use this endpoint.
-}
enterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{org_id}"
                config.params.org_id
                (String.replace
                    "{runner_group_id}"
                    config.params.runner_group_id
                    (String.replace
                        "{enterprise}"
                        config.params.enterprise
                        "https://api.github.com/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations/{org_id}"
                    )
                )
        }


{-| Removes an organization from the list of selected organizations that can access a self-hosted runner group. The runner group must have `visibility` set to `selected`. For more information, see "[Create a self-hosted runner group for an enterprise](#create-a-self-hosted-runner-group-for-an-enterprise)."

You must authenticate using an access token with the `manage_runners:enterprise` scope to use this endpoint.
-}
enterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{org_id}"
                config.params.org_id
                (String.replace
                    "{runner_group_id}"
                    config.params.runner_group_id
                    (String.replace
                        "{enterprise}"
                        config.params.enterprise
                        "https://api.github.com/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations/{org_id}"
                    )
                )
        }


{-| Lists the self-hosted runners that are in a specific enterprise group.

You must authenticate using an access token with the `manage_runners:enterprise` scope to use this endpoint.
-}
enterpriseAdminListSelfHostedRunnersInGroupForEnterprise config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\runners total_count ->
                      { runners = runners, total_count = total_count }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "runners"
                            (Json.Decode.list decodeRunner)
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.float)
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{runner_group_id}"
                    config.params.runner_group_id
                    (String.replace
                        "{enterprise}"
                        config.params.enterprise
                        "https://api.github.com/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Replaces the list of self-hosted runners that are part of an enterprise runner group.

You must authenticate using an access token with the `manage_runners:enterprise` scope to use this endpoint.
-}
enterpriseAdminSetSelfHostedRunnersInGroupForEnterprise config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "runners"
                           , Json.Encode.list Json.Encode.int rec.runners
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{runner_group_id}"
                config.params.runner_group_id
                (String.replace
                    "{enterprise}"
                    config.params.enterprise
                    "https://api.github.com/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners"
                )
        }


{-| Adds a self-hosted runner to a runner group configured in an enterprise.

You must authenticate using an access token with the `manage_runners:enterprise`
scope to use this endpoint.
-}
enterpriseAdminAddSelfHostedRunnerToGroupForEnterprise config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{runner_id}"
                config.params.runner_id
                (String.replace
                    "{runner_group_id}"
                    config.params.runner_group_id
                    (String.replace
                        "{enterprise}"
                        config.params.enterprise
                        "https://api.github.com/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners/{runner_id}"
                    )
                )
        }


{-| Removes a self-hosted runner from a group configured in an enterprise. The runner is then returned to the default group.

You must authenticate using an access token with the `manage_runners:enterprise` scope to use this endpoint.
-}
enterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{runner_id}"
                config.params.runner_id
                (String.replace
                    "{runner_group_id}"
                    config.params.runner_group_id
                    (String.replace
                        "{enterprise}"
                        config.params.enterprise
                        "https://api.github.com/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners/{runner_id}"
                    )
                )
        }


{-| Lists all self-hosted runners configured for an enterprise.

You must authenticate using an access token with the `manage_runners:enterprise` scope to use this endpoint.
-}
enterpriseAdminListSelfHostedRunnersForEnterprise config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\runners total_count ->
                      { runners = runners, total_count = total_count }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "runners"
                            (Json.Decode.list decodeRunner)
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.float)
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{enterprise}"
                    config.params.enterprise
                    "https://api.github.com/enterprises/{enterprise}/actions/runners"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Lists binaries for the runner application that you can download and run.

You must authenticate using an access token with the `manage_runners:enterprise` scope to use this endpoint.
-}
enterpriseAdminListRunnerApplicationsForEnterprise :
    { toMsg : Result Http.Error (List RunnerApplication) -> msg
    , params : { enterprise : String }
    }
    -> Cmd msg
enterpriseAdminListRunnerApplicationsForEnterprise config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeRunnerApplication)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{enterprise}"
                config.params.enterprise
                "https://api.github.com/enterprises/{enterprise}/actions/runners/downloads"
        }


{-| Returns a token that you can pass to the `config` script. The token expires after one hour.

You must authenticate using an access token with the `manage_runners:enterprise` scope to use this endpoint.

#### Example using registration token

Configure your self-hosted runner, replacing `TOKEN` with the registration token provided by this endpoint.

```
./config.sh --url https://github.com/enterprises/octo-enterprise --token TOKEN
```
-}
enterpriseAdminCreateRegistrationTokenForEnterprise :
    { toMsg : Result Http.Error AuthenticationToken -> msg
    , params : { enterprise : String }
    }
    -> Cmd msg
enterpriseAdminCreateRegistrationTokenForEnterprise config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeAuthenticationToken
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{enterprise}"
                config.params.enterprise
                "https://api.github.com/enterprises/{enterprise}/actions/runners/registration-token"
        }


{-| Returns a token that you can pass to the `config` script to remove a self-hosted runner from an enterprise. The token expires after one hour.

You must authenticate using an access token with the `manage_runners:enterprise` scope to use this endpoint.

#### Example using remove token

To remove your self-hosted runner from an enterprise, replace `TOKEN` with the remove token provided by this
endpoint.

```
./config.sh remove --token TOKEN
```
-}
enterpriseAdminCreateRemoveTokenForEnterprise :
    { toMsg : Result Http.Error AuthenticationToken -> msg
    , params : { enterprise : String }
    }
    -> Cmd msg
enterpriseAdminCreateRemoveTokenForEnterprise config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeAuthenticationToken
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{enterprise}"
                config.params.enterprise
                "https://api.github.com/enterprises/{enterprise}/actions/runners/remove-token"
        }


{-| Gets a specific self-hosted runner configured in an enterprise.

You must authenticate using an access token with the `manage_runners:enterprise` scope to use this endpoint.
-}
enterpriseAdminGetSelfHostedRunnerForEnterprise config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeRunner
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{runner_id}"
                config.params.runner_id
                (String.replace
                    "{enterprise}"
                    config.params.enterprise
                    "https://api.github.com/enterprises/{enterprise}/actions/runners/{runner_id}"
                )
        }


{-| Forces the removal of a self-hosted runner from an enterprise. You can use this endpoint to completely remove the runner when the machine you were using no longer exists.

You must authenticate using an access token with the `manage_runners:enterprise` scope to use this endpoint.
-}
enterpriseAdminDeleteSelfHostedRunnerFromEnterprise config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{runner_id}"
                config.params.runner_id
                (String.replace
                    "{enterprise}"
                    config.params.enterprise
                    "https://api.github.com/enterprises/{enterprise}/actions/runners/{runner_id}"
                )
        }


{-| Lists all labels for a self-hosted runner configured in an enterprise.

You must authenticate using an access token with the `manage_runners:enterprise` scope to use this endpoint.
-}
enterpriseAdminListLabelsForSelfHostedRunnerForEnterprise config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeActionsRunnerLabels
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{runner_id}"
                config.params.runner_id
                (String.replace
                    "{enterprise}"
                    config.params.enterprise
                    "https://api.github.com/enterprises/{enterprise}/actions/runners/{runner_id}/labels"
                )
        }


{-| Add custom labels to a self-hosted runner configured in an enterprise.

You must authenticate using an access token with the `manage_runners:enterprise` scope to use this endpoint.
-}
enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterprise config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeActionsRunnerLabels
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "labels"
                           , Json.Encode.list Json.Encode.string rec.labels
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{runner_id}"
                config.params.runner_id
                (String.replace
                    "{enterprise}"
                    config.params.enterprise
                    "https://api.github.com/enterprises/{enterprise}/actions/runners/{runner_id}/labels"
                )
        }


{-| Remove all previous custom labels and set the new custom labels for a specific
self-hosted runner configured in an enterprise.

You must authenticate using an access token with the `manage_runners:enterprise` scope to use this endpoint.
-}
enterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterprise config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeActionsRunnerLabels
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "labels"
                           , Json.Encode.list Json.Encode.string rec.labels
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{runner_id}"
                config.params.runner_id
                (String.replace
                    "{enterprise}"
                    config.params.enterprise
                    "https://api.github.com/enterprises/{enterprise}/actions/runners/{runner_id}/labels"
                )
        }


{-| Remove all custom labels from a self-hosted runner configured in an
enterprise. Returns the remaining read-only labels from the runner.

You must authenticate using an access token with the `manage_runners:enterprise` scope to use this endpoint.
-}
enterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterprise config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect =
            Http.expectJson config.toMsg decodeActionsRunnerLabelsReadonly
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{runner_id}"
                config.params.runner_id
                (String.replace
                    "{enterprise}"
                    config.params.enterprise
                    "https://api.github.com/enterprises/{enterprise}/actions/runners/{runner_id}/labels"
                )
        }


{-| Remove a custom label from a self-hosted runner configured
in an enterprise. Returns the remaining labels from the runner.

This endpoint returns a `404 Not Found` status if the custom label is not
present on the runner.

You must authenticate using an access token with the `manage_runners:enterprise` scope to use this endpoint.
-}
enterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterprise config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeActionsRunnerLabels
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{name}"
                config.params.name
                (String.replace
                    "{runner_id}"
                    config.params.runner_id
                    (String.replace
                        "{enterprise}"
                        config.params.enterprise
                        "https://api.github.com/enterprises/{enterprise}/actions/runners/{runner_id}/labels/{name}"
                    )
                )
        }


{-| Lists code scanning alerts for the default branch for all eligible repositories in an enterprise. Eligible repositories are repositories that are owned by organizations that you own or for which you are a security manager. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."

To use this endpoint, you must be a member of the enterprise,
and you must use an access token with the `repo` scope or `security_events` scope.
-}
codeScanningListAlertsForEnterprise :
    { toMsg : Result Http.Error (List CodeScanningOrganizationAlertItems) -> msg
    , params :
        { enterprise : String
        , tool_name : Maybe CodeScanningAnalysisToolName
        , tool_guid : Maybe CodeScanningAnalysisToolGuid
        , before : Maybe String
        , after : Maybe String
        , page : Maybe Int
        , per_page : Maybe Int
        , direction : Maybe String
        , state : Maybe CodeScanningAlertState
        , sort : Maybe String
        }
    }
    -> Cmd msg
codeScanningListAlertsForEnterprise config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeCodeScanningOrganizationAlertItems)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{enterprise}"
                    config.params.enterprise
                    "https://api.github.com/enterprises/{enterprise}/code-scanning/alerts"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "tool_name"
                                (Debug.todo
                                    "Params of type \"CodeScanningAnalysisToolName\" (in helper)"
                                )
                        )
                        config.params.tool_name
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "tool_guid"
                                (Debug.todo
                                    "Params of type \"CodeScanningAnalysisToolGuid\" (in helper)"
                                )
                        )
                        config.params.tool_guid
                    , Maybe.map
                        (Url.Builder.string "before")
                        config.params.before
                    , Maybe.map (Url.Builder.string "after") config.params.after
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (Url.Builder.string "direction")
                        config.params.direction
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "state"
                                (Debug.todo
                                    "Params of type \"CodeScanningAlertState\" (in helper)"
                                )
                        )
                        config.params.state
                    , Maybe.map (Url.Builder.string "sort") config.params.sort
                    ]
                )
        }


{-| Lists secret scanning alerts for eligible repositories in an enterprise, from newest to oldest.
To use this endpoint, you must be a member of the enterprise, and you must use an access token with the `repo` scope or `security_events` scope. Alerts are only returned for organizations in the enterprise for which you are an organization owner or a [security manager](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization).
-}
secretScanningListAlertsForEnterprise :
    { toMsg : Result Http.Error (List OrganizationSecretScanningAlert) -> msg
    , params :
        { enterprise : String
        , state : Maybe String
        , secret_type : Maybe String
        , resolution : Maybe String
        , sort : Maybe String
        , direction : Maybe String
        , per_page : Maybe Int
        , before : Maybe String
        , after : Maybe String
        }
    }
    -> Cmd msg
secretScanningListAlertsForEnterprise config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeOrganizationSecretScanningAlert)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{enterprise}"
                    config.params.enterprise
                    "https://api.github.com/enterprises/{enterprise}/secret-scanning/alerts"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map (Url.Builder.string "state") config.params.state
                    , Maybe.map
                        (Url.Builder.string "secret_type")
                        config.params.secret_type
                    , Maybe.map
                        (Url.Builder.string "resolution")
                        config.params.resolution
                    , Maybe.map (Url.Builder.string "sort") config.params.sort
                    , Maybe.map
                        (Url.Builder.string "direction")
                        config.params.direction
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (Url.Builder.string "before")
                        config.params.before
                    , Maybe.map (Url.Builder.string "after") config.params.after
                    ]
                )
        }


{-| Gets the GitHub Advanced Security active committers for an enterprise per repository.

Each distinct user login across all repositories is counted as a single Advanced Security seat, so the `total_advanced_security_committers` is not the sum of active_users for each repository.

The total number of repositories with committer information is tracked by the `total_count` field.
-}
billingGetGithubAdvancedSecurityBillingGhe :
    { toMsg : Result Http.Error AdvancedSecurityActiveCommitters -> msg
    , params : { enterprise : String, per_page : Maybe Int, page : Maybe Int }
    }
    -> Cmd msg
billingGetGithubAdvancedSecurityBillingGhe config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg decodeAdvancedSecurityActiveCommitters
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{enterprise}"
                    config.params.enterprise
                    "https://api.github.com/enterprises/{enterprise}/settings/billing/advanced-security"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| We delay the public events feed by five minutes, which means the most recent event returned by the public events API actually occurred at least five minutes ago. -}
activityListPublicEvents :
    { toMsg : Result Http.Error (List Event) -> msg
    , params : { per_page : Maybe Int, page : Maybe Int }
    }
    -> Cmd msg
activityListPublicEvents config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.list decodeEvent)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                "https://api.github.com/events"
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| GitHub provides several timeline resources in [Atom](http://en.wikipedia.org/wiki/Atom_(standard)) format. The Feeds API lists all the feeds available to the authenticated user:

*   **Timeline**: The GitHub global public timeline
*   **User**: The public timeline for any user, using [URI template](https://docs.github.com/rest/overview/resources-in-the-rest-api#hypermedia)
*   **Current user public**: The public timeline for the authenticated user
*   **Current user**: The private timeline for the authenticated user
*   **Current user actor**: The private timeline for activity created by the authenticated user
*   **Current user organizations**: The private timeline for the organizations the authenticated user is a member of.
*   **Security advisories**: A collection of public announcements that provide information about security-related vulnerabilities in software on GitHub.

**Note**: Private feeds are only returned when [authenticating via Basic Auth](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) since current feed URIs use the older, non revocable auth tokens.
-}
activityGetFeeds : { toMsg : Result Http.Error Feed -> msg } -> Cmd msg
activityGetFeeds config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeFeed
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url = "https://api.github.com/feeds"
        }


{-| Lists the authenticated user's gists or if called anonymously, this endpoint returns all public gists: -}
gistsList :
    { toMsg : Result Http.Error (List BaseGist) -> msg
    , params : { since : Maybe String, per_page : Maybe Int, page : Maybe Int }
    }
    -> Cmd msg
gistsList config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeBaseGist)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                "https://api.github.com/gists"
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map (Url.Builder.string "since") config.params.since
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Allows you to add a new gist with one or more files.

**Note:** Don't name your files "gistfile" with a numerical suffix. This is the format of the automatic naming scheme that Gist uses internally.
-}
gistsCreate :
    { toMsg : Result Http.Error GistSimple -> msg
    , body : { description : String, files : {}, public : Json.Encode.Value }
    }
    -> Cmd msg
gistsCreate config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeGistSimple
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "description", Json.Encode.string rec.description )
                         , ( "files"
                           , (\rec0 -> Json.Encode.object []) rec.files
                           )
                         , ( "public", Basics.identity rec.public )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url = "https://api.github.com/gists"
        }


{-| List public gists sorted by most recently updated to least recently updated.

Note: With [pagination](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination), you can fetch up to 3000 gists. For example, you can fetch 100 pages with 30 gists per page or 30 pages with 100 gists per page.
-}
gistsListPublic :
    { toMsg : Result Http.Error (List BaseGist) -> msg
    , params : { since : Maybe String, per_page : Maybe Int, page : Maybe Int }
    }
    -> Cmd msg
gistsListPublic config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeBaseGist)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                "https://api.github.com/gists/public"
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map (Url.Builder.string "since") config.params.since
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| List the authenticated user's starred gists: -}
gistsListStarred :
    { toMsg : Result Http.Error (List BaseGist) -> msg
    , params : { since : Maybe String, per_page : Maybe Int, page : Maybe Int }
    }
    -> Cmd msg
gistsListStarred config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeBaseGist)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                "https://api.github.com/gists/starred"
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map (Url.Builder.string "since") config.params.since
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


gistsGet :
    { toMsg : Result Http.Error GistSimple -> msg
    , params : { gist_id : String }
    }
    -> Cmd msg
gistsGet config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeGistSimple
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{gist_id}"
                config.params.gist_id
                "https://api.github.com/gists/{gist_id}"
        }


{-| Allows you to update a gist's description and to update, delete, or rename gist files. Files from the previous version of the gist that aren't explicitly changed during an edit are unchanged. -}
gistsUpdate :
    { toMsg : Result Http.Error GistSimple -> msg
    , body : Nullable { description : String, files : {} }
    , params : { gist_id : String }
    }
    -> Cmd msg
gistsUpdate config =
    Http.request
        { method = "PATCH"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeGistSimple
        , body =
            Http.jsonBody
                ((\nullableValue ->
                     case nullableValue of
                         Null ->
                             Json.Encode.null

                         Present value ->
                             (\rec ->
                                 Json.Encode.object
                                     [ ( "description"
                                       , Json.Encode.string rec.description
                                       )
                                     , ( "files"
                                       , (\rec0 -> Json.Encode.object [])
                                             rec.files
                                       )
                                     ]
                             )
                                 value
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{gist_id}"
                config.params.gist_id
                "https://api.github.com/gists/{gist_id}"
        }


gistsDelete :
    { toMsg : Result Http.Error () -> msg, params : { gist_id : String } }
    -> Cmd msg
gistsDelete config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{gist_id}"
                config.params.gist_id
                "https://api.github.com/gists/{gist_id}"
        }


gistsListComments :
    { toMsg : Result Http.Error (List GistComment) -> msg
    , params : { gist_id : String, per_page : Maybe Int, page : Maybe Int }
    }
    -> Cmd msg
gistsListComments config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeGistComment)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{gist_id}"
                    config.params.gist_id
                    "https://api.github.com/gists/{gist_id}/comments"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


gistsCreateComment :
    { toMsg : Result Http.Error GistComment -> msg
    , body : { body : String }
    , params : { gist_id : String }
    }
    -> Cmd msg
gistsCreateComment config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeGistComment
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "body", Json.Encode.string rec.body ) ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{gist_id}"
                config.params.gist_id
                "https://api.github.com/gists/{gist_id}/comments"
        }


gistsGetComment config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeGistComment
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{comment_id}"
                config.params.comment_id
                (String.replace
                    "{gist_id}"
                    config.params.gist_id
                    "https://api.github.com/gists/{gist_id}/comments/{comment_id}"
                )
        }


gistsUpdateComment config =
    Http.request
        { method = "PATCH"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeGistComment
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "body", Json.Encode.string rec.body ) ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{comment_id}"
                config.params.comment_id
                (String.replace
                    "{gist_id}"
                    config.params.gist_id
                    "https://api.github.com/gists/{gist_id}/comments/{comment_id}"
                )
        }


gistsDeleteComment config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{comment_id}"
                config.params.comment_id
                (String.replace
                    "{gist_id}"
                    config.params.gist_id
                    "https://api.github.com/gists/{gist_id}/comments/{comment_id}"
                )
        }


gistsListCommits :
    { toMsg : Result Http.Error (List GistCommit) -> msg
    , params : { gist_id : String, per_page : Maybe Int, page : Maybe Int }
    }
    -> Cmd msg
gistsListCommits config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeGistCommit)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{gist_id}"
                    config.params.gist_id
                    "https://api.github.com/gists/{gist_id}/commits"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


gistsListForks :
    { toMsg : Result Http.Error (List GistSimple) -> msg
    , params : { gist_id : String, per_page : Maybe Int, page : Maybe Int }
    }
    -> Cmd msg
gistsListForks config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeGistSimple)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{gist_id}"
                    config.params.gist_id
                    "https://api.github.com/gists/{gist_id}/forks"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


gistsFork :
    { toMsg : Result Http.Error BaseGist -> msg, params : { gist_id : String } }
    -> Cmd msg
gistsFork config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeBaseGist
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{gist_id}"
                config.params.gist_id
                "https://api.github.com/gists/{gist_id}/forks"
        }


gistsCheckIsStarred :
    { toMsg : Result Http.Error () -> msg, params : { gist_id : String } }
    -> Cmd msg
gistsCheckIsStarred config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{gist_id}"
                config.params.gist_id
                "https://api.github.com/gists/{gist_id}/star"
        }


{-| Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs)." -}
gistsStar :
    { toMsg : Result Http.Error () -> msg, params : { gist_id : String } }
    -> Cmd msg
gistsStar config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{gist_id}"
                config.params.gist_id
                "https://api.github.com/gists/{gist_id}/star"
        }


gistsUnstar :
    { toMsg : Result Http.Error () -> msg, params : { gist_id : String } }
    -> Cmd msg
gistsUnstar config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{gist_id}"
                config.params.gist_id
                "https://api.github.com/gists/{gist_id}/star"
        }


gistsGetRevision :
    { toMsg : Result Http.Error GistSimple -> msg
    , params : { gist_id : String, sha : String }
    }
    -> Cmd msg
gistsGetRevision config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeGistSimple
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{sha}"
                config.params.sha
                (String.replace
                    "{gist_id}"
                    config.params.gist_id
                    "https://api.github.com/gists/{gist_id}/{sha}"
                )
        }


{-| List all templates available to pass as an option when [creating a repository](https://docs.github.com/rest/reference/repos#create-a-repository-for-the-authenticated-user). -}
gitignoreGetAllTemplates :
    { toMsg : Result Http.Error (List String) -> msg } -> Cmd msg
gitignoreGetAllTemplates config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list Json.Decode.string)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url = "https://api.github.com/gitignore/templates"
        }


{-| The API also allows fetching the source of a single template.
Use the raw [media type](https://docs.github.com/rest/overview/media-types/) to get the raw contents.
-}
gitignoreGetTemplate :
    { toMsg : Result Http.Error GitignoreTemplate -> msg
    , params : { name : String }
    }
    -> Cmd msg
gitignoreGetTemplate config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeGitignoreTemplate
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{name}"
                config.params.name
                "https://api.github.com/gitignore/templates/{name}"
        }


{-| List repositories that an app installation can access.

You must use an [installation access token](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation) to access this endpoint.
-}
appsListReposAccessibleToInstallation config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\repositories repository_selection total_count ->
                      { repositories = repositories
                      , repository_selection = repository_selection
                      , total_count = total_count
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "repositories"
                            (Json.Decode.list decodeRepository)
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "repository_selection"
                            Json.Decode.string
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.int)
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                "https://api.github.com/installation/repositories"
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Revokes the installation token you're using to authenticate as an installation and access this endpoint.

Once an installation token is revoked, the token is invalidated and cannot be used. Other endpoints that require the revoked installation token must have a new installation token to work. You can create a new token using the "[Create an installation access token for an app](https://docs.github.com/rest/reference/apps#create-an-installation-access-token-for-an-app)" endpoint.

You must use an [installation access token](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation) to access this endpoint.
-}
appsRevokeInstallationAccessToken :
    { toMsg : Result Http.Error () -> msg } -> Cmd msg
appsRevokeInstallationAccessToken config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url = "https://api.github.com/installation/token"
        }


{-| List issues assigned to the authenticated user across all visible repositories including owned repositories, member
repositories, and organization repositories. You can use the `filter` query parameter to fetch issues that are not
necessarily assigned to you.


**Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a pull request. For this
reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by
the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
request id, use the "[List pull requests](https://docs.github.com/rest/reference/pulls#list-pull-requests)" endpoint.
-}
issuesList :
    { toMsg : Result Http.Error (List Issue) -> msg
    , params :
        { filter : Maybe String
        , state : Maybe String
        , labels : Maybe String
        , sort : Maybe String
        , direction : Maybe String
        , since : Maybe String
        , collab : Maybe Bool
        , orgs : Maybe Bool
        , owned : Maybe Bool
        , pulls : Maybe Bool
        , per_page : Maybe Int
        , page : Maybe Int
        }
    }
    -> Cmd msg
issuesList config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.list decodeIssue)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                "https://api.github.com/issues"
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (Url.Builder.string "filter")
                        config.params.filter
                    , Maybe.map (Url.Builder.string "state") config.params.state
                    , Maybe.map
                        (Url.Builder.string "labels")
                        config.params.labels
                    , Maybe.map (Url.Builder.string "sort") config.params.sort
                    , Maybe.map
                        (Url.Builder.string "direction")
                        config.params.direction
                    , Maybe.map (Url.Builder.string "since") config.params.since
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "collab"
                                (if mapUnpack then
                                    "true"

                                 else
                                    "false"
                                )
                        )
                        config.params.collab
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "orgs"
                                (if mapUnpack then
                                    "true"

                                 else
                                    "false"
                                )
                        )
                        config.params.orgs
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "owned"
                                (if mapUnpack then
                                    "true"

                                 else
                                    "false"
                                )
                        )
                        config.params.owned
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "pulls"
                                (if mapUnpack then
                                    "true"

                                 else
                                    "false"
                                )
                        )
                        config.params.pulls
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


licensesGetAllCommonlyUsed :
    { toMsg : Result Http.Error (List LicenseSimple) -> msg
    , params : { featured : Maybe Bool, per_page : Maybe Int, page : Maybe Int }
    }
    -> Cmd msg
licensesGetAllCommonlyUsed config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeLicenseSimple)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                "https://api.github.com/licenses"
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "featured"
                                (if mapUnpack then
                                    "true"

                                 else
                                    "false"
                                )
                        )
                        config.params.featured
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


licensesGet :
    { toMsg : Result Http.Error License -> msg, params : { license : String } }
    -> Cmd msg
licensesGet config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeLicense
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{license}"
                config.params.license
                "https://api.github.com/licenses/{license}"
        }


markdownRender :
    { toMsg : Result Http.Error String -> msg
    , body : { context : String, mode : String, text : String }
    }
    -> Cmd msg
markdownRender config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectString config.toMsg
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "context", Json.Encode.string rec.context )
                         , ( "mode", Json.Encode.string rec.mode )
                         , ( "text", Json.Encode.string rec.text )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url = "https://api.github.com/markdown"
        }


{-| You must send Markdown as plain text (using a `Content-Type` header of `text/plain` or `text/x-markdown`) to this endpoint, rather than using JSON format. In raw mode, [GitHub Flavored Markdown](https://github.github.com/gfm/) is not supported and Markdown will be rendered in plain format like a README.md file. Markdown content must be 400 KB or less. -}
markdownRenderRaw :
    { toMsg : Result Http.Error String -> msg, body : String } -> Cmd msg
markdownRenderRaw config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectString config.toMsg
        , body = Http.stringBody "text/plain" config.body
        , timeout = Nothing
        , tracker = Nothing
        , url = "https://api.github.com/markdown/raw"
        }


{-| Shows whether the user or organization account actively subscribes to a plan listed by the authenticated GitHub App. When someone submits a plan change that won't be processed until the end of their billing cycle, you will also see the upcoming pending change.

GitHub Apps must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and client secret to access this endpoint.
-}
appsGetSubscriptionPlanForAccount config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeMarketplacePurchase
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{account_id}"
                config.params.account_id
                "https://api.github.com/marketplace_listing/accounts/{account_id}"
        }


{-| Lists all plans that are part of your GitHub Marketplace listing.

GitHub Apps must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and client secret to access this endpoint.
-}
appsListPlans :
    { toMsg : Result Http.Error (List MarketplaceListingPlan) -> msg
    , params : { per_page : Maybe Int, page : Maybe Int }
    }
    -> Cmd msg
appsListPlans config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeMarketplaceListingPlan)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                "https://api.github.com/marketplace_listing/plans"
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Returns user and organization accounts associated with the specified plan, including free plans. For per-seat pricing, you see the list of accounts that have purchased the plan, including the number of seats purchased. When someone submits a plan change that won't be processed until the end of their billing cycle, you will also see the upcoming pending change.

GitHub Apps must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and client secret to access this endpoint.
-}
appsListAccountsForPlan config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeMarketplacePurchase)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{plan_id}"
                    config.params.plan_id
                    "https://api.github.com/marketplace_listing/plans/{plan_id}/accounts"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map (Url.Builder.string "sort") config.params.sort
                    , Maybe.map
                        (Url.Builder.string "direction")
                        config.params.direction
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Shows whether the user or organization account actively subscribes to a plan listed by the authenticated GitHub App. When someone submits a plan change that won't be processed until the end of their billing cycle, you will also see the upcoming pending change.

GitHub Apps must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and client secret to access this endpoint.
-}
appsGetSubscriptionPlanForAccountStubbed config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeMarketplacePurchase
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{account_id}"
                config.params.account_id
                "https://api.github.com/marketplace_listing/stubbed/accounts/{account_id}"
        }


{-| Lists all plans that are part of your GitHub Marketplace listing.

GitHub Apps must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and client secret to access this endpoint.
-}
appsListPlansStubbed :
    { toMsg : Result Http.Error (List MarketplaceListingPlan) -> msg
    , params : { per_page : Maybe Int, page : Maybe Int }
    }
    -> Cmd msg
appsListPlansStubbed config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeMarketplaceListingPlan)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                "https://api.github.com/marketplace_listing/stubbed/plans"
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Returns repository and organization accounts associated with the specified plan, including free plans. For per-seat pricing, you see the list of accounts that have purchased the plan, including the number of seats purchased. When someone submits a plan change that won't be processed until the end of their billing cycle, you will also see the upcoming pending change.

GitHub Apps must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and client secret to access this endpoint.
-}
appsListAccountsForPlanStubbed config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeMarketplacePurchase)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{plan_id}"
                    config.params.plan_id
                    "https://api.github.com/marketplace_listing/stubbed/plans/{plan_id}/accounts"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map (Url.Builder.string "sort") config.params.sort
                    , Maybe.map
                        (Url.Builder.string "direction")
                        config.params.direction
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Returns meta information about GitHub, including a list of GitHub's IP addresses. For more information, see "[About GitHub's IP addresses](https://docs.github.com/articles/about-github-s-ip-addresses/)."

**Note:** The IP addresses shown in the documentation's response are only example values. You must always query the API directly to get the latest list of IP addresses.
-}
metaGet : { toMsg : Result Http.Error ApiOverview -> msg } -> Cmd msg
metaGet config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeApiOverview
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url = "https://api.github.com/meta"
        }


activityListPublicEventsForRepoNetwork :
    { toMsg : Result Http.Error (List Event) -> msg
    , params :
        { owner : String
        , repo : String
        , per_page : Maybe Int
        , page : Maybe Int
        }
    }
    -> Cmd msg
activityListPublicEventsForRepoNetwork config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.list decodeEvent)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/networks/{owner}/{repo}/events"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| List all notifications for the current user, sorted by most recently updated. -}
activityListNotificationsForAuthenticatedUser :
    { toMsg : Result Http.Error (List Thread) -> msg
    , params :
        { all : Maybe Bool
        , participating : Maybe Bool
        , since : Maybe String
        , before : Maybe String
        , page : Maybe Int
        , per_page : Maybe Int
        }
    }
    -> Cmd msg
activityListNotificationsForAuthenticatedUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.list decodeThread)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                "https://api.github.com/notifications"
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "all"
                                (if mapUnpack then
                                    "true"

                                 else
                                    "false"
                                )
                        )
                        config.params.all
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "participating"
                                (if mapUnpack then
                                    "true"

                                 else
                                    "false"
                                )
                        )
                        config.params.participating
                    , Maybe.map (Url.Builder.string "since") config.params.since
                    , Maybe.map
                        (Url.Builder.string "before")
                        config.params.before
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    ]
                )
        }


{-| Marks all notifications as "read" for the current user. If the number of notifications is too large to complete in one request, you will receive a `202 Accepted` status and GitHub will run an asynchronous process to mark notifications as "read." To check whether any "unread" notifications remain, you can use the [List notifications for the authenticated user](https://docs.github.com/rest/reference/activity#list-notifications-for-the-authenticated-user) endpoint and pass the query parameter `all=false`. -}
activityMarkNotificationsAsRead :
    { toMsg : Result Http.Error { message : String } -> msg
    , body : { last_read_at : String, read : Bool }
    }
    -> Cmd msg
activityMarkNotificationsAsRead config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed (\message -> { message = message })
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "message" Json.Decode.string)
                )
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "last_read_at"
                           , Json.Encode.string rec.last_read_at
                           )
                         , ( "read", Json.Encode.bool rec.read )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url = "https://api.github.com/notifications"
        }


{-| Gets information about a notification thread. -}
activityGetThread config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeThread
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{thread_id}"
                config.params.thread_id
                "https://api.github.com/notifications/threads/{thread_id}"
        }


{-| Marks a thread as "read." Marking a thread as "read" is equivalent to clicking a notification in your notification inbox on GitHub: https://github.com/notifications. -}
activityMarkThreadAsRead config =
    Http.request
        { method = "PATCH"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{thread_id}"
                config.params.thread_id
                "https://api.github.com/notifications/threads/{thread_id}"
        }


{-| This checks to see if the current user is subscribed to a thread. You can also [get a repository subscription](https://docs.github.com/rest/reference/activity#get-a-repository-subscription).

Note that subscriptions are only generated if a user is participating in a conversation--for example, they've replied to the thread, were **@mentioned**, or manually subscribe to a thread.
-}
activityGetThreadSubscriptionForAuthenticatedUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeThreadSubscription
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{thread_id}"
                config.params.thread_id
                "https://api.github.com/notifications/threads/{thread_id}/subscription"
        }


{-| If you are watching a repository, you receive notifications for all threads by default. Use this endpoint to ignore future notifications for threads until you comment on the thread or get an **@mention**.

You can also use this endpoint to subscribe to threads that you are currently not receiving notifications for or to subscribed to threads that you have previously ignored.

Unsubscribing from a conversation in a repository that you are not watching is functionally equivalent to the [Delete a thread subscription](https://docs.github.com/rest/reference/activity#delete-a-thread-subscription) endpoint.
-}
activitySetThreadSubscription config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeThreadSubscription
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "ignored", Json.Encode.bool rec.ignored ) ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{thread_id}"
                config.params.thread_id
                "https://api.github.com/notifications/threads/{thread_id}/subscription"
        }


{-| Mutes all future notifications for a conversation until you comment on the thread or get an **@mention**. If you are watching the repository of the thread, you will still receive notifications. To ignore future notifications for a repository you are watching, use the [Set a thread subscription](https://docs.github.com/rest/reference/activity#set-a-thread-subscription) endpoint and set `ignore` to `true`. -}
activityDeleteThreadSubscription config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{thread_id}"
                config.params.thread_id
                "https://api.github.com/notifications/threads/{thread_id}/subscription"
        }


{-| Get the octocat as ASCII art -}
metaGetOctocat :
    { toMsg : Result Http.Error String -> msg, params : { s : Maybe String } }
    -> Cmd msg
metaGetOctocat config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectString config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                "https://api.github.com/octocat"
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map (Url.Builder.string "s") config.params.s ]
                )
        }


{-| Lists all organizations, in the order that they were created on GitHub.

**Note:** Pagination is powered exclusively by the `since` parameter. Use the [Link header](https://docs.github.com/rest/overview/resources-in-the-rest-api#link-header) to get the URL for the next page of organizations.
-}
orgsList :
    { toMsg : Result Http.Error (List OrganizationSimple) -> msg
    , params : { since : Maybe Int, per_page : Maybe Int }
    }
    -> Cmd msg
orgsList config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeOrganizationSimple)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                "https://api.github.com/organizations"
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "since"
                                (String.fromInt mapUnpack)
                        )
                        config.params.since
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    ]
                )
        }


{-| List the custom repository roles available in this organization. In order to see custom
repository roles in an organization, the authenticated user must be an organization owner.

To use this endpoint the authenticated user must be an administrator for the organization or of an repository of the organizaiton and must use an access token with `admin:org repo` scope.
GitHub Apps must have the `organization_custom_roles:read` organization permission to use this endpoint.

For more information on custom repository roles, see "[Managing custom repository roles for an organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-custom-repository-roles-for-an-organization)".
-}
orgsListCustomRoles config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\custom_roles total_count ->
                      { custom_roles = custom_roles, total_count = total_count }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "custom_roles"
                            (Json.Decode.list
                                decodeOrganizationCustomRepositoryRole
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.int)
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{organization_id}"
                config.params.organization_id
                "https://api.github.com/organizations/{organization_id}/custom_roles"
        }


{-| To see many of the organization response values, you need to be an authenticated organization owner with the `admin:org` scope. When the value of `two_factor_requirement_enabled` is `true`, the organization requires all members, billing managers, and outside collaborators to enable [two-factor authentication](https://docs.github.com/articles/securing-your-account-with-two-factor-authentication-2fa/).

GitHub Apps with the `Organization plan` permission can use this endpoint to retrieve information about an organization's GitHub plan. See "[Authenticating with GitHub Apps](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/)" for details. For an example response, see 'Response with GitHub plan information' below."
-}
orgsGet :
    { toMsg : Result Http.Error OrganizationFull -> msg
    , params : { org : String }
    }
    -> Cmd msg
orgsGet config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeOrganizationFull
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{org}"
                config.params.org
                "https://api.github.com/orgs/{org}"
        }


{-| **Parameter Deprecation Notice:** GitHub will replace and discontinue `members_allowed_repository_creation_type` in favor of more granular permissions. The new input parameters are `members_can_create_public_repositories`, `members_can_create_private_repositories` for all organizations and `members_can_create_internal_repositories` for organizations associated with an enterprise account using GitHub Enterprise Cloud or GitHub Enterprise Server 2.20+. For more information, see the [blog post](https://developer.github.com/changes/2019-12-03-internal-visibility-changes).

Enables an authenticated organization owner with the `admin:org` scope to update the organization's profile and member privileges.
-}
orgsUpdate :
    { toMsg : Result Http.Error OrganizationFull -> msg
    , body :
        { advanced_security_enabled_for_new_repositories : Bool
        , billing_email : String
        , blog : String
        , company : String
        , default_repository_permission : String
        , dependabot_alerts_enabled_for_new_repositories : Bool
        , dependabot_security_updates_enabled_for_new_repositories : Bool
        , dependency_graph_enabled_for_new_repositories : Bool
        , description : String
        , email : String
        , has_organization_projects : Bool
        , has_repository_projects : Bool
        , location : String
        , members_allowed_repository_creation_type : String
        , members_can_create_internal_repositories : Bool
        , members_can_create_pages : Bool
        , members_can_create_private_pages : Bool
        , members_can_create_private_repositories : Bool
        , members_can_create_public_pages : Bool
        , members_can_create_public_repositories : Bool
        , members_can_create_repositories : Bool
        , members_can_fork_private_repositories : Bool
        , name : String
        , secret_scanning_enabled_for_new_repositories : Bool
        , secret_scanning_push_protection_enabled_for_new_repositories : Bool
        , twitter_username : String
        , web_commit_signoff_required : Bool
        }
    , params : { org : String }
    }
    -> Cmd msg
orgsUpdate config =
    Http.request
        { method = "PATCH"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeOrganizationFull
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "advanced_security_enabled_for_new_repositories"
                           , Json.Encode.bool
                                 rec.advanced_security_enabled_for_new_repositories
                           )
                         , ( "billing_email"
                           , Json.Encode.string rec.billing_email
                           )
                         , ( "blog", Json.Encode.string rec.blog )
                         , ( "company", Json.Encode.string rec.company )
                         , ( "default_repository_permission"
                           , Json.Encode.string
                                 rec.default_repository_permission
                           )
                         , ( "dependabot_alerts_enabled_for_new_repositories"
                           , Json.Encode.bool
                                 rec.dependabot_alerts_enabled_for_new_repositories
                           )
                         , ( "dependabot_security_updates_enabled_for_new_repositories"
                           , Json.Encode.bool
                                 rec.dependabot_security_updates_enabled_for_new_repositories
                           )
                         , ( "dependency_graph_enabled_for_new_repositories"
                           , Json.Encode.bool
                                 rec.dependency_graph_enabled_for_new_repositories
                           )
                         , ( "description", Json.Encode.string rec.description )
                         , ( "email", Json.Encode.string rec.email )
                         , ( "has_organization_projects"
                           , Json.Encode.bool rec.has_organization_projects
                           )
                         , ( "has_repository_projects"
                           , Json.Encode.bool rec.has_repository_projects
                           )
                         , ( "location", Json.Encode.string rec.location )
                         , ( "members_allowed_repository_creation_type"
                           , Json.Encode.string
                                 rec.members_allowed_repository_creation_type
                           )
                         , ( "members_can_create_internal_repositories"
                           , Json.Encode.bool
                                 rec.members_can_create_internal_repositories
                           )
                         , ( "members_can_create_pages"
                           , Json.Encode.bool rec.members_can_create_pages
                           )
                         , ( "members_can_create_private_pages"
                           , Json.Encode.bool
                                 rec.members_can_create_private_pages
                           )
                         , ( "members_can_create_private_repositories"
                           , Json.Encode.bool
                                 rec.members_can_create_private_repositories
                           )
                         , ( "members_can_create_public_pages"
                           , Json.Encode.bool
                                 rec.members_can_create_public_pages
                           )
                         , ( "members_can_create_public_repositories"
                           , Json.Encode.bool
                                 rec.members_can_create_public_repositories
                           )
                         , ( "members_can_create_repositories"
                           , Json.Encode.bool
                                 rec.members_can_create_repositories
                           )
                         , ( "members_can_fork_private_repositories"
                           , Json.Encode.bool
                                 rec.members_can_fork_private_repositories
                           )
                         , ( "name", Json.Encode.string rec.name )
                         , ( "secret_scanning_enabled_for_new_repositories"
                           , Json.Encode.bool
                                 rec.secret_scanning_enabled_for_new_repositories
                           )
                         , ( "secret_scanning_push_protection_enabled_for_new_repositories"
                           , Json.Encode.bool
                                 rec.secret_scanning_push_protection_enabled_for_new_repositories
                           )
                         , ( "twitter_username"
                           , Json.Encode.string rec.twitter_username
                           )
                         , ( "web_commit_signoff_required"
                           , Json.Encode.bool rec.web_commit_signoff_required
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{org}"
                config.params.org
                "https://api.github.com/orgs/{org}"
        }


{-| Gets the total GitHub Actions cache usage for an organization.
The data fetched using this API is refreshed approximately every 5 minutes, so values returned from this endpoint may take at least 5 minutes to get updated.
You must authenticate using an access token with the `read:org` scope to use this endpoint. GitHub Apps must have the `organization_admistration:read` permission to use this endpoint.
-}
actionsGetActionsCacheUsageForOrg :
    { toMsg : Result Http.Error ActionsCacheUsageOrgEnterprise -> msg
    , params : { org : String }
    }
    -> Cmd msg
actionsGetActionsCacheUsageForOrg config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg decodeActionsCacheUsageOrgEnterprise
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{org}"
                config.params.org
                "https://api.github.com/orgs/{org}/actions/cache/usage"
        }


{-| Lists repositories and their GitHub Actions cache usage for an organization.
The data fetched using this API is refreshed approximately every 5 minutes, so values returned from this endpoint may take at least 5 minutes to get updated.
You must authenticate using an access token with the `read:org` scope to use this endpoint. GitHub Apps must have the `organization_admistration:read` permission to use this endpoint.
-}
actionsGetActionsCacheUsageByRepoForOrg config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\repository_cache_usages total_count ->
                      { repository_cache_usages = repository_cache_usages
                      , total_count = total_count
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "repository_cache_usages"
                            (Json.Decode.list
                                decodeActionsCacheUsageByRepository
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.int)
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/actions/cache/usage-by-repository"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Gets the GitHub Actions permissions policy for repositories and allowed actions and reusable workflows in an organization.

You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.
-}
actionsGetGithubActionsPermissionsOrganization :
    { toMsg : Result Http.Error ActionsOrganizationPermissions -> msg
    , params : { org : String }
    }
    -> Cmd msg
actionsGetGithubActionsPermissionsOrganization config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg decodeActionsOrganizationPermissions
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{org}"
                config.params.org
                "https://api.github.com/orgs/{org}/actions/permissions"
        }


{-| Sets the GitHub Actions permissions policy for repositories and allowed actions and reusable workflows in an organization.

If the organization belongs to an enterprise that has set restrictive permissions at the enterprise level, such as `allowed_actions` to `selected` actions and reusable workflows, then you cannot override them for the organization.

You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.
-}
actionsSetGithubActionsPermissionsOrganization :
    { toMsg : Result Http.Error () -> msg
    , body :
        { allowed_actions : AllowedActions
        , enabled_repositories : EnabledRepositories
        }
    , params : { org : String }
    }
    -> Cmd msg
actionsSetGithubActionsPermissionsOrganization config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "allowed_actions"
                           , encodeAllowedActions rec.allowed_actions
                           )
                         , ( "enabled_repositories"
                           , encodeEnabledRepositories rec.enabled_repositories
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{org}"
                config.params.org
                "https://api.github.com/orgs/{org}/actions/permissions"
        }


{-| Lists the selected repositories that are enabled for GitHub Actions in an organization. To use this endpoint, the organization permission policy for `enabled_repositories` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization)."

You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.
-}
actionsListSelectedRepositoriesEnabledGithubActionsOrganization config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\repositories total_count ->
                      { repositories = repositories, total_count = total_count }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "repositories"
                            (Json.Decode.list decodeRepository)
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.float)
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/actions/permissions/repositories"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Replaces the list of selected repositories that are enabled for GitHub Actions in an organization. To use this endpoint, the organization permission policy for `enabled_repositories` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization)."

You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.
-}
actionsSetSelectedRepositoriesEnabledGithubActionsOrganization :
    { toMsg : Result Http.Error () -> msg
    , body : { selected_repository_ids : List Int }
    , params : { org : String }
    }
    -> Cmd msg
actionsSetSelectedRepositoriesEnabledGithubActionsOrganization config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "selected_repository_ids"
                           , Json.Encode.list Json.Encode.int
                                 rec.selected_repository_ids
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{org}"
                config.params.org
                "https://api.github.com/orgs/{org}/actions/permissions/repositories"
        }


{-| Adds a repository to the list of selected repositories that are enabled for GitHub Actions in an organization. To use this endpoint, the organization permission policy for `enabled_repositories` must be must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization)."

You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.
-}
actionsEnableSelectedRepositoryGithubActionsOrganization config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repository_id}"
                config.params.repository_id
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/actions/permissions/repositories/{repository_id}"
                )
        }


{-| Removes a repository from the list of selected repositories that are enabled for GitHub Actions in an organization. To use this endpoint, the organization permission policy for `enabled_repositories` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization)."

You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.
-}
actionsDisableSelectedRepositoryGithubActionsOrganization config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repository_id}"
                config.params.repository_id
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/actions/permissions/repositories/{repository_id}"
                )
        }


{-| Gets the selected actions and reusable workflows that are allowed in an organization. To use this endpoint, the organization permission policy for `allowed_actions` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization).""

You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.
-}
actionsGetAllowedActionsOrganization :
    { toMsg : Result Http.Error SelectedActions -> msg
    , params : { org : String }
    }
    -> Cmd msg
actionsGetAllowedActionsOrganization config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeSelectedActions
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{org}"
                config.params.org
                "https://api.github.com/orgs/{org}/actions/permissions/selected-actions"
        }


{-| Sets the actions and reusable workflows that are allowed in an organization. To use this endpoint, the organization permission policy for `allowed_actions` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization)."

If the organization belongs to an enterprise that has `selected` actions and reusable workflows set at the enterprise level, then you cannot override any of the enterprise's allowed actions and reusable workflows settings.

To use the `patterns_allowed` setting for private repositories, the organization must belong to an enterprise. If the organization does not belong to an enterprise, then the `patterns_allowed` setting only applies to public repositories in the organization.

You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.
-}
actionsSetAllowedActionsOrganization :
    { toMsg : Result Http.Error () -> msg
    , body : SelectedActions
    , params : { org : String }
    }
    -> Cmd msg
actionsSetAllowedActionsOrganization config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.jsonBody (encodeSelectedActions config.body)
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{org}"
                config.params.org
                "https://api.github.com/orgs/{org}/actions/permissions/selected-actions"
        }


{-| Gets the default workflow permissions granted to the `GITHUB_TOKEN` when running workflows in an organization,
as well as whether GitHub Actions can submit approving pull request reviews. For more information, see
"[Setting the permissions of the GITHUB_TOKEN for your organization](https://docs.github.com/organizations/managing-organization-settings/disabling-or-limiting-github-actions-for-your-organization#setting-the-permissions-of-the-github_token-for-your-organization)."

You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.
-}
actionsGetGithubActionsDefaultWorkflowPermissionsOrganization :
    { toMsg : Result Http.Error ActionsGetDefaultWorkflowPermissions -> msg
    , params : { org : String }
    }
    -> Cmd msg
actionsGetGithubActionsDefaultWorkflowPermissionsOrganization config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                decodeActionsGetDefaultWorkflowPermissions
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{org}"
                config.params.org
                "https://api.github.com/orgs/{org}/actions/permissions/workflow"
        }


{-| Sets the default workflow permissions granted to the `GITHUB_TOKEN` when running workflows in an organization, and sets if GitHub Actions
can submit approving pull request reviews. For more information, see
"[Setting the permissions of the GITHUB_TOKEN for your organization](https://docs.github.com/organizations/managing-organization-settings/disabling-or-limiting-github-actions-for-your-organization#setting-the-permissions-of-the-github_token-for-your-organization)."

You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.
-}
actionsSetGithubActionsDefaultWorkflowPermissionsOrganization :
    { toMsg : Result Http.Error () -> msg
    , body : ActionsSetDefaultWorkflowPermissions
    , params : { org : String }
    }
    -> Cmd msg
actionsSetGithubActionsDefaultWorkflowPermissionsOrganization config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body =
            Http.jsonBody
                (encodeActionsSetDefaultWorkflowPermissions config.body)
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{org}"
                config.params.org
                "https://api.github.com/orgs/{org}/actions/permissions/workflow"
        }


{-| The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)."

Lists all self-hosted runner groups configured in an organization and inherited from an enterprise.

You must authenticate using an access token with the `admin:org` scope to use this endpoint.
-}
actionsListSelfHostedRunnerGroupsForOrg config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\runner_groups total_count ->
                      { runner_groups = runner_groups
                      , total_count = total_count
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "runner_groups"
                            (Json.Decode.list decodeRunnerGroupsOrg)
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.float)
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/actions/runner-groups"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    , Maybe.map
                        (Url.Builder.string "visible_to_repository")
                        config.params.visible_to_repository
                    ]
                )
        }


{-| The self-hosted runner groups REST API is available with GitHub Enterprise Cloud and GitHub Enterprise Server. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)."

Creates a new self-hosted runner group for an organization.

You must authenticate using an access token with the `admin:org` scope to use this endpoint.
-}
actionsCreateSelfHostedRunnerGroupForOrg :
    { toMsg : Result Http.Error RunnerGroupsOrg -> msg
    , body :
        { allows_public_repositories : Bool
        , name : String
        , restricted_to_workflows : Bool
        , runners : List Int
        , selected_repository_ids : List Int
        , selected_workflows : List String
        , visibility : String
        }
    , params : { org : String }
    }
    -> Cmd msg
actionsCreateSelfHostedRunnerGroupForOrg config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeRunnerGroupsOrg
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "allows_public_repositories"
                           , Json.Encode.bool rec.allows_public_repositories
                           )
                         , ( "name", Json.Encode.string rec.name )
                         , ( "restricted_to_workflows"
                           , Json.Encode.bool rec.restricted_to_workflows
                           )
                         , ( "runners"
                           , Json.Encode.list Json.Encode.int rec.runners
                           )
                         , ( "selected_repository_ids"
                           , Json.Encode.list Json.Encode.int
                                 rec.selected_repository_ids
                           )
                         , ( "selected_workflows"
                           , Json.Encode.list Json.Encode.string
                                 rec.selected_workflows
                           )
                         , ( "visibility", Json.Encode.string rec.visibility )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{org}"
                config.params.org
                "https://api.github.com/orgs/{org}/actions/runner-groups"
        }


{-| The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)."

Gets a specific self-hosted runner group for an organization.

You must authenticate using an access token with the `admin:org` scope to use this endpoint.
-}
actionsGetSelfHostedRunnerGroupForOrg config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeRunnerGroupsOrg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{runner_group_id}"
                config.params.runner_group_id
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/actions/runner-groups/{runner_group_id}"
                )
        }


{-| The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)."

Updates the `name` and `visibility` of a self-hosted runner group in an organization.

You must authenticate using an access token with the `admin:org` scope to use this endpoint.
-}
actionsUpdateSelfHostedRunnerGroupForOrg config =
    Http.request
        { method = "PATCH"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeRunnerGroupsOrg
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "allows_public_repositories"
                           , Json.Encode.bool rec.allows_public_repositories
                           )
                         , ( "name", Json.Encode.string rec.name )
                         , ( "restricted_to_workflows"
                           , Json.Encode.bool rec.restricted_to_workflows
                           )
                         , ( "selected_workflows"
                           , Json.Encode.list Json.Encode.string
                                 rec.selected_workflows
                           )
                         , ( "visibility", Json.Encode.string rec.visibility )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{runner_group_id}"
                config.params.runner_group_id
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/actions/runner-groups/{runner_group_id}"
                )
        }


{-| The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)."

Deletes a self-hosted runner group for an organization.

You must authenticate using an access token with the `admin:org` scope to use this endpoint.
-}
actionsDeleteSelfHostedRunnerGroupFromOrg config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{runner_group_id}"
                config.params.runner_group_id
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/actions/runner-groups/{runner_group_id}"
                )
        }


{-| The self-hosted runner groups REST API is available with GitHub Enterprise Cloud and GitHub Enterprise Server. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)."

Lists the repositories with access to a self-hosted runner group configured in an organization.

You must authenticate using an access token with the `admin:org` scope to use this endpoint.
-}
actionsListRepoAccessToSelfHostedRunnerGroupInOrg config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\repositories total_count ->
                      { repositories = repositories, total_count = total_count }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "repositories"
                            (Json.Decode.list decodeMinimalRepository)
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.float)
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{runner_group_id}"
                    config.params.runner_group_id
                    (String.replace
                        "{org}"
                        config.params.org
                        "https://api.github.com/orgs/{org}/actions/runner-groups/{runner_group_id}/repositories"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    ]
                )
        }


{-| The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)."

Replaces the list of repositories that have access to a self-hosted runner group configured in an organization.

You must authenticate using an access token with the `admin:org` scope to use this endpoint.
-}
actionsSetRepoAccessToSelfHostedRunnerGroupInOrg config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "selected_repository_ids"
                           , Json.Encode.list Json.Encode.int
                                 rec.selected_repository_ids
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{runner_group_id}"
                config.params.runner_group_id
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/actions/runner-groups/{runner_group_id}/repositories"
                )
        }


{-| The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)."


Removes a repository from the list of selected repositories that can access a self-hosted runner group. The runner group must have `visibility` set to `selected`. For more information, see "[Create a self-hosted runner group for an organization](#create-a-self-hosted-runner-group-for-an-organization)."

You must authenticate using an access token with the `admin:org` scope to use this endpoint.
-}
actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repository_id}"
                config.params.repository_id
                (String.replace
                    "{runner_group_id}"
                    config.params.runner_group_id
                    (String.replace
                        "{org}"
                        config.params.org
                        "https://api.github.com/orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}"
                    )
                )
        }


{-| The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)."

Lists self-hosted runners that are in a specific organization group.

You must authenticate using an access token with the `admin:org` scope to use this endpoint.
-}
actionsListSelfHostedRunnersInGroupForOrg config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\runners total_count ->
                      { runners = runners, total_count = total_count }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "runners"
                            (Json.Decode.list decodeRunner)
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.float)
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{runner_group_id}"
                    config.params.runner_group_id
                    (String.replace
                        "{org}"
                        config.params.org
                        "https://api.github.com/orgs/{org}/actions/runner-groups/{runner_group_id}/runners"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)."

Replaces the list of self-hosted runners that are part of an organization runner group.

You must authenticate using an access token with the `admin:org` scope to use this endpoint.
-}
actionsSetSelfHostedRunnersInGroupForOrg config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "runners"
                           , Json.Encode.list Json.Encode.int rec.runners
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{runner_group_id}"
                config.params.runner_group_id
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/actions/runner-groups/{runner_group_id}/runners"
                )
        }


{-| The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)."


Adds a self-hosted runner to a runner group configured in an organization.

You must authenticate using an access token with the `admin:org`
scope to use this endpoint.
-}
actionsAddSelfHostedRunnerToGroupForOrg config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{runner_id}"
                config.params.runner_id
                (String.replace
                    "{runner_group_id}"
                    config.params.runner_group_id
                    (String.replace
                        "{org}"
                        config.params.org
                        "https://api.github.com/orgs/{org}/actions/runner-groups/{runner_group_id}/runners/{runner_id}"
                    )
                )
        }


{-| The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)."


Removes a self-hosted runner from a group configured in an organization. The runner is then returned to the default group.

You must authenticate using an access token with the `admin:org` scope to use this endpoint.
-}
actionsRemoveSelfHostedRunnerFromGroupForOrg config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{runner_id}"
                config.params.runner_id
                (String.replace
                    "{runner_group_id}"
                    config.params.runner_group_id
                    (String.replace
                        "{org}"
                        config.params.org
                        "https://api.github.com/orgs/{org}/actions/runner-groups/{runner_group_id}/runners/{runner_id}"
                    )
                )
        }


{-| Lists all self-hosted runners configured in an organization.

You must authenticate using an access token with the `admin:org` scope to use this endpoint.
-}
actionsListSelfHostedRunnersForOrg config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\runners total_count ->
                      { runners = runners, total_count = total_count }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "runners"
                            (Json.Decode.list decodeRunner)
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.int)
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/actions/runners"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Lists binaries for the runner application that you can download and run.

You must authenticate using an access token with the `admin:org` scope to use this endpoint.
-}
actionsListRunnerApplicationsForOrg :
    { toMsg : Result Http.Error (List RunnerApplication) -> msg
    , params : { org : String }
    }
    -> Cmd msg
actionsListRunnerApplicationsForOrg config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeRunnerApplication)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{org}"
                config.params.org
                "https://api.github.com/orgs/{org}/actions/runners/downloads"
        }


{-| Returns a token that you can pass to the `config` script. The token expires after one hour.

You must authenticate using an access token with the `admin:org` scope to use this endpoint.

#### Example using registration token

Configure your self-hosted runner, replacing `TOKEN` with the registration token provided by this endpoint.

```
./config.sh --url https://github.com/octo-org --token TOKEN
```
-}
actionsCreateRegistrationTokenForOrg :
    { toMsg : Result Http.Error AuthenticationToken -> msg
    , params : { org : String }
    }
    -> Cmd msg
actionsCreateRegistrationTokenForOrg config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeAuthenticationToken
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{org}"
                config.params.org
                "https://api.github.com/orgs/{org}/actions/runners/registration-token"
        }


{-| Returns a token that you can pass to the `config` script to remove a self-hosted runner from an organization. The token expires after one hour.

You must authenticate using an access token with the `admin:org` scope to use this endpoint.

#### Example using remove token

To remove your self-hosted runner from an organization, replace `TOKEN` with the remove token provided by this
endpoint.

```
./config.sh remove --token TOKEN
```
-}
actionsCreateRemoveTokenForOrg :
    { toMsg : Result Http.Error AuthenticationToken -> msg
    , params : { org : String }
    }
    -> Cmd msg
actionsCreateRemoveTokenForOrg config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeAuthenticationToken
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{org}"
                config.params.org
                "https://api.github.com/orgs/{org}/actions/runners/remove-token"
        }


{-| Gets a specific self-hosted runner configured in an organization.

You must authenticate using an access token with the `admin:org` scope to use this endpoint.
-}
actionsGetSelfHostedRunnerForOrg config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeRunner
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{runner_id}"
                config.params.runner_id
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/actions/runners/{runner_id}"
                )
        }


{-| Forces the removal of a self-hosted runner from an organization. You can use this endpoint to completely remove the runner when the machine you were using no longer exists.

You must authenticate using an access token with the `admin:org` scope to use this endpoint.
-}
actionsDeleteSelfHostedRunnerFromOrg config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{runner_id}"
                config.params.runner_id
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/actions/runners/{runner_id}"
                )
        }


{-| Lists all labels for a self-hosted runner configured in an organization.

You must authenticate using an access token with the `admin:org` scope to use this endpoint.
-}
actionsListLabelsForSelfHostedRunnerForOrg config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeActionsRunnerLabels
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{runner_id}"
                config.params.runner_id
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/actions/runners/{runner_id}/labels"
                )
        }


{-| Add custom labels to a self-hosted runner configured in an organization.

You must authenticate using an access token with the `admin:org` scope to use this endpoint.
-}
actionsAddCustomLabelsToSelfHostedRunnerForOrg config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeActionsRunnerLabels
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "labels"
                           , Json.Encode.list Json.Encode.string rec.labels
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{runner_id}"
                config.params.runner_id
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/actions/runners/{runner_id}/labels"
                )
        }


{-| Remove all previous custom labels and set the new custom labels for a specific
self-hosted runner configured in an organization.

You must authenticate using an access token with the `admin:org` scope to use this endpoint.
-}
actionsSetCustomLabelsForSelfHostedRunnerForOrg config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeActionsRunnerLabels
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "labels"
                           , Json.Encode.list Json.Encode.string rec.labels
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{runner_id}"
                config.params.runner_id
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/actions/runners/{runner_id}/labels"
                )
        }


{-| Remove all custom labels from a self-hosted runner configured in an
organization. Returns the remaining read-only labels from the runner.

You must authenticate using an access token with the `admin:org` scope to use this endpoint.
-}
actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect =
            Http.expectJson config.toMsg decodeActionsRunnerLabelsReadonly
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{runner_id}"
                config.params.runner_id
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/actions/runners/{runner_id}/labels"
                )
        }


{-| Remove a custom label from a self-hosted runner configured
in an organization. Returns the remaining labels from the runner.

This endpoint returns a `404 Not Found` status if the custom label is not
present on the runner.

You must authenticate using an access token with the `admin:org` scope to use this endpoint.
-}
actionsRemoveCustomLabelFromSelfHostedRunnerForOrg config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeActionsRunnerLabels
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{name}"
                config.params.name
                (String.replace
                    "{runner_id}"
                    config.params.runner_id
                    (String.replace
                        "{org}"
                        config.params.org
                        "https://api.github.com/orgs/{org}/actions/runners/{runner_id}/labels/{name}"
                    )
                )
        }


{-| Lists all secrets available in an organization without revealing their encrypted values. You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use this endpoint. -}
actionsListOrgSecrets config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\secrets total_count ->
                      { secrets = secrets, total_count = total_count }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "secrets"
                            (Json.Decode.list decodeOrganizationActionsSecret)
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.int)
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/actions/secrets"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before you can create or update secrets. You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use this endpoint. -}
actionsGetOrgPublicKey :
    { toMsg : Result Http.Error ActionsPublicKey -> msg
    , params : { org : String }
    }
    -> Cmd msg
actionsGetOrgPublicKey config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeActionsPublicKey
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{org}"
                config.params.org
                "https://api.github.com/orgs/{org}/actions/secrets/public-key"
        }


{-| Gets a single organization secret without revealing its encrypted value. You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use this endpoint. -}
actionsGetOrgSecret :
    { toMsg : Result Http.Error OrganizationActionsSecret -> msg
    , params : { org : String, secret_name : String }
    }
    -> Cmd msg
actionsGetOrgSecret config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeOrganizationActionsSecret
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{secret_name}"
                config.params.secret_name
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/actions/secrets/{secret_name}"
                )
        }


{-| Creates or updates an organization secret with an encrypted value. Encrypt your secret using
[LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must authenticate using an access
token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to
use this endpoint.

#### Example encrypting a secret using Node.js

Encrypt your secret using the [tweetsodium](https://github.com/github/tweetsodium) library.

```
const sodium = require('tweetsodium');

const key = "base64-encoded-public-key";
const value = "plain-text-secret";

// Convert the message and key to Uint8Array's (Buffer implements that interface)
const messageBytes = Buffer.from(value);
const keyBytes = Buffer.from(key, 'base64');

// Encrypt using LibSodium.
const encryptedBytes = sodium.seal(messageBytes, keyBytes);

// Base64 the encrypted secret
const encrypted = Buffer.from(encryptedBytes).toString('base64');

console.log(encrypted);
```


#### Example encrypting a secret using Python

Encrypt your secret using [pynacl](https://pynacl.readthedocs.io/en/latest/public/#nacl-public-sealedbox) with Python 3.

```
from base64 import b64encode
from nacl import encoding, public

def encrypt(public_key: str, secret_value: str) -> str:
  """Encrypt a Unicode string using the public key."""
  public_key = public.PublicKey(public_key.encode("utf-8"), encoding.Base64Encoder())
  sealed_box = public.SealedBox(public_key)
  encrypted = sealed_box.encrypt(secret_value.encode("utf-8"))
  return b64encode(encrypted).decode("utf-8")
```

#### Example encrypting a secret using C#

Encrypt your secret using the [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package.

```
var secretValue = System.Text.Encoding.UTF8.GetBytes("mySecret");
var publicKey = Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=");

var sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);

Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));
```

#### Example encrypting a secret using Ruby

Encrypt your secret using the [rbnacl](https://github.com/RubyCrypto/rbnacl) gem.

```ruby
require "rbnacl"
require "base64"

key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=")
public_key = RbNaCl::PublicKey.new(key)

box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
encrypted_secret = box.encrypt("my_secret")

# Print the base64 encoded secret
puts Base64.strict_encode64(encrypted_secret)
```
-}
actionsCreateOrUpdateOrgSecret :
    { toMsg : Result Http.Error EmptyObject -> msg
    , body :
        { encrypted_value : String
        , key_id : String
        , selected_repository_ids : List Int
        , visibility : String
        }
    , params : { org : String, secret_name : String }
    }
    -> Cmd msg
actionsCreateOrUpdateOrgSecret config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeEmptyObject
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "encrypted_value"
                           , Json.Encode.string rec.encrypted_value
                           )
                         , ( "key_id", Json.Encode.string rec.key_id )
                         , ( "selected_repository_ids"
                           , Json.Encode.list Json.Encode.int
                                 rec.selected_repository_ids
                           )
                         , ( "visibility", Json.Encode.string rec.visibility )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{secret_name}"
                config.params.secret_name
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/actions/secrets/{secret_name}"
                )
        }


{-| Deletes a secret in an organization using the secret name. You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use this endpoint. -}
actionsDeleteOrgSecret :
    { toMsg : Result Http.Error () -> msg
    , params : { org : String, secret_name : String }
    }
    -> Cmd msg
actionsDeleteOrgSecret config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{secret_name}"
                config.params.secret_name
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/actions/secrets/{secret_name}"
                )
        }


{-| Lists all repositories that have been selected when the `visibility` for repository access to a secret is set to `selected`. You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use this endpoint. -}
actionsListSelectedReposForOrgSecret config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\repositories total_count ->
                      { repositories = repositories, total_count = total_count }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "repositories"
                            (Json.Decode.list decodeMinimalRepository)
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.int)
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{secret_name}"
                    config.params.secret_name
                    (String.replace
                        "{org}"
                        config.params.org
                        "https://api.github.com/orgs/{org}/actions/secrets/{secret_name}/repositories"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    ]
                )
        }


{-| Replaces all repositories for an organization secret when the `visibility` for repository access is set to `selected`. The visibility is set when you [Create or update an organization secret](https://docs.github.com/rest/reference/actions#create-or-update-an-organization-secret). You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use this endpoint. -}
actionsSetSelectedReposForOrgSecret :
    { toMsg : Result Http.Error () -> msg
    , body : { selected_repository_ids : List Int }
    , params : { org : String, secret_name : String }
    }
    -> Cmd msg
actionsSetSelectedReposForOrgSecret config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "selected_repository_ids"
                           , Json.Encode.list Json.Encode.int
                                 rec.selected_repository_ids
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{secret_name}"
                config.params.secret_name
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/actions/secrets/{secret_name}/repositories"
                )
        }


{-| Adds a repository to an organization secret when the `visibility` for repository access is set to `selected`. The visibility is set when you [Create or update an organization secret](https://docs.github.com/rest/reference/actions#create-or-update-an-organization-secret). You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use this endpoint. -}
actionsAddSelectedRepoToOrgSecret config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repository_id}"
                config.params.repository_id
                (String.replace
                    "{secret_name}"
                    config.params.secret_name
                    (String.replace
                        "{org}"
                        config.params.org
                        "https://api.github.com/orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"
                    )
                )
        }


{-| Removes a repository from an organization secret when the `visibility` for repository access is set to `selected`. The visibility is set when you [Create or update an organization secret](https://docs.github.com/rest/reference/actions#create-or-update-an-organization-secret). You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use this endpoint. -}
actionsRemoveSelectedRepoFromOrgSecret config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repository_id}"
                config.params.repository_id
                (String.replace
                    "{secret_name}"
                    config.params.secret_name
                    (String.replace
                        "{org}"
                        config.params.org
                        "https://api.github.com/orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"
                    )
                )
        }


{-| List the users blocked by an organization. -}
orgsListBlockedUsers :
    { toMsg : Result Http.Error (List SimpleUser) -> msg
    , params : { org : String }
    }
    -> Cmd msg
orgsListBlockedUsers config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeSimpleUser)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{org}"
                config.params.org
                "https://api.github.com/orgs/{org}/blocks"
        }


orgsCheckBlockedUser :
    { toMsg : Result Http.Error () -> msg
    , params : { org : String, username : String }
    }
    -> Cmd msg
orgsCheckBlockedUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{username}"
                config.params.username
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/blocks/{username}"
                )
        }


orgsBlockUser :
    { toMsg : Result Http.Error () -> msg
    , params : { org : String, username : String }
    }
    -> Cmd msg
orgsBlockUser config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{username}"
                config.params.username
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/blocks/{username}"
                )
        }


orgsUnblockUser :
    { toMsg : Result Http.Error () -> msg
    , params : { org : String, username : String }
    }
    -> Cmd msg
orgsUnblockUser config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{username}"
                config.params.username
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/blocks/{username}"
                )
        }


{-| Lists code scanning alerts for the default branch for all eligible repositories in an organization. Eligible repositories are repositories that are owned by organizations that you own or for which you are a security manager. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."

To use this endpoint, you must be an owner or security manager for the organization, and you must use an access token with the `repo` scope or `security_events` scope.

For public repositories, you may instead use the `public_repo` scope.

GitHub Apps must have the `security_events` read permission to use this endpoint.
-}
codeScanningListAlertsForOrg :
    { toMsg : Result Http.Error (List CodeScanningOrganizationAlertItems) -> msg
    , params :
        { org : String
        , tool_name : Maybe CodeScanningAnalysisToolName
        , tool_guid : Maybe CodeScanningAnalysisToolGuid
        , before : Maybe String
        , after : Maybe String
        , page : Maybe Int
        , per_page : Maybe Int
        , direction : Maybe String
        , state : Maybe CodeScanningAlertState
        , sort : Maybe String
        }
    }
    -> Cmd msg
codeScanningListAlertsForOrg config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeCodeScanningOrganizationAlertItems)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/code-scanning/alerts"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "tool_name"
                                (Debug.todo
                                    "Params of type \"CodeScanningAnalysisToolName\" (in helper)"
                                )
                        )
                        config.params.tool_name
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "tool_guid"
                                (Debug.todo
                                    "Params of type \"CodeScanningAnalysisToolGuid\" (in helper)"
                                )
                        )
                        config.params.tool_guid
                    , Maybe.map
                        (Url.Builder.string "before")
                        config.params.before
                    , Maybe.map (Url.Builder.string "after") config.params.after
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (Url.Builder.string "direction")
                        config.params.direction
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "state"
                                (Debug.todo
                                    "Params of type \"CodeScanningAlertState\" (in helper)"
                                )
                        )
                        config.params.state
                    , Maybe.map (Url.Builder.string "sort") config.params.sort
                    ]
                )
        }


{-| Lists the codespaces associated to a specified organization.

You must authenticate using an access token with the `admin:org` scope to use this endpoint.
-}
codespacesListInOrganization config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\codespaces total_count ->
                      { codespaces = codespaces, total_count = total_count }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "codespaces"
                            (Json.Decode.list decodeCodespace)
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.int)
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/codespaces"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Sets which users can access codespaces in an organization. This is synonymous with granting or revoking codespaces billing permissions for users according to the visibility.
You must authenticate using an access token with the `admin:org` scope to use this endpoint.
-}
codespacesSetCodespacesBilling :
    { toMsg : Result Http.Error () -> msg
    , body : { selected_usernames : List String, visibility : String }
    , params : { org : String }
    }
    -> Cmd msg
codespacesSetCodespacesBilling config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "selected_usernames"
                           , Json.Encode.list Json.Encode.string
                                 rec.selected_usernames
                           )
                         , ( "visibility", Json.Encode.string rec.visibility )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{org}"
                config.params.org
                "https://api.github.com/orgs/{org}/codespaces/billing"
        }


{-| Lists all Codespaces secrets available at the organization-level without revealing their encrypted values.
You must authenticate using an access token with the `admin:org` scope to use this endpoint.
-}
codespacesListOrgSecrets config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\secrets total_count ->
                      { secrets = secrets, total_count = total_count }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "secrets"
                            (Json.Decode.list decodeCodespacesOrgSecret)
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.int)
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/codespaces/secrets"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Gets a public key for an organization, which is required in order to encrypt secrets. You need to encrypt the value of a secret before you can create or update secrets. You must authenticate using an access token with the `admin:org` scope to use this endpoint. -}
codespacesGetOrgPublicKey :
    { toMsg : Result Http.Error CodespacesPublicKey -> msg
    , params : { org : String }
    }
    -> Cmd msg
codespacesGetOrgPublicKey config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeCodespacesPublicKey
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{org}"
                config.params.org
                "https://api.github.com/orgs/{org}/codespaces/secrets/public-key"
        }


{-| Gets an organization secret without revealing its encrypted value.
You must authenticate using an access token with the `admin:org` scope to use this endpoint.
-}
codespacesGetOrgSecret :
    { toMsg : Result Http.Error CodespacesOrgSecret -> msg
    , params : { org : String, secret_name : String }
    }
    -> Cmd msg
codespacesGetOrgSecret config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeCodespacesOrgSecret
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{secret_name}"
                config.params.secret_name
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/codespaces/secrets/{secret_name}"
                )
        }


{-| Creates or updates an organization secret with an encrypted value. Encrypt your secret using
[LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must authenticate using an access
token with the `admin:org` scope to use this endpoint.

#### Example encrypting a secret using Node.js

Encrypt your secret using the [libsodium-wrappers](https://www.npmjs.com/package/libsodium-wrappers) library.

```
// Written with  by PSJ and free to use under The Unlicense.
const sodium=require('libsodium-wrappers')
const secret = 'plain-text-secret' // replace with secret before running the script.
const key = 'base64-encoded-public-key' // replace with the Base64 encoded public key.

//Check if libsodium is ready and then proceed.

sodium.ready.then( ()=>{

// Convert Secret & Base64 key to Uint8Array.
let binkey= sodium.from_base64(key, sodium.base64_variants.ORIGINAL) //Equivalent of Buffer.from(key, 'base64')
let binsec= sodium.from_string(secret) // Equivalent of Buffer.from(secret)

//Encrypt the secret using LibSodium
let encBytes= sodium.crypto_box_seal(binsec,binkey) // Similar to tweetsodium.seal(binsec,binkey)

// Convert encrypted Uint8Array to Base64
let output=sodium.to_base64(encBytes, sodium.base64_variants.ORIGINAL) //Equivalent of Buffer.from(encBytes).toString('base64')

console.log(output)
});
```

#### Example encrypting a secret using Python

Encrypt your secret using [pynacl](https://pynacl.readthedocs.io/en/latest/public/#nacl-public-sealedbox) with Python 3.

```
from base64 import b64encode
from nacl import encoding, public

def encrypt(public_key: str, secret_value: str) -> str:
  """Encrypt a Unicode string using the public key."""
  public_key = public.PublicKey(public_key.encode("utf-8"), encoding.Base64Encoder())
  sealed_box = public.SealedBox(public_key)
  encrypted = sealed_box.encrypt(secret_value.encode("utf-8"))
  return b64encode(encrypted).decode("utf-8")
```

#### Example encrypting a secret using C#

Encrypt your secret using the [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package.

```
var secretValue = System.Text.Encoding.UTF8.GetBytes("mySecret");
var publicKey = Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=");

var sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);

Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));
```

#### Example encrypting a secret using Ruby

Encrypt your secret using the [rbnacl](https://github.com/RubyCrypto/rbnacl) gem.

```ruby
require "rbnacl"
require "base64"

key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=")
public_key = RbNaCl::PublicKey.new(key)

box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
encrypted_secret = box.encrypt("my_secret")

# Print the base64 encoded secret
puts Base64.strict_encode64(encrypted_secret)
```
-}
codespacesCreateOrUpdateOrgSecret :
    { toMsg : Result Http.Error EmptyObject -> msg
    , body :
        { encrypted_value : String
        , key_id : String
        , selected_repository_ids : List Int
        , visibility : String
        }
    , params : { org : String, secret_name : String }
    }
    -> Cmd msg
codespacesCreateOrUpdateOrgSecret config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeEmptyObject
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "encrypted_value"
                           , Json.Encode.string rec.encrypted_value
                           )
                         , ( "key_id", Json.Encode.string rec.key_id )
                         , ( "selected_repository_ids"
                           , Json.Encode.list Json.Encode.int
                                 rec.selected_repository_ids
                           )
                         , ( "visibility", Json.Encode.string rec.visibility )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{secret_name}"
                config.params.secret_name
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/codespaces/secrets/{secret_name}"
                )
        }


{-| Deletes an organization secret using the secret name. You must authenticate using an access token with the `admin:org` scope to use this endpoint. -}
codespacesDeleteOrgSecret :
    { toMsg : Result Http.Error () -> msg
    , params : { org : String, secret_name : String }
    }
    -> Cmd msg
codespacesDeleteOrgSecret config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{secret_name}"
                config.params.secret_name
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/codespaces/secrets/{secret_name}"
                )
        }


{-| Lists all repositories that have been selected when the `visibility` for repository access to a secret is set to `selected`. You must authenticate using an access token with the `admin:org` scope to use this endpoint. -}
codespacesListSelectedReposForOrgSecret config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\repositories total_count ->
                      { repositories = repositories, total_count = total_count }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "repositories"
                            (Json.Decode.list decodeMinimalRepository)
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.int)
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{secret_name}"
                    config.params.secret_name
                    (String.replace
                        "{org}"
                        config.params.org
                        "https://api.github.com/orgs/{org}/codespaces/secrets/{secret_name}/repositories"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    ]
                )
        }


{-| Replaces all repositories for an organization secret when the `visibility` for repository access is set to `selected`. The visibility is set when you [Create or update an organization secret](https://docs.github.com/rest/reference/codespaces#create-or-update-an-organization-secret). You must authenticate using an access token with the `admin:org` scope to use this endpoint. -}
codespacesSetSelectedReposForOrgSecret :
    { toMsg : Result Http.Error () -> msg
    , body : { selected_repository_ids : List Int }
    , params : { org : String, secret_name : String }
    }
    -> Cmd msg
codespacesSetSelectedReposForOrgSecret config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "selected_repository_ids"
                           , Json.Encode.list Json.Encode.int
                                 rec.selected_repository_ids
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{secret_name}"
                config.params.secret_name
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/codespaces/secrets/{secret_name}/repositories"
                )
        }


{-| Adds a repository to an organization secret when the `visibility` for repository access is set to `selected`. The visibility is set when you [Create or update an organization secret](https://docs.github.com/rest/reference/codespaces#create-or-update-an-organization-secret). You must authenticate using an access token with the `admin:org` scope to use this endpoint. -}
codespacesAddSelectedRepoToOrgSecret config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repository_id}"
                config.params.repository_id
                (String.replace
                    "{secret_name}"
                    config.params.secret_name
                    (String.replace
                        "{org}"
                        config.params.org
                        "https://api.github.com/orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"
                    )
                )
        }


{-| Removes a repository from an organization secret when the `visibility` for repository access is set to `selected`. The visibility is set when you [Create or update an organization secret](https://docs.github.com/rest/reference/codespaces#create-or-update-an-organization-secret). You must authenticate using an access token with the `admin:org` scope to use this endpoint. -}
codespacesRemoveSelectedRepoFromOrgSecret config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repository_id}"
                config.params.repository_id
                (String.replace
                    "{secret_name}"
                    config.params.secret_name
                    (String.replace
                        "{org}"
                        config.params.org
                        "https://api.github.com/orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"
                    )
                )
        }


{-| **Note**: This operation is in beta and is subject to change.

Creates a custom repository role that can be used by all repositories owned by the organization.

To use this endpoint the authenticated user must be an administrator for the organization and must use an access token with `admin:org` scope.
GitHub Apps must have the `organization_custom_roles:write` organization permission to use this endpoint.

For more information on custom repository roles, see "[Managing custom repository roles for an organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-custom-repository-roles-for-an-organization)."
-}
orgsCreateCustomRole :
    { toMsg : Result Http.Error OrganizationCustomRepositoryRole -> msg
    , body :
        { base_role : String
        , description : String
        , name : String
        , permissions : List String
        }
    , params : { org : String }
    }
    -> Cmd msg
orgsCreateCustomRole config =
    Http.request
        { method = "POST"
        , headers = []
        , expect =
            Http.expectJson config.toMsg decodeOrganizationCustomRepositoryRole
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "base_role", Json.Encode.string rec.base_role )
                         , ( "description", Json.Encode.string rec.description )
                         , ( "name", Json.Encode.string rec.name )
                         , ( "permissions"
                           , Json.Encode.list Json.Encode.string rec.permissions
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{org}"
                config.params.org
                "https://api.github.com/orgs/{org}/custom_roles"
        }


{-| **Note**: This operation is in beta and subject to change.

Updates a custom repository role that can be used by all repositories owned by the organization.

To use this endpoint the authenticated user must be an administrator for the organization and must use an access token with `admin:org` scope.
GitHub Apps must have the `organization_custom_roles:write` organization permission to use this endpoint.

For more information about custom repository roles, see "[Managing custom repository roles for an organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-custom-repository-roles-for-an-organization)."
-}
orgsUpdateCustomRole config =
    Http.request
        { method = "PATCH"
        , headers = []
        , expect =
            Http.expectJson config.toMsg decodeOrganizationCustomRepositoryRole
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "base_role", Json.Encode.string rec.base_role )
                         , ( "description", Json.Encode.string rec.description )
                         , ( "name", Json.Encode.string rec.name )
                         , ( "permissions"
                           , Json.Encode.list Json.Encode.string rec.permissions
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{role_id}"
                config.params.role_id
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/custom_roles/{role_id}"
                )
        }


{-| **Note**: This operation is in beta and is subject to change.

Deletes a custom role from an organization. Once the custom role has been deleted, any
user, team, or invitation with the deleted custom role will be reassigned the inherited role.

To use this endpoint the authenticated user must be an administrator for the organization and must use an access token with `admin:org` scope.
GitHub Apps must have the `organization_custom_roles:write` organization permission to use this endpoint.

For more information about custom repository roles, see "[Managing custom repository roles for an organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-custom-repository-roles-for-an-organization)."
-}
orgsDeleteCustomRole config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{role_id}"
                config.params.role_id
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/custom_roles/{role_id}"
                )
        }


{-| Lists all secrets available in an organization without revealing their encrypted values. You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `dependabot_secrets` organization permission to use this endpoint. -}
dependabotListOrgSecrets config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\secrets total_count ->
                      { secrets = secrets, total_count = total_count }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "secrets"
                            (Json.Decode.list decodeOrganizationDependabotSecret
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.int)
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/dependabot/secrets"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before you can create or update secrets. You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `dependabot_secrets` organization permission to use this endpoint. -}
dependabotGetOrgPublicKey :
    { toMsg : Result Http.Error DependabotPublicKey -> msg
    , params : { org : String }
    }
    -> Cmd msg
dependabotGetOrgPublicKey config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeDependabotPublicKey
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{org}"
                config.params.org
                "https://api.github.com/orgs/{org}/dependabot/secrets/public-key"
        }


{-| Gets a single organization secret without revealing its encrypted value. You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `dependabot_secrets` organization permission to use this endpoint. -}
dependabotGetOrgSecret :
    { toMsg : Result Http.Error OrganizationDependabotSecret -> msg
    , params : { org : String, secret_name : String }
    }
    -> Cmd msg
dependabotGetOrgSecret config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg decodeOrganizationDependabotSecret
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{secret_name}"
                config.params.secret_name
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/dependabot/secrets/{secret_name}"
                )
        }


{-| Creates or updates an organization secret with an encrypted value. Encrypt your secret using
[LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must authenticate using an access
token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `dependabot_secrets` organization
permission to use this endpoint.

#### Example encrypting a secret using Node.js

Encrypt your secret using the [tweetsodium](https://github.com/github/tweetsodium) library.

```
const sodium = require('tweetsodium');

const key = "base64-encoded-public-key";
const value = "plain-text-secret";

// Convert the message and key to Uint8Array's (Buffer implements that interface)
const messageBytes = Buffer.from(value);
const keyBytes = Buffer.from(key, 'base64');

// Encrypt using LibSodium.
const encryptedBytes = sodium.seal(messageBytes, keyBytes);

// Base64 the encrypted secret
const encrypted = Buffer.from(encryptedBytes).toString('base64');

console.log(encrypted);
```


#### Example encrypting a secret using Python

Encrypt your secret using [pynacl](https://pynacl.readthedocs.io/en/latest/public/#nacl-public-sealedbox) with Python 3.

```
from base64 import b64encode
from nacl import encoding, public

def encrypt(public_key: str, secret_value: str) -> str:
  """Encrypt a Unicode string using the public key."""
  public_key = public.PublicKey(public_key.encode("utf-8"), encoding.Base64Encoder())
  sealed_box = public.SealedBox(public_key)
  encrypted = sealed_box.encrypt(secret_value.encode("utf-8"))
  return b64encode(encrypted).decode("utf-8")
```

#### Example encrypting a secret using C#

Encrypt your secret using the [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package.

```
var secretValue = System.Text.Encoding.UTF8.GetBytes("mySecret");
var publicKey = Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=");

var sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);

Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));
```

#### Example encrypting a secret using Ruby

Encrypt your secret using the [rbnacl](https://github.com/RubyCrypto/rbnacl) gem.

```ruby
require "rbnacl"
require "base64"

key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=")
public_key = RbNaCl::PublicKey.new(key)

box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
encrypted_secret = box.encrypt("my_secret")

# Print the base64 encoded secret
puts Base64.strict_encode64(encrypted_secret)
```
-}
dependabotCreateOrUpdateOrgSecret :
    { toMsg : Result Http.Error EmptyObject -> msg
    , body :
        { encrypted_value : String
        , key_id : String
        , selected_repository_ids : List String
        , visibility : String
        }
    , params : { org : String, secret_name : String }
    }
    -> Cmd msg
dependabotCreateOrUpdateOrgSecret config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeEmptyObject
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "encrypted_value"
                           , Json.Encode.string rec.encrypted_value
                           )
                         , ( "key_id", Json.Encode.string rec.key_id )
                         , ( "selected_repository_ids"
                           , Json.Encode.list Json.Encode.string
                                 rec.selected_repository_ids
                           )
                         , ( "visibility", Json.Encode.string rec.visibility )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{secret_name}"
                config.params.secret_name
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/dependabot/secrets/{secret_name}"
                )
        }


{-| Deletes a secret in an organization using the secret name. You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `dependabot_secrets` organization permission to use this endpoint. -}
dependabotDeleteOrgSecret :
    { toMsg : Result Http.Error () -> msg
    , params : { org : String, secret_name : String }
    }
    -> Cmd msg
dependabotDeleteOrgSecret config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{secret_name}"
                config.params.secret_name
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/dependabot/secrets/{secret_name}"
                )
        }


{-| Lists all repositories that have been selected when the `visibility` for repository access to a secret is set to `selected`. You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `dependabot_secrets` organization permission to use this endpoint. -}
dependabotListSelectedReposForOrgSecret config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\repositories total_count ->
                      { repositories = repositories, total_count = total_count }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "repositories"
                            (Json.Decode.list decodeMinimalRepository)
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.int)
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{secret_name}"
                    config.params.secret_name
                    (String.replace
                        "{org}"
                        config.params.org
                        "https://api.github.com/orgs/{org}/dependabot/secrets/{secret_name}/repositories"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    ]
                )
        }


{-| Replaces all repositories for an organization secret when the `visibility` for repository access is set to `selected`. The visibility is set when you [Create or update an organization secret](https://docs.github.com/rest/reference/dependabot#create-or-update-an-organization-secret). You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `dependabot_secrets` organization permission to use this endpoint. -}
dependabotSetSelectedReposForOrgSecret :
    { toMsg : Result Http.Error () -> msg
    , body : { selected_repository_ids : List Int }
    , params : { org : String, secret_name : String }
    }
    -> Cmd msg
dependabotSetSelectedReposForOrgSecret config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "selected_repository_ids"
                           , Json.Encode.list Json.Encode.int
                                 rec.selected_repository_ids
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{secret_name}"
                config.params.secret_name
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/dependabot/secrets/{secret_name}/repositories"
                )
        }


{-| Adds a repository to an organization secret when the `visibility` for repository access is set to `selected`. The visibility is set when you [Create or update an organization secret](https://docs.github.com/rest/reference/dependabot#create-or-update-an-organization-secret). You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `dependabot_secrets` organization permission to use this endpoint. -}
dependabotAddSelectedRepoToOrgSecret config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repository_id}"
                config.params.repository_id
                (String.replace
                    "{secret_name}"
                    config.params.secret_name
                    (String.replace
                        "{org}"
                        config.params.org
                        "https://api.github.com/orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"
                    )
                )
        }


{-| Removes a repository from an organization secret when the `visibility` for repository access is set to `selected`. The visibility is set when you [Create or update an organization secret](https://docs.github.com/rest/reference/dependabot#create-or-update-an-organization-secret). You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `dependabot_secrets` organization permission to use this endpoint. -}
dependabotRemoveSelectedRepoFromOrgSecret config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repository_id}"
                config.params.repository_id
                (String.replace
                    "{secret_name}"
                    config.params.secret_name
                    (String.replace
                        "{org}"
                        config.params.org
                        "https://api.github.com/orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"
                    )
                )
        }


activityListPublicOrgEvents :
    { toMsg : Result Http.Error (List Event) -> msg
    , params : { org : String, per_page : Maybe Int, page : Maybe Int }
    }
    -> Cmd msg
activityListPublicOrgEvents config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.list decodeEvent)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/events"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| The return hash contains `failed_at` and `failed_reason` fields which represent the time at which the invitation failed and the reason for the failure. -}
orgsListFailedInvitations :
    { toMsg : Result Http.Error (List OrganizationInvitation) -> msg
    , params : { org : String, per_page : Maybe Int, page : Maybe Int }
    }
    -> Cmd msg
orgsListFailedInvitations config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeOrganizationInvitation)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/failed_invitations"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| **Note**: This operation is in beta and subject to change.

Lists the fine-grained permissions available for an organization.

To use this endpoint the authenticated user must be an administrator for the organization or of an repository of the organizaiton and must use an access token with `admin:org repo` scope.
GitHub Apps must have the `organization_custom_roles:read` organization permission to use this endpoint.
-}
orgsListFineGrainedPermissions :
    { toMsg : Result Http.Error (List OrganizationFineGrainedPermission) -> msg
    , params : { org : String }
    }
    -> Cmd msg
orgsListFineGrainedPermissions config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeOrganizationFineGrainedPermission)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{org}"
                config.params.org
                "https://api.github.com/orgs/{org}/fine_grained_permissions"
        }


orgsListWebhooks :
    { toMsg : Result Http.Error (List OrgHook) -> msg
    , params : { org : String, per_page : Maybe Int, page : Maybe Int }
    }
    -> Cmd msg
orgsListWebhooks config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.list decodeOrgHook)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/hooks"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Here's how you can create a hook that posts payloads in JSON format: -}
orgsCreateWebhook :
    { toMsg : Result Http.Error OrgHook -> msg
    , body :
        { active : Bool
        , config :
            { content_type : WebhookConfigContentType
            , insecure_ssl : WebhookConfigInsecureSsl
            , password : String
            , secret : WebhookConfigSecret
            , url : WebhookConfigUrl
            , username : String
            }
        , events : List String
        , name : String
        }
    , params : { org : String }
    }
    -> Cmd msg
orgsCreateWebhook config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeOrgHook
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "active", Json.Encode.bool rec.active )
                         , ( "config"
                           , (\rec0 ->
                                 Json.Encode.object
                                     [ ( "content_type"
                                       , encodeWebhookConfigContentType
                                             rec0.content_type
                                       )
                                     , ( "insecure_ssl"
                                       , encodeWebhookConfigInsecureSsl
                                             rec0.insecure_ssl
                                       )
                                     , ( "password"
                                       , Json.Encode.string rec0.password
                                       )
                                     , ( "secret"
                                       , encodeWebhookConfigSecret rec0.secret
                                       )
                                     , ( "url"
                                       , encodeWebhookConfigUrl rec0.url
                                       )
                                     , ( "username"
                                       , Json.Encode.string rec0.username
                                       )
                                     ]
                             )
                                 rec.config
                           )
                         , ( "events"
                           , Json.Encode.list Json.Encode.string rec.events
                           )
                         , ( "name", Json.Encode.string rec.name )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{org}"
                config.params.org
                "https://api.github.com/orgs/{org}/hooks"
        }


{-| Returns a webhook configured in an organization. To get only the webhook `config` properties, see "[Get a webhook configuration for an organization](/rest/reference/orgs#get-a-webhook-configuration-for-an-organization)." -}
orgsGetWebhook config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeOrgHook
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{hook_id}"
                config.params.hook_id
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/hooks/{hook_id}"
                )
        }


{-| Updates a webhook configured in an organization. When you update a webhook, the `secret` will be overwritten. If you previously had a `secret` set, you must provide the same `secret` or set a new `secret` or the secret will be removed. If you are only updating individual webhook `config` properties, use "[Update a webhook configuration for an organization](/rest/reference/orgs#update-a-webhook-configuration-for-an-organization)." -}
orgsUpdateWebhook config =
    Http.request
        { method = "PATCH"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeOrgHook
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "active", Json.Encode.bool rec.active )
                         , ( "config"
                           , (\rec0 ->
                                 Json.Encode.object
                                     [ ( "content_type"
                                       , encodeWebhookConfigContentType
                                             rec0.content_type
                                       )
                                     , ( "insecure_ssl"
                                       , encodeWebhookConfigInsecureSsl
                                             rec0.insecure_ssl
                                       )
                                     , ( "secret"
                                       , encodeWebhookConfigSecret rec0.secret
                                       )
                                     , ( "url"
                                       , encodeWebhookConfigUrl rec0.url
                                       )
                                     ]
                             )
                                 rec.config
                           )
                         , ( "events"
                           , Json.Encode.list Json.Encode.string rec.events
                           )
                         , ( "name", Json.Encode.string rec.name )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{hook_id}"
                config.params.hook_id
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/hooks/{hook_id}"
                )
        }


orgsDeleteWebhook config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{hook_id}"
                config.params.hook_id
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/hooks/{hook_id}"
                )
        }


{-| Returns the webhook configuration for an organization. To get more information about the webhook, including the `active` state and `events`, use "[Get an organization webhook ](/rest/reference/orgs#get-an-organization-webhook)."

Access tokens must have the `admin:org_hook` scope, and GitHub Apps must have the `organization_hooks:read` permission.
-}
orgsGetWebhookConfigForOrg config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeWebhookConfig
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{hook_id}"
                config.params.hook_id
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/hooks/{hook_id}/config"
                )
        }


{-| Updates the webhook configuration for an organization. To update more information about the webhook, including the `active` state and `events`, use "[Update an organization webhook ](/rest/reference/orgs#update-an-organization-webhook)."

Access tokens must have the `admin:org_hook` scope, and GitHub Apps must have the `organization_hooks:write` permission.
-}
orgsUpdateWebhookConfigForOrg config =
    Http.request
        { method = "PATCH"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeWebhookConfig
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "content_type"
                           , encodeWebhookConfigContentType rec.content_type
                           )
                         , ( "insecure_ssl"
                           , encodeWebhookConfigInsecureSsl rec.insecure_ssl
                           )
                         , ( "secret", encodeWebhookConfigSecret rec.secret )
                         , ( "url", encodeWebhookConfigUrl rec.url )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{hook_id}"
                config.params.hook_id
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/hooks/{hook_id}/config"
                )
        }


{-| Returns a list of webhook deliveries for a webhook configured in an organization. -}
orgsListWebhookDeliveries config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeHookDeliveryItem)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{hook_id}"
                    config.params.hook_id
                    (String.replace
                        "{org}"
                        config.params.org
                        "https://api.github.com/orgs/{org}/hooks/{hook_id}/deliveries"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (Url.Builder.string "cursor")
                        config.params.cursor
                    ]
                )
        }


{-| Returns a delivery for a webhook configured in an organization. -}
orgsGetWebhookDelivery config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeHookDelivery
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{delivery_id}"
                config.params.delivery_id
                (String.replace
                    "{hook_id}"
                    config.params.hook_id
                    (String.replace
                        "{org}"
                        config.params.org
                        "https://api.github.com/orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}"
                    )
                )
        }


{-| Redeliver a delivery for a webhook configured in an organization. -}
orgsRedeliverWebhookDelivery config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeAccepted
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{delivery_id}"
                config.params.delivery_id
                (String.replace
                    "{hook_id}"
                    config.params.hook_id
                    (String.replace
                        "{org}"
                        config.params.org
                        "https://api.github.com/orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"
                    )
                )
        }


{-| This will trigger a [ping event](https://docs.github.com/webhooks/#ping-event) to be sent to the hook. -}
orgsPingWebhook config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{hook_id}"
                config.params.hook_id
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/hooks/{hook_id}/pings"
                )
        }


{-| Enables an authenticated GitHub App to find the organization's installation information.

You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
-}
appsGetOrgInstallation :
    { toMsg : Result Http.Error Installation -> msg, params : { org : String } }
    -> Cmd msg
appsGetOrgInstallation config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeInstallation
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{org}"
                config.params.org
                "https://api.github.com/orgs/{org}/installation"
        }


{-| Lists all GitHub Apps in an organization. The installation count includes all GitHub Apps installed on repositories in the organization. You must be an organization owner with `admin:read` scope to use this endpoint. -}
orgsListAppInstallations config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\installations total_count ->
                      { installations = installations
                      , total_count = total_count
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "installations"
                            (Json.Decode.list decodeInstallation)
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.int)
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/installations"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Shows which type of GitHub user can interact with this organization and when the restriction expires. If there is no restrictions, you will see an empty response. -}
interactionsGetRestrictionsForOrg :
    { toMsg : Result Http.Error (EnumTwo InteractionLimitResponse {}) -> msg
    , params : { org : String }
    }
    -> Cmd msg
interactionsGetRestrictionsForOrg config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Debug.todo "Enum decoder not implemented yet")
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{org}"
                config.params.org
                "https://api.github.com/orgs/{org}/interaction-limits"
        }


{-| Temporarily restricts interactions to a certain type of GitHub user in any public repository in the given organization. You must be an organization owner to set these restrictions. Setting the interaction limit at the organization level will overwrite any interaction limits that are set for individual repositories owned by the organization. -}
interactionsSetRestrictionsForOrg :
    { toMsg : Result Http.Error InteractionLimitResponse -> msg
    , body : InteractionLimit
    , params : { org : String }
    }
    -> Cmd msg
interactionsSetRestrictionsForOrg config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeInteractionLimitResponse
        , body = Http.jsonBody (encodeInteractionLimit config.body)
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{org}"
                config.params.org
                "https://api.github.com/orgs/{org}/interaction-limits"
        }


{-| Removes all interaction restrictions from public repositories in the given organization. You must be an organization owner to remove restrictions. -}
interactionsRemoveRestrictionsForOrg :
    { toMsg : Result Http.Error () -> msg, params : { org : String } }
    -> Cmd msg
interactionsRemoveRestrictionsForOrg config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{org}"
                config.params.org
                "https://api.github.com/orgs/{org}/interaction-limits"
        }


{-| The return hash contains a `role` field which refers to the Organization Invitation role and will be one of the following values: `direct_member`, `admin`, `billing_manager`, `hiring_manager`, or `reinstate`. If the invitee is not a GitHub member, the `login` field in the return hash will be `null`. -}
orgsListPendingInvitations :
    { toMsg : Result Http.Error (List OrganizationInvitation) -> msg
    , params : { org : String, per_page : Maybe Int, page : Maybe Int }
    }
    -> Cmd msg
orgsListPendingInvitations config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeOrganizationInvitation)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/invitations"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Invite people to an organization by using their GitHub user ID or their email address. In order to create invitations in an organization, the authenticated user must be an organization owner.

This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
-}
orgsCreateInvitation :
    { toMsg : Result Http.Error OrganizationInvitation -> msg
    , body :
        { email : String, invitee_id : Int, role : String, team_ids : List Int }
    , params : { org : String }
    }
    -> Cmd msg
orgsCreateInvitation config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeOrganizationInvitation
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "email", Json.Encode.string rec.email )
                         , ( "invitee_id", Json.Encode.int rec.invitee_id )
                         , ( "role", Json.Encode.string rec.role )
                         , ( "team_ids"
                           , Json.Encode.list Json.Encode.int rec.team_ids
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{org}"
                config.params.org
                "https://api.github.com/orgs/{org}/invitations"
        }


{-| Cancel an organization invitation. In order to cancel an organization invitation, the authenticated user must be an organization owner.

This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications).
-}
orgsCancelInvitation config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{invitation_id}"
                config.params.invitation_id
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/invitations/{invitation_id}"
                )
        }


{-| List all teams associated with an invitation. In order to see invitations in an organization, the authenticated user must be an organization owner. -}
orgsListInvitationTeams config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.list decodeTeam)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{invitation_id}"
                    config.params.invitation_id
                    (String.replace
                        "{org}"
                        config.params.org
                        "https://api.github.com/orgs/{org}/invitations/{invitation_id}/teams"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| List issues in an organization assigned to the authenticated user.

**Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a pull request. For this
reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by
the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
request id, use the "[List pull requests](https://docs.github.com/rest/reference/pulls#list-pull-requests)" endpoint.
-}
issuesListForOrg :
    { toMsg : Result Http.Error (List Issue) -> msg
    , params :
        { org : String
        , filter : Maybe String
        , state : Maybe String
        , labels : Maybe String
        , sort : Maybe String
        , direction : Maybe String
        , since : Maybe String
        , per_page : Maybe Int
        , page : Maybe Int
        }
    }
    -> Cmd msg
issuesListForOrg config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.list decodeIssue)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/issues"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (Url.Builder.string "filter")
                        config.params.filter
                    , Maybe.map (Url.Builder.string "state") config.params.state
                    , Maybe.map
                        (Url.Builder.string "labels")
                        config.params.labels
                    , Maybe.map (Url.Builder.string "sort") config.params.sort
                    , Maybe.map
                        (Url.Builder.string "direction")
                        config.params.direction
                    , Maybe.map (Url.Builder.string "since") config.params.since
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| List all users who are members of an organization. If the authenticated user is also a member of this organization then both concealed and public members will be returned. -}
orgsListMembers :
    { toMsg : Result Http.Error (List SimpleUser) -> msg
    , params :
        { org : String
        , filter : Maybe String
        , role : Maybe String
        , per_page : Maybe Int
        , page : Maybe Int
        }
    }
    -> Cmd msg
orgsListMembers config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeSimpleUser)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/members"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (Url.Builder.string "filter")
                        config.params.filter
                    , Maybe.map (Url.Builder.string "role") config.params.role
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Check if a user is, publicly or privately, a member of the organization. -}
orgsCheckMembershipForUser :
    { toMsg : Result Http.Error () -> msg
    , params : { org : String, username : String }
    }
    -> Cmd msg
orgsCheckMembershipForUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{username}"
                config.params.username
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/members/{username}"
                )
        }


{-| Removing a user from this list will remove them from all teams and they will no longer have any access to the organization's repositories. -}
orgsRemoveMember :
    { toMsg : Result Http.Error () -> msg
    , params : { org : String, username : String }
    }
    -> Cmd msg
orgsRemoveMember config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{username}"
                config.params.username
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/members/{username}"
                )
        }


{-| Lists the codespaces that a member of an organization has for repositories in that organization.

You must authenticate using an access token with the `admin:org` scope to use this endpoint.
-}
codespacesGetCodespacesForUserInOrg config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\codespaces total_count ->
                      { codespaces = codespaces, total_count = total_count }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "codespaces"
                            (Json.Decode.list decodeCodespace)
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.int)
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{username}"
                    config.params.username
                    (String.replace
                        "{org}"
                        config.params.org
                        "https://api.github.com/orgs/{org}/members/{username}/codespaces"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Deletes a user's codespace.

You must authenticate using an access token with the `admin:org` scope to use this endpoint.
-}
codespacesDeleteFromOrganization :
    { toMsg : Result Http.Error Accepted -> msg
    , params : { org : String, username : String, codespace_name : String }
    }
    -> Cmd msg
codespacesDeleteFromOrganization config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeAccepted
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{codespace_name}"
                config.params.codespace_name
                (String.replace
                    "{username}"
                    config.params.username
                    (String.replace
                        "{org}"
                        config.params.org
                        "https://api.github.com/orgs/{org}/members/{username}/codespaces/{codespace_name}"
                    )
                )
        }


{-| Stops a user's codespace.

You must authenticate using an access token with the `admin:org` scope to use this endpoint.
-}
codespacesStopInOrganization :
    { toMsg : Result Http.Error Codespace -> msg
    , params : { org : String, username : String, codespace_name : String }
    }
    -> Cmd msg
codespacesStopInOrganization config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeCodespace
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{codespace_name}"
                config.params.codespace_name
                (String.replace
                    "{username}"
                    config.params.username
                    (String.replace
                        "{org}"
                        config.params.org
                        "https://api.github.com/orgs/{org}/members/{username}/codespaces/{codespace_name}/stop"
                    )
                )
        }


{-| In order to get a user's membership with an organization, the authenticated user must be an organization member. The `state` parameter in the response can be used to identify the user's membership status. -}
orgsGetMembershipForUser :
    { toMsg : Result Http.Error OrgMembership -> msg
    , params : { org : String, username : String }
    }
    -> Cmd msg
orgsGetMembershipForUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeOrgMembership
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{username}"
                config.params.username
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/memberships/{username}"
                )
        }


{-| Only authenticated organization owners can add a member to the organization or update the member's role.

*   If the authenticated user is _adding_ a member to the organization, the invited user will receive an email inviting them to the organization. The user's [membership status](https://docs.github.com/rest/reference/orgs#get-organization-membership-for-a-user) will be `pending` until they accept the invitation.
    
*   Authenticated users can _update_ a user's membership by passing the `role` parameter. If the authenticated user changes a member's role to `admin`, the affected user will receive an email notifying them that they've been made an organization owner. If the authenticated user changes an owner's role to `member`, no email will be sent.

**Rate limits**

To prevent abuse, the authenticated user is limited to 50 organization invitations per 24 hour period. If the organization is more than one month old or on a paid plan, the limit is 500 invitations per 24 hour period.
-}
orgsSetMembershipForUser :
    { toMsg : Result Http.Error OrgMembership -> msg
    , body : { role : String }
    , params : { org : String, username : String }
    }
    -> Cmd msg
orgsSetMembershipForUser config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeOrgMembership
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "role", Json.Encode.string rec.role ) ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{username}"
                config.params.username
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/memberships/{username}"
                )
        }


{-| In order to remove a user's membership with an organization, the authenticated user must be an organization owner.

If the specified user is an active member of the organization, this will remove them from the organization. If the specified user has been invited to the organization, this will cancel their invitation. The specified user will receive an email notification in both cases.
-}
orgsRemoveMembershipForUser :
    { toMsg : Result Http.Error () -> msg
    , params : { org : String, username : String }
    }
    -> Cmd msg
orgsRemoveMembershipForUser config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{username}"
                config.params.username
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/memberships/{username}"
                )
        }


{-| Lists the most recent migrations. -}
migrationsListForOrg :
    { toMsg : Result Http.Error (List Migration) -> msg
    , params :
        { org : String
        , per_page : Maybe Int
        , page : Maybe Int
        , exclude : Maybe (List String)
        }
    }
    -> Cmd msg
migrationsListForOrg config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeMigration)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/migrations"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "exclude"
                                (Debug.todo
                                    "Params of type \"(List String)\" (in helper)"
                                )
                        )
                        config.params.exclude
                    ]
                )
        }


{-| Initiates the generation of a migration archive. -}
migrationsStartForOrg :
    { toMsg : Result Http.Error Migration -> msg
    , body :
        { exclude : List String
        , exclude_attachments : Bool
        , exclude_git_data : Bool
        , exclude_metadata : Bool
        , exclude_owner_projects : Bool
        , exclude_releases : Bool
        , lock_repositories : Bool
        , org_metadata_only : Bool
        , repositories : List String
        }
    , params : { org : String }
    }
    -> Cmd msg
migrationsStartForOrg config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeMigration
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "exclude"
                           , Json.Encode.list Json.Encode.string rec.exclude
                           )
                         , ( "exclude_attachments"
                           , Json.Encode.bool rec.exclude_attachments
                           )
                         , ( "exclude_git_data"
                           , Json.Encode.bool rec.exclude_git_data
                           )
                         , ( "exclude_metadata"
                           , Json.Encode.bool rec.exclude_metadata
                           )
                         , ( "exclude_owner_projects"
                           , Json.Encode.bool rec.exclude_owner_projects
                           )
                         , ( "exclude_releases"
                           , Json.Encode.bool rec.exclude_releases
                           )
                         , ( "lock_repositories"
                           , Json.Encode.bool rec.lock_repositories
                           )
                         , ( "org_metadata_only"
                           , Json.Encode.bool rec.org_metadata_only
                           )
                         , ( "repositories"
                           , Json.Encode.list Json.Encode.string
                                 rec.repositories
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{org}"
                config.params.org
                "https://api.github.com/orgs/{org}/migrations"
        }


{-| Fetches the status of a migration.

The `state` of a migration can be one of the following values:

*   `pending`, which means the migration hasn't started yet.
*   `exporting`, which means the migration is in progress.
*   `exported`, which means the migration finished successfully.
*   `failed`, which means the migration failed.
-}
migrationsGetStatusForOrg config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeMigration
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{migration_id}"
                    config.params.migration_id
                    (String.replace
                        "{org}"
                        config.params.org
                        "https://api.github.com/orgs/{org}/migrations/{migration_id}"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "exclude"
                                (Debug.todo
                                    "Params of type \"(List String)\" (in helper)"
                                )
                        )
                        config.params.exclude
                    ]
                )
        }


{-| Deletes a previous migration archive. Migration archives are automatically deleted after seven days. -}
migrationsDeleteArchiveForOrg config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{migration_id}"
                config.params.migration_id
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/migrations/{migration_id}/archive"
                )
        }


{-| Unlocks a repository that was locked for migration. You should unlock each migrated repository and [delete them](https://docs.github.com/rest/reference/repos#delete-a-repository) when the migration is complete and you no longer need the source data. -}
migrationsUnlockRepoForOrg config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo_name}"
                config.params.repo_name
                (String.replace
                    "{migration_id}"
                    config.params.migration_id
                    (String.replace
                        "{org}"
                        config.params.org
                        "https://api.github.com/orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock"
                    )
                )
        }


{-| List all the repositories for this organization migration. -}
migrationsListReposForOrg config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeMinimalRepository)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{migration_id}"
                    config.params.migration_id
                    (String.replace
                        "{org}"
                        config.params.org
                        "https://api.github.com/orgs/{org}/migrations/{migration_id}/repositories"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| List all users who are outside collaborators of an organization. -}
orgsListOutsideCollaborators :
    { toMsg : Result Http.Error (List SimpleUser) -> msg
    , params :
        { org : String
        , filter : Maybe String
        , per_page : Maybe Int
        , page : Maybe Int
        }
    }
    -> Cmd msg
orgsListOutsideCollaborators config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeSimpleUser)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/outside_collaborators"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (Url.Builder.string "filter")
                        config.params.filter
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| When an organization member is converted to an outside collaborator, they'll only have access to the repositories that their current team membership allows. The user will no longer be a member of the organization. For more information, see "[Converting an organization member to an outside collaborator](https://docs.github.com/articles/converting-an-organization-member-to-an-outside-collaborator/)". Converting an organization member to an outside collaborator may be restricted by enterprise administrators. For more information, see "[Enforcing repository management policies in your enterprise](https://docs.github.com/enterprise-cloud@latest/admin/policies/enforcing-policies-for-your-enterprise/enforcing-repository-management-policies-in-your-enterprise#enforcing-a-policy-for-inviting-outside-collaborators-to-repositories)." -}
orgsConvertMemberToOutsideCollaborator :
    { toMsg : Result Http.Error {} -> msg
    , body : { async : Bool }
    , params : { org : String, username : String }
    }
    -> Cmd msg
orgsConvertMemberToOutsideCollaborator config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.succeed {})
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "async", Json.Encode.bool rec.async ) ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{username}"
                config.params.username
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/outside_collaborators/{username}"
                )
        }


{-| Removing a user from this list will remove them from all the organization's repositories. -}
orgsRemoveOutsideCollaborator :
    { toMsg : Result Http.Error () -> msg
    , params : { org : String, username : String }
    }
    -> Cmd msg
orgsRemoveOutsideCollaborator config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{username}"
                config.params.username
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/outside_collaborators/{username}"
                )
        }


{-| Lists all packages in an organization readable by the user.

To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
If `package_type` is not `container`, your token must also include the `repo` scope.
-}
packagesListPackagesForOrganization config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.list decodePackage)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/packages"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Just
                        (Url.Builder.string
                            "package_type"
                            config.params.package_type
                        )
                    , Maybe.map
                        (Url.Builder.string "visibility")
                        config.params.visibility
                    ]
                )
        }


{-| Gets a specific package in an organization.

To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
If `package_type` is not `container`, your token must also include the `repo` scope.
-}
packagesGetPackageForOrganization :
    { toMsg : Result Http.Error Package -> msg
    , params : { package_type : String, package_name : String, org : String }
    }
    -> Cmd msg
packagesGetPackageForOrganization config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodePackage
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{org}"
                config.params.org
                (String.replace
                    "{package_name}"
                    config.params.package_name
                    (String.replace
                        "{package_type}"
                        config.params.package_type
                        "https://api.github.com/orgs/{org}/packages/{package_type}/{package_name}"
                    )
                )
        }


{-| Deletes an entire package in an organization. You cannot delete a public package if any version of the package has more than 5,000 downloads. In this scenario, contact GitHub support for further assistance.

To use this endpoint, you must have admin permissions in the organization and authenticate using an access token with the `packages:read` and `packages:delete` scopes. In addition:
- If `package_type` is not `container`, your token must also include the `repo` scope.
- If `package_type` is `container`, you must also have admin permissions to the container you want to delete.
-}
packagesDeletePackageForOrg :
    { toMsg : Result Http.Error () -> msg
    , params : { package_type : String, package_name : String, org : String }
    }
    -> Cmd msg
packagesDeletePackageForOrg config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{org}"
                config.params.org
                (String.replace
                    "{package_name}"
                    config.params.package_name
                    (String.replace
                        "{package_type}"
                        config.params.package_type
                        "https://api.github.com/orgs/{org}/packages/{package_type}/{package_name}"
                    )
                )
        }


{-| Restores an entire package in an organization.

You can restore a deleted package under the following conditions:
  - The package was deleted within the last 30 days.
  - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.

To use this endpoint, you must have admin permissions in the organization and authenticate using an access token with the `packages:read` and `packages:write` scopes. In addition:
- If `package_type` is not `container`, your token must also include the `repo` scope.
- If `package_type` is `container`, you must also have admin permissions to the container that you want to restore.
-}
packagesRestorePackageForOrg :
    { toMsg : Result Http.Error () -> msg
    , params :
        { package_type : String
        , package_name : String
        , org : String
        , token : Maybe String
        }
    }
    -> Cmd msg
packagesRestorePackageForOrg config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{org}"
                    config.params.org
                    (String.replace
                        "{package_name}"
                        config.params.package_name
                        (String.replace
                            "{package_type}"
                            config.params.package_type
                            "https://api.github.com/orgs/{org}/packages/{package_type}/{package_name}/restore"
                        )
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map (Url.Builder.string "token") config.params.token
                    ]
                )
        }


{-| Lists package versions for a package owned by an organization.

To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
If `package_type` is not `container`, your token must also include the `repo` scope.
-}
packagesGetAllPackageVersionsForPackageOwnedByOrg :
    { toMsg : Result Http.Error (List PackageVersion) -> msg
    , params :
        { package_type : String
        , package_name : String
        , org : String
        , page : Maybe Int
        , per_page : Maybe Int
        , state : Maybe String
        }
    }
    -> Cmd msg
packagesGetAllPackageVersionsForPackageOwnedByOrg config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodePackageVersion)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{org}"
                    config.params.org
                    (String.replace
                        "{package_name}"
                        config.params.package_name
                        (String.replace
                            "{package_type}"
                            config.params.package_type
                            "https://api.github.com/orgs/{org}/packages/{package_type}/{package_name}/versions"
                        )
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map (Url.Builder.string "state") config.params.state
                    ]
                )
        }


{-| Gets a specific package version in an organization.

You must authenticate using an access token with the `packages:read` scope.
If `package_type` is not `container`, your token must also include the `repo` scope.
-}
packagesGetPackageVersionForOrganization config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodePackageVersion
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{package_version_id}"
                config.params.package_version_id
                (String.replace
                    "{org}"
                    config.params.org
                    (String.replace
                        "{package_name}"
                        config.params.package_name
                        (String.replace
                            "{package_type}"
                            config.params.package_type
                            "https://api.github.com/orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
                        )
                    )
                )
        }


{-| Deletes a specific package version in an organization. If the package is public and the package version has more than 5,000 downloads, you cannot delete the package version. In this scenario, contact GitHub support for further assistance.

To use this endpoint, you must have admin permissions in the organization and authenticate using an access token with the `packages:read` and `packages:delete` scopes. In addition:
- If `package_type` is not `container`, your token must also include the `repo` scope.
- If `package_type` is `container`, you must also have admin permissions to the container you want to delete.
-}
packagesDeletePackageVersionForOrg config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{package_version_id}"
                config.params.package_version_id
                (String.replace
                    "{org}"
                    config.params.org
                    (String.replace
                        "{package_name}"
                        config.params.package_name
                        (String.replace
                            "{package_type}"
                            config.params.package_type
                            "https://api.github.com/orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
                        )
                    )
                )
        }


{-| Restores a specific package version in an organization.

You can restore a deleted package under the following conditions:
  - The package was deleted within the last 30 days.
  - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.

To use this endpoint, you must have admin permissions in the organization and authenticate using an access token with the `packages:read` and `packages:write` scopes. In addition:
- If `package_type` is not `container`, your token must also include the `repo` scope.
- If `package_type` is `container`, you must also have admin permissions to the container that you want to restore.
-}
packagesRestorePackageVersionForOrg config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{package_version_id}"
                config.params.package_version_id
                (String.replace
                    "{org}"
                    config.params.org
                    (String.replace
                        "{package_name}"
                        config.params.package_name
                        (String.replace
                            "{package_type}"
                            config.params.package_type
                            "https://api.github.com/orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
                        )
                    )
                )
        }


{-| Lists the projects in an organization. Returns a `404 Not Found` status if projects are disabled in the organization. If you do not have sufficient privileges to perform this action, a `401 Unauthorized` or `410 Gone` status is returned. -}
projectsListForOrg :
    { toMsg : Result Http.Error (List Project) -> msg
    , params :
        { org : String
        , state : Maybe String
        , per_page : Maybe Int
        , page : Maybe Int
        }
    }
    -> Cmd msg
projectsListForOrg config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.list decodeProject)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/projects"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map (Url.Builder.string "state") config.params.state
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Creates an organization project board. Returns a `410 Gone` status if projects are disabled in the organization or if the organization does not have existing classic projects. If you do not have sufficient privileges to perform this action, a `401 Unauthorized` or `410 Gone` status is returned. -}
projectsCreateForOrg :
    { toMsg : Result Http.Error Project -> msg
    , body : { body : String, name : String }
    , params : { org : String }
    }
    -> Cmd msg
projectsCreateForOrg config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeProject
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "body", Json.Encode.string rec.body )
                         , ( "name", Json.Encode.string rec.name )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{org}"
                config.params.org
                "https://api.github.com/orgs/{org}/projects"
        }


{-| Members of an organization can choose to have their membership publicized or not. -}
orgsListPublicMembers :
    { toMsg : Result Http.Error (List SimpleUser) -> msg
    , params : { org : String, per_page : Maybe Int, page : Maybe Int }
    }
    -> Cmd msg
orgsListPublicMembers config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeSimpleUser)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/public_members"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


orgsCheckPublicMembershipForUser :
    { toMsg : Result Http.Error () -> msg
    , params : { org : String, username : String }
    }
    -> Cmd msg
orgsCheckPublicMembershipForUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{username}"
                config.params.username
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/public_members/{username}"
                )
        }


{-| The user can publicize their own membership. (A user cannot publicize the membership for another user.)

Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs)."
-}
orgsSetPublicMembershipForAuthenticatedUser :
    { toMsg : Result Http.Error () -> msg
    , params : { org : String, username : String }
    }
    -> Cmd msg
orgsSetPublicMembershipForAuthenticatedUser config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{username}"
                config.params.username
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/public_members/{username}"
                )
        }


orgsRemovePublicMembershipForAuthenticatedUser :
    { toMsg : Result Http.Error () -> msg
    , params : { org : String, username : String }
    }
    -> Cmd msg
orgsRemovePublicMembershipForAuthenticatedUser config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{username}"
                config.params.username
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/public_members/{username}"
                )
        }


{-| Lists repositories for the specified organization. -}
reposListForOrg :
    { toMsg : Result Http.Error (List MinimalRepository) -> msg
    , params :
        { org : String
        , type_ : Maybe String
        , sort : Maybe String
        , direction : Maybe String
        , per_page : Maybe Int
        , page : Maybe Int
        }
    }
    -> Cmd msg
reposListForOrg config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeMinimalRepository)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/repos"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map (Url.Builder.string "type") config.params.type_
                    , Maybe.map (Url.Builder.string "sort") config.params.sort
                    , Maybe.map
                        (Url.Builder.string "direction")
                        config.params.direction
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Creates a new repository in the specified organization. The authenticated user must be a member of the organization.

**OAuth scope requirements**

When using [OAuth](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/), authorizations must include:

*   `public_repo` scope or `repo` scope to create a public repository. Note: For GitHub AE, use `repo` scope to create an internal repository.
*   `repo` scope to create a private repository
-}
reposCreateInOrg :
    { toMsg : Result Http.Error Repository -> msg
    , body :
        { allow_auto_merge : Bool
        , allow_merge_commit : Bool
        , allow_rebase_merge : Bool
        , allow_squash_merge : Bool
        , auto_init : Bool
        , delete_branch_on_merge : Bool
        , description : String
        , gitignore_template : String
        , has_issues : Bool
        , has_projects : Bool
        , has_wiki : Bool
        , homepage : String
        , is_template : Bool
        , license_template : String
        , merge_commit_message : String
        , merge_commit_title : String
        , name : String
        , private : Bool
        , squash_merge_commit_message : String
        , squash_merge_commit_title : String
        , team_id : Int
        , use_squash_pr_title_as_default : Bool
        , visibility : String
        }
    , params : { org : String }
    }
    -> Cmd msg
reposCreateInOrg config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeRepository
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "allow_auto_merge"
                           , Json.Encode.bool rec.allow_auto_merge
                           )
                         , ( "allow_merge_commit"
                           , Json.Encode.bool rec.allow_merge_commit
                           )
                         , ( "allow_rebase_merge"
                           , Json.Encode.bool rec.allow_rebase_merge
                           )
                         , ( "allow_squash_merge"
                           , Json.Encode.bool rec.allow_squash_merge
                           )
                         , ( "auto_init", Json.Encode.bool rec.auto_init )
                         , ( "delete_branch_on_merge"
                           , Json.Encode.bool rec.delete_branch_on_merge
                           )
                         , ( "description", Json.Encode.string rec.description )
                         , ( "gitignore_template"
                           , Json.Encode.string rec.gitignore_template
                           )
                         , ( "has_issues", Json.Encode.bool rec.has_issues )
                         , ( "has_projects", Json.Encode.bool rec.has_projects )
                         , ( "has_wiki", Json.Encode.bool rec.has_wiki )
                         , ( "homepage", Json.Encode.string rec.homepage )
                         , ( "is_template", Json.Encode.bool rec.is_template )
                         , ( "license_template"
                           , Json.Encode.string rec.license_template
                           )
                         , ( "merge_commit_message"
                           , Json.Encode.string rec.merge_commit_message
                           )
                         , ( "merge_commit_title"
                           , Json.Encode.string rec.merge_commit_title
                           )
                         , ( "name", Json.Encode.string rec.name )
                         , ( "private", Json.Encode.bool rec.private )
                         , ( "squash_merge_commit_message"
                           , Json.Encode.string rec.squash_merge_commit_message
                           )
                         , ( "squash_merge_commit_title"
                           , Json.Encode.string rec.squash_merge_commit_title
                           )
                         , ( "team_id", Json.Encode.int rec.team_id )
                         , ( "use_squash_pr_title_as_default"
                           , Json.Encode.bool rec.use_squash_pr_title_as_default
                           )
                         , ( "visibility", Json.Encode.string rec.visibility )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{org}"
                config.params.org
                "https://api.github.com/orgs/{org}/repos"
        }


{-| Lists secret scanning alerts for eligible repositories in an organization, from newest to oldest.
To use this endpoint, you must be an administrator or security manager for the organization, and you must use an access token with the `repo` scope or `security_events` scope.
For public repositories, you may instead use the `public_repo` scope.

GitHub Apps must have the `secret_scanning_alerts` read permission to use this endpoint.
-}
secretScanningListAlertsForOrg :
    { toMsg : Result Http.Error (List OrganizationSecretScanningAlert) -> msg
    , params :
        { org : String
        , state : Maybe String
        , secret_type : Maybe String
        , resolution : Maybe String
        , sort : Maybe String
        , direction : Maybe String
        , page : Maybe Int
        , per_page : Maybe Int
        , before : Maybe String
        , after : Maybe String
        }
    }
    -> Cmd msg
secretScanningListAlertsForOrg config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeOrganizationSecretScanningAlert)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/secret-scanning/alerts"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map (Url.Builder.string "state") config.params.state
                    , Maybe.map
                        (Url.Builder.string "secret_type")
                        config.params.secret_type
                    , Maybe.map
                        (Url.Builder.string "resolution")
                        config.params.resolution
                    , Maybe.map (Url.Builder.string "sort") config.params.sort
                    , Maybe.map
                        (Url.Builder.string "direction")
                        config.params.direction
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (Url.Builder.string "before")
                        config.params.before
                    , Maybe.map (Url.Builder.string "after") config.params.after
                    ]
                )
        }


{-| Lists teams that are security managers for an organization. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."

To use this endpoint, you must be an administrator or security manager for the organization, and you must use an access token with the `read:org` scope.

GitHub Apps must have the `administration` organization read permission to use this endpoint.
-}
orgsListSecurityManagerTeams :
    { toMsg : Result Http.Error (List TeamSimple) -> msg
    , params : { org : String }
    }
    -> Cmd msg
orgsListSecurityManagerTeams config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeTeamSimple)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{org}"
                config.params.org
                "https://api.github.com/orgs/{org}/security-managers"
        }


{-| Adds a team as a security manager for an organization. For more information, see "[Managing security for an organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization) for an organization."

To use this endpoint, you must be an administrator for the organization, and you must use an access token with the `write:org` scope.

GitHub Apps must have the `administration` organization read-write permission to use this endpoint.
-}
orgsAddSecurityManagerTeam :
    { toMsg : Result Http.Error () -> msg
    , params : { org : String, team_slug : String }
    }
    -> Cmd msg
orgsAddSecurityManagerTeam config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{team_slug}"
                config.params.team_slug
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/security-managers/teams/{team_slug}"
                )
        }


{-| Removes the security manager role from a team for an organization. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization) team from an organization."

To use this endpoint, you must be an administrator for the organization, and you must use an access token with the `admin:org` scope.

GitHub Apps must have the `administration` organization read-write permission to use this endpoint.
-}
orgsRemoveSecurityManagerTeam :
    { toMsg : Result Http.Error () -> msg
    , params : { org : String, team_slug : String }
    }
    -> Cmd msg
orgsRemoveSecurityManagerTeam config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{team_slug}"
                config.params.team_slug
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/security-managers/teams/{team_slug}"
                )
        }


{-| Gets the summary of the free and paid GitHub Actions minutes used.

Paid minutes only apply to workflows in private repositories that use GitHub-hosted runners. Minutes used is listed for each GitHub-hosted runner operating system. Any job re-runs are also included in the usage. The usage returned includes any minute multipliers for macOS and Windows runners, and is rounded up to the nearest whole minute. For more information, see "[Managing billing for GitHub Actions](https://docs.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)".

Access tokens must have the `repo` or `admin:org` scope.
-}
billingGetGithubActionsBillingOrg :
    { toMsg : Result Http.Error ActionsBillingUsage -> msg
    , params : { org : String }
    }
    -> Cmd msg
billingGetGithubActionsBillingOrg config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeActionsBillingUsage
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{org}"
                config.params.org
                "https://api.github.com/orgs/{org}/settings/billing/actions"
        }


{-| Gets the GitHub Advanced Security active committers for an organization per repository.

Each distinct user login across all repositories is counted as a single Advanced Security seat, so the `total_advanced_security_committers` is not the sum of advanced_security_committers for each repository.

If this organization defers to an enterprise for billing, the `total_advanced_security_committers` returned from the organization API may include some users that are in more than one organization, so they will only consume a single Advanced Security seat at the enterprise level.

The total number of repositories with committer information is tracked by the `total_count` field.
-}
billingGetGithubAdvancedSecurityBillingOrg :
    { toMsg : Result Http.Error AdvancedSecurityActiveCommitters -> msg
    , params : { org : String, per_page : Maybe Int, page : Maybe Int }
    }
    -> Cmd msg
billingGetGithubAdvancedSecurityBillingOrg config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg decodeAdvancedSecurityActiveCommitters
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/settings/billing/advanced-security"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Gets the free and paid storage used for GitHub Packages in gigabytes.

Paid minutes only apply to packages stored for private repositories. For more information, see "[Managing billing for GitHub Packages](https://docs.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."

Access tokens must have the `repo` or `admin:org` scope.
-}
billingGetGithubPackagesBillingOrg :
    { toMsg : Result Http.Error PackagesBillingUsage -> msg
    , params : { org : String }
    }
    -> Cmd msg
billingGetGithubPackagesBillingOrg config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodePackagesBillingUsage
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{org}"
                config.params.org
                "https://api.github.com/orgs/{org}/settings/billing/packages"
        }


{-| Gets the estimated paid and estimated total storage used for GitHub Actions and GitHub Packages.

Paid minutes only apply to packages stored for private repositories. For more information, see "[Managing billing for GitHub Packages](https://docs.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."

Access tokens must have the `repo` or `admin:org` scope.
-}
billingGetSharedStorageBillingOrg :
    { toMsg : Result Http.Error CombinedBillingUsage -> msg
    , params : { org : String }
    }
    -> Cmd msg
billingGetSharedStorageBillingOrg config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeCombinedBillingUsage
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{org}"
                config.params.org
                "https://api.github.com/orgs/{org}/settings/billing/shared-storage"
        }


{-| Lists all teams in an organization that are visible to the authenticated user. -}
teamsList :
    { toMsg : Result Http.Error (List Team) -> msg
    , params : { org : String, per_page : Maybe Int, page : Maybe Int }
    }
    -> Cmd msg
teamsList config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.list decodeTeam)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/teams"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| To create a team, the authenticated user must be a member or owner of `{org}`. By default, organization members can create teams. Organization owners can limit team creation to organization owners. For more information, see "[Setting team creation permissions](https://docs.github.com/en/articles/setting-team-creation-permissions-in-your-organization)."

When you create a new team, you automatically become a team maintainer without explicitly adding yourself to the optional array of `maintainers`. For more information, see "[About teams](https://docs.github.com/en/github/setting-up-and-managing-organizations-and-teams/about-teams)".
-}
teamsCreate :
    { toMsg : Result Http.Error TeamFull -> msg
    , body :
        { description : String
        , maintainers : List String
        , name : String
        , parent_team_id : Int
        , permission : String
        , privacy : String
        , repo_names : List String
        }
    , params : { org : String }
    }
    -> Cmd msg
teamsCreate config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeTeamFull
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "description", Json.Encode.string rec.description )
                         , ( "maintainers"
                           , Json.Encode.list Json.Encode.string rec.maintainers
                           )
                         , ( "name", Json.Encode.string rec.name )
                         , ( "parent_team_id"
                           , Json.Encode.int rec.parent_team_id
                           )
                         , ( "permission", Json.Encode.string rec.permission )
                         , ( "privacy", Json.Encode.string rec.privacy )
                         , ( "repo_names"
                           , Json.Encode.list Json.Encode.string rec.repo_names
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{org}"
                config.params.org
                "https://api.github.com/orgs/{org}/teams"
        }


{-| Gets a team using the team's `slug`. GitHub generates the `slug` from the team `name`.

**Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}`.
-}
teamsGetByName :
    { toMsg : Result Http.Error TeamFull -> msg
    , params : { org : String, team_slug : String }
    }
    -> Cmd msg
teamsGetByName config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeTeamFull
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{team_slug}"
                config.params.team_slug
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/teams/{team_slug}"
                )
        }


{-| To edit a team, the authenticated user must either be an organization owner or a team maintainer.

**Note:** You can also specify a team by `org_id` and `team_id` using the route `PATCH /organizations/{org_id}/team/{team_id}`.
-}
teamsUpdateInOrg :
    { toMsg : Result Http.Error TeamFull -> msg
    , body :
        { description : String
        , name : String
        , parent_team_id : Nullable Int
        , permission : String
        , privacy : String
        }
    , params : { org : String, team_slug : String }
    }
    -> Cmd msg
teamsUpdateInOrg config =
    Http.request
        { method = "PATCH"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeTeamFull
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "description", Json.Encode.string rec.description )
                         , ( "name", Json.Encode.string rec.name )
                         , ( "parent_team_id"
                           , (\nullableValue ->
                                 case nullableValue of
                                     Null ->
                                         Json.Encode.null

                                     Present value ->
                                         Json.Encode.int value
                             )
                                 rec.parent_team_id
                           )
                         , ( "permission", Json.Encode.string rec.permission )
                         , ( "privacy", Json.Encode.string rec.privacy )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{team_slug}"
                config.params.team_slug
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/teams/{team_slug}"
                )
        }


{-| To delete a team, the authenticated user must be an organization owner or team maintainer.

If you are an organization owner, deleting a parent team will delete all of its child teams as well.

**Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE /organizations/{org_id}/team/{team_id}`.
-}
teamsDeleteInOrg :
    { toMsg : Result Http.Error () -> msg
    , params : { org : String, team_slug : String }
    }
    -> Cmd msg
teamsDeleteInOrg config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{team_slug}"
                config.params.team_slug
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/teams/{team_slug}"
                )
        }


{-| List all discussions on a team's page. OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).

**Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/discussions`.
-}
teamsListDiscussionsInOrg :
    { toMsg : Result Http.Error (List TeamDiscussion) -> msg
    , params :
        { org : String
        , team_slug : String
        , direction : Maybe String
        , per_page : Maybe Int
        , page : Maybe Int
        , pinned : Maybe String
        }
    }
    -> Cmd msg
teamsListDiscussionsInOrg config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeTeamDiscussion)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{team_slug}"
                    config.params.team_slug
                    (String.replace
                        "{org}"
                        config.params.org
                        "https://api.github.com/orgs/{org}/teams/{team_slug}/discussions"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (Url.Builder.string "direction")
                        config.params.direction
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    , Maybe.map
                        (Url.Builder.string "pinned")
                        config.params.pinned
                    ]
                )
        }


{-| Creates a new discussion post on a team's page. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).

This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.

**Note:** You can also specify a team by `org_id` and `team_id` using the route `POST /organizations/{org_id}/team/{team_id}/discussions`.
-}
teamsCreateDiscussionInOrg :
    { toMsg : Result Http.Error TeamDiscussion -> msg
    , body : { body : String, private : Bool, title : String }
    , params : { org : String, team_slug : String }
    }
    -> Cmd msg
teamsCreateDiscussionInOrg config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeTeamDiscussion
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "body", Json.Encode.string rec.body )
                         , ( "private", Json.Encode.bool rec.private )
                         , ( "title", Json.Encode.string rec.title )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{team_slug}"
                config.params.team_slug
                (String.replace
                    "{org}"
                    config.params.org
                    "https://api.github.com/orgs/{org}/teams/{team_slug}/discussions"
                )
        }


{-| Get a specific discussion on a team's page. OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).

**Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}`.
-}
teamsGetDiscussionInOrg config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeTeamDiscussion
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{discussion_number}"
                config.params.discussion_number
                (String.replace
                    "{team_slug}"
                    config.params.team_slug
                    (String.replace
                        "{org}"
                        config.params.org
                        "https://api.github.com/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
                    )
                )
        }


{-| Edits the title and body text of a discussion post. Only the parameters you provide are updated. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).

**Note:** You can also specify a team by `org_id` and `team_id` using the route `PATCH /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}`.
-}
teamsUpdateDiscussionInOrg config =
    Http.request
        { method = "PATCH"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeTeamDiscussion
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "body", Json.Encode.string rec.body )
                         , ( "title", Json.Encode.string rec.title )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{discussion_number}"
                config.params.discussion_number
                (String.replace
                    "{team_slug}"
                    config.params.team_slug
                    (String.replace
                        "{org}"
                        config.params.org
                        "https://api.github.com/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
                    )
                )
        }


{-| Delete a discussion from a team's page. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).

**Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}`.
-}
teamsDeleteDiscussionInOrg config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{discussion_number}"
                config.params.discussion_number
                (String.replace
                    "{team_slug}"
                    config.params.team_slug
                    (String.replace
                        "{org}"
                        config.params.org
                        "https://api.github.com/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
                    )
                )
        }


{-| List all comments on a team discussion. OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).

**Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments`.
-}
teamsListDiscussionCommentsInOrg config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeTeamDiscussionComment)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{discussion_number}"
                    config.params.discussion_number
                    (String.replace
                        "{team_slug}"
                        config.params.team_slug
                        (String.replace
                            "{org}"
                            config.params.org
                            "https://api.github.com/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"
                        )
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (Url.Builder.string "direction")
                        config.params.direction
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Creates a new comment on a team discussion. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).

This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.

**Note:** You can also specify a team by `org_id` and `team_id` using the route `POST /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments`.
-}
teamsCreateDiscussionCommentInOrg config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeTeamDiscussionComment
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "body", Json.Encode.string rec.body ) ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{discussion_number}"
                config.params.discussion_number
                (String.replace
                    "{team_slug}"
                    config.params.team_slug
                    (String.replace
                        "{org}"
                        config.params.org
                        "https://api.github.com/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"
                    )
                )
        }


{-| Get a specific comment on a team discussion. OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).

**Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments/{comment_number}`.
-}
teamsGetDiscussionCommentInOrg config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeTeamDiscussionComment
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{comment_number}"
                config.params.comment_number
                (String.replace
                    "{discussion_number}"
                    config.params.discussion_number
                    (String.replace
                        "{team_slug}"
                        config.params.team_slug
                        (String.replace
                            "{org}"
                            config.params.org
                            "https://api.github.com/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
                        )
                    )
                )
        }


{-| Edits the body text of a discussion comment. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).

**Note:** You can also specify a team by `org_id` and `team_id` using the route `PATCH /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments/{comment_number}`.
-}
teamsUpdateDiscussionCommentInOrg config =
    Http.request
        { method = "PATCH"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeTeamDiscussionComment
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "body", Json.Encode.string rec.body ) ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{comment_number}"
                config.params.comment_number
                (String.replace
                    "{discussion_number}"
                    config.params.discussion_number
                    (String.replace
                        "{team_slug}"
                        config.params.team_slug
                        (String.replace
                            "{org}"
                            config.params.org
                            "https://api.github.com/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
                        )
                    )
                )
        }


{-| Deletes a comment on a team discussion. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).

**Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments/{comment_number}`.
-}
teamsDeleteDiscussionCommentInOrg config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{comment_number}"
                config.params.comment_number
                (String.replace
                    "{discussion_number}"
                    config.params.discussion_number
                    (String.replace
                        "{team_slug}"
                        config.params.team_slug
                        (String.replace
                            "{org}"
                            config.params.org
                            "https://api.github.com/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
                        )
                    )
                )
        }


{-| List the reactions to a [team discussion comment](https://docs.github.com/rest/reference/teams#discussion-comments/). OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).

**Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/:org_id/team/:team_id/discussions/:discussion_number/comments/:comment_number/reactions`.
-}
reactionsListForTeamDiscussionCommentInOrg config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeReaction)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{comment_number}"
                    config.params.comment_number
                    (String.replace
                        "{discussion_number}"
                        config.params.discussion_number
                        (String.replace
                            "{team_slug}"
                            config.params.team_slug
                            (String.replace
                                "{org}"
                                config.params.org
                                "https://api.github.com/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"
                            )
                        )
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (Url.Builder.string "content")
                        config.params.content
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Create a reaction to a [team discussion comment](https://docs.github.com/rest/reference/teams#discussion-comments). OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). A response with an HTTP `200` status means that you already added the reaction type to this team discussion comment.

**Note:** You can also specify a team by `org_id` and `team_id` using the route `POST /organizations/:org_id/team/:team_id/discussions/:discussion_number/comments/:comment_number/reactions`.
-}
reactionsCreateForTeamDiscussionCommentInOrg config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeReaction
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "content", Json.Encode.string rec.content ) ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{comment_number}"
                config.params.comment_number
                (String.replace
                    "{discussion_number}"
                    config.params.discussion_number
                    (String.replace
                        "{team_slug}"
                        config.params.team_slug
                        (String.replace
                            "{org}"
                            config.params.org
                            "https://api.github.com/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"
                        )
                    )
                )
        }


{-| **Note:** You can also specify a team or organization with `team_id` and `org_id` using the route `DELETE /organizations/:org_id/team/:team_id/discussions/:discussion_number/comments/:comment_number/reactions/:reaction_id`.

Delete a reaction to a [team discussion comment](https://docs.github.com/rest/reference/teams#discussion-comments). OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
-}
reactionsDeleteForTeamDiscussionComment config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{reaction_id}"
                config.params.reaction_id
                (String.replace
                    "{comment_number}"
                    config.params.comment_number
                    (String.replace
                        "{discussion_number}"
                        config.params.discussion_number
                        (String.replace
                            "{team_slug}"
                            config.params.team_slug
                            (String.replace
                                "{org}"
                                config.params.org
                                "https://api.github.com/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}"
                            )
                        )
                    )
                )
        }


{-| List the reactions to a [team discussion](https://docs.github.com/rest/reference/teams#discussions). OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).

**Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/:org_id/team/:team_id/discussions/:discussion_number/reactions`.
-}
reactionsListForTeamDiscussionInOrg config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeReaction)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{discussion_number}"
                    config.params.discussion_number
                    (String.replace
                        "{team_slug}"
                        config.params.team_slug
                        (String.replace
                            "{org}"
                            config.params.org
                            "https://api.github.com/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"
                        )
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (Url.Builder.string "content")
                        config.params.content
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Create a reaction to a [team discussion](https://docs.github.com/rest/reference/teams#discussions). OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). A response with an HTTP `200` status means that you already added the reaction type to this team discussion.

**Note:** You can also specify a team by `org_id` and `team_id` using the route `POST /organizations/:org_id/team/:team_id/discussions/:discussion_number/reactions`.
-}
reactionsCreateForTeamDiscussionInOrg config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeReaction
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "content", Json.Encode.string rec.content ) ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{discussion_number}"
                config.params.discussion_number
                (String.replace
                    "{team_slug}"
                    config.params.team_slug
                    (String.replace
                        "{org}"
                        config.params.org
                        "https://api.github.com/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"
                    )
                )
        }


{-| **Note:** You can also specify a team or organization with `team_id` and `org_id` using the route `DELETE /organizations/:org_id/team/:team_id/discussions/:discussion_number/reactions/:reaction_id`.

Delete a reaction to a [team discussion](https://docs.github.com/rest/reference/teams#discussions). OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
-}
reactionsDeleteForTeamDiscussion config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{reaction_id}"
                config.params.reaction_id
                (String.replace
                    "{discussion_number}"
                    config.params.discussion_number
                    (String.replace
                        "{team_slug}"
                        config.params.team_slug
                        (String.replace
                            "{org}"
                            config.params.org
                            "https://api.github.com/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}"
                        )
                    )
                )
        }


{-| The return hash contains a `role` field which refers to the Organization Invitation role and will be one of the following values: `direct_member`, `admin`, `billing_manager`, `hiring_manager`, or `reinstate`. If the invitee is not a GitHub member, the `login` field in the return hash will be `null`.

**Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/invitations`.
-}
teamsListPendingInvitationsInOrg :
    { toMsg : Result Http.Error (List OrganizationInvitation) -> msg
    , params :
        { org : String
        , team_slug : String
        , per_page : Maybe Int
        , page : Maybe Int
        }
    }
    -> Cmd msg
teamsListPendingInvitationsInOrg config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeOrganizationInvitation)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{team_slug}"
                    config.params.team_slug
                    (String.replace
                        "{org}"
                        config.params.org
                        "https://api.github.com/orgs/{org}/teams/{team_slug}/invitations"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Team members will include the members of child teams.

To list members in a team, the team must be visible to the authenticated user.
-}
teamsListMembersInOrg :
    { toMsg : Result Http.Error (List SimpleUser) -> msg
    , params :
        { org : String
        , team_slug : String
        , role : Maybe String
        , per_page : Maybe Int
        , page : Maybe Int
        }
    }
    -> Cmd msg
teamsListMembersInOrg config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeSimpleUser)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{team_slug}"
                    config.params.team_slug
                    (String.replace
                        "{org}"
                        config.params.org
                        "https://api.github.com/orgs/{org}/teams/{team_slug}/members"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map (Url.Builder.string "role") config.params.role
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Team members will include the members of child teams.

To get a user's membership with a team, the team must be visible to the authenticated user.

**Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/memberships/{username}`.

**Note:**
The response contains the `state` of the membership and the member's `role`.

The `role` for organization owners is set to `maintainer`. For more information about `maintainer` roles, see see [Create a team](https://docs.github.com/rest/reference/teams#create-a-team).
-}
teamsGetMembershipForUserInOrg :
    { toMsg : Result Http.Error TeamMembership -> msg
    , params : { org : String, team_slug : String, username : String }
    }
    -> Cmd msg
teamsGetMembershipForUserInOrg config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeTeamMembership
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{username}"
                config.params.username
                (String.replace
                    "{team_slug}"
                    config.params.team_slug
                    (String.replace
                        "{org}"
                        config.params.org
                        "https://api.github.com/orgs/{org}/teams/{team_slug}/memberships/{username}"
                    )
                )
        }


{-| Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Adds an organization member to a team. An authenticated organization owner or team maintainer can add organization members to a team.

**Note:** When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see an error if you attempt to use the API for making changes to the team's membership. If you have access to manage group membership in your IdP, you can manage GitHub team membership through your identity provider, which automatically adds and removes team members in an organization. For more information, see "[Synchronizing teams between your identity provider and GitHub](https://docs.github.com/articles/synchronizing-teams-between-your-identity-provider-and-github/)."

An organization owner can add someone who is not part of the team's organization to a team. When an organization owner adds someone to a team who is not an organization member, this endpoint will send an invitation to the person via email. This newly-created membership will be in the "pending" state until the person accepts the invitation, at which point the membership will transition to the "active" state and the user will be added as a member of the team.

If the user is already a member of the team, this endpoint will update the role of the team member's role. To update the membership of a team member, the authenticated user must be an organization owner or a team maintainer.

**Note:** You can also specify a team by `org_id` and `team_id` using the route `PUT /organizations/{org_id}/team/{team_id}/memberships/{username}`.
-}
teamsAddOrUpdateMembershipForUserInOrg :
    { toMsg : Result Http.Error TeamMembership -> msg
    , body : { role : String }
    , params : { org : String, team_slug : String, username : String }
    }
    -> Cmd msg
teamsAddOrUpdateMembershipForUserInOrg config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeTeamMembership
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "role", Json.Encode.string rec.role ) ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{username}"
                config.params.username
                (String.replace
                    "{team_slug}"
                    config.params.team_slug
                    (String.replace
                        "{org}"
                        config.params.org
                        "https://api.github.com/orgs/{org}/teams/{team_slug}/memberships/{username}"
                    )
                )
        }


{-| Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

To remove a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with. Removing team membership does not delete the user, it just removes their membership from the team.

**Note:** When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see an error if you attempt to use the API for making changes to the team's membership. If you have access to manage group membership in your IdP, you can manage GitHub team membership through your identity provider, which automatically adds and removes team members in an organization. For more information, see "[Synchronizing teams between your identity provider and GitHub](https://docs.github.com/articles/synchronizing-teams-between-your-identity-provider-and-github/)."

**Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE /organizations/{org_id}/team/{team_id}/memberships/{username}`.
-}
teamsRemoveMembershipForUserInOrg :
    { toMsg : Result Http.Error () -> msg
    , params : { org : String, team_slug : String, username : String }
    }
    -> Cmd msg
teamsRemoveMembershipForUserInOrg config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{username}"
                config.params.username
                (String.replace
                    "{team_slug}"
                    config.params.team_slug
                    (String.replace
                        "{org}"
                        config.params.org
                        "https://api.github.com/orgs/{org}/teams/{team_slug}/memberships/{username}"
                    )
                )
        }


{-| Lists the organization projects for a team.

**Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/projects`.
-}
teamsListProjectsInOrg :
    { toMsg : Result Http.Error (List TeamProject) -> msg
    , params :
        { org : String
        , team_slug : String
        , per_page : Maybe Int
        , page : Maybe Int
        }
    }
    -> Cmd msg
teamsListProjectsInOrg config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeTeamProject)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{team_slug}"
                    config.params.team_slug
                    (String.replace
                        "{org}"
                        config.params.org
                        "https://api.github.com/orgs/{org}/teams/{team_slug}/projects"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Checks whether a team has `read`, `write`, or `admin` permissions for an organization project. The response includes projects inherited from a parent team.

**Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/projects/{project_id}`.
-}
teamsCheckPermissionsForProjectInOrg config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeTeamProject
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{project_id}"
                config.params.project_id
                (String.replace
                    "{team_slug}"
                    config.params.team_slug
                    (String.replace
                        "{org}"
                        config.params.org
                        "https://api.github.com/orgs/{org}/teams/{team_slug}/projects/{project_id}"
                    )
                )
        }


{-| Adds an organization project to a team. To add a project to a team or update the team's permission on a project, the authenticated user must have `admin` permissions for the project. The project and team must be part of the same organization.

**Note:** You can also specify a team by `org_id` and `team_id` using the route `PUT /organizations/{org_id}/team/{team_id}/projects/{project_id}`.
-}
teamsAddOrUpdateProjectPermissionsInOrg config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body =
            Http.jsonBody
                ((\nullableValue ->
                     case nullableValue of
                         Null ->
                             Json.Encode.null

                         Present value ->
                             (\rec ->
                                 Json.Encode.object
                                     [ ( "permission"
                                       , Json.Encode.string rec.permission
                                       )
                                     ]
                             )
                                 value
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{project_id}"
                config.params.project_id
                (String.replace
                    "{team_slug}"
                    config.params.team_slug
                    (String.replace
                        "{org}"
                        config.params.org
                        "https://api.github.com/orgs/{org}/teams/{team_slug}/projects/{project_id}"
                    )
                )
        }


{-| Removes an organization project from a team. An organization owner or a team maintainer can remove any project from the team. To remove a project from a team as an organization member, the authenticated user must have `read` access to both the team and project, or `admin` access to the team or project. This endpoint removes the project from the team, but does not delete the project.

**Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE /organizations/{org_id}/team/{team_id}/projects/{project_id}`.
-}
teamsRemoveProjectInOrg config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{project_id}"
                config.params.project_id
                (String.replace
                    "{team_slug}"
                    config.params.team_slug
                    (String.replace
                        "{org}"
                        config.params.org
                        "https://api.github.com/orgs/{org}/teams/{team_slug}/projects/{project_id}"
                    )
                )
        }


{-| Lists a team's repositories visible to the authenticated user.

**Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/repos`.
-}
teamsListReposInOrg :
    { toMsg : Result Http.Error (List MinimalRepository) -> msg
    , params :
        { org : String
        , team_slug : String
        , per_page : Maybe Int
        , page : Maybe Int
        }
    }
    -> Cmd msg
teamsListReposInOrg config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeMinimalRepository)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{team_slug}"
                    config.params.team_slug
                    (String.replace
                        "{org}"
                        config.params.org
                        "https://api.github.com/orgs/{org}/teams/{team_slug}/repos"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Checks whether a team has `admin`, `push`, `maintain`, `triage`, or `pull` permission for a repository. Repositories inherited through a parent team will also be checked.

You can also get information about the specified repository, including what permissions the team grants on it, by passing the following custom [media type](https://docs.github.com/rest/overview/media-types/) via the `application/vnd.github.v3.repository+json` accept header.

If a team doesn't have permission for the repository, you will receive a `404 Not Found` response status.

**Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/repos/{owner}/{repo}`.
-}
teamsCheckPermissionsForRepoInOrg :
    { toMsg : Result Http.Error TeamRepository -> msg
    , params :
        { org : String, team_slug : String, owner : String, repo : String }
    }
    -> Cmd msg
teamsCheckPermissionsForRepoInOrg config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeTeamRepository
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    (String.replace
                        "{team_slug}"
                        config.params.team_slug
                        (String.replace
                            "{org}"
                            config.params.org
                            "https://api.github.com/orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
                        )
                    )
                )
        }


{-| To add a repository to a team or update the team's permission on a repository, the authenticated user must have admin access to the repository, and must be able to see the team. The repository must be owned by the organization, or a direct fork of a repository owned by the organization. You will get a `422 Unprocessable Entity` status if you attempt to add a repository to a team that is not owned by the organization. Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs)."

**Note:** You can also specify a team by `org_id` and `team_id` using the route `PUT /organizations/{org_id}/team/{team_id}/repos/{owner}/{repo}`.

For more information about the permission levels, see "[Repository permission levels for an organization](https://docs.github.com/en/github/setting-up-and-managing-organizations-and-teams/repository-permission-levels-for-an-organization#permission-levels-for-repositories-owned-by-an-organization)".
-}
teamsAddOrUpdateRepoPermissionsInOrg :
    { toMsg : Result Http.Error () -> msg
    , body : { permission : String }
    , params :
        { org : String, team_slug : String, owner : String, repo : String }
    }
    -> Cmd msg
teamsAddOrUpdateRepoPermissionsInOrg config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "permission", Json.Encode.string rec.permission ) ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    (String.replace
                        "{team_slug}"
                        config.params.team_slug
                        (String.replace
                            "{org}"
                            config.params.org
                            "https://api.github.com/orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
                        )
                    )
                )
        }


{-| If the authenticated user is an organization owner or a team maintainer, they can remove any repositories from the team. To remove a repository from a team as an organization member, the authenticated user must have admin access to the repository and must be able to see the team. This does not delete the repository, it just removes it from the team.

**Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE /organizations/{org_id}/team/{team_id}/repos/{owner}/{repo}`.
-}
teamsRemoveRepoInOrg :
    { toMsg : Result Http.Error () -> msg
    , params :
        { org : String, team_slug : String, owner : String, repo : String }
    }
    -> Cmd msg
teamsRemoveRepoInOrg config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    (String.replace
                        "{team_slug}"
                        config.params.team_slug
                        (String.replace
                            "{org}"
                            config.params.org
                            "https://api.github.com/orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
                        )
                    )
                )
        }


{-| Lists the child teams of the team specified by `{team_slug}`.

**Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/teams`.
-}
teamsListChildInOrg :
    { toMsg : Result Http.Error (List Team) -> msg
    , params :
        { org : String
        , team_slug : String
        , per_page : Maybe Int
        , page : Maybe Int
        }
    }
    -> Cmd msg
teamsListChildInOrg config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.list decodeTeam)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{team_slug}"
                    config.params.team_slug
                    (String.replace
                        "{org}"
                        config.params.org
                        "https://api.github.com/orgs/{org}/teams/{team_slug}/teams"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Enables or disables the specified security feature for all repositories in an organization.

To use this endpoint, you must be an organization owner or be member of a team with the security manager role.
A token with the 'write:org' scope is also required.

GitHub Apps must have the `organization_administration:write` permission to use this endpoint.

For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."
-}
orgsEnableOrDisableSecurityProductOnAllOrgRepos :
    { toMsg : Result Http.Error () -> msg
    , params : { org : String, security_product : String, enablement : String }
    }
    -> Cmd msg
orgsEnableOrDisableSecurityProductOnAllOrgRepos config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{enablement}"
                config.params.enablement
                (String.replace
                    "{security_product}"
                    config.params.security_product
                    (String.replace
                        "{org}"
                        config.params.org
                        "https://api.github.com/orgs/{org}/{security_product}/{enablement}"
                    )
                )
        }


projectsGetCard config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeProjectCard
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{card_id}"
                config.params.card_id
                "https://api.github.com/projects/columns/cards/{card_id}"
        }


projectsUpdateCard config =
    Http.request
        { method = "PATCH"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeProjectCard
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "archived", Json.Encode.bool rec.archived )
                         , ( "note"
                           , (\nullableValue ->
                                 case nullableValue of
                                     Null ->
                                         Json.Encode.null

                                     Present value ->
                                         Json.Encode.string value
                             )
                                 rec.note
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{card_id}"
                config.params.card_id
                "https://api.github.com/projects/columns/cards/{card_id}"
        }


projectsDeleteCard config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{card_id}"
                config.params.card_id
                "https://api.github.com/projects/columns/cards/{card_id}"
        }


projectsMoveCard config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.succeed {})
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "column_id", Json.Encode.int rec.column_id )
                         , ( "position", Json.Encode.string rec.position )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{card_id}"
                config.params.card_id
                "https://api.github.com/projects/columns/cards/{card_id}/moves"
        }


projectsGetColumn config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeProjectColumn
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{column_id}"
                config.params.column_id
                "https://api.github.com/projects/columns/{column_id}"
        }


projectsUpdateColumn config =
    Http.request
        { method = "PATCH"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeProjectColumn
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "name", Json.Encode.string rec.name ) ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{column_id}"
                config.params.column_id
                "https://api.github.com/projects/columns/{column_id}"
        }


projectsDeleteColumn config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{column_id}"
                config.params.column_id
                "https://api.github.com/projects/columns/{column_id}"
        }


projectsListCards config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeProjectCard)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{column_id}"
                    config.params.column_id
                    "https://api.github.com/projects/columns/{column_id}/cards"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (Url.Builder.string "archived_state")
                        config.params.archived_state
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


projectsCreateCard config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeProjectCard
        , body = Http.jsonBody (Basics.identity config.body)
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{column_id}"
                config.params.column_id
                "https://api.github.com/projects/columns/{column_id}/cards"
        }


projectsMoveColumn config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.succeed {})
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "position", Json.Encode.string rec.position ) ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{column_id}"
                config.params.column_id
                "https://api.github.com/projects/columns/{column_id}/moves"
        }


{-| Gets a project by its `id`. Returns a `404 Not Found` status if projects are disabled. If you do not have sufficient privileges to perform this action, a `401 Unauthorized` or `410 Gone` status is returned. -}
projectsGet config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeProject
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{project_id}"
                config.params.project_id
                "https://api.github.com/projects/{project_id}"
        }


{-| Updates a project board's information. Returns a `404 Not Found` status if projects are disabled. If you do not have sufficient privileges to perform this action, a `401 Unauthorized` or `410 Gone` status is returned. -}
projectsUpdate config =
    Http.request
        { method = "PATCH"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeProject
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "body"
                           , (\nullableValue ->
                                 case nullableValue of
                                     Null ->
                                         Json.Encode.null

                                     Present value ->
                                         Json.Encode.string value
                             )
                                 rec.body
                           )
                         , ( "name", Json.Encode.string rec.name )
                         , ( "organization_permission"
                           , Json.Encode.string rec.organization_permission
                           )
                         , ( "private", Json.Encode.bool rec.private )
                         , ( "state", Json.Encode.string rec.state )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{project_id}"
                config.params.project_id
                "https://api.github.com/projects/{project_id}"
        }


{-| Deletes a project board. Returns a `404 Not Found` status if projects are disabled. -}
projectsDelete config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{project_id}"
                config.params.project_id
                "https://api.github.com/projects/{project_id}"
        }


{-| Lists the collaborators for an organization project. For a project, the list of collaborators includes outside collaborators, organization members that are direct collaborators, organization members with access through team memberships, organization members with access through default organization permissions, and organization owners. You must be an organization owner or a project `admin` to list collaborators. -}
projectsListCollaborators config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeSimpleUser)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{project_id}"
                    config.params.project_id
                    "https://api.github.com/projects/{project_id}/collaborators"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (Url.Builder.string "affiliation")
                        config.params.affiliation
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Adds a collaborator to an organization project and sets their permission level. You must be an organization owner or a project `admin` to add a collaborator. -}
projectsAddCollaborator config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body =
            Http.jsonBody
                ((\nullableValue ->
                     case nullableValue of
                         Null ->
                             Json.Encode.null

                         Present value ->
                             (\rec ->
                                 Json.Encode.object
                                     [ ( "permission"
                                       , Json.Encode.string rec.permission
                                       )
                                     ]
                             )
                                 value
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{username}"
                config.params.username
                (String.replace
                    "{project_id}"
                    config.params.project_id
                    "https://api.github.com/projects/{project_id}/collaborators/{username}"
                )
        }


{-| Removes a collaborator from an organization project. You must be an organization owner or a project `admin` to remove a collaborator. -}
projectsRemoveCollaborator config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{username}"
                config.params.username
                (String.replace
                    "{project_id}"
                    config.params.project_id
                    "https://api.github.com/projects/{project_id}/collaborators/{username}"
                )
        }


{-| Returns the collaborator's permission level for an organization project. Possible values for the `permission` key: `admin`, `write`, `read`, `none`. You must be an organization owner or a project `admin` to review a user's permission level. -}
projectsGetPermissionForUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg decodeProjectCollaboratorPermission
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{username}"
                config.params.username
                (String.replace
                    "{project_id}"
                    config.params.project_id
                    "https://api.github.com/projects/{project_id}/collaborators/{username}/permission"
                )
        }


projectsListColumns config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeProjectColumn)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{project_id}"
                    config.params.project_id
                    "https://api.github.com/projects/{project_id}/columns"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


projectsCreateColumn config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeProjectColumn
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "name", Json.Encode.string rec.name ) ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{project_id}"
                config.params.project_id
                "https://api.github.com/projects/{project_id}/columns"
        }


{-| **Note:** Accessing this endpoint does not count against your REST API rate limit.

**Note:** The `rate` object is deprecated. If you're writing new API client code or updating existing code, you should use the `core` object instead of the `rate` object. The `core` object contains the same information that is present in the `rate` object.
-}
rateLimitGet : { toMsg : Result Http.Error RateLimitOverview -> msg } -> Cmd msg
rateLimitGet config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeRateLimitOverview
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url = "https://api.github.com/rate_limit"
        }


{-| The `parent` and `source` objects are present when the repository is a fork. `parent` is the repository this repository was forked from, `source` is the ultimate source for the network. -}
reposGet :
    { toMsg : Result Http.Error FullRepository -> msg
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
reposGet config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeFullRepository
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}"
                )
        }


{-| **Note**: To edit a repository's topics, use the [Replace all repository topics](https://docs.github.com/rest/reference/repos#replace-all-repository-topics) endpoint. -}
reposUpdate :
    { toMsg : Result Http.Error FullRepository -> msg
    , body :
        { allow_auto_merge : Bool
        , allow_forking : Bool
        , allow_merge_commit : Bool
        , allow_rebase_merge : Bool
        , allow_squash_merge : Bool
        , allow_update_branch : Bool
        , archived : Bool
        , default_branch : String
        , delete_branch_on_merge : Bool
        , description : String
        , has_issues : Bool
        , has_projects : Bool
        , has_wiki : Bool
        , homepage : String
        , is_template : Bool
        , merge_commit_message : String
        , merge_commit_title : String
        , name : String
        , private : Bool
        , security_and_analysis :
            Nullable { advanced_security : { status : String }
            , secret_scanning : { status : String }
            , secret_scanning_push_protection : { status : String }
            }
        , squash_merge_commit_message : String
        , squash_merge_commit_title : String
        , use_squash_pr_title_as_default : Bool
        , visibility : String
        , web_commit_signoff_required : Bool
        }
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
reposUpdate config =
    Http.request
        { method = "PATCH"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeFullRepository
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "allow_auto_merge"
                           , Json.Encode.bool rec.allow_auto_merge
                           )
                         , ( "allow_forking"
                           , Json.Encode.bool rec.allow_forking
                           )
                         , ( "allow_merge_commit"
                           , Json.Encode.bool rec.allow_merge_commit
                           )
                         , ( "allow_rebase_merge"
                           , Json.Encode.bool rec.allow_rebase_merge
                           )
                         , ( "allow_squash_merge"
                           , Json.Encode.bool rec.allow_squash_merge
                           )
                         , ( "allow_update_branch"
                           , Json.Encode.bool rec.allow_update_branch
                           )
                         , ( "archived", Json.Encode.bool rec.archived )
                         , ( "default_branch"
                           , Json.Encode.string rec.default_branch
                           )
                         , ( "delete_branch_on_merge"
                           , Json.Encode.bool rec.delete_branch_on_merge
                           )
                         , ( "description", Json.Encode.string rec.description )
                         , ( "has_issues", Json.Encode.bool rec.has_issues )
                         , ( "has_projects", Json.Encode.bool rec.has_projects )
                         , ( "has_wiki", Json.Encode.bool rec.has_wiki )
                         , ( "homepage", Json.Encode.string rec.homepage )
                         , ( "is_template", Json.Encode.bool rec.is_template )
                         , ( "merge_commit_message"
                           , Json.Encode.string rec.merge_commit_message
                           )
                         , ( "merge_commit_title"
                           , Json.Encode.string rec.merge_commit_title
                           )
                         , ( "name", Json.Encode.string rec.name )
                         , ( "private", Json.Encode.bool rec.private )
                         , ( "security_and_analysis"
                           , (\nullableValue ->
                                 case nullableValue of
                                     Null ->
                                         Json.Encode.null

                                     Present value ->
                                         (\rec0 ->
                                             Json.Encode.object
                                                 [ ( "advanced_security"
                                                   , (\rec_0_1_1_1_0_0_1_0_0_20_1_0_0_1_3_1_0_0 ->
                                                         Json.Encode.object
                                                             [ ( "status"
                                                               , Json.Encode.string
                                                                     rec_0_1_1_1_0_0_1_0_0_20_1_0_0_1_3_1_0_0.status
                                                               )
                                                             ]
                                                     )
                                                         rec0.advanced_security
                                                   )
                                                 , ( "secret_scanning"
                                                   , (\rec_0_2_1_1_0_0_1_0_0_20_1_0_0_1_3_1_0_0 ->
                                                         Json.Encode.object
                                                             [ ( "status"
                                                               , Json.Encode.string
                                                                     rec_0_2_1_1_0_0_1_0_0_20_1_0_0_1_3_1_0_0.status
                                                               )
                                                             ]
                                                     )
                                                         rec0.secret_scanning
                                                   )
                                                 , ( "secret_scanning_push_protection"
                                                   , (\rec_0_3_1_1_0_0_1_0_0_20_1_0_0_1_3_1_0_0 ->
                                                         Json.Encode.object
                                                             [ ( "status"
                                                               , Json.Encode.string
                                                                     rec_0_3_1_1_0_0_1_0_0_20_1_0_0_1_3_1_0_0.status
                                                               )
                                                             ]
                                                     )
                                                         rec0.secret_scanning_push_protection
                                                   )
                                                 ]
                                         )
                                             value
                             )
                                 rec.security_and_analysis
                           )
                         , ( "squash_merge_commit_message"
                           , Json.Encode.string rec.squash_merge_commit_message
                           )
                         , ( "squash_merge_commit_title"
                           , Json.Encode.string rec.squash_merge_commit_title
                           )
                         , ( "use_squash_pr_title_as_default"
                           , Json.Encode.bool rec.use_squash_pr_title_as_default
                           )
                         , ( "visibility", Json.Encode.string rec.visibility )
                         , ( "web_commit_signoff_required"
                           , Json.Encode.bool rec.web_commit_signoff_required
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}"
                )
        }


{-| Deleting a repository requires admin access. If OAuth is used, the `delete_repo` scope is required.

If an organization owner has configured the organization to prevent members from deleting organization-owned
repositories, you will get a `403 Forbidden` response.
-}
reposDelete :
    { toMsg : Result Http.Error () -> msg
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
reposDelete config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}"
                )
        }


{-| Lists all artifacts for a repository. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint. -}
actionsListArtifactsForRepo config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\artifacts total_count ->
                      { artifacts = artifacts, total_count = total_count }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "artifacts"
                            (Json.Decode.list decodeArtifact)
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.int)
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/actions/artifacts"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Gets a specific artifact for a workflow run. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint. -}
actionsGetArtifact config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeArtifact
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{artifact_id}"
                config.params.artifact_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/actions/artifacts/{artifact_id}"
                    )
                )
        }


{-| Deletes an artifact for a workflow run. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this endpoint. -}
actionsDeleteArtifact config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{artifact_id}"
                config.params.artifact_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/actions/artifacts/{artifact_id}"
                    )
                )
        }


{-| Gets GitHub Actions cache usage for a repository.
The data fetched using this API is refreshed approximately every 5 minutes, so values returned from this endpoint may take at least 5 minutes to get updated.
Anyone with read access to the repository can use this endpoint. If the repository is private, you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
-}
actionsGetActionsCacheUsage :
    { toMsg : Result Http.Error ActionsCacheUsageByRepository -> msg
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
actionsGetActionsCacheUsage config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg decodeActionsCacheUsageByRepository
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/actions/cache/usage"
                )
        }


{-| Lists the GitHub Actions caches for a repository.
You must authenticate using an access token with the `repo` scope to use this endpoint.
GitHub Apps must have the `actions:read` permission to use this endpoint.
-}
actionsGetActionsCacheList :
    { toMsg : Result Http.Error ActionsCacheList -> msg
    , params :
        { owner : String
        , repo : String
        , per_page : Maybe Int
        , page : Maybe Int
        , ref : Maybe CodeScanningRef
        , key : Maybe String
        , sort : Maybe String
        , direction : Maybe String
        }
    }
    -> Cmd msg
actionsGetActionsCacheList config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeActionsCacheList
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/actions/caches"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "ref"
                                (Debug.todo
                                    "Params of type \"CodeScanningRef\" (in helper)"
                                )
                        )
                        config.params.ref
                    , Maybe.map (Url.Builder.string "key") config.params.key
                    , Maybe.map (Url.Builder.string "sort") config.params.sort
                    , Maybe.map
                        (Url.Builder.string "direction")
                        config.params.direction
                    ]
                )
        }


{-| Deletes one or more GitHub Actions caches for a repository, using a complete cache key. By default, all caches that match the provided key are deleted, but you can optionally provide a Git ref to restrict deletions to caches that match both the provided key and the Git ref.

You must authenticate using an access token with the `repo` scope to use this endpoint.

GitHub Apps must have the `actions:write` permission to use this endpoint.
-}
actionsDeleteActionsCacheByKey config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeActionsCacheList
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/actions/caches"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Just (Url.Builder.string "key" config.params.key)
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "ref"
                                (Debug.todo
                                    "Params of type \"CodeScanningRef\" (in helper)"
                                )
                        )
                        config.params.ref
                    ]
                )
        }


{-| Deletes a GitHub Actions cache for a repository, using a cache ID.

You must authenticate using an access token with the `repo` scope to use this endpoint.

GitHub Apps must have the `actions:write` permission to use this endpoint.
-}
actionsDeleteActionsCacheById config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{cache_id}"
                config.params.cache_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/actions/caches/{cache_id}"
                    )
                )
        }


{-| Gets a specific job in a workflow run. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint. -}
actionsGetJobForWorkflowRun config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeJob
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{job_id}"
                config.params.job_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/actions/jobs/{job_id}"
                    )
                )
        }


{-| Re-run a job and its dependent jobs in a workflow run. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this endpoint. -}
actionsReRunJobForWorkflowRun config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeEmptyObject
        , body =
            Http.jsonBody
                ((\nullableValue ->
                     case nullableValue of
                         Null ->
                             Json.Encode.null

                         Present value ->
                             (\rec ->
                                 Json.Encode.object
                                     [ ( "enable_debug_logging"
                                       , Json.Encode.bool
                                             rec.enable_debug_logging
                                       )
                                     ]
                             )
                                 value
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{job_id}"
                config.params.job_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/actions/jobs/{job_id}/rerun"
                    )
                )
        }


{-| Gets the GitHub Actions permissions policy for a repository, including whether GitHub Actions is enabled and the actions and reusable workflows allowed to run in the repository.

You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `administration` repository permission to use this API.
-}
actionsGetGithubActionsPermissionsRepository :
    { toMsg : Result Http.Error ActionsRepositoryPermissions -> msg
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
actionsGetGithubActionsPermissionsRepository config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg decodeActionsRepositoryPermissions
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/actions/permissions"
                )
        }


{-| Sets the GitHub Actions permissions policy for enabling GitHub Actions and allowed actions and reusable workflows in the repository.

If the repository belongs to an organization or enterprise that has set restrictive permissions at the organization or enterprise levels, such as `allowed_actions` to `selected` actions and reusable workflows, then you cannot override them for the repository.

You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `administration` repository permission to use this API.
-}
actionsSetGithubActionsPermissionsRepository :
    { toMsg : Result Http.Error () -> msg
    , body : { allowed_actions : AllowedActions, enabled : ActionsEnabled }
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
actionsSetGithubActionsPermissionsRepository config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "allowed_actions"
                           , encodeAllowedActions rec.allowed_actions
                           )
                         , ( "enabled", encodeActionsEnabled rec.enabled )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/actions/permissions"
                )
        }


{-| Gets the level of access that workflows outside of the repository have to actions and reusable workflows in the repository.
This endpoint only applies to internal repositories. For more information, see "[Managing GitHub Actions settings for a repository](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#allowing-access-to-components-in-an-internal-repository)."

You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the
repository `administration` permission to use this endpoint.
-}
actionsGetWorkflowAccessToRepository :
    { toMsg : Result Http.Error ActionsWorkflowAccessToRepository -> msg
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
actionsGetWorkflowAccessToRepository config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg decodeActionsWorkflowAccessToRepository
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/actions/permissions/access"
                )
        }


{-| Sets the level of access that workflows outside of the repository have to actions and reusable workflows in the repository.
This endpoint only applies to internal repositories. For more information, see "[Managing GitHub Actions settings for a repository](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#allowing-access-to-components-in-an-internal-repository)."

You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the
repository `administration` permission to use this endpoint.
-}
actionsSetWorkflowAccessToRepository :
    { toMsg : Result Http.Error () -> msg
    , body : ActionsWorkflowAccessToRepository
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
actionsSetWorkflowAccessToRepository config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body =
            Http.jsonBody (encodeActionsWorkflowAccessToRepository config.body)
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/actions/permissions/access"
                )
        }


{-| Gets the settings for selected actions and reusable workflows that are allowed in a repository. To use this endpoint, the repository policy for `allowed_actions` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for a repository](#set-github-actions-permissions-for-a-repository)."

You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `administration` repository permission to use this API.
-}
actionsGetAllowedActionsRepository :
    { toMsg : Result Http.Error SelectedActions -> msg
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
actionsGetAllowedActionsRepository config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeSelectedActions
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/actions/permissions/selected-actions"
                )
        }


{-| Sets the actions and reusable workflows that are allowed in a repository. To use this endpoint, the repository permission policy for `allowed_actions` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for a repository](#set-github-actions-permissions-for-a-repository)."

If the repository belongs to an organization or enterprise that has `selected` actions and reusable workflows set at the organization or enterprise levels, then you cannot override any of the allowed actions and reusable workflows settings.

To use the `patterns_allowed` setting for private repositories, the repository must belong to an enterprise. If the repository does not belong to an enterprise, then the `patterns_allowed` setting only applies to public repositories.

You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `administration` repository permission to use this API.
-}
actionsSetAllowedActionsRepository :
    { toMsg : Result Http.Error () -> msg
    , body : SelectedActions
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
actionsSetAllowedActionsRepository config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.jsonBody (encodeSelectedActions config.body)
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/actions/permissions/selected-actions"
                )
        }


{-| Gets the default workflow permissions granted to the `GITHUB_TOKEN` when running workflows in a repository,
as well as if GitHub Actions can submit approving pull request reviews.
For more information, see "[Setting the permissions of the GITHUB_TOKEN for your repository](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#setting-the-permissions-of-the-github_token-for-your-repository)."

You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the repository `administration` permission to use this API.
-}
actionsGetGithubActionsDefaultWorkflowPermissionsRepository :
    { toMsg : Result Http.Error ActionsGetDefaultWorkflowPermissions -> msg
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
actionsGetGithubActionsDefaultWorkflowPermissionsRepository config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                decodeActionsGetDefaultWorkflowPermissions
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/actions/permissions/workflow"
                )
        }


{-| Sets the default workflow permissions granted to the `GITHUB_TOKEN` when running workflows in a repository, and sets if GitHub Actions
can submit approving pull request reviews.
For more information, see "[Setting the permissions of the GITHUB_TOKEN for your repository](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#setting-the-permissions-of-the-github_token-for-your-repository)."

You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the repository `administration` permission to use this API.
-}
actionsSetGithubActionsDefaultWorkflowPermissionsRepository :
    { toMsg : Result Http.Error () -> msg
    , body : ActionsSetDefaultWorkflowPermissions
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
actionsSetGithubActionsDefaultWorkflowPermissionsRepository config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body =
            Http.jsonBody
                (encodeActionsSetDefaultWorkflowPermissions config.body)
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/actions/permissions/workflow"
                )
        }


{-| Lists all self-hosted runners configured in a repository. You must authenticate using an access token with the `repo` scope to use this endpoint. -}
actionsListSelfHostedRunnersForRepo config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\runners total_count ->
                      { runners = runners, total_count = total_count }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "runners"
                            (Json.Decode.list decodeRunner)
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.int)
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/actions/runners"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Lists binaries for the runner application that you can download and run.

You must authenticate using an access token with the `repo` scope to use this endpoint.
-}
actionsListRunnerApplicationsForRepo :
    { toMsg : Result Http.Error (List RunnerApplication) -> msg
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
actionsListRunnerApplicationsForRepo config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeRunnerApplication)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/actions/runners/downloads"
                )
        }


{-| Returns a token that you can pass to the `config` script. The token expires after one hour. You must authenticate
using an access token with the `repo` scope to use this endpoint.

#### Example using registration token
 
Configure your self-hosted runner, replacing `TOKEN` with the registration token provided by this endpoint.

```
./config.sh --url https://github.com/octo-org/octo-repo-artifacts --token TOKEN
```
-}
actionsCreateRegistrationTokenForRepo :
    { toMsg : Result Http.Error AuthenticationToken -> msg
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
actionsCreateRegistrationTokenForRepo config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeAuthenticationToken
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/actions/runners/registration-token"
                )
        }


{-| Returns a token that you can pass to remove a self-hosted runner from a repository. The token expires after one hour.
You must authenticate using an access token with the `repo` scope to use this endpoint.

#### Example using remove token
 
To remove your self-hosted runner from a repository, replace TOKEN with the remove token provided by this endpoint.

```
./config.sh remove --token TOKEN
```
-}
actionsCreateRemoveTokenForRepo :
    { toMsg : Result Http.Error AuthenticationToken -> msg
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
actionsCreateRemoveTokenForRepo config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeAuthenticationToken
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/actions/runners/remove-token"
                )
        }


{-| Gets a specific self-hosted runner configured in a repository.

You must authenticate using an access token with the `repo` scope to use this
endpoint.
-}
actionsGetSelfHostedRunnerForRepo config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeRunner
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{runner_id}"
                config.params.runner_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/actions/runners/{runner_id}"
                    )
                )
        }


{-| Forces the removal of a self-hosted runner from a repository. You can use this endpoint to completely remove the runner when the machine you were using no longer exists.

You must authenticate using an access token with the `repo`
scope to use this endpoint.
-}
actionsDeleteSelfHostedRunnerFromRepo config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{runner_id}"
                config.params.runner_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/actions/runners/{runner_id}"
                    )
                )
        }


{-| Lists all labels for a self-hosted runner configured in a repository.

You must authenticate using an access token with the `repo` scope to use this
endpoint.
-}
actionsListLabelsForSelfHostedRunnerForRepo config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeActionsRunnerLabels
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{runner_id}"
                config.params.runner_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
                    )
                )
        }


{-| Add custom labels to a self-hosted runner configured in a repository.

You must authenticate using an access token with the `repo` scope to use this
endpoint.
-}
actionsAddCustomLabelsToSelfHostedRunnerForRepo config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeActionsRunnerLabels
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "labels"
                           , Json.Encode.list Json.Encode.string rec.labels
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{runner_id}"
                config.params.runner_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
                    )
                )
        }


{-| Remove all previous custom labels and set the new custom labels for a specific
self-hosted runner configured in a repository.

You must authenticate using an access token with the `repo` scope to use this
endpoint.
-}
actionsSetCustomLabelsForSelfHostedRunnerForRepo config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeActionsRunnerLabels
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "labels"
                           , Json.Encode.list Json.Encode.string rec.labels
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{runner_id}"
                config.params.runner_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
                    )
                )
        }


{-| Remove all custom labels from a self-hosted runner configured in a
repository. Returns the remaining read-only labels from the runner.

You must authenticate using an access token with the `repo` scope to use this
endpoint.
-}
actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect =
            Http.expectJson config.toMsg decodeActionsRunnerLabelsReadonly
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{runner_id}"
                config.params.runner_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
                    )
                )
        }


{-| Remove a custom label from a self-hosted runner configured
in a repository. Returns the remaining labels from the runner.

This endpoint returns a `404 Not Found` status if the custom label is not
present on the runner.

You must authenticate using an access token with the `repo` scope to use this
endpoint.
-}
actionsRemoveCustomLabelFromSelfHostedRunnerForRepo config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeActionsRunnerLabels
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{name}"
                config.params.name
                (String.replace
                    "{runner_id}"
                    config.params.runner_id
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/actions/runners/{runner_id}/labels/{name}"
                        )
                    )
                )
        }


{-| Lists all workflow runs for a repository. You can use parameters to narrow the list of results. For more information about using parameters, see [Parameters](https://docs.github.com/rest/overview/resources-in-the-rest-api#parameters).

Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
-}
actionsListWorkflowRunsForRepo config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\total_count workflow_runs ->
                      { total_count = total_count
                      , workflow_runs = workflow_runs
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.int)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "workflow_runs"
                            (Json.Decode.list decodeWorkflowRun)
                        )
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/actions/runs"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map (Url.Builder.string "actor") config.params.actor
                    , Maybe.map
                        (Url.Builder.string "branch")
                        config.params.branch
                    , Maybe.map (Url.Builder.string "event") config.params.event
                    , Maybe.map
                        (Url.Builder.string "status")
                        config.params.status
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    , Maybe.map
                        (Url.Builder.string "created")
                        config.params.created
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "exclude_pull_requests"
                                (if mapUnpack then
                                    "true"

                                 else
                                    "false"
                                )
                        )
                        config.params.exclude_pull_requests
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "check_suite_id"
                                (String.fromInt mapUnpack)
                        )
                        config.params.check_suite_id
                    , Maybe.map
                        (Url.Builder.string "head_sha")
                        config.params.head_sha
                    ]
                )
        }


{-| Gets a specific workflow run. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint. -}
actionsGetWorkflowRun config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeWorkflowRun
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{run_id}"
                    config.params.run_id
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/actions/runs/{run_id}"
                        )
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "exclude_pull_requests"
                                (if mapUnpack then
                                    "true"

                                 else
                                    "false"
                                )
                        )
                        config.params.exclude_pull_requests
                    ]
                )
        }


{-| Delete a specific workflow run. Anyone with write access to the repository can use this endpoint. If the repository is
private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:write` permission to use
this endpoint.
-}
actionsDeleteWorkflowRun config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{run_id}"
                config.params.run_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/actions/runs/{run_id}"
                    )
                )
        }


{-| Anyone with read access to the repository can use this endpoint. If the repository is private, you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint. -}
actionsGetReviewsForRun config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeEnvironmentApprovals)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{run_id}"
                config.params.run_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/actions/runs/{run_id}/approvals"
                    )
                )
        }


{-| Approves a workflow run for a pull request from a public fork of a first time contributor. For more information, see ["Approving workflow runs from public forks](https://docs.github.com/actions/managing-workflow-runs/approving-workflow-runs-from-public-forks)."

You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this endpoint.
-}
actionsApproveWorkflowRun config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeEmptyObject
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{run_id}"
                config.params.run_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/actions/runs/{run_id}/approve"
                    )
                )
        }


{-| Lists artifacts for a workflow run. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint. -}
actionsListWorkflowRunArtifacts config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\artifacts total_count ->
                      { artifacts = artifacts, total_count = total_count }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "artifacts"
                            (Json.Decode.list decodeArtifact)
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.int)
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{run_id}"
                    config.params.run_id
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/actions/runs/{run_id}/artifacts"
                        )
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Gets a specific workflow run attempt. Anyone with read access to the repository
can use this endpoint. If the repository is private you must use an access token
with the `repo` scope. GitHub Apps must have the `actions:read` permission to
use this endpoint.
-}
actionsGetWorkflowRunAttempt config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeWorkflowRun
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{attempt_number}"
                    config.params.attempt_number
                    (String.replace
                        "{run_id}"
                        config.params.run_id
                        (String.replace
                            "{repo}"
                            config.params.repo
                            (String.replace
                                "{owner}"
                                config.params.owner
                                "https://api.github.com/repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}"
                            )
                        )
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "exclude_pull_requests"
                                (if mapUnpack then
                                    "true"

                                 else
                                    "false"
                                )
                        )
                        config.params.exclude_pull_requests
                    ]
                )
        }


{-| Lists jobs for a specific workflow run attempt. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint. You can use parameters to narrow the list of results. For more information about using parameters, see [Parameters](https://docs.github.com/rest/overview/resources-in-the-rest-api#parameters). -}
actionsListJobsForWorkflowRunAttempt config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\jobs total_count ->
                      { jobs = jobs, total_count = total_count }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "jobs" (Json.Decode.list decodeJob))
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.int)
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{attempt_number}"
                    config.params.attempt_number
                    (String.replace
                        "{run_id}"
                        config.params.run_id
                        (String.replace
                            "{repo}"
                            config.params.repo
                            (String.replace
                                "{owner}"
                                config.params.owner
                                "https://api.github.com/repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs"
                            )
                        )
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Cancels a workflow run using its `id`. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this endpoint. -}
actionsCancelWorkflowRun config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeEmptyObject
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{run_id}"
                config.params.run_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/actions/runs/{run_id}/cancel"
                    )
                )
        }


{-| Lists jobs for a workflow run. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint. You can use parameters to narrow the list of results. For more information about using parameters, see [Parameters](https://docs.github.com/rest/overview/resources-in-the-rest-api#parameters). -}
actionsListJobsForWorkflowRun config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\jobs total_count ->
                      { jobs = jobs, total_count = total_count }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "jobs" (Json.Decode.list decodeJob))
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.int)
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{run_id}"
                    config.params.run_id
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/actions/runs/{run_id}/jobs"
                        )
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (Url.Builder.string "filter")
                        config.params.filter
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Deletes all logs for a workflow run. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this endpoint. -}
actionsDeleteWorkflowRunLogs config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{run_id}"
                config.params.run_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/actions/runs/{run_id}/logs"
                    )
                )
        }


{-| Get all deployment environments for a workflow run that are waiting for protection rules to pass.

Anyone with read access to the repository can use this endpoint. If the repository is private, you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
-}
actionsGetPendingDeploymentsForRun config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodePendingDeployment)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{run_id}"
                config.params.run_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"
                    )
                )
        }


{-| Approve or reject pending deployments that are waiting on approval by a required reviewer.

Required reviewers with read access to the repository contents and deployments can use this endpoint. Required reviewers must authenticate using an access token with the `repo` scope to use this endpoint.
-}
actionsReviewPendingDeploymentsForRun config =
    Http.request
        { method = "POST"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeDeployment)
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "comment", Json.Encode.string rec.comment )
                         , ( "environment_ids"
                           , Json.Encode.list Json.Encode.int
                                 rec.environment_ids
                           )
                         , ( "state", Json.Encode.string rec.state )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{run_id}"
                config.params.run_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"
                    )
                )
        }


{-| Re-runs your workflow run using its `id`. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this endpoint. -}
actionsReRunWorkflow config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeEmptyObject
        , body =
            Http.jsonBody
                ((\nullableValue ->
                     case nullableValue of
                         Null ->
                             Json.Encode.null

                         Present value ->
                             (\rec ->
                                 Json.Encode.object
                                     [ ( "enable_debug_logging"
                                       , Json.Encode.bool
                                             rec.enable_debug_logging
                                       )
                                     ]
                             )
                                 value
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{run_id}"
                config.params.run_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/actions/runs/{run_id}/rerun"
                    )
                )
        }


{-| Re-run all of the failed jobs and their dependent jobs in a workflow run using the `id` of the workflow run. You must authenticate using an access token with the `repo` scope to use this endpoint. -}
actionsReRunWorkflowFailedJobs config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeEmptyObject
        , body =
            Http.jsonBody
                ((\nullableValue ->
                     case nullableValue of
                         Null ->
                             Json.Encode.null

                         Present value ->
                             (\rec ->
                                 Json.Encode.object
                                     [ ( "enable_debug_logging"
                                       , Json.Encode.bool
                                             rec.enable_debug_logging
                                       )
                                     ]
                             )
                                 value
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{run_id}"
                config.params.run_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/actions/runs/{run_id}/rerun-failed-jobs"
                    )
                )
        }


{-| Gets the number of billable minutes and total run time for a specific workflow run. Billable minutes only apply to workflows in private repositories that use GitHub-hosted runners. Usage is listed for each GitHub-hosted runner operating system in milliseconds. Any job re-runs are also included in the usage. The usage does not include the multiplier for macOS and Windows runners and is not rounded up to the nearest whole minute. For more information, see "[Managing billing for GitHub Actions](https://docs.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)".

Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
-}
actionsGetWorkflowRunUsage config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeWorkflowRunUsage
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{run_id}"
                config.params.run_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/actions/runs/{run_id}/timing"
                    )
                )
        }


{-| Lists all secrets available in a repository without revealing their encrypted values. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository permission to use this endpoint. -}
actionsListRepoSecrets config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\secrets total_count ->
                      { secrets = secrets, total_count = total_count }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "secrets"
                            (Json.Decode.list decodeActionsSecret)
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.int)
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/actions/secrets"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before you can create or update secrets. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `secrets` repository permission to use this endpoint. -}
actionsGetRepoPublicKey :
    { toMsg : Result Http.Error ActionsPublicKey -> msg
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
actionsGetRepoPublicKey config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeActionsPublicKey
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/actions/secrets/public-key"
                )
        }


{-| Gets a single repository secret without revealing its encrypted value. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository permission to use this endpoint. -}
actionsGetRepoSecret :
    { toMsg : Result Http.Error ActionsSecret -> msg
    , params : { owner : String, repo : String, secret_name : String }
    }
    -> Cmd msg
actionsGetRepoSecret config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeActionsSecret
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{secret_name}"
                config.params.secret_name
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/actions/secrets/{secret_name}"
                    )
                )
        }


{-| Creates or updates a repository secret with an encrypted value. Encrypt your secret using
[LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must authenticate using an access
token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository permission to use
this endpoint.

#### Example encrypting a secret using Node.js

Encrypt your secret using the [tweetsodium](https://github.com/github/tweetsodium) library.

```
const sodium = require('tweetsodium');

const key = "base64-encoded-public-key";
const value = "plain-text-secret";

// Convert the message and key to Uint8Array's (Buffer implements that interface)
const messageBytes = Buffer.from(value);
const keyBytes = Buffer.from(key, 'base64');

// Encrypt using LibSodium.
const encryptedBytes = sodium.seal(messageBytes, keyBytes);

// Base64 the encrypted secret
const encrypted = Buffer.from(encryptedBytes).toString('base64');

console.log(encrypted);
```


#### Example encrypting a secret using Python

Encrypt your secret using [pynacl](https://pynacl.readthedocs.io/en/latest/public/#nacl-public-sealedbox) with Python 3.

```
from base64 import b64encode
from nacl import encoding, public

def encrypt(public_key: str, secret_value: str) -> str:
  """Encrypt a Unicode string using the public key."""
  public_key = public.PublicKey(public_key.encode("utf-8"), encoding.Base64Encoder())
  sealed_box = public.SealedBox(public_key)
  encrypted = sealed_box.encrypt(secret_value.encode("utf-8"))
  return b64encode(encrypted).decode("utf-8")
```

#### Example encrypting a secret using C#

Encrypt your secret using the [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package.

```
var secretValue = System.Text.Encoding.UTF8.GetBytes("mySecret");
var publicKey = Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=");

var sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);

Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));
```

#### Example encrypting a secret using Ruby

Encrypt your secret using the [rbnacl](https://github.com/RubyCrypto/rbnacl) gem.

```ruby
require "rbnacl"
require "base64"

key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=")
public_key = RbNaCl::PublicKey.new(key)

box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
encrypted_secret = box.encrypt("my_secret")

# Print the base64 encoded secret
puts Base64.strict_encode64(encrypted_secret)
```
-}
actionsCreateOrUpdateRepoSecret :
    { toMsg : Result Http.Error EmptyObject -> msg
    , body : { encrypted_value : String, key_id : String }
    , params : { owner : String, repo : String, secret_name : String }
    }
    -> Cmd msg
actionsCreateOrUpdateRepoSecret config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeEmptyObject
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "encrypted_value"
                           , Json.Encode.string rec.encrypted_value
                           )
                         , ( "key_id", Json.Encode.string rec.key_id )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{secret_name}"
                config.params.secret_name
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/actions/secrets/{secret_name}"
                    )
                )
        }


{-| Deletes a secret in a repository using the secret name. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository permission to use this endpoint. -}
actionsDeleteRepoSecret :
    { toMsg : Result Http.Error () -> msg
    , params : { owner : String, repo : String, secret_name : String }
    }
    -> Cmd msg
actionsDeleteRepoSecret config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{secret_name}"
                config.params.secret_name
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/actions/secrets/{secret_name}"
                    )
                )
        }


{-| Lists the workflows in a repository. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint. -}
actionsListRepoWorkflows config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\total_count workflows ->
                      { total_count = total_count, workflows = workflows }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.int)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "workflows"
                            (Json.Decode.list decodeWorkflow)
                        )
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/actions/workflows"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Gets a specific workflow. You can replace `workflow_id` with the workflow file name. For example, you could use `main.yaml`. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint. -}
actionsGetWorkflow config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeWorkflow
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{workflow_id}"
                config.params.workflow_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/actions/workflows/{workflow_id}"
                    )
                )
        }


{-| Disables a workflow and sets the `state` of the workflow to `disabled_manually`. You can replace `workflow_id` with the workflow file name. For example, you could use `main.yaml`.

You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this endpoint.
-}
actionsDisableWorkflow config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{workflow_id}"
                config.params.workflow_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable"
                    )
                )
        }


{-| You can use this endpoint to manually trigger a GitHub Actions workflow run. You can replace `workflow_id` with the workflow file name. For example, you could use `main.yaml`.

You must configure your GitHub Actions workflow to run when the [`workflow_dispatch` webhook](/developers/webhooks-and-events/webhook-events-and-payloads#workflow_dispatch) event occurs. The `inputs` are configured in the workflow file. For more information about how to configure the `workflow_dispatch` event in the workflow file, see "[Events that trigger workflows](/actions/reference/events-that-trigger-workflows#workflow_dispatch)."

You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this endpoint. For more information, see "[Creating a personal access token for the command line](https://docs.github.com/articles/creating-a-personal-access-token-for-the-command-line)."
-}
actionsCreateWorkflowDispatch config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "inputs"
                           , (\rec0 -> Json.Encode.object []) rec.inputs
                           )
                         , ( "ref", Json.Encode.string rec.ref )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{workflow_id}"
                config.params.workflow_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches"
                    )
                )
        }


{-| Enables a workflow and sets the `state` of the workflow to `active`. You can replace `workflow_id` with the workflow file name. For example, you could use `main.yaml`.

You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this endpoint.
-}
actionsEnableWorkflow config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{workflow_id}"
                config.params.workflow_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable"
                    )
                )
        }


{-| List all workflow runs for a workflow. You can replace `workflow_id` with the workflow file name. For example, you could use `main.yaml`. You can use parameters to narrow the list of results. For more information about using parameters, see [Parameters](https://docs.github.com/rest/overview/resources-in-the-rest-api#parameters).

Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope.
-}
actionsListWorkflowRuns config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\total_count workflow_runs ->
                      { total_count = total_count
                      , workflow_runs = workflow_runs
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.int)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "workflow_runs"
                            (Json.Decode.list decodeWorkflowRun)
                        )
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{workflow_id}"
                    config.params.workflow_id
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs"
                        )
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map (Url.Builder.string "actor") config.params.actor
                    , Maybe.map
                        (Url.Builder.string "branch")
                        config.params.branch
                    , Maybe.map (Url.Builder.string "event") config.params.event
                    , Maybe.map
                        (Url.Builder.string "status")
                        config.params.status
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    , Maybe.map
                        (Url.Builder.string "created")
                        config.params.created
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "exclude_pull_requests"
                                (if mapUnpack then
                                    "true"

                                 else
                                    "false"
                                )
                        )
                        config.params.exclude_pull_requests
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "check_suite_id"
                                (String.fromInt mapUnpack)
                        )
                        config.params.check_suite_id
                    , Maybe.map
                        (Url.Builder.string "head_sha")
                        config.params.head_sha
                    ]
                )
        }


{-| Gets the number of billable minutes used by a specific workflow during the current billing cycle. Billable minutes only apply to workflows in private repositories that use GitHub-hosted runners. Usage is listed for each GitHub-hosted runner operating system in milliseconds. Any job re-runs are also included in the usage. The usage does not include the multiplier for macOS and Windows runners and is not rounded up to the nearest whole minute. For more information, see "[Managing billing for GitHub Actions](https://docs.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)".

You can replace `workflow_id` with the workflow file name. For example, you could use `main.yaml`. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
-}
actionsGetWorkflowUsage config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeWorkflowUsage
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{workflow_id}"
                config.params.workflow_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing"
                    )
                )
        }


{-| Lists the [available assignees](https://docs.github.com/articles/assigning-issues-and-pull-requests-to-other-github-users/) for issues in a repository. -}
issuesListAssignees :
    { toMsg : Result Http.Error (List SimpleUser) -> msg
    , params :
        { owner : String
        , repo : String
        , per_page : Maybe Int
        , page : Maybe Int
        }
    }
    -> Cmd msg
issuesListAssignees config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeSimpleUser)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/assignees"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Checks if a user has permission to be assigned to an issue in this repository.

If the `assignee` can be assigned to issues in the repository, a `204` header with no content is returned.

Otherwise a `404` status code is returned.
-}
issuesCheckUserCanBeAssigned :
    { toMsg : Result Http.Error () -> msg
    , params : { owner : String, repo : String, assignee : String }
    }
    -> Cmd msg
issuesCheckUserCanBeAssigned config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{assignee}"
                config.params.assignee
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/assignees/{assignee}"
                    )
                )
        }


{-| This returns a list of autolinks configured for the given repository.

Information about autolinks are only available to repository administrators.
-}
reposListAutolinks :
    { toMsg : Result Http.Error (List Autolink) -> msg
    , params : { owner : String, repo : String, page : Maybe Int }
    }
    -> Cmd msg
reposListAutolinks config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeAutolink)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/autolinks"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Users with admin access to the repository can create an autolink. -}
reposCreateAutolink :
    { toMsg : Result Http.Error Autolink -> msg
    , body :
        { is_alphanumeric : Bool, key_prefix : String, url_template : String }
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
reposCreateAutolink config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeAutolink
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "is_alphanumeric"
                           , Json.Encode.bool rec.is_alphanumeric
                           )
                         , ( "key_prefix", Json.Encode.string rec.key_prefix )
                         , ( "url_template"
                           , Json.Encode.string rec.url_template
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/autolinks"
                )
        }


{-| This returns a single autolink reference by ID that was configured for the given repository.

Information about autolinks are only available to repository administrators.
-}
reposGetAutolink config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeAutolink
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{autolink_id}"
                config.params.autolink_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/autolinks/{autolink_id}"
                    )
                )
        }


{-| This deletes a single autolink reference by ID that was configured for the given repository.

Information about autolinks are only available to repository administrators.
-}
reposDeleteAutolink config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{autolink_id}"
                config.params.autolink_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/autolinks/{autolink_id}"
                    )
                )
        }


{-| Enables automated security fixes for a repository. The authenticated user must have admin access to the repository. For more information, see "[Configuring automated security fixes](https://docs.github.com/en/articles/configuring-automated-security-fixes)". -}
reposEnableAutomatedSecurityFixes :
    { toMsg : Result Http.Error () -> msg
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
reposEnableAutomatedSecurityFixes config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/automated-security-fixes"
                )
        }


{-| Disables automated security fixes for a repository. The authenticated user must have admin access to the repository. For more information, see "[Configuring automated security fixes](https://docs.github.com/en/articles/configuring-automated-security-fixes)". -}
reposDisableAutomatedSecurityFixes :
    { toMsg : Result Http.Error () -> msg
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
reposDisableAutomatedSecurityFixes config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/automated-security-fixes"
                )
        }


reposListBranches :
    { toMsg : Result Http.Error (List ShortBranch) -> msg
    , params :
        { owner : String
        , repo : String
        , protected : Maybe Bool
        , per_page : Maybe Int
        , page : Maybe Int
        }
    }
    -> Cmd msg
reposListBranches config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeShortBranch)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/branches"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "protected"
                                (if mapUnpack then
                                    "true"

                                 else
                                    "false"
                                )
                        )
                        config.params.protected
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


reposGetBranch :
    { toMsg : Result Http.Error BranchWithProtection -> msg
    , params : { owner : String, repo : String, branch : String }
    }
    -> Cmd msg
reposGetBranch config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeBranchWithProtection
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{branch}"
                config.params.branch
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/branches/{branch}"
                    )
                )
        }


{-| Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation. -}
reposGetBranchProtection :
    { toMsg : Result Http.Error BranchProtection -> msg
    , params : { owner : String, repo : String, branch : String }
    }
    -> Cmd msg
reposGetBranchProtection config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeBranchProtection
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{branch}"
                config.params.branch
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/branches/{branch}/protection"
                    )
                )
        }


{-| Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Protecting a branch requires admin or owner permissions to the repository.

**Note**: Passing new arrays of `users` and `teams` replaces their previous values.

**Note**: The list of users, apps, and teams in total is limited to 100 items.
-}
reposUpdateBranchProtection config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeProtectedBranch
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "allow_deletions"
                           , Json.Encode.bool rec.allow_deletions
                           )
                         , ( "allow_force_pushes"
                           , (\nullableValue ->
                                 case nullableValue of
                                     Null ->
                                         Json.Encode.null

                                     Present value ->
                                         Json.Encode.bool value
                             )
                                 rec.allow_force_pushes
                           )
                         , ( "block_creations"
                           , Json.Encode.bool rec.block_creations
                           )
                         , ( "enforce_admins"
                           , (\nullableValue ->
                                 case nullableValue of
                                     Null ->
                                         Json.Encode.null

                                     Present value ->
                                         Json.Encode.bool value
                             )
                                 rec.enforce_admins
                           )
                         , ( "required_conversation_resolution"
                           , Json.Encode.bool
                                 rec.required_conversation_resolution
                           )
                         , ( "required_linear_history"
                           , Json.Encode.bool rec.required_linear_history
                           )
                         , ( "required_pull_request_reviews"
                           , (\nullableValue ->
                                 case nullableValue of
                                     Null ->
                                         Json.Encode.null

                                     Present value ->
                                         (\rec0 ->
                                             Json.Encode.object
                                                 [ ( "bypass_pull_request_allowances"
                                                   , (\rec_0_1_1_1_0_0_1_0_0_7_1_0_0_1_3_1_0_0 ->
                                                         Json.Encode.object
                                                             [ ( "apps"
                                                               , Json.Encode.list
                                                                     Json.Encode.string
                                                                     rec_0_1_1_1_0_0_1_0_0_7_1_0_0_1_3_1_0_0.apps
                                                               )
                                                             , ( "teams"
                                                               , Json.Encode.list
                                                                     Json.Encode.string
                                                                     rec_0_1_1_1_0_0_1_0_0_7_1_0_0_1_3_1_0_0.teams
                                                               )
                                                             , ( "users"
                                                               , Json.Encode.list
                                                                     Json.Encode.string
                                                                     rec_0_1_1_1_0_0_1_0_0_7_1_0_0_1_3_1_0_0.users
                                                               )
                                                             ]
                                                     )
                                                         rec0.bypass_pull_request_allowances
                                                   )
                                                 , ( "dismiss_stale_reviews"
                                                   , Json.Encode.bool
                                                         rec0.dismiss_stale_reviews
                                                   )
                                                 , ( "dismissal_restrictions"
                                                   , (\rec_0_3_1_1_0_0_1_0_0_7_1_0_0_1_3_1_0_0 ->
                                                         Json.Encode.object
                                                             [ ( "apps"
                                                               , Json.Encode.list
                                                                     Json.Encode.string
                                                                     rec_0_3_1_1_0_0_1_0_0_7_1_0_0_1_3_1_0_0.apps
                                                               )
                                                             , ( "teams"
                                                               , Json.Encode.list
                                                                     Json.Encode.string
                                                                     rec_0_3_1_1_0_0_1_0_0_7_1_0_0_1_3_1_0_0.teams
                                                               )
                                                             , ( "users"
                                                               , Json.Encode.list
                                                                     Json.Encode.string
                                                                     rec_0_3_1_1_0_0_1_0_0_7_1_0_0_1_3_1_0_0.users
                                                               )
                                                             ]
                                                     )
                                                         rec0.dismissal_restrictions
                                                   )
                                                 , ( "require_code_owner_reviews"
                                                   , Json.Encode.bool
                                                         rec0.require_code_owner_reviews
                                                   )
                                                 , ( "required_approving_review_count"
                                                   , Json.Encode.int
                                                         rec0.required_approving_review_count
                                                   )
                                                 ]
                                         )
                                             value
                             )
                                 rec.required_pull_request_reviews
                           )
                         , ( "required_status_checks"
                           , (\nullableValue ->
                                 case nullableValue of
                                     Null ->
                                         Json.Encode.null

                                     Present value ->
                                         (\rec0 ->
                                             Json.Encode.object
                                                 [ ( "checks"
                                                   , Json.Encode.list
                                                         (\rec_1_0_1_1_1_0_0_1_0_0_8_1_0_0_1_3_1_0_0 ->
                                                             Json.Encode.object
                                                                 [ ( "app_id"
                                                                   , Json.Encode.int
                                                                         rec_1_0_1_1_1_0_0_1_0_0_8_1_0_0_1_3_1_0_0.app_id
                                                                   )
                                                                 , ( "context"
                                                                   , Json.Encode.string
                                                                         rec_1_0_1_1_1_0_0_1_0_0_8_1_0_0_1_3_1_0_0.context
                                                                   )
                                                                 ]
                                                         )
                                                         rec0.checks
                                                   )
                                                 , ( "contexts"
                                                   , Json.Encode.list
                                                         Json.Encode.string
                                                         rec0.contexts
                                                   )
                                                 , ( "strict"
                                                   , Json.Encode.bool
                                                         rec0.strict
                                                   )
                                                 ]
                                         )
                                             value
                             )
                                 rec.required_status_checks
                           )
                         , ( "restrictions"
                           , (\nullableValue ->
                                 case nullableValue of
                                     Null ->
                                         Json.Encode.null

                                     Present value ->
                                         (\rec0 ->
                                             Json.Encode.object
                                                 [ ( "apps"
                                                   , Json.Encode.list
                                                         Json.Encode.string
                                                         rec0.apps
                                                   )
                                                 , ( "teams"
                                                   , Json.Encode.list
                                                         Json.Encode.string
                                                         rec0.teams
                                                   )
                                                 , ( "users"
                                                   , Json.Encode.list
                                                         Json.Encode.string
                                                         rec0.users
                                                   )
                                                 ]
                                         )
                                             value
                             )
                                 rec.restrictions
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{branch}"
                config.params.branch
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/branches/{branch}/protection"
                    )
                )
        }


{-| Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation. -}
reposDeleteBranchProtection :
    { toMsg : Result Http.Error () -> msg
    , params : { owner : String, repo : String, branch : String }
    }
    -> Cmd msg
reposDeleteBranchProtection config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{branch}"
                config.params.branch
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/branches/{branch}/protection"
                    )
                )
        }


{-| Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation. -}
reposGetAdminBranchProtection :
    { toMsg : Result Http.Error ProtectedBranchAdminEnforced -> msg
    , params : { owner : String, repo : String, branch : String }
    }
    -> Cmd msg
reposGetAdminBranchProtection config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg decodeProtectedBranchAdminEnforced
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{branch}"
                config.params.branch
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
                    )
                )
        }


{-| Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Adding admin enforcement requires admin or owner permissions to the repository and branch protection to be enabled.
-}
reposSetAdminBranchProtection :
    { toMsg : Result Http.Error ProtectedBranchAdminEnforced -> msg
    , params : { owner : String, repo : String, branch : String }
    }
    -> Cmd msg
reposSetAdminBranchProtection config =
    Http.request
        { method = "POST"
        , headers = []
        , expect =
            Http.expectJson config.toMsg decodeProtectedBranchAdminEnforced
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{branch}"
                config.params.branch
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
                    )
                )
        }


{-| Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Removing admin enforcement requires admin or owner permissions to the repository and branch protection to be enabled.
-}
reposDeleteAdminBranchProtection :
    { toMsg : Result Http.Error () -> msg
    , params : { owner : String, repo : String, branch : String }
    }
    -> Cmd msg
reposDeleteAdminBranchProtection config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{branch}"
                config.params.branch
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
                    )
                )
        }


{-| Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation. -}
reposGetPullRequestReviewProtection :
    { toMsg : Result Http.Error ProtectedBranchPullRequestReview -> msg
    , params : { owner : String, repo : String, branch : String }
    }
    -> Cmd msg
reposGetPullRequestReviewProtection config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg decodeProtectedBranchPullRequestReview
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{branch}"
                config.params.branch
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
                    )
                )
        }


{-| Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Updating pull request review enforcement requires admin or owner permissions to the repository and branch protection to be enabled.

**Note**: Passing new arrays of `users` and `teams` replaces their previous values.
-}
reposUpdatePullRequestReviewProtection :
    { toMsg : Result Http.Error ProtectedBranchPullRequestReview -> msg
    , body :
        { bypass_pull_request_allowances :
            { apps : List String, teams : List String, users : List String }
        , dismiss_stale_reviews : Bool
        , dismissal_restrictions :
            { apps : List String, teams : List String, users : List String }
        , require_code_owner_reviews : Bool
        , required_approving_review_count : Int
        }
    , params : { owner : String, repo : String, branch : String }
    }
    -> Cmd msg
reposUpdatePullRequestReviewProtection config =
    Http.request
        { method = "PATCH"
        , headers = []
        , expect =
            Http.expectJson config.toMsg decodeProtectedBranchPullRequestReview
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "bypass_pull_request_allowances"
                           , (\rec0 ->
                                 Json.Encode.object
                                     [ ( "apps"
                                       , Json.Encode.list Json.Encode.string
                                             rec0.apps
                                       )
                                     , ( "teams"
                                       , Json.Encode.list Json.Encode.string
                                             rec0.teams
                                       )
                                     , ( "users"
                                       , Json.Encode.list Json.Encode.string
                                             rec0.users
                                       )
                                     ]
                             )
                                 rec.bypass_pull_request_allowances
                           )
                         , ( "dismiss_stale_reviews"
                           , Json.Encode.bool rec.dismiss_stale_reviews
                           )
                         , ( "dismissal_restrictions"
                           , (\rec0 ->
                                 Json.Encode.object
                                     [ ( "apps"
                                       , Json.Encode.list Json.Encode.string
                                             rec0.apps
                                       )
                                     , ( "teams"
                                       , Json.Encode.list Json.Encode.string
                                             rec0.teams
                                       )
                                     , ( "users"
                                       , Json.Encode.list Json.Encode.string
                                             rec0.users
                                       )
                                     ]
                             )
                                 rec.dismissal_restrictions
                           )
                         , ( "require_code_owner_reviews"
                           , Json.Encode.bool rec.require_code_owner_reviews
                           )
                         , ( "required_approving_review_count"
                           , Json.Encode.int rec.required_approving_review_count
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{branch}"
                config.params.branch
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
                    )
                )
        }


{-| Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation. -}
reposDeletePullRequestReviewProtection :
    { toMsg : Result Http.Error () -> msg
    , params : { owner : String, repo : String, branch : String }
    }
    -> Cmd msg
reposDeletePullRequestReviewProtection config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{branch}"
                config.params.branch
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
                    )
                )
        }


{-| Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

When authenticated with admin or owner permissions to the repository, you can use this endpoint to check whether a branch requires signed commits. An enabled status of `true` indicates you must sign commits on this branch. For more information, see [Signing commits with GPG](https://docs.github.com/articles/signing-commits-with-gpg) in GitHub Help.

**Note**: You must enable branch protection to require signed commits.
-}
reposGetCommitSignatureProtection :
    { toMsg : Result Http.Error ProtectedBranchAdminEnforced -> msg
    , params : { owner : String, repo : String, branch : String }
    }
    -> Cmd msg
reposGetCommitSignatureProtection config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg decodeProtectedBranchAdminEnforced
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{branch}"
                config.params.branch
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
                    )
                )
        }


{-| Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

When authenticated with admin or owner permissions to the repository, you can use this endpoint to require signed commits on a branch. You must enable branch protection to require signed commits.
-}
reposCreateCommitSignatureProtection :
    { toMsg : Result Http.Error ProtectedBranchAdminEnforced -> msg
    , params : { owner : String, repo : String, branch : String }
    }
    -> Cmd msg
reposCreateCommitSignatureProtection config =
    Http.request
        { method = "POST"
        , headers = []
        , expect =
            Http.expectJson config.toMsg decodeProtectedBranchAdminEnforced
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{branch}"
                config.params.branch
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
                    )
                )
        }


{-| Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

When authenticated with admin or owner permissions to the repository, you can use this endpoint to disable required signed commits on a branch. You must enable branch protection to require signed commits.
-}
reposDeleteCommitSignatureProtection :
    { toMsg : Result Http.Error () -> msg
    , params : { owner : String, repo : String, branch : String }
    }
    -> Cmd msg
reposDeleteCommitSignatureProtection config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{branch}"
                config.params.branch
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
                    )
                )
        }


{-| Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation. -}
reposGetStatusChecksProtection :
    { toMsg : Result Http.Error StatusCheckPolicy -> msg
    , params : { owner : String, repo : String, branch : String }
    }
    -> Cmd msg
reposGetStatusChecksProtection config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeStatusCheckPolicy
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{branch}"
                config.params.branch
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
                    )
                )
        }


{-| Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Updating required status checks requires admin or owner permissions to the repository and branch protection to be enabled.
-}
reposUpdateStatusCheckProtection :
    { toMsg : Result Http.Error StatusCheckPolicy -> msg
    , body :
        { checks : List { app_id : Int, context : String }
        , contexts : List String
        , strict : Bool
        }
    , params : { owner : String, repo : String, branch : String }
    }
    -> Cmd msg
reposUpdateStatusCheckProtection config =
    Http.request
        { method = "PATCH"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeStatusCheckPolicy
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "checks"
                           , Json.Encode.list
                                 (\rec0 ->
                                     Json.Encode.object
                                         [ ( "app_id"
                                           , Json.Encode.int rec0.app_id
                                           )
                                         , ( "context"
                                           , Json.Encode.string rec0.context
                                           )
                                         ]
                                 )
                                 rec.checks
                           )
                         , ( "contexts"
                           , Json.Encode.list Json.Encode.string rec.contexts
                           )
                         , ( "strict", Json.Encode.bool rec.strict )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{branch}"
                config.params.branch
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
                    )
                )
        }


{-| Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation. -}
reposRemoveStatusCheckProtection :
    { toMsg : Result Http.Error () -> msg
    , params : { owner : String, repo : String, branch : String }
    }
    -> Cmd msg
reposRemoveStatusCheckProtection config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{branch}"
                config.params.branch
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
                    )
                )
        }


{-| Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation. -}
reposGetAllStatusCheckContexts :
    { toMsg : Result Http.Error (List String) -> msg
    , params : { owner : String, repo : String, branch : String }
    }
    -> Cmd msg
reposGetAllStatusCheckContexts config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list Json.Decode.string)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{branch}"
                config.params.branch
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"
                    )
                )
        }


{-| Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation. -}
reposAddStatusCheckContexts :
    { toMsg : Result Http.Error (List String) -> msg
    , body : Json.Encode.Value
    , params : { owner : String, repo : String, branch : String }
    }
    -> Cmd msg
reposAddStatusCheckContexts config =
    Http.request
        { method = "POST"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list Json.Decode.string)
        , body = Http.jsonBody (Basics.identity config.body)
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{branch}"
                config.params.branch
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"
                    )
                )
        }


{-| Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation. -}
reposSetStatusCheckContexts :
    { toMsg : Result Http.Error (List String) -> msg
    , body : Json.Encode.Value
    , params : { owner : String, repo : String, branch : String }
    }
    -> Cmd msg
reposSetStatusCheckContexts config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list Json.Decode.string)
        , body = Http.jsonBody (Basics.identity config.body)
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{branch}"
                config.params.branch
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"
                    )
                )
        }


{-| Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation. -}
reposRemoveStatusCheckContexts :
    { toMsg : Result Http.Error (List String) -> msg
    , body : Json.Encode.Value
    , params : { owner : String, repo : String, branch : String }
    }
    -> Cmd msg
reposRemoveStatusCheckContexts config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list Json.Decode.string)
        , body = Http.jsonBody (Basics.identity config.body)
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{branch}"
                config.params.branch
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"
                    )
                )
        }


{-| Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Lists who has access to this protected branch.

**Note**: Users, apps, and teams `restrictions` are only available for organization-owned repositories.
-}
reposGetAccessRestrictions :
    { toMsg : Result Http.Error BranchRestrictionPolicy -> msg
    , params : { owner : String, repo : String, branch : String }
    }
    -> Cmd msg
reposGetAccessRestrictions config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeBranchRestrictionPolicy
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{branch}"
                config.params.branch
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/branches/{branch}/protection/restrictions"
                    )
                )
        }


{-| Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Disables the ability to restrict who can push to this branch.
-}
reposDeleteAccessRestrictions :
    { toMsg : Result Http.Error () -> msg
    , params : { owner : String, repo : String, branch : String }
    }
    -> Cmd msg
reposDeleteAccessRestrictions config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{branch}"
                config.params.branch
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/branches/{branch}/protection/restrictions"
                    )
                )
        }


{-| Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Lists the GitHub Apps that have push access to this branch. Only installed GitHub Apps with `write` access to the `contents` permission can be added as authorized actors on a protected branch.
-}
reposGetAppsWithAccessToProtectedBranch :
    { toMsg : Result Http.Error (List Integration) -> msg
    , params : { owner : String, repo : String, branch : String }
    }
    -> Cmd msg
reposGetAppsWithAccessToProtectedBranch config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeIntegration)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{branch}"
                config.params.branch
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"
                    )
                )
        }


{-| Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Grants the specified apps push access for this branch. Only installed GitHub Apps with `write` access to the `contents` permission can be added as authorized actors on a protected branch.

| Type    | Description                                                                                                                                                |
| ------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `array` | The GitHub Apps that have push access to this branch. Use the app's `slug`. **Note**: The list of users, apps, and teams in total is limited to 100 items. |
-}
reposAddAppAccessRestrictions :
    { toMsg : Result Http.Error (List Integration) -> msg
    , body : Json.Encode.Value
    , params : { owner : String, repo : String, branch : String }
    }
    -> Cmd msg
reposAddAppAccessRestrictions config =
    Http.request
        { method = "POST"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeIntegration)
        , body = Http.jsonBody (Basics.identity config.body)
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{branch}"
                config.params.branch
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"
                    )
                )
        }


{-| Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Replaces the list of apps that have push access to this branch. This removes all apps that previously had push access and grants push access to the new list of apps. Only installed GitHub Apps with `write` access to the `contents` permission can be added as authorized actors on a protected branch.

| Type    | Description                                                                                                                                                |
| ------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `array` | The GitHub Apps that have push access to this branch. Use the app's `slug`. **Note**: The list of users, apps, and teams in total is limited to 100 items. |
-}
reposSetAppAccessRestrictions :
    { toMsg : Result Http.Error (List Integration) -> msg
    , body : Json.Encode.Value
    , params : { owner : String, repo : String, branch : String }
    }
    -> Cmd msg
reposSetAppAccessRestrictions config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeIntegration)
        , body = Http.jsonBody (Basics.identity config.body)
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{branch}"
                config.params.branch
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"
                    )
                )
        }


{-| Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Removes the ability of an app to push to this branch. Only installed GitHub Apps with `write` access to the `contents` permission can be added as authorized actors on a protected branch.

| Type    | Description                                                                                                                                                |
| ------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `array` | The GitHub Apps that have push access to this branch. Use the app's `slug`. **Note**: The list of users, apps, and teams in total is limited to 100 items. |
-}
reposRemoveAppAccessRestrictions :
    { toMsg : Result Http.Error (List Integration) -> msg
    , body : Json.Encode.Value
    , params : { owner : String, repo : String, branch : String }
    }
    -> Cmd msg
reposRemoveAppAccessRestrictions config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeIntegration)
        , body = Http.jsonBody (Basics.identity config.body)
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{branch}"
                config.params.branch
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"
                    )
                )
        }


{-| Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Lists the teams who have push access to this branch. The list includes child teams.
-}
reposGetTeamsWithAccessToProtectedBranch :
    { toMsg : Result Http.Error (List Team) -> msg
    , params : { owner : String, repo : String, branch : String }
    }
    -> Cmd msg
reposGetTeamsWithAccessToProtectedBranch config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.list decodeTeam)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{branch}"
                config.params.branch
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"
                    )
                )
        }


{-| Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Grants the specified teams push access for this branch. You can also give push access to child teams.

| Type    | Description                                                                                                                                |
| ------- | ------------------------------------------------------------------------------------------------------------------------------------------ |
| `array` | The teams that can have push access. Use the team's `slug`. **Note**: The list of users, apps, and teams in total is limited to 100 items. |
-}
reposAddTeamAccessRestrictions :
    { toMsg : Result Http.Error (List Team) -> msg
    , body : Json.Encode.Value
    , params : { owner : String, repo : String, branch : String }
    }
    -> Cmd msg
reposAddTeamAccessRestrictions config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.list decodeTeam)
        , body = Http.jsonBody (Basics.identity config.body)
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{branch}"
                config.params.branch
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"
                    )
                )
        }


{-| Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Replaces the list of teams that have push access to this branch. This removes all teams that previously had push access and grants push access to the new list of teams. Team restrictions include child teams.

| Type    | Description                                                                                                                                |
| ------- | ------------------------------------------------------------------------------------------------------------------------------------------ |
| `array` | The teams that can have push access. Use the team's `slug`. **Note**: The list of users, apps, and teams in total is limited to 100 items. |
-}
reposSetTeamAccessRestrictions :
    { toMsg : Result Http.Error (List Team) -> msg
    , body : Json.Encode.Value
    , params : { owner : String, repo : String, branch : String }
    }
    -> Cmd msg
reposSetTeamAccessRestrictions config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.list decodeTeam)
        , body = Http.jsonBody (Basics.identity config.body)
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{branch}"
                config.params.branch
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"
                    )
                )
        }


{-| Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Removes the ability of a team to push to this branch. You can also remove push access for child teams.

| Type    | Description                                                                                                                                         |
| ------- | --------------------------------------------------------------------------------------------------------------------------------------------------- |
| `array` | Teams that should no longer have push access. Use the team's `slug`. **Note**: The list of users, apps, and teams in total is limited to 100 items. |
-}
reposRemoveTeamAccessRestrictions :
    { toMsg : Result Http.Error (List Team) -> msg
    , body : Json.Encode.Value
    , params : { owner : String, repo : String, branch : String }
    }
    -> Cmd msg
reposRemoveTeamAccessRestrictions config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.list decodeTeam)
        , body = Http.jsonBody (Basics.identity config.body)
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{branch}"
                config.params.branch
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"
                    )
                )
        }


{-| Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Lists the people who have push access to this branch.
-}
reposGetUsersWithAccessToProtectedBranch :
    { toMsg : Result Http.Error (List SimpleUser) -> msg
    , params : { owner : String, repo : String, branch : String }
    }
    -> Cmd msg
reposGetUsersWithAccessToProtectedBranch config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeSimpleUser)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{branch}"
                config.params.branch
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"
                    )
                )
        }


{-| Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Grants the specified people push access for this branch.

| Type    | Description                                                                                                                   |
| ------- | ----------------------------------------------------------------------------------------------------------------------------- |
| `array` | Usernames for people who can have push access. **Note**: The list of users, apps, and teams in total is limited to 100 items. |
-}
reposAddUserAccessRestrictions :
    { toMsg : Result Http.Error (List SimpleUser) -> msg
    , body : Json.Encode.Value
    , params : { owner : String, repo : String, branch : String }
    }
    -> Cmd msg
reposAddUserAccessRestrictions config =
    Http.request
        { method = "POST"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeSimpleUser)
        , body = Http.jsonBody (Basics.identity config.body)
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{branch}"
                config.params.branch
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"
                    )
                )
        }


{-| Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Replaces the list of people that have push access to this branch. This removes all people that previously had push access and grants push access to the new list of people.

| Type    | Description                                                                                                                   |
| ------- | ----------------------------------------------------------------------------------------------------------------------------- |
| `array` | Usernames for people who can have push access. **Note**: The list of users, apps, and teams in total is limited to 100 items. |
-}
reposSetUserAccessRestrictions :
    { toMsg : Result Http.Error (List SimpleUser) -> msg
    , body : Json.Encode.Value
    , params : { owner : String, repo : String, branch : String }
    }
    -> Cmd msg
reposSetUserAccessRestrictions config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeSimpleUser)
        , body = Http.jsonBody (Basics.identity config.body)
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{branch}"
                config.params.branch
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"
                    )
                )
        }


{-| Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Removes the ability of a user to push to this branch.

| Type    | Description                                                                                                                                   |
| ------- | --------------------------------------------------------------------------------------------------------------------------------------------- |
| `array` | Usernames of the people who should no longer have push access. **Note**: The list of users, apps, and teams in total is limited to 100 items. |
-}
reposRemoveUserAccessRestrictions :
    { toMsg : Result Http.Error (List SimpleUser) -> msg
    , body : Json.Encode.Value
    , params : { owner : String, repo : String, branch : String }
    }
    -> Cmd msg
reposRemoveUserAccessRestrictions config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeSimpleUser)
        , body = Http.jsonBody (Basics.identity config.body)
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{branch}"
                config.params.branch
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"
                    )
                )
        }


{-| Renames a branch in a repository.

**Note:** Although the API responds immediately, the branch rename process might take some extra time to complete in the background. You won't be able to push to the old branch name while the rename process is in progress. For more information, see "[Renaming a branch](https://docs.github.com/github/administering-a-repository/renaming-a-branch)".

The permissions required to use this endpoint depends on whether you are renaming the default branch.

To rename a non-default branch:

* Users must have push access.
* GitHub Apps must have the `contents:write` repository permission.

To rename the default branch:

* Users must have admin or owner permissions.
* GitHub Apps must have the `administration:write` repository permission.
-}
reposRenameBranch :
    { toMsg : Result Http.Error BranchWithProtection -> msg
    , body : { new_name : String }
    , params : { owner : String, repo : String, branch : String }
    }
    -> Cmd msg
reposRenameBranch config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeBranchWithProtection
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "new_name", Json.Encode.string rec.new_name ) ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{branch}"
                config.params.branch
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/branches/{branch}/rename"
                    )
                )
        }


{-| **Note:** The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array.

Creates a new check run for a specific commit in a repository. Your GitHub App must have the `checks:write` permission to create check runs.

In a check suite, GitHub limits the number of check runs with the same name to 1000. Once these check runs exceed 1000, GitHub will start to automatically delete older check runs.
-}
checksCreate :
    { toMsg : Result Http.Error CheckRun -> msg
    , body :
        { actions :
            List { description : String, identifier : String, label : String }
        , completed_at : String
        , conclusion : String
        , details_url : String
        , external_id : String
        , head_sha : String
        , name : String
        , output :
            { annotations :
                List { annotation_level : String
                , end_column : Int
                , end_line : Int
                , message : String
                , path : String
                , raw_details : String
                , start_column : Int
                , start_line : Int
                , title : String
                }
            , images :
                List { alt : String, caption : String, image_url : String }
            , summary : String
            , text : String
            , title : String
            }
        , started_at : String
        , status : String
        }
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
checksCreate config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeCheckRun
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "actions"
                           , Json.Encode.list
                                 (\rec0 ->
                                     Json.Encode.object
                                         [ ( "description"
                                           , Json.Encode.string rec0.description
                                           )
                                         , ( "identifier"
                                           , Json.Encode.string rec0.identifier
                                           )
                                         , ( "label"
                                           , Json.Encode.string rec0.label
                                           )
                                         ]
                                 )
                                 rec.actions
                           )
                         , ( "completed_at"
                           , Json.Encode.string rec.completed_at
                           )
                         , ( "conclusion", Json.Encode.string rec.conclusion )
                         , ( "details_url", Json.Encode.string rec.details_url )
                         , ( "external_id", Json.Encode.string rec.external_id )
                         , ( "head_sha", Json.Encode.string rec.head_sha )
                         , ( "name", Json.Encode.string rec.name )
                         , ( "output"
                           , (\rec0 ->
                                 Json.Encode.object
                                     [ ( "annotations"
                                       , Json.Encode.list
                                             (\rec_1_0_1_1_1_0_8_1_0_0_1_3_1_0_0 ->
                                                 Json.Encode.object
                                                     [ ( "annotation_level"
                                                       , Json.Encode.string
                                                             rec_1_0_1_1_1_0_8_1_0_0_1_3_1_0_0.annotation_level
                                                       )
                                                     , ( "end_column"
                                                       , Json.Encode.int
                                                             rec_1_0_1_1_1_0_8_1_0_0_1_3_1_0_0.end_column
                                                       )
                                                     , ( "end_line"
                                                       , Json.Encode.int
                                                             rec_1_0_1_1_1_0_8_1_0_0_1_3_1_0_0.end_line
                                                       )
                                                     , ( "message"
                                                       , Json.Encode.string
                                                             rec_1_0_1_1_1_0_8_1_0_0_1_3_1_0_0.message
                                                       )
                                                     , ( "path"
                                                       , Json.Encode.string
                                                             rec_1_0_1_1_1_0_8_1_0_0_1_3_1_0_0.path
                                                       )
                                                     , ( "raw_details"
                                                       , Json.Encode.string
                                                             rec_1_0_1_1_1_0_8_1_0_0_1_3_1_0_0.raw_details
                                                       )
                                                     , ( "start_column"
                                                       , Json.Encode.int
                                                             rec_1_0_1_1_1_0_8_1_0_0_1_3_1_0_0.start_column
                                                       )
                                                     , ( "start_line"
                                                       , Json.Encode.int
                                                             rec_1_0_1_1_1_0_8_1_0_0_1_3_1_0_0.start_line
                                                       )
                                                     , ( "title"
                                                       , Json.Encode.string
                                                             rec_1_0_1_1_1_0_8_1_0_0_1_3_1_0_0.title
                                                       )
                                                     ]
                                             )
                                             rec0.annotations
                                       )
                                     , ( "images"
                                       , Json.Encode.list
                                             (\rec_1_0_2_1_1_0_8_1_0_0_1_3_1_0_0 ->
                                                 Json.Encode.object
                                                     [ ( "alt"
                                                       , Json.Encode.string
                                                             rec_1_0_2_1_1_0_8_1_0_0_1_3_1_0_0.alt
                                                       )
                                                     , ( "caption"
                                                       , Json.Encode.string
                                                             rec_1_0_2_1_1_0_8_1_0_0_1_3_1_0_0.caption
                                                       )
                                                     , ( "image_url"
                                                       , Json.Encode.string
                                                             rec_1_0_2_1_1_0_8_1_0_0_1_3_1_0_0.image_url
                                                       )
                                                     ]
                                             )
                                             rec0.images
                                       )
                                     , ( "summary"
                                       , Json.Encode.string rec0.summary
                                       )
                                     , ( "text", Json.Encode.string rec0.text )
                                     , ( "title"
                                       , Json.Encode.string rec0.title
                                       )
                                     ]
                             )
                                 rec.output
                           )
                         , ( "started_at", Json.Encode.string rec.started_at )
                         , ( "status", Json.Encode.string rec.status )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/check-runs"
                )
        }


{-| **Note:** The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array.

Gets a single check run using its `id`. GitHub Apps must have the `checks:read` permission on a private repository or pull access to a public repository to get check runs. OAuth Apps and authenticated users must have the `repo` scope to get check runs in a private repository.
-}
checksGet config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeCheckRun
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{check_run_id}"
                config.params.check_run_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/check-runs/{check_run_id}"
                    )
                )
        }


{-| **Note:** The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array.

Updates a check run for a specific commit in a repository. Your GitHub App must have the `checks:write` permission to edit check runs.
-}
checksUpdate config =
    Http.request
        { method = "PATCH"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeCheckRun
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "actions"
                           , Json.Encode.list
                                 (\rec0 ->
                                     Json.Encode.object
                                         [ ( "description"
                                           , Json.Encode.string rec0.description
                                           )
                                         , ( "identifier"
                                           , Json.Encode.string rec0.identifier
                                           )
                                         , ( "label"
                                           , Json.Encode.string rec0.label
                                           )
                                         ]
                                 )
                                 rec.actions
                           )
                         , ( "completed_at"
                           , Json.Encode.string rec.completed_at
                           )
                         , ( "conclusion", Json.Encode.string rec.conclusion )
                         , ( "details_url", Json.Encode.string rec.details_url )
                         , ( "external_id", Json.Encode.string rec.external_id )
                         , ( "name", Json.Encode.string rec.name )
                         , ( "output"
                           , (\rec0 ->
                                 Json.Encode.object
                                     [ ( "annotations"
                                       , Json.Encode.list
                                             (\rec_1_0_1_1_1_0_7_1_0_0_1_3_1_0_0 ->
                                                 Json.Encode.object
                                                     [ ( "annotation_level"
                                                       , Json.Encode.string
                                                             rec_1_0_1_1_1_0_7_1_0_0_1_3_1_0_0.annotation_level
                                                       )
                                                     , ( "end_column"
                                                       , Json.Encode.int
                                                             rec_1_0_1_1_1_0_7_1_0_0_1_3_1_0_0.end_column
                                                       )
                                                     , ( "end_line"
                                                       , Json.Encode.int
                                                             rec_1_0_1_1_1_0_7_1_0_0_1_3_1_0_0.end_line
                                                       )
                                                     , ( "message"
                                                       , Json.Encode.string
                                                             rec_1_0_1_1_1_0_7_1_0_0_1_3_1_0_0.message
                                                       )
                                                     , ( "path"
                                                       , Json.Encode.string
                                                             rec_1_0_1_1_1_0_7_1_0_0_1_3_1_0_0.path
                                                       )
                                                     , ( "raw_details"
                                                       , Json.Encode.string
                                                             rec_1_0_1_1_1_0_7_1_0_0_1_3_1_0_0.raw_details
                                                       )
                                                     , ( "start_column"
                                                       , Json.Encode.int
                                                             rec_1_0_1_1_1_0_7_1_0_0_1_3_1_0_0.start_column
                                                       )
                                                     , ( "start_line"
                                                       , Json.Encode.int
                                                             rec_1_0_1_1_1_0_7_1_0_0_1_3_1_0_0.start_line
                                                       )
                                                     , ( "title"
                                                       , Json.Encode.string
                                                             rec_1_0_1_1_1_0_7_1_0_0_1_3_1_0_0.title
                                                       )
                                                     ]
                                             )
                                             rec0.annotations
                                       )
                                     , ( "images"
                                       , Json.Encode.list
                                             (\rec_1_0_2_1_1_0_7_1_0_0_1_3_1_0_0 ->
                                                 Json.Encode.object
                                                     [ ( "alt"
                                                       , Json.Encode.string
                                                             rec_1_0_2_1_1_0_7_1_0_0_1_3_1_0_0.alt
                                                       )
                                                     , ( "caption"
                                                       , Json.Encode.string
                                                             rec_1_0_2_1_1_0_7_1_0_0_1_3_1_0_0.caption
                                                       )
                                                     , ( "image_url"
                                                       , Json.Encode.string
                                                             rec_1_0_2_1_1_0_7_1_0_0_1_3_1_0_0.image_url
                                                       )
                                                     ]
                                             )
                                             rec0.images
                                       )
                                     , ( "summary"
                                       , Json.Encode.string rec0.summary
                                       )
                                     , ( "text", Json.Encode.string rec0.text )
                                     , ( "title"
                                       , Json.Encode.string rec0.title
                                       )
                                     ]
                             )
                                 rec.output
                           )
                         , ( "started_at", Json.Encode.string rec.started_at )
                         , ( "status", Json.Encode.string rec.status )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{check_run_id}"
                config.params.check_run_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/check-runs/{check_run_id}"
                    )
                )
        }


{-| Lists annotations for a check run using the annotation `id`. GitHub Apps must have the `checks:read` permission on a private repository or pull access to a public repository to get annotations for a check run. OAuth Apps and authenticated users must have the `repo` scope to get annotations for a check run in a private repository. -}
checksListAnnotations config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeCheckAnnotation)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{check_run_id}"
                    config.params.check_run_id
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/check-runs/{check_run_id}/annotations"
                        )
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Triggers GitHub to rerequest an existing check run, without pushing new code to a repository. This endpoint will trigger the [`check_run` webhook](https://docs.github.com/webhooks/event-payloads/#check_run) event with the action `rerequested`. When a check run is `rerequested`, its `status` is reset to `queued` and the `conclusion` is cleared.

To rerequest a check run, your GitHub App must have the `checks:read` permission on a private repository or pull access to a public repository.
-}
checksRerequestRun config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.succeed {})
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{check_run_id}"
                config.params.check_run_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/check-runs/{check_run_id}/rerequest"
                    )
                )
        }


{-| **Note:** The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array and a `null` value for `head_branch`.

By default, check suites are automatically created when you create a [check run](https://docs.github.com/rest/reference/checks#check-runs). You only need to use this endpoint for manually creating check suites when you've disabled automatic creation using "[Update repository preferences for check suites](https://docs.github.com/rest/reference/checks#update-repository-preferences-for-check-suites)". Your GitHub App must have the `checks:write` permission to create check suites.
-}
checksCreateSuite :
    { toMsg : Result Http.Error CheckSuite -> msg
    , body : { head_sha : String }
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
checksCreateSuite config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeCheckSuite
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "head_sha", Json.Encode.string rec.head_sha ) ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/check-suites"
                )
        }


{-| Changes the default automatic flow when creating check suites. By default, a check suite is automatically created each time code is pushed to a repository. When you disable the automatic creation of check suites, you can manually [Create a check suite](https://docs.github.com/rest/reference/checks#create-a-check-suite). You must have admin permissions in the repository to set preferences for check suites. -}
checksSetSuitesPreferences :
    { toMsg : Result Http.Error CheckSuitePreference -> msg
    , body : { auto_trigger_checks : List { app_id : Int, setting : Bool } }
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
checksSetSuitesPreferences config =
    Http.request
        { method = "PATCH"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeCheckSuitePreference
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "auto_trigger_checks"
                           , Json.Encode.list
                                 (\rec0 ->
                                     Json.Encode.object
                                         [ ( "app_id"
                                           , Json.Encode.int rec0.app_id
                                           )
                                         , ( "setting"
                                           , Json.Encode.bool rec0.setting
                                           )
                                         ]
                                 )
                                 rec.auto_trigger_checks
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/check-suites/preferences"
                )
        }


{-| **Note:** The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array and a `null` value for `head_branch`.

Gets a single check suite using its `id`. GitHub Apps must have the `checks:read` permission on a private repository or pull access to a public repository to get check suites. OAuth Apps and authenticated users must have the `repo` scope to get check suites in a private repository.
-}
checksGetSuite config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeCheckSuite
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{check_suite_id}"
                config.params.check_suite_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/check-suites/{check_suite_id}"
                    )
                )
        }


{-| **Note:** The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array.

Lists check runs for a check suite using its `id`. GitHub Apps must have the `checks:read` permission on a private repository or pull access to a public repository to get check runs. OAuth Apps and authenticated users must have the `repo` scope to get check runs in a private repository.
-}
checksListForSuite config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\check_runs total_count ->
                      { check_runs = check_runs, total_count = total_count }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "check_runs"
                            (Json.Decode.list decodeCheckRun)
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.int)
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{check_suite_id}"
                    config.params.check_suite_id
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs"
                        )
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (Url.Builder.string "check_name")
                        config.params.check_name
                    , Maybe.map
                        (Url.Builder.string "status")
                        config.params.status
                    , Maybe.map
                        (Url.Builder.string "filter")
                        config.params.filter
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Triggers GitHub to rerequest an existing check suite, without pushing new code to a repository. This endpoint will trigger the [`check_suite` webhook](https://docs.github.com/webhooks/event-payloads/#check_suite) event with the action `rerequested`. When a check suite is `rerequested`, its `status` is reset to `queued` and the `conclusion` is cleared.

To rerequest a check suite, your GitHub App must have the `checks:read` permission on a private repository or pull access to a public repository.
-}
checksRerequestSuite config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.succeed {})
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{check_suite_id}"
                config.params.check_suite_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest"
                    )
                )
        }


{-| Lists code scanning alerts.

To use this endpoint, you must use an access token with the `security_events` scope or, for alerts from public repositories only, an access token with the `public_repo` scope.

GitHub Apps must have the `security_events` read
permission to use this endpoint.

The response includes a `most_recent_instance` object.
This provides details of the most recent instance of this alert
for the default branch (or for the specified Git reference if you used `ref` in the request).
-}
codeScanningListAlertsForRepo :
    { toMsg : Result Http.Error (List CodeScanningAlertItems) -> msg
    , params :
        { owner : String
        , repo : String
        , tool_name : Maybe CodeScanningAnalysisToolName
        , tool_guid : Maybe CodeScanningAnalysisToolGuid
        , page : Maybe Int
        , per_page : Maybe Int
        , ref : Maybe CodeScanningRef
        , direction : Maybe String
        , sort : Maybe String
        , state : Maybe CodeScanningAlertState
        }
    }
    -> Cmd msg
codeScanningListAlertsForRepo config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeCodeScanningAlertItems)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/code-scanning/alerts"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "tool_name"
                                (Debug.todo
                                    "Params of type \"CodeScanningAnalysisToolName\" (in helper)"
                                )
                        )
                        config.params.tool_name
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "tool_guid"
                                (Debug.todo
                                    "Params of type \"CodeScanningAnalysisToolGuid\" (in helper)"
                                )
                        )
                        config.params.tool_guid
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "ref"
                                (Debug.todo
                                    "Params of type \"CodeScanningRef\" (in helper)"
                                )
                        )
                        config.params.ref
                    , Maybe.map
                        (Url.Builder.string "direction")
                        config.params.direction
                    , Maybe.map (Url.Builder.string "sort") config.params.sort
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "state"
                                (Debug.todo
                                    "Params of type \"CodeScanningAlertState\" (in helper)"
                                )
                        )
                        config.params.state
                    ]
                )
        }


{-| Gets a single code scanning alert. You must use an access token with the `security_events` scope to use this endpoint with private repos, the `public_repo` scope also grants permission to read security events on public repos only. GitHub Apps must have the `security_events` read permission to use this endpoint.

**Deprecation notice**:
The instances field is deprecated and will, in future, not be included in the response for this endpoint. The example response reflects this change. The same information can now be retrieved via a GET request to the URL specified by `instances_url`.
-}
codeScanningGetAlert config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeCodeScanningAlert
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{alert_number}"
                config.params.alert_number
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/code-scanning/alerts/{alert_number}"
                    )
                )
        }


{-| Updates the status of a single code scanning alert. You must use an access token with the `security_events` scope to use this endpoint with private repositories. You can also use tokens with the `public_repo` scope for public repositories only. GitHub Apps must have the `security_events` write permission to use this endpoint. -}
codeScanningUpdateAlert config =
    Http.request
        { method = "PATCH"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeCodeScanningAlert
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "dismissed_comment"
                           , encodeCodeScanningAlertDismissedComment
                                 rec.dismissed_comment
                           )
                         , ( "dismissed_reason"
                           , encodeCodeScanningAlertDismissedReason
                                 rec.dismissed_reason
                           )
                         , ( "state"
                           , encodeCodeScanningAlertSetState rec.state
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{alert_number}"
                config.params.alert_number
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/code-scanning/alerts/{alert_number}"
                    )
                )
        }


{-| Lists all instances of the specified code scanning alert.
You must use an access token with the `security_events` scope to use this endpoint with private repos,
the `public_repo` scope also grants permission to read security events on public repos only.
GitHub Apps must have the `security_events` read permission to use this endpoint.
-}
codeScanningListAlertInstances config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeCodeScanningAlertInstance)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{alert_number}"
                    config.params.alert_number
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances"
                        )
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "ref"
                                (Debug.todo
                                    "Params of type \"CodeScanningRef\" (in helper)"
                                )
                        )
                        config.params.ref
                    ]
                )
        }


{-| Lists the details of all code scanning analyses for a repository,
starting with the most recent.
The response is paginated and you can use the `page` and `per_page` parameters
to list the analyses you're interested in.
By default 30 analyses are listed per page.

The `rules_count` field in the response give the number of rules
that were run in the analysis.
For very old analyses this data is not available,
and `0` is returned in this field.

You must use an access token with the `security_events` scope to use this endpoint with private repos,
the `public_repo` scope also grants permission to read security events on public repos only.
GitHub Apps must have the `security_events` read permission to use this endpoint.

**Deprecation notice**:
The `tool_name` field is deprecated and will, in future, not be included in the response for this endpoint. The example response reflects this change. The tool name can now be found inside the `tool` field.
-}
codeScanningListRecentAnalyses :
    { toMsg : Result Http.Error (List CodeScanningAnalysis) -> msg
    , params :
        { owner : String
        , repo : String
        , tool_name : Maybe CodeScanningAnalysisToolName
        , tool_guid : Maybe CodeScanningAnalysisToolGuid
        , page : Maybe Int
        , per_page : Maybe Int
        , ref : Maybe CodeScanningRef
        , sarif_id : Maybe CodeScanningAnalysisSarifId
        , direction : Maybe String
        , sort : Maybe String
        }
    }
    -> Cmd msg
codeScanningListRecentAnalyses config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeCodeScanningAnalysis)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/code-scanning/analyses"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "tool_name"
                                (Debug.todo
                                    "Params of type \"CodeScanningAnalysisToolName\" (in helper)"
                                )
                        )
                        config.params.tool_name
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "tool_guid"
                                (Debug.todo
                                    "Params of type \"CodeScanningAnalysisToolGuid\" (in helper)"
                                )
                        )
                        config.params.tool_guid
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "ref"
                                (Debug.todo
                                    "Params of type \"CodeScanningRef\" (in helper)"
                                )
                        )
                        config.params.ref
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "sarif_id"
                                (Debug.todo
                                    "Params of type \"CodeScanningAnalysisSarifId\" (in helper)"
                                )
                        )
                        config.params.sarif_id
                    , Maybe.map
                        (Url.Builder.string "direction")
                        config.params.direction
                    , Maybe.map (Url.Builder.string "sort") config.params.sort
                    ]
                )
        }


{-| Gets a specified code scanning analysis for a repository.
You must use an access token with the `security_events` scope to use this endpoint with private repos,
the `public_repo` scope also grants permission to read security events on public repos only.
GitHub Apps must have the `security_events` read permission to use this endpoint.

The default JSON response contains fields that describe the analysis.
This includes the Git reference and commit SHA to which the analysis relates,
the datetime of the analysis, the name of the code scanning tool,
and the number of alerts.

The `rules_count` field in the default response give the number of rules
that were run in the analysis.
For very old analyses this data is not available,
and `0` is returned in this field.

If you use the Accept header `application/sarif+json`,
the response contains the analysis data that was uploaded.
This is formatted as
[SARIF version 2.1.0](https://docs.oasis-open.org/sarif/sarif/v2.1.0/cs01/sarif-v2.1.0-cs01.html).
-}
codeScanningGetAnalysis config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeCodeScanningAnalysis
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{analysis_id}"
                config.params.analysis_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}"
                    )
                )
        }


{-| Deletes a specified code scanning analysis from a repository. For
private repositories, you must use an access token with the `repo` scope. For public repositories,
you must use an access token with `public_repo` scope.
GitHub Apps must have the `security_events` write permission to use this endpoint.

You can delete one analysis at a time.
To delete a series of analyses, start with the most recent analysis and work backwards.
Conceptually, the process is similar to the undo function in a text editor.

When you list the analyses for a repository,
one or more will be identified as deletable in the response:

```
"deletable": true
```

An analysis is deletable when it's the most recent in a set of analyses.
Typically, a repository will have multiple sets of analyses
for each enabled code scanning tool,
where a set is determined by a unique combination of analysis values:

* `ref`
* `tool`
* `category`

If you attempt to delete an analysis that is not the most recent in a set,
you'll get a 400 response with the message:

```
Analysis specified is not deletable.
```

The response from a successful `DELETE` operation provides you with
two alternative URLs for deleting the next analysis in the set:
`next_analysis_url` and `confirm_delete_url`.
Use the `next_analysis_url` URL if you want to avoid accidentally deleting the final analysis
in a set. This is a useful option if you want to preserve at least one analysis
for the specified tool in your repository.
Use the `confirm_delete_url` URL if you are content to remove all analyses for a tool.
When you delete the last analysis in a set, the value of `next_analysis_url` and `confirm_delete_url`
in the 200 response is `null`.

As an example of the deletion process,
let's imagine that you added a workflow that configured a particular code scanning tool
to analyze the code in a repository. This tool has added 15 analyses:
10 on the default branch, and another 5 on a topic branch.
You therefore have two separate sets of analyses for this tool.
You've now decided that you want to remove all of the analyses for the tool.
To do this you must make 15 separate deletion requests.
To start, you must find an analysis that's identified as deletable.
Each set of analyses always has one that's identified as deletable.
Having found the deletable analysis for one of the two sets,
delete this analysis and then continue deleting the next analysis in the set until they're all deleted.
Then repeat the process for the second set.
The procedure therefore consists of a nested loop:

**Outer loop**:
* List the analyses for the repository, filtered by tool.
* Parse this list to find a deletable analysis. If found:

  **Inner loop**:
  * Delete the identified analysis.
  * Parse the response for the value of `confirm_delete_url` and, if found, use this in the next iteration.

The above process assumes that you want to remove all trace of the tool's analyses from the GitHub user interface, for the specified repository, and it therefore uses the `confirm_delete_url` value. Alternatively, you could use the `next_analysis_url` value, which would leave the last analysis in each set undeleted to avoid removing a tool's analysis entirely.
-}
codeScanningDeleteAnalysis config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect =
            Http.expectJson config.toMsg decodeCodeScanningAnalysisDeletion
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{analysis_id}"
                    config.params.analysis_id
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}"
                        )
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "confirm_delete"
                                (Debug.todo
                                    "Params of type \"(Nullable String)\" (in helper)"
                                )
                        )
                        config.params.confirm_delete
                    ]
                )
        }


{-| Lists the CodeQL databases that are available in a repository.

For private repositories, you must use an access token with the `security_events` scope.
For public repositories, you can use tokens with the `security_events` or `public_repo` scope.
GitHub Apps must have the `contents` read permission to use this endpoint.
-}
codeScanningListCodeqlDatabases :
    { toMsg : Result Http.Error (List CodeScanningCodeqlDatabase) -> msg
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
codeScanningListCodeqlDatabases config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeCodeScanningCodeqlDatabase)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/code-scanning/codeql/databases"
                )
        }


{-| Gets a CodeQL database for a language in a repository.

By default this endpoint returns JSON metadata about the CodeQL database. To
download the CodeQL database binary content, set the `Accept` header of the request
to [`application/zip`](https://docs.github.com/rest/overview/media-types), and make sure
your HTTP client is configured to follow redirects or use the `Location` header
to make a second request to get the redirect URL.

For private repositories, you must use an access token with the `security_events` scope.
For public repositories, you can use tokens with the `security_events` or `public_repo` scope.
GitHub Apps must have the `contents` read permission to use this endpoint.
-}
codeScanningGetCodeqlDatabase :
    { toMsg : Result Http.Error CodeScanningCodeqlDatabase -> msg
    , params : { owner : String, repo : String, language : String }
    }
    -> Cmd msg
codeScanningGetCodeqlDatabase config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeCodeScanningCodeqlDatabase
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{language}"
                config.params.language
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/code-scanning/codeql/databases/{language}"
                    )
                )
        }


{-| Uploads SARIF data containing the results of a code scanning analysis to make the results available in a repository. You must use an access token with the `security_events` scope to use this endpoint for private repositories. You can also use tokens with the `public_repo` scope for public repositories only. GitHub Apps must have the `security_events` write permission to use this endpoint.

There are two places where you can upload code scanning results.
 - If you upload to a pull request, for example `--ref refs/pull/42/merge` or `--ref refs/pull/42/head`, then the results appear as alerts in a pull request check. For more information, see "[Triaging code scanning alerts in pull requests](/code-security/secure-coding/triaging-code-scanning-alerts-in-pull-requests)."
 - If you upload to a branch, for example `--ref refs/heads/my-branch`, then the results appear in the **Security** tab for your repository. For more information, see "[Managing code scanning alerts for your repository](/code-security/secure-coding/managing-code-scanning-alerts-for-your-repository#viewing-the-alerts-for-a-repository)."

You must compress the SARIF-formatted analysis data that you want to upload, using `gzip`, and then encode it as a Base64 format string. For example:

```
gzip -c analysis-data.sarif | base64 -w0
```

SARIF upload supports a maximum of 5000 results per analysis run. Any results over this limit are ignored and any SARIF uploads with more than 25,000 results are rejected. Typically, but not necessarily, a SARIF file contains a single run of a single tool. If a code scanning tool generates too many results, you should update the analysis configuration to run only the most important rules or queries.

The `202 Accepted`, response includes an `id` value.
You can use this ID to check the status of the upload by using this for the `/sarifs/{sarif_id}` endpoint.
For more information, see "[Get information about a SARIF upload](/rest/reference/code-scanning#get-information-about-a-sarif-upload)."
-}
codeScanningUploadSarif :
    { toMsg : Result Http.Error CodeScanningSarifsReceipt -> msg
    , body :
        { checkout_uri : String
        , commit_sha : CodeScanningAnalysisCommitSha
        , ref : CodeScanningRef
        , sarif : CodeScanningAnalysisSarifFile
        , started_at : String
        , tool_name : String
        }
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
codeScanningUploadSarif config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeCodeScanningSarifsReceipt
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "checkout_uri"
                           , Json.Encode.string rec.checkout_uri
                           )
                         , ( "commit_sha"
                           , encodeCodeScanningAnalysisCommitSha rec.commit_sha
                           )
                         , ( "ref", encodeCodeScanningRef rec.ref )
                         , ( "sarif"
                           , encodeCodeScanningAnalysisSarifFile rec.sarif
                           )
                         , ( "started_at", Json.Encode.string rec.started_at )
                         , ( "tool_name", Json.Encode.string rec.tool_name )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/code-scanning/sarifs"
                )
        }


{-| Gets information about a SARIF upload, including the status and the URL of the analysis that was uploaded so that you can retrieve details of the analysis. For more information, see "[Get a code scanning analysis for a repository](/rest/reference/code-scanning#get-a-code-scanning-analysis-for-a-repository)." You must use an access token with the `security_events` scope to use this endpoint with private repos, the `public_repo` scope also grants permission to read security events on public repos only. GitHub Apps must have the `security_events` read permission to use this endpoint. -}
codeScanningGetSarif :
    { toMsg : Result Http.Error CodeScanningSarifsStatus -> msg
    , params : { owner : String, repo : String, sarif_id : String }
    }
    -> Cmd msg
codeScanningGetSarif config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeCodeScanningSarifsStatus
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{sarif_id}"
                config.params.sarif_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}"
                    )
                )
        }


{-| List any syntax errors that are detected in the CODEOWNERS
file.

For more information about the correct CODEOWNERS syntax,
see "[About code owners](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners)."
-}
reposCodeownersErrors :
    { toMsg : Result Http.Error CodeownersErrors -> msg
    , params : { owner : String, repo : String, ref : Maybe String }
    }
    -> Cmd msg
reposCodeownersErrors config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeCodeownersErrors
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/codeowners/errors"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map (Url.Builder.string "ref") config.params.ref ]
                )
        }


{-| Lists the codespaces associated to a specified repository and the authenticated user.

You must authenticate using an access token with the `codespace` scope to use this endpoint.

GitHub Apps must have read access to the `codespaces` repository permission to use this endpoint.
-}
codespacesListInRepositoryForAuthenticatedUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\codespaces total_count ->
                      { codespaces = codespaces, total_count = total_count }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "codespaces"
                            (Json.Decode.list decodeCodespace)
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.int)
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/codespaces"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Creates a codespace owned by the authenticated user in the specified repository.

You must authenticate using an access token with the `codespace` scope to use this endpoint.

GitHub Apps must have write access to the `codespaces` repository permission to use this endpoint.
-}
codespacesCreateWithRepoForAuthenticatedUser :
    { toMsg : Result Http.Error Codespace -> msg
    , body :
        Nullable { client_ip : String
        , devcontainer_path : String
        , display_name : String
        , idle_timeout_minutes : Int
        , location : String
        , machine : String
        , multi_repo_permissions_opt_out : Bool
        , ref : String
        , retention_period_minutes : Int
        , working_directory : String
        }
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
codespacesCreateWithRepoForAuthenticatedUser config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeCodespace
        , body =
            Http.jsonBody
                ((\nullableValue ->
                     case nullableValue of
                         Null ->
                             Json.Encode.null

                         Present value ->
                             (\rec ->
                                 Json.Encode.object
                                     [ ( "client_ip"
                                       , Json.Encode.string rec.client_ip
                                       )
                                     , ( "devcontainer_path"
                                       , Json.Encode.string
                                             rec.devcontainer_path
                                       )
                                     , ( "display_name"
                                       , Json.Encode.string rec.display_name
                                       )
                                     , ( "idle_timeout_minutes"
                                       , Json.Encode.int
                                             rec.idle_timeout_minutes
                                       )
                                     , ( "location"
                                       , Json.Encode.string rec.location
                                       )
                                     , ( "machine"
                                       , Json.Encode.string rec.machine
                                       )
                                     , ( "multi_repo_permissions_opt_out"
                                       , Json.Encode.bool
                                             rec.multi_repo_permissions_opt_out
                                       )
                                     , ( "ref", Json.Encode.string rec.ref )
                                     , ( "retention_period_minutes"
                                       , Json.Encode.int
                                             rec.retention_period_minutes
                                       )
                                     , ( "working_directory"
                                       , Json.Encode.string
                                             rec.working_directory
                                       )
                                     ]
                             )
                                 value
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/codespaces"
                )
        }


{-| Lists the devcontainer.json files associated with a specified repository and the authenticated user. These files
specify launchpoint configurations for codespaces created within the repository.

You must authenticate using an access token with the `codespace` scope to use this endpoint.

GitHub Apps must have read access to the `codespaces_metadata` repository permission to use this endpoint.
-}
codespacesListDevcontainersInRepositoryForAuthenticatedUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\devcontainers total_count ->
                      { devcontainers = devcontainers
                      , total_count = total_count
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "devcontainers"
                            (Json.Decode.list
                                (Json.Decode.succeed
                                  (\name path -> { name = name, path = path })
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "name"
                                            Json.Decode.string
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "path"
                                            Json.Decode.string
                                        )
                                )
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.int)
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/codespaces/devcontainers"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| List the machine types available for a given repository based on its configuration.

You must authenticate using an access token with the `codespace` scope to use this endpoint.

GitHub Apps must have write access to the `codespaces_metadata` repository permission to use this endpoint.
-}
codespacesRepoMachinesForAuthenticatedUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\machines total_count ->
                      { machines = machines, total_count = total_count }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "machines"
                            (Json.Decode.list decodeCodespaceMachine)
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.int)
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/codespaces/machines"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (Url.Builder.string "location")
                        config.params.location
                    , Maybe.map
                        (Url.Builder.string "client_ip")
                        config.params.client_ip
                    ]
                )
        }


{-| Gets the default attributes for codespaces created by the user with the repository.

You must authenticate using an access token with the `codespace` scope to use this endpoint.

GitHub Apps must have write access to the `codespaces` repository permission to use this endpoint.
-}
codespacesPreFlightWithRepoForAuthenticatedUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\billable_owner defaults ->
                      { billable_owner = billable_owner, defaults = defaults }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "billable_owner" decodeSimpleUser)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "defaults"
                            (Json.Decode.succeed
                              (\devcontainer_path location ->
                                  { devcontainer_path = devcontainer_path
                                  , location = location
                                  }
                              )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "devcontainer_path"
                                        (Json.Decode.oneOf
                                            [ Json.Decode.map
                                                Present
                                                Json.Decode.string
                                            , Json.Decode.null Null
                                            ]
                                        )
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "location"
                                        Json.Decode.string
                                    )
                            )
                        )
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/codespaces/new"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map (Url.Builder.string "ref") config.params.ref
                    , Maybe.map
                        (Url.Builder.string "client_ip")
                        config.params.client_ip
                    ]
                )
        }


{-| Lists all secrets available in a repository without revealing their encrypted values. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `codespaces_secrets` repository permission to use this endpoint. -}
codespacesListRepoSecrets config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\secrets total_count ->
                      { secrets = secrets, total_count = total_count }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "secrets"
                            (Json.Decode.list decodeRepoCodespacesSecret)
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.int)
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/codespaces/secrets"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before you can create or update secrets. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `codespaces_secrets` repository permission to use this endpoint. -}
codespacesGetRepoPublicKey :
    { toMsg : Result Http.Error CodespacesPublicKey -> msg
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
codespacesGetRepoPublicKey config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeCodespacesPublicKey
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/codespaces/secrets/public-key"
                )
        }


{-| Gets a single repository secret without revealing its encrypted value. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `codespaces_secrets` repository permission to use this endpoint. -}
codespacesGetRepoSecret :
    { toMsg : Result Http.Error RepoCodespacesSecret -> msg
    , params : { owner : String, repo : String, secret_name : String }
    }
    -> Cmd msg
codespacesGetRepoSecret config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeRepoCodespacesSecret
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{secret_name}"
                config.params.secret_name
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
                    )
                )
        }


{-| Creates or updates a repository secret with an encrypted value. Encrypt your secret using
[LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must authenticate using an access
token with the `repo` scope to use this endpoint. GitHub Apps must have the `codespaces_secrets` repository
permission to use this endpoint.

#### Example of encrypting a secret using Node.js

Encrypt your secret using the [tweetsodium](https://github.com/github/tweetsodium) library.

```
const sodium = require('tweetsodium');

const key = "base64-encoded-public-key";
const value = "plain-text-secret";

// Convert the message and key to Uint8Array's (Buffer implements that interface)
const messageBytes = Buffer.from(value);
const keyBytes = Buffer.from(key, 'base64');

// Encrypt using LibSodium.
const encryptedBytes = sodium.seal(messageBytes, keyBytes);

// Base64 the encrypted secret
const encrypted = Buffer.from(encryptedBytes).toString('base64');

console.log(encrypted);
```


#### Example of encrypting a secret using Python

Encrypt your secret using [pynacl](https://pynacl.readthedocs.io/en/latest/public/#nacl-public-sealedbox) with Python 3.

```
from base64 import b64encode
from nacl import encoding, public

def encrypt(public_key: str, secret_value: str) -> str:
  """Encrypt a Unicode string using the public key."""
  public_key = public.PublicKey(public_key.encode("utf-8"), encoding.Base64Encoder())
  sealed_box = public.SealedBox(public_key)
  encrypted = sealed_box.encrypt(secret_value.encode("utf-8"))
  return b64encode(encrypted).decode("utf-8")
```

#### Example of encrypting a secret using C#

Encrypt your secret using the [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package.

```
var secretValue = System.Text.Encoding.UTF8.GetBytes("mySecret");
var publicKey = Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=");

var sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);

Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));
```

#### Example of encrypting a secret using Ruby

Encrypt your secret using the [rbnacl](https://github.com/RubyCrypto/rbnacl) gem.

```ruby
require "rbnacl"
require "base64"

key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=")
public_key = RbNaCl::PublicKey.new(key)

box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
encrypted_secret = box.encrypt("my_secret")

# Print the base64 encoded secret
puts Base64.strict_encode64(encrypted_secret)
```
-}
codespacesCreateOrUpdateRepoSecret :
    { toMsg : Result Http.Error {} -> msg
    , body : { encrypted_value : String, key_id : String }
    , params : { owner : String, repo : String, secret_name : String }
    }
    -> Cmd msg
codespacesCreateOrUpdateRepoSecret config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.succeed {})
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "encrypted_value"
                           , Json.Encode.string rec.encrypted_value
                           )
                         , ( "key_id", Json.Encode.string rec.key_id )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{secret_name}"
                config.params.secret_name
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
                    )
                )
        }


{-| Deletes a secret in a repository using the secret name. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `codespaces_secrets` repository permission to use this endpoint. -}
codespacesDeleteRepoSecret :
    { toMsg : Result Http.Error () -> msg
    , params : { owner : String, repo : String, secret_name : String }
    }
    -> Cmd msg
codespacesDeleteRepoSecret config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{secret_name}"
                config.params.secret_name
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
                    )
                )
        }


{-| For organization-owned repositories, the list of collaborators includes outside collaborators, organization members that are direct collaborators, organization members with access through team memberships, organization members with access through default organization permissions, and organization owners.
Organization members with write, maintain, or admin privileges on the organization-owned repository can use this endpoint.

Team members will include the members of child teams.

You must authenticate using an access token with the `read:org` and `repo` scopes with push access to use this
endpoint. GitHub Apps must have the `members` organization permission and `metadata` repository permission to use this
endpoint.
-}
reposListCollaborators :
    { toMsg : Result Http.Error (List Collaborator) -> msg
    , params :
        { owner : String
        , repo : String
        , affiliation : Maybe String
        , permission : Maybe String
        , per_page : Maybe Int
        , page : Maybe Int
        }
    }
    -> Cmd msg
reposListCollaborators config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeCollaborator)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/collaborators"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (Url.Builder.string "affiliation")
                        config.params.affiliation
                    , Maybe.map
                        (Url.Builder.string "permission")
                        config.params.permission
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| For organization-owned repositories, the list of collaborators includes outside collaborators, organization members that are direct collaborators, organization members with access through team memberships, organization members with access through default organization permissions, and organization owners.

Team members will include the members of child teams.

You must authenticate using an access token with the `read:org` and `repo` scopes with push access to use this
endpoint. GitHub Apps must have the `members` organization permission and `metadata` repository permission to use this
endpoint.
-}
reposCheckCollaborator :
    { toMsg : Result Http.Error () -> msg
    , params : { owner : String, repo : String, username : String }
    }
    -> Cmd msg
reposCheckCollaborator config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{username}"
                config.params.username
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/collaborators/{username}"
                    )
                )
        }


{-| This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.

Adding an outside collaborator may be restricted by enterprise administrators. For more information, see "[Enforcing repository management policies in your enterprise](https://docs.github.com/enterprise-cloud@latest/admin/policies/enforcing-policies-for-your-enterprise/enforcing-repository-management-policies-in-your-enterprise#enforcing-a-policy-for-inviting-outside-collaborators-to-repositories)."

For more information on permission levels, see "[Repository permission levels for an organization](https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/repository-permission-levels-for-an-organization#permission-levels-for-repositories-owned-by-an-organization)". There are restrictions on which permissions can be granted to organization members when an organization base role is in place. In this case, the permission being given must be equal to or higher than the org base permission. Otherwise, the request will fail with:

```
Cannot assign {member} permission of {role name}
```

Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs)."

The invitee will receive a notification that they have been invited to the repository, which they must accept or decline. They may do this via the notifications page, the email they receive, or by using the [repository invitations API endpoints](https://docs.github.com/rest/reference/repos#invitations).

**Updating an existing collaborator's permission level**

The endpoint can also be used to change the permissions of an existing collaborator without first removing and re-adding the collaborator. To change the permissions, use the same endpoint and pass a different `permission` parameter. The response will be a `204`, with no other indication that the permission level changed.

**Rate limits**

You are limited to sending 50 invitations to a repository per 24 hour period. Note there is no limit if you are inviting organization members to an organization repository.
-}
reposAddCollaborator :
    { toMsg : Result Http.Error RepositoryInvitation -> msg
    , body : { permission : String }
    , params : { owner : String, repo : String, username : String }
    }
    -> Cmd msg
reposAddCollaborator config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeRepositoryInvitation
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "permission", Json.Encode.string rec.permission ) ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{username}"
                config.params.username
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/collaborators/{username}"
                    )
                )
        }


reposRemoveCollaborator :
    { toMsg : Result Http.Error () -> msg
    , params : { owner : String, repo : String, username : String }
    }
    -> Cmd msg
reposRemoveCollaborator config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{username}"
                config.params.username
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/collaborators/{username}"
                    )
                )
        }


{-| Checks the repository permission of a collaborator. The possible repository permissions are `admin`, `write`, `read`, and `none`. -}
reposGetCollaboratorPermissionLevel :
    { toMsg : Result Http.Error RepositoryCollaboratorPermission -> msg
    , params : { owner : String, repo : String, username : String }
    }
    -> Cmd msg
reposGetCollaboratorPermissionLevel config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg decodeRepositoryCollaboratorPermission
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{username}"
                config.params.username
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/collaborators/{username}/permission"
                    )
                )
        }


{-| Commit Comments use [these custom media types](https://docs.github.com/rest/reference/repos#custom-media-types). You can read more about the use of media types in the API [here](https://docs.github.com/rest/overview/media-types/).

Comments are ordered by ascending ID.
-}
reposListCommitCommentsForRepo :
    { toMsg : Result Http.Error (List CommitComment) -> msg
    , params :
        { owner : String
        , repo : String
        , per_page : Maybe Int
        , page : Maybe Int
        }
    }
    -> Cmd msg
reposListCommitCommentsForRepo config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeCommitComment)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/comments"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


reposGetCommitComment config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeCommitComment
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{comment_id}"
                config.params.comment_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/comments/{comment_id}"
                    )
                )
        }


reposUpdateCommitComment config =
    Http.request
        { method = "PATCH"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeCommitComment
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "body", Json.Encode.string rec.body ) ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{comment_id}"
                config.params.comment_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/comments/{comment_id}"
                    )
                )
        }


reposDeleteCommitComment config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{comment_id}"
                config.params.comment_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/comments/{comment_id}"
                    )
                )
        }


{-| List the reactions to a [commit comment](https://docs.github.com/rest/reference/repos#comments). -}
reactionsListForCommitComment config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeReaction)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{comment_id}"
                    config.params.comment_id
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/comments/{comment_id}/reactions"
                        )
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (Url.Builder.string "content")
                        config.params.content
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Create a reaction to a [commit comment](https://docs.github.com/rest/reference/repos#comments). A response with an HTTP `200` status means that you already added the reaction type to this commit comment. -}
reactionsCreateForCommitComment config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeReaction
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "content", Json.Encode.string rec.content ) ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{comment_id}"
                config.params.comment_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/comments/{comment_id}/reactions"
                    )
                )
        }


{-| **Note:** You can also specify a repository by `repository_id` using the route `DELETE /repositories/:repository_id/comments/:comment_id/reactions/:reaction_id`.

Delete a reaction to a [commit comment](https://docs.github.com/rest/reference/repos#comments).
-}
reactionsDeleteForCommitComment config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{reaction_id}"
                config.params.reaction_id
                (String.replace
                    "{comment_id}"
                    config.params.comment_id
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}"
                        )
                    )
                )
        }


{-| **Signature verification object**

The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:

| Name | Type | Description |
| ---- | ---- | ----------- |
| `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
| `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. |
| `signature` | `string` | The signature that was extracted from the commit. |
| `payload` | `string` | The value that was signed. |

These are the possible values for `reason` in the `verification` object:

| Value | Description |
| ----- | ----------- |
| `expired_key` | The key that made the signature is expired. |
| `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
| `gpgverify_error` | There was an error communicating with the signature verification service. |
| `gpgverify_unavailable` | The signature verification service is currently unavailable. |
| `unsigned` | The object does not include a signature. |
| `unknown_signature_type` | A non-PGP signature was found in the commit. |
| `no_user` | No user was associated with the `committer` email address in the commit. |
| `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on her/his account. |
| `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
| `unknown_key` | The key that made the signature has not been registered with any user's account. |
| `malformed_signature` | There was an error parsing the signature. |
| `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
| `valid` | None of the above errors applied, so the signature is considered to be verified. |
-}
reposListCommits :
    { toMsg : Result Http.Error (List Commit) -> msg
    , params :
        { owner : String
        , repo : String
        , sha : Maybe String
        , path : Maybe String
        , author : Maybe String
        , since : Maybe String
        , until : Maybe String
        , per_page : Maybe Int
        , page : Maybe Int
        }
    }
    -> Cmd msg
reposListCommits config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.list decodeCommit)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/commits"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map (Url.Builder.string "sha") config.params.sha
                    , Maybe.map (Url.Builder.string "path") config.params.path
                    , Maybe.map
                        (Url.Builder.string "author")
                        config.params.author
                    , Maybe.map (Url.Builder.string "since") config.params.since
                    , Maybe.map (Url.Builder.string "until") config.params.until
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Returns all branches where the given commit SHA is the HEAD, or latest commit for the branch.
-}
reposListBranchesForHeadCommit :
    { toMsg : Result Http.Error (List BranchShort) -> msg
    , params : { owner : String, repo : String, commit_sha : String }
    }
    -> Cmd msg
reposListBranchesForHeadCommit config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeBranchShort)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{commit_sha}"
                config.params.commit_sha
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head"
                    )
                )
        }


{-| Use the `:commit_sha` to specify the commit that will have its comments listed. -}
reposListCommentsForCommit :
    { toMsg : Result Http.Error (List CommitComment) -> msg
    , params :
        { owner : String
        , repo : String
        , commit_sha : String
        , per_page : Maybe Int
        , page : Maybe Int
        }
    }
    -> Cmd msg
reposListCommentsForCommit config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeCommitComment)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{commit_sha}"
                    config.params.commit_sha
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/commits/{commit_sha}/comments"
                        )
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Create a comment for a commit using its `:commit_sha`.

This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
-}
reposCreateCommitComment :
    { toMsg : Result Http.Error CommitComment -> msg
    , body : { body : String, line : Int, path : String, position : Int }
    , params : { owner : String, repo : String, commit_sha : String }
    }
    -> Cmd msg
reposCreateCommitComment config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeCommitComment
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "body", Json.Encode.string rec.body )
                         , ( "line", Json.Encode.int rec.line )
                         , ( "path", Json.Encode.string rec.path )
                         , ( "position", Json.Encode.int rec.position )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{commit_sha}"
                config.params.commit_sha
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/commits/{commit_sha}/comments"
                    )
                )
        }


{-| Lists the merged pull request that introduced the commit to the repository. If the commit is not present in the default branch, additionally returns open pull requests associated with the commit. The results may include open and closed pull requests. -}
reposListPullRequestsAssociatedWithCommit :
    { toMsg : Result Http.Error (List PullRequestSimple) -> msg
    , params :
        { owner : String
        , repo : String
        , commit_sha : String
        , per_page : Maybe Int
        , page : Maybe Int
        }
    }
    -> Cmd msg
reposListPullRequestsAssociatedWithCommit config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodePullRequestSimple)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{commit_sha}"
                    config.params.commit_sha
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/commits/{commit_sha}/pulls"
                        )
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Returns the contents of a single commit reference. You must have `read` access for the repository to use this endpoint.

**Note:** If there are more than 300 files in the commit diff, the response will include pagination link headers for the remaining files, up to a limit of 3000 files. Each page contains the static commit information, and the only changes are to the file listing.

You can pass the appropriate [media type](https://docs.github.com/rest/overview/media-types/#commits-commit-comparison-and-pull-requests) to  fetch `diff` and `patch` formats. Diffs with binary data will have no `patch` property.

To return only the SHA-1 hash of the commit reference, you can provide the `sha` custom [media type](https://docs.github.com/rest/overview/media-types/#commits-commit-comparison-and-pull-requests) in the `Accept` header. You can use this endpoint to check if a remote reference's SHA-1 hash is the same as your local reference's SHA-1 hash by providing the local SHA-1 reference as the ETag.

**Signature verification object**

The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:

| Name | Type | Description |
| ---- | ---- | ----------- |
| `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
| `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. |
| `signature` | `string` | The signature that was extracted from the commit. |
| `payload` | `string` | The value that was signed. |

These are the possible values for `reason` in the `verification` object:

| Value | Description |
| ----- | ----------- |
| `expired_key` | The key that made the signature is expired. |
| `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
| `gpgverify_error` | There was an error communicating with the signature verification service. |
| `gpgverify_unavailable` | The signature verification service is currently unavailable. |
| `unsigned` | The object does not include a signature. |
| `unknown_signature_type` | A non-PGP signature was found in the commit. |
| `no_user` | No user was associated with the `committer` email address in the commit. |
| `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on her/his account. |
| `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
| `unknown_key` | The key that made the signature has not been registered with any user's account. |
| `malformed_signature` | There was an error parsing the signature. |
| `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
| `valid` | None of the above errors applied, so the signature is considered to be verified. |
-}
reposGetCommit :
    { toMsg : Result Http.Error Commit -> msg
    , params :
        { owner : String
        , repo : String
        , page : Maybe Int
        , per_page : Maybe Int
        , ref : String
        }
    }
    -> Cmd msg
reposGetCommit config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeCommit
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{ref}"
                    config.params.ref
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/commits/{ref}"
                        )
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    ]
                )
        }


{-| **Note:** The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array.

Lists check runs for a commit ref. The `ref` can be a SHA, branch name, or a tag name. GitHub Apps must have the `checks:read` permission on a private repository or pull access to a public repository to get check runs. OAuth Apps and authenticated users must have the `repo` scope to get check runs in a private repository.
-}
checksListForRef config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\check_runs total_count ->
                      { check_runs = check_runs, total_count = total_count }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "check_runs"
                            (Json.Decode.list decodeCheckRun)
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.int)
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{ref}"
                    config.params.ref
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/commits/{ref}/check-runs"
                        )
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (Url.Builder.string "check_name")
                        config.params.check_name
                    , Maybe.map
                        (Url.Builder.string "status")
                        config.params.status
                    , Maybe.map
                        (Url.Builder.string "filter")
                        config.params.filter
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "app_id"
                                (String.fromInt mapUnpack)
                        )
                        config.params.app_id
                    ]
                )
        }


{-| **Note:** The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array and a `null` value for `head_branch`.

Lists check suites for a commit `ref`. The `ref` can be a SHA, branch name, or a tag name. GitHub Apps must have the `checks:read` permission on a private repository or pull access to a public repository to list check suites. OAuth Apps and authenticated users must have the `repo` scope to get check suites in a private repository.
-}
checksListSuitesForRef config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\check_suites total_count ->
                      { check_suites = check_suites, total_count = total_count }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "check_suites"
                            (Json.Decode.list decodeCheckSuite)
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.int)
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{ref}"
                    config.params.ref
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/commits/{ref}/check-suites"
                        )
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "app_id"
                                (String.fromInt mapUnpack)
                        )
                        config.params.app_id
                    , Maybe.map
                        (Url.Builder.string "check_name")
                        config.params.check_name
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Users with pull access in a repository can access a combined view of commit statuses for a given ref. The ref can be a SHA, a branch name, or a tag name.


Additionally, a combined `state` is returned. The `state` is one of:

*   **failure** if any of the contexts report as `error` or `failure`
*   **pending** if there are no statuses or a context is `pending`
*   **success** if the latest status for all contexts is `success`
-}
reposGetCombinedStatusForRef :
    { toMsg : Result Http.Error CombinedCommitStatus -> msg
    , params :
        { owner : String
        , repo : String
        , ref : String
        , per_page : Maybe Int
        , page : Maybe Int
        }
    }
    -> Cmd msg
reposGetCombinedStatusForRef config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeCombinedCommitStatus
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{ref}"
                    config.params.ref
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/commits/{ref}/status"
                        )
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Users with pull access in a repository can view commit statuses for a given ref. The ref can be a SHA, a branch name, or a tag name. Statuses are returned in reverse chronological order. The first status in the list will be the latest one.

This resource is also available via a legacy route: `GET /repos/:owner/:repo/statuses/:ref`.
-}
reposListCommitStatusesForRef :
    { toMsg : Result Http.Error (List Status) -> msg
    , params :
        { owner : String
        , repo : String
        , ref : String
        , per_page : Maybe Int
        , page : Maybe Int
        }
    }
    -> Cmd msg
reposListCommitStatusesForRef config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.list decodeStatus)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{ref}"
                    config.params.ref
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/commits/{ref}/statuses"
                        )
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Returns all community profile metrics for a repository. The repository must be public, and cannot be a fork.

The returned metrics include an overall health score, the repository description, the presence of documentation, the
detected code of conduct, the detected license, and the presence of ISSUE\_TEMPLATE, PULL\_REQUEST\_TEMPLATE,
README, and CONTRIBUTING files.

The `health_percentage` score is defined as a percentage of how many of
these four documents are present: README, CONTRIBUTING, LICENSE, and
CODE_OF_CONDUCT. For example, if all four documents are present, then
the `health_percentage` is `100`. If only one is present, then the
`health_percentage` is `25`.

`content_reports_enabled` is only returned for organization-owned repositories.
-}
reposGetCommunityProfileMetrics :
    { toMsg : Result Http.Error CommunityProfile -> msg
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
reposGetCommunityProfileMetrics config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeCommunityProfile
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/community/profile"
                )
        }


{-| The `basehead` param is comprised of two parts separated by triple dots: `{base}...{head}`. Both must be branch names in `repo`. To compare branches across other repositories in the same network as `repo`, use the format `<USERNAME>:branch`.

The response from the API is equivalent to running the `git log base..head` command; however, commits are returned in chronological order. Pass the appropriate [media type](https://docs.github.com/rest/overview/media-types/#commits-commit-comparison-and-pull-requests) to fetch diff and patch formats.

The response also includes details on the files that were changed between the two commits. This includes the status of the change (for example, if a file was added, removed, modified, or renamed), and details of the change itself. For example, files with a `renamed` status have a `previous_filename` field showing the previous filename of the file, and files with a `modified` status have a `patch` field showing the changes made to the file.

**Working with large comparisons**

To process a response with a large number of commits, you can use (`per_page` or `page`) to paginate the results. When using paging, the list of changed files is only returned with page 1, but includes all changed files for the entire comparison. For more information on working with pagination, see "[Traversing with pagination](/rest/guides/traversing-with-pagination)."

When calling this API without any paging parameters (`per_page` or `page`), the returned list is limited to 250 commits and the last commit in the list is the most recent of the entire comparison. When a paging parameter is specified, the first commit in the returned list of each page is the earliest.

**Signature verification object**

The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:

| Name | Type | Description |
| ---- | ---- | ----------- |
| `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
| `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. |
| `signature` | `string` | The signature that was extracted from the commit. |
| `payload` | `string` | The value that was signed. |

These are the possible values for `reason` in the `verification` object:

| Value | Description |
| ----- | ----------- |
| `expired_key` | The key that made the signature is expired. |
| `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
| `gpgverify_error` | There was an error communicating with the signature verification service. |
| `gpgverify_unavailable` | The signature verification service is currently unavailable. |
| `unsigned` | The object does not include a signature. |
| `unknown_signature_type` | A non-PGP signature was found in the commit. |
| `no_user` | No user was associated with the `committer` email address in the commit. |
| `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on her/his account. |
| `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
| `unknown_key` | The key that made the signature has not been registered with any user's account. |
| `malformed_signature` | There was an error parsing the signature. |
| `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
| `valid` | None of the above errors applied, so the signature is considered to be verified. |
-}
reposCompareCommits :
    { toMsg : Result Http.Error CommitComparison -> msg
    , params :
        { owner : String
        , repo : String
        , page : Maybe Int
        , per_page : Maybe Int
        , basehead : String
        }
    }
    -> Cmd msg
reposCompareCommits config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeCommitComparison
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{basehead}"
                    config.params.basehead
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/compare/{basehead}"
                        )
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    ]
                )
        }


{-| Gets the contents of a file or directory in a repository. Specify the file path or directory in `:path`. If you omit
`:path`, you will receive the contents of the repository's root directory. See the description below regarding what the API response includes for directories. 

Files and symlinks support [a custom media type](https://docs.github.com/rest/reference/repos#custom-media-types) for
retrieving the raw content or rendered HTML (when supported). All content types support [a custom media
type](https://docs.github.com/rest/reference/repos#custom-media-types) to ensure the content is returned in a consistent
object format.

**Notes**:
*   To get a repository's contents recursively, you can [recursively get the tree](https://docs.github.com/rest/reference/git#trees).
*   This API has an upper limit of 1,000 files for a directory. If you need to retrieve more files, use the [Git Trees
API](https://docs.github.com/rest/reference/git#get-a-tree).
 *  Download URLs expire and are meant to be used just once. To ensure the download URL does not expire, please use the contents API to obtain a fresh download URL for each download.
#### Size limits
If the requested file's size is:
* 1 MB or smaller: All features of this endpoint are supported.
* Between 1-100 MB: Only the `raw` or `object` [custom media types](https://docs.github.com/rest/repos/contents#custom-media-types-for-repository-contents) are supported. Both will work as normal, except that when using the `object` media type, the `content` field will be an empty string and the `encoding` field will be `"none"`. To get the contents of these larger files, use the `raw` media type.
 * Greater than 100 MB: This endpoint is not supported.

#### If the content is a directory
The response will be an array of objects, one object for each item in the directory.
When listing the contents of a directory, submodules have their "type" specified as "file". Logically, the value
_should_ be "submodule". This behavior exists in API v3 [for backwards compatibility purposes](https://git.io/v1YCW).
In the next major version of the API, the type will be returned as "submodule".

#### If the content is a symlink 
If the requested `:path` points to a symlink, and the symlink's target is a normal file in the repository, then the
API responds with the content of the file (in the format shown in the example. Otherwise, the API responds with an object 
describing the symlink itself.

#### If the content is a submodule
The `submodule_git_url` identifies the location of the submodule repository, and the `sha` identifies a specific
commit within the submodule repository. Git uses the given URL when cloning the submodule repository, and checks out
the submodule at that specific commit.

If the submodule repository is not hosted on github.com, the Git URLs (`git_url` and `_links["git"]`) and the
github.com URLs (`html_url` and `_links["html"]`) will have null values.
-}
reposGetContent :
    { toMsg : Result Http.Error Json.Encode.Value -> msg
    , params :
        { owner : String, repo : String, path : String, ref : Maybe String }
    }
    -> Cmd msg
reposGetContent config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg Json.Decode.value
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{path}"
                    config.params.path
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/contents/{path}"
                        )
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map (Url.Builder.string "ref") config.params.ref ]
                )
        }


{-| Creates a new file or replaces an existing file in a repository. You must authenticate using an access token with the `workflow` scope to use this endpoint.

**Note:** If you use this endpoint and the "[Delete a file](https://docs.github.com/rest/reference/repos/#delete-file)" endpoint in parallel, the concurrent requests will conflict and you will receive errors. You must use these endpoints serially instead.
-}
reposCreateOrUpdateFileContents :
    { toMsg : Result Http.Error FileCommit -> msg
    , body :
        { author : { date : String, email : String, name : String }
        , branch : String
        , committer : { date : String, email : String, name : String }
        , content : String
        , message : String
        , sha : String
        }
    , params : { owner : String, repo : String, path : String }
    }
    -> Cmd msg
reposCreateOrUpdateFileContents config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeFileCommit
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "author"
                           , (\rec0 ->
                                 Json.Encode.object
                                     [ ( "date", Json.Encode.string rec0.date )
                                     , ( "email"
                                       , Json.Encode.string rec0.email
                                       )
                                     , ( "name", Json.Encode.string rec0.name )
                                     ]
                             )
                                 rec.author
                           )
                         , ( "branch", Json.Encode.string rec.branch )
                         , ( "committer"
                           , (\rec0 ->
                                 Json.Encode.object
                                     [ ( "date", Json.Encode.string rec0.date )
                                     , ( "email"
                                       , Json.Encode.string rec0.email
                                       )
                                     , ( "name", Json.Encode.string rec0.name )
                                     ]
                             )
                                 rec.committer
                           )
                         , ( "content", Json.Encode.string rec.content )
                         , ( "message", Json.Encode.string rec.message )
                         , ( "sha", Json.Encode.string rec.sha )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{path}"
                config.params.path
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/contents/{path}"
                    )
                )
        }


{-| Deletes a file in a repository.

You can provide an additional `committer` parameter, which is an object containing information about the committer. Or, you can provide an `author` parameter, which is an object containing information about the author.

The `author` section is optional and is filled in with the `committer` information if omitted. If the `committer` information is omitted, the authenticated user's information is used.

You must provide values for both `name` and `email`, whether you choose to use `author` or `committer`. Otherwise, you'll receive a `422` status code.

**Note:** If you use this endpoint and the "[Create or update file contents](https://docs.github.com/rest/reference/repos/#create-or-update-file-contents)" endpoint in parallel, the concurrent requests will conflict and you will receive errors. You must use these endpoints serially instead.
-}
reposDeleteFile :
    { toMsg : Result Http.Error FileCommit -> msg
    , body :
        { author : { email : String, name : String }
        , branch : String
        , committer : { email : String, name : String }
        , message : String
        , sha : String
        }
    , params : { owner : String, repo : String, path : String }
    }
    -> Cmd msg
reposDeleteFile config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeFileCommit
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "author"
                           , (\rec0 ->
                                 Json.Encode.object
                                     [ ( "email"
                                       , Json.Encode.string rec0.email
                                       )
                                     , ( "name", Json.Encode.string rec0.name )
                                     ]
                             )
                                 rec.author
                           )
                         , ( "branch", Json.Encode.string rec.branch )
                         , ( "committer"
                           , (\rec0 ->
                                 Json.Encode.object
                                     [ ( "email"
                                       , Json.Encode.string rec0.email
                                       )
                                     , ( "name", Json.Encode.string rec0.name )
                                     ]
                             )
                                 rec.committer
                           )
                         , ( "message", Json.Encode.string rec.message )
                         , ( "sha", Json.Encode.string rec.sha )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{path}"
                config.params.path
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/contents/{path}"
                    )
                )
        }


{-| Lists contributors to the specified repository and sorts them by the number of commits per contributor in descending order. This endpoint may return information that is a few hours old because the GitHub REST API v3 caches contributor data to improve performance.

GitHub identifies contributors by author email address. This endpoint groups contribution counts by GitHub user, which includes all associated email addresses. To improve performance, only the first 500 author email addresses in the repository link to GitHub users. The rest will appear as anonymous contributors without associated GitHub user information.
-}
reposListContributors :
    { toMsg : Result Http.Error (List Contributor) -> msg
    , params :
        { owner : String
        , repo : String
        , anon : Maybe String
        , per_page : Maybe Int
        , page : Maybe Int
        }
    }
    -> Cmd msg
reposListContributors config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeContributor)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/contributors"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map (Url.Builder.string "anon") config.params.anon
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| You must use an access token with the `security_events` scope to use this endpoint with private repositories.
You can also use tokens with the `public_repo` scope for public repositories only.
GitHub Apps must have **Dependabot alerts** read permission to use this endpoint.
-}
dependabotListAlertsForRepo :
    { toMsg : Result Http.Error (List DependabotAlert) -> msg
    , params :
        { owner : String
        , repo : String
        , state : Maybe String
        , severity : Maybe String
        , ecosystem : Maybe String
        , package : Maybe String
        , manifest : Maybe String
        , scope : Maybe String
        , sort : Maybe String
        , direction : Maybe String
        , page : Maybe Int
        , per_page : Maybe Int
        }
    }
    -> Cmd msg
dependabotListAlertsForRepo config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeDependabotAlert)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/dependabot/alerts"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map (Url.Builder.string "state") config.params.state
                    , Maybe.map
                        (Url.Builder.string "severity")
                        config.params.severity
                    , Maybe.map
                        (Url.Builder.string "ecosystem")
                        config.params.ecosystem
                    , Maybe.map
                        (Url.Builder.string "package")
                        config.params.package
                    , Maybe.map
                        (Url.Builder.string "manifest")
                        config.params.manifest
                    , Maybe.map (Url.Builder.string "scope") config.params.scope
                    , Maybe.map (Url.Builder.string "sort") config.params.sort
                    , Maybe.map
                        (Url.Builder.string "direction")
                        config.params.direction
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    ]
                )
        }


{-| You must use an access token with the `security_events` scope to use this endpoint with private repositories.
You can also use tokens with the `public_repo` scope for public repositories only.
GitHub Apps must have **Dependabot alerts** read permission to use this endpoint.
-}
dependabotGetAlert config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeDependabotAlert
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{alert_number}"
                config.params.alert_number
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/dependabot/alerts/{alert_number}"
                    )
                )
        }


{-| You must use an access token with the `security_events` scope to use this endpoint with private repositories.
You can also use tokens with the `public_repo` scope for public repositories only.
GitHub Apps must have **Dependabot alerts** write permission to use this endpoint.
-}
dependabotUpdateAlert config =
    Http.request
        { method = "PATCH"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeDependabotAlert
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "dismissed_comment"
                           , Json.Encode.string rec.dismissed_comment
                           )
                         , ( "dismissed_reason"
                           , Json.Encode.string rec.dismissed_reason
                           )
                         , ( "state", Json.Encode.string rec.state )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{alert_number}"
                config.params.alert_number
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/dependabot/alerts/{alert_number}"
                    )
                )
        }


{-| Lists all secrets available in a repository without revealing their encrypted values. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `dependabot_secrets` repository permission to use this endpoint. -}
dependabotListRepoSecrets config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\secrets total_count ->
                      { secrets = secrets, total_count = total_count }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "secrets"
                            (Json.Decode.list decodeDependabotSecret)
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.int)
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/dependabot/secrets"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before you can create or update secrets. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `dependabot_secrets` repository permission to use this endpoint. -}
dependabotGetRepoPublicKey :
    { toMsg : Result Http.Error DependabotPublicKey -> msg
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
dependabotGetRepoPublicKey config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeDependabotPublicKey
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/dependabot/secrets/public-key"
                )
        }


{-| Gets a single repository secret without revealing its encrypted value. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `dependabot_secrets` repository permission to use this endpoint. -}
dependabotGetRepoSecret :
    { toMsg : Result Http.Error DependabotSecret -> msg
    , params : { owner : String, repo : String, secret_name : String }
    }
    -> Cmd msg
dependabotGetRepoSecret config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeDependabotSecret
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{secret_name}"
                config.params.secret_name
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
                    )
                )
        }


{-| Creates or updates a repository secret with an encrypted value. Encrypt your secret using
[LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must authenticate using an access
token with the `repo` scope to use this endpoint. GitHub Apps must have the `dependabot_secrets` repository
permission to use this endpoint.

#### Example encrypting a secret using Node.js

Encrypt your secret using the [tweetsodium](https://github.com/github/tweetsodium) library.

```
const sodium = require('tweetsodium');

const key = "base64-encoded-public-key";
const value = "plain-text-secret";

// Convert the message and key to Uint8Array's (Buffer implements that interface)
const messageBytes = Buffer.from(value);
const keyBytes = Buffer.from(key, 'base64');

// Encrypt using LibSodium.
const encryptedBytes = sodium.seal(messageBytes, keyBytes);

// Base64 the encrypted secret
const encrypted = Buffer.from(encryptedBytes).toString('base64');

console.log(encrypted);
```


#### Example encrypting a secret using Python

Encrypt your secret using [pynacl](https://pynacl.readthedocs.io/en/latest/public/#nacl-public-sealedbox) with Python 3.

```
from base64 import b64encode
from nacl import encoding, public

def encrypt(public_key: str, secret_value: str) -> str:
  """Encrypt a Unicode string using the public key."""
  public_key = public.PublicKey(public_key.encode("utf-8"), encoding.Base64Encoder())
  sealed_box = public.SealedBox(public_key)
  encrypted = sealed_box.encrypt(secret_value.encode("utf-8"))
  return b64encode(encrypted).decode("utf-8")
```

#### Example encrypting a secret using C#

Encrypt your secret using the [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package.

```
var secretValue = System.Text.Encoding.UTF8.GetBytes("mySecret");
var publicKey = Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=");

var sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);

Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));
```

#### Example encrypting a secret using Ruby

Encrypt your secret using the [rbnacl](https://github.com/RubyCrypto/rbnacl) gem.

```ruby
require "rbnacl"
require "base64"

key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=")
public_key = RbNaCl::PublicKey.new(key)

box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
encrypted_secret = box.encrypt("my_secret")

# Print the base64 encoded secret
puts Base64.strict_encode64(encrypted_secret)
```
-}
dependabotCreateOrUpdateRepoSecret :
    { toMsg : Result Http.Error EmptyObject -> msg
    , body : { encrypted_value : String, key_id : String }
    , params : { owner : String, repo : String, secret_name : String }
    }
    -> Cmd msg
dependabotCreateOrUpdateRepoSecret config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeEmptyObject
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "encrypted_value"
                           , Json.Encode.string rec.encrypted_value
                           )
                         , ( "key_id", Json.Encode.string rec.key_id )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{secret_name}"
                config.params.secret_name
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
                    )
                )
        }


{-| Deletes a secret in a repository using the secret name. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `dependabot_secrets` repository permission to use this endpoint. -}
dependabotDeleteRepoSecret :
    { toMsg : Result Http.Error () -> msg
    , params : { owner : String, repo : String, secret_name : String }
    }
    -> Cmd msg
dependabotDeleteRepoSecret config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{secret_name}"
                config.params.secret_name
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
                    )
                )
        }


{-| Gets the diff of the dependency changes between two commits of a repository, based on the changes to the dependency manifests made in those commits. -}
dependencyGraphDiffRange :
    { toMsg : Result Http.Error DependencyGraphDiff -> msg
    , params :
        { owner : String
        , repo : String
        , basehead : String
        , name : Maybe String
        }
    }
    -> Cmd msg
dependencyGraphDiffRange config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeDependencyGraphDiff
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{basehead}"
                    config.params.basehead
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/dependency-graph/compare/{basehead}"
                        )
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map (Url.Builder.string "name") config.params.name ]
                )
        }


{-| Create a new snapshot of a repository's dependencies. You must authenticate using an access token with the `repo` scope to use this endpoint for a repository that the requesting user has access to. -}
dependencyGraphCreateRepositorySnapshot config =
    Http.request
        { method = "POST"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\created_at id message result ->
                      { created_at = created_at
                      , id = id
                      , message = message
                      , result = result
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "created_at" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "id" Json.Decode.int)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "message" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "result" Json.Decode.string)
                )
        , body = Http.jsonBody (encodeSnapshot config.body)
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/dependency-graph/snapshots"
                )
        }


{-| Simple filtering of deployments is available via query parameters: -}
reposListDeployments :
    { toMsg : Result Http.Error (List Deployment) -> msg
    , params :
        { owner : String
        , repo : String
        , sha : Maybe String
        , ref : Maybe String
        , task : Maybe String
        , environment : Maybe (Nullable String)
        , per_page : Maybe Int
        , page : Maybe Int
        }
    }
    -> Cmd msg
reposListDeployments config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeDeployment)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/deployments"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map (Url.Builder.string "sha") config.params.sha
                    , Maybe.map (Url.Builder.string "ref") config.params.ref
                    , Maybe.map (Url.Builder.string "task") config.params.task
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "environment"
                                (Debug.todo
                                    "Params of type \"(Nullable String)\" (in helper)"
                                )
                        )
                        config.params.environment
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Deployments offer a few configurable parameters with certain defaults.

The `ref` parameter can be any named branch, tag, or SHA. At GitHub we often deploy branches and verify them
before we merge a pull request.

The `environment` parameter allows deployments to be issued to different runtime environments. Teams often have
multiple environments for verifying their applications, such as `production`, `staging`, and `qa`. This parameter
makes it easier to track which environments have requested deployments. The default environment is `production`.

The `auto_merge` parameter is used to ensure that the requested ref is not behind the repository's default branch. If
the ref _is_ behind the default branch for the repository, we will attempt to merge it for you. If the merge succeeds,
the API will return a successful merge commit. If merge conflicts prevent the merge from succeeding, the API will
return a failure response.

By default, [commit statuses](https://docs.github.com/rest/commits/statuses) for every submitted context must be in a `success`
state. The `required_contexts` parameter allows you to specify a subset of contexts that must be `success`, or to
specify contexts that have not yet been submitted. You are not required to use commit statuses to deploy. If you do
not require any contexts or create any commit statuses, the deployment will always succeed.

The `payload` parameter is available for any extra information that a deployment system might need. It is a JSON text
field that will be passed on when a deployment event is dispatched.

The `task` parameter is used by the deployment system to allow different execution paths. In the web world this might
be `deploy:migrations` to run schema changes on the system. In the compiled world this could be a flag to compile an
application with debugging enabled.

Users with `repo` or `repo_deployment` scopes can create a deployment for a given ref.

#### Merged branch response
You will see this response when GitHub automatically merges the base branch into the topic branch instead of creating
a deployment. This auto-merge happens when:
*   Auto-merge option is enabled in the repository
*   Topic branch does not include the latest changes on the base branch, which is `master` in the response example
*   There are no merge conflicts

If there are no new commits in the base branch, a new request to create a deployment should give a successful
response.

#### Merge conflict response
This error happens when the `auto_merge` option is enabled and when the default branch (in this case `master`), can't
be merged into the branch that's being deployed (in this case `topic-branch`), due to merge conflicts.

#### Failed commit status checks
This error happens when the `required_contexts` parameter indicates that one or more contexts need to have a `success`
status for the commit to be deployed, but one or more of the required contexts do not have a state of `success`.
-}
reposCreateDeployment :
    { toMsg : Result Http.Error Deployment -> msg
    , body :
        { auto_merge : Bool
        , description : Nullable String
        , environment : String
        , payload : Json.Encode.Value
        , production_environment : Bool
        , ref : String
        , required_contexts : List String
        , task : String
        , transient_environment : Bool
        }
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
reposCreateDeployment config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeDeployment
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "auto_merge", Json.Encode.bool rec.auto_merge )
                         , ( "description"
                           , (\nullableValue ->
                                 case nullableValue of
                                     Null ->
                                         Json.Encode.null

                                     Present value ->
                                         Json.Encode.string value
                             )
                                 rec.description
                           )
                         , ( "environment", Json.Encode.string rec.environment )
                         , ( "payload", Basics.identity rec.payload )
                         , ( "production_environment"
                           , Json.Encode.bool rec.production_environment
                           )
                         , ( "ref", Json.Encode.string rec.ref )
                         , ( "required_contexts"
                           , Json.Encode.list Json.Encode.string
                                 rec.required_contexts
                           )
                         , ( "task", Json.Encode.string rec.task )
                         , ( "transient_environment"
                           , Json.Encode.bool rec.transient_environment
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/deployments"
                )
        }


reposGetDeployment config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeDeployment
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{deployment_id}"
                config.params.deployment_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/deployments/{deployment_id}"
                    )
                )
        }


{-| If the repository only has one deployment, you can delete the deployment regardless of its status. If the repository has more than one deployment, you can only delete inactive deployments. This ensures that repositories with multiple deployments will always have an active deployment. Anyone with `repo` or `repo_deployment` scopes can delete a deployment.

To set a deployment as inactive, you must:

*   Create a new deployment that is active so that the system has a record of the current state, then delete the previously active deployment.
*   Mark the active deployment as inactive by adding any non-successful deployment status.

For more information, see "[Create a deployment](https://docs.github.com/rest/reference/repos/#create-a-deployment)" and "[Create a deployment status](https://docs.github.com/rest/reference/repos#create-a-deployment-status)."
-}
reposDeleteDeployment config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{deployment_id}"
                config.params.deployment_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/deployments/{deployment_id}"
                    )
                )
        }


{-| Users with pull access can view deployment statuses for a deployment: -}
reposListDeploymentStatuses config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeDeploymentStatus)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{deployment_id}"
                    config.params.deployment_id
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/deployments/{deployment_id}/statuses"
                        )
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Users with `push` access can create deployment statuses for a given deployment.

GitHub Apps require `read & write` access to "Deployments" and `read-only` access to "Repo contents" (for private repos). OAuth Apps require the `repo_deployment` scope.
-}
reposCreateDeploymentStatus config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeDeploymentStatus
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "auto_inactive"
                           , Json.Encode.bool rec.auto_inactive
                           )
                         , ( "description", Json.Encode.string rec.description )
                         , ( "environment", Json.Encode.string rec.environment )
                         , ( "environment_url"
                           , Json.Encode.string rec.environment_url
                           )
                         , ( "log_url", Json.Encode.string rec.log_url )
                         , ( "state", Json.Encode.string rec.state )
                         , ( "target_url", Json.Encode.string rec.target_url )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{deployment_id}"
                config.params.deployment_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/deployments/{deployment_id}/statuses"
                    )
                )
        }


{-| Users with pull access can view a deployment status for a deployment: -}
reposGetDeploymentStatus config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeDeploymentStatus
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{status_id}"
                config.params.status_id
                (String.replace
                    "{deployment_id}"
                    config.params.deployment_id
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}"
                        )
                    )
                )
        }


{-| You can use this endpoint to trigger a webhook event called `repository_dispatch` when you want activity that happens outside of GitHub to trigger a GitHub Actions workflow or GitHub App webhook. You must configure your GitHub Actions workflow or GitHub App to run when the `repository_dispatch` event occurs. For an example `repository_dispatch` webhook payload, see "[RepositoryDispatchEvent](https://docs.github.com/webhooks/event-payloads/#repository_dispatch)."

The `client_payload` parameter is available for any extra information that your workflow might need. This parameter is a JSON payload that will be passed on when the webhook event is dispatched. For example, the `client_payload` can include a message that a user would like to send using a GitHub Actions workflow. Or the `client_payload` can be used as a test to debug your workflow.

This endpoint requires write access to the repository by providing either:

  - Personal access tokens with `repo` scope. For more information, see "[Creating a personal access token for the command line](https://docs.github.com/articles/creating-a-personal-access-token-for-the-command-line)" in the GitHub Help documentation.
  - GitHub Apps with both `metadata:read` and `contents:read&write` permissions.

This input example shows how you can use the `client_payload` as a test to debug your workflow.
-}
reposCreateDispatchEvent :
    { toMsg : Result Http.Error () -> msg
    , body : { client_payload : {}, event_type : String }
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
reposCreateDispatchEvent config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "client_payload"
                           , (\rec0 -> Json.Encode.object []) rec.client_payload
                           )
                         , ( "event_type", Json.Encode.string rec.event_type )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/dispatches"
                )
        }


{-| Lists the environments for a repository.

Anyone with read access to the repository can use this endpoint. If the repository is private, you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
-}
reposGetAllEnvironments config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\environments total_count ->
                      { environments = environments, total_count = total_count }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "environments"
                            (Json.Decode.list decodeEnvironment)
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.int)
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/environments"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| **Note:** To get information about name patterns that branches must match in order to deploy to this environment, see "[Get a deployment branch policy](/rest/deployments/branch-policies#get-a-deployment-branch-policy)."

Anyone with read access to the repository can use this endpoint. If the
repository is private, you must use an access token with the `repo` scope. GitHub
Apps must have the `actions:read` permission to use this endpoint.
-}
reposGetEnvironment :
    { toMsg : Result Http.Error Environment -> msg
    , params : { owner : String, repo : String, environment_name : String }
    }
    -> Cmd msg
reposGetEnvironment config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeEnvironment
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{environment_name}"
                config.params.environment_name
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/environments/{environment_name}"
                    )
                )
        }


{-| Create or update an environment with protection rules, such as required reviewers. For more information about environment protection rules, see "[Environments](/actions/reference/environments#environment-protection-rules)."

**Note:** To create or update name patterns that branches must match in order to deploy to this environment, see "[Deployment branch policies](/rest/deployments/branch-policies)."

**Note:** To create or update secrets for an environment, see "[Secrets](/rest/reference/actions#secrets)."

You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `administration:write` permission for the repository to use this endpoint.
-}
reposCreateOrUpdateEnvironment config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeEnvironment
        , body =
            Http.jsonBody
                ((\nullableValue ->
                     case nullableValue of
                         Null ->
                             Json.Encode.null

                         Present value ->
                             (\rec ->
                                 Json.Encode.object
                                     [ ( "deployment_branch_policy"
                                       , encodeDeploymentBranchPolicySettings
                                             rec.deployment_branch_policy
                                       )
                                     , ( "reviewers"
                                       , (\nullableValue0 ->
                                             case nullableValue0 of
                                                 Null ->
                                                     Json.Encode.null

                                                 Present value0 ->
                                                     Json.Encode.list
                                                         (\rec0 ->
                                                             Json.Encode.object
                                                                 [ ( "id"
                                                                   , Json.Encode.int
                                                                         rec0.id
                                                                   )
                                                                 , ( "type"
                                                                   , encodeDeploymentReviewerType
                                                                         rec0.type_
                                                                   )
                                                                 ]
                                                         )
                                                         value0
                                         )
                                             rec.reviewers
                                       )
                                     , ( "wait_timer"
                                       , encodeWaitTimer rec.wait_timer
                                       )
                                     ]
                             )
                                 value
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{environment_name}"
                config.params.environment_name
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/environments/{environment_name}"
                    )
                )
        }


{-| You must authenticate using an access token with the repo scope to use this endpoint. -}
reposDeleteAnEnvironment :
    { toMsg : Result Http.Error () -> msg
    , params : { owner : String, repo : String, environment_name : String }
    }
    -> Cmd msg
reposDeleteAnEnvironment config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{environment_name}"
                config.params.environment_name
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/environments/{environment_name}"
                    )
                )
        }


{-| Lists the deployment branch policies for an environment.

Anyone with read access to the repository can use this endpoint. If the repository is private, you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
-}
reposListDeploymentBranchPolicies config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\branch_policies total_count ->
                      { branch_policies = branch_policies
                      , total_count = total_count
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "branch_policies"
                            (Json.Decode.list decodeDeploymentBranchPolicy)
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.int)
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{environment_name}"
                    config.params.environment_name
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"
                        )
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Creates a deployment branch policy for an environment.

You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `administration:write` permission for the repository to use this endpoint.
-}
reposCreateDeploymentBranchPolicy :
    { toMsg : Result Http.Error DeploymentBranchPolicy -> msg
    , body : DeploymentBranchPolicyNamePattern
    , params : { owner : String, repo : String, environment_name : String }
    }
    -> Cmd msg
reposCreateDeploymentBranchPolicy config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeDeploymentBranchPolicy
        , body =
            Http.jsonBody (encodeDeploymentBranchPolicyNamePattern config.body)
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{environment_name}"
                config.params.environment_name
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"
                    )
                )
        }


{-| Gets a deployment branch policy for an environment.

Anyone with read access to the repository can use this endpoint. If the repository is private, you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
-}
reposGetDeploymentBranchPolicy config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeDeploymentBranchPolicy
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{branch_policy_id}"
                config.params.branch_policy_id
                (String.replace
                    "{environment_name}"
                    config.params.environment_name
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
                        )
                    )
                )
        }


{-| Updates a deployment branch policy for an environment.

You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `administration:write` permission for the repository to use this endpoint.
-}
reposUpdateDeploymentBranchPolicy config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeDeploymentBranchPolicy
        , body =
            Http.jsonBody (encodeDeploymentBranchPolicyNamePattern config.body)
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{branch_policy_id}"
                config.params.branch_policy_id
                (String.replace
                    "{environment_name}"
                    config.params.environment_name
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
                        )
                    )
                )
        }


{-| Deletes a deployment branch policy for an environment.

You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `administration:write` permission for the repository to use this endpoint.
-}
reposDeleteDeploymentBranchPolicy config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{branch_policy_id}"
                config.params.branch_policy_id
                (String.replace
                    "{environment_name}"
                    config.params.environment_name
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
                        )
                    )
                )
        }


activityListRepoEvents :
    { toMsg : Result Http.Error (List Event) -> msg
    , params :
        { owner : String
        , repo : String
        , per_page : Maybe Int
        , page : Maybe Int
        }
    }
    -> Cmd msg
activityListRepoEvents config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.list decodeEvent)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/events"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


reposListForks :
    { toMsg : Result Http.Error (List MinimalRepository) -> msg
    , params :
        { owner : String
        , repo : String
        , sort : Maybe String
        , per_page : Maybe Int
        , page : Maybe Int
        }
    }
    -> Cmd msg
reposListForks config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeMinimalRepository)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/forks"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map (Url.Builder.string "sort") config.params.sort
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Create a fork for the authenticated user.

**Note**: Forking a Repository happens asynchronously. You may have to wait a short period of time before you can access the git objects. If this takes longer than 5 minutes, be sure to contact [GitHub Support](https://support.github.com/contact?tags=dotcom-rest-api).
-}
reposCreateFork :
    { toMsg : Result Http.Error FullRepository -> msg
    , body :
        Nullable { default_branch_only : Bool
        , name : String
        , organization : String
        }
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
reposCreateFork config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeFullRepository
        , body =
            Http.jsonBody
                ((\nullableValue ->
                     case nullableValue of
                         Null ->
                             Json.Encode.null

                         Present value ->
                             (\rec ->
                                 Json.Encode.object
                                     [ ( "default_branch_only"
                                       , Json.Encode.bool
                                             rec.default_branch_only
                                       )
                                     , ( "name", Json.Encode.string rec.name )
                                     , ( "organization"
                                       , Json.Encode.string rec.organization
                                       )
                                     ]
                             )
                                 value
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/forks"
                )
        }


gitCreateBlob :
    { toMsg : Result Http.Error ShortBlob -> msg
    , body : { content : String, encoding : String }
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
gitCreateBlob config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeShortBlob
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "content", Json.Encode.string rec.content )
                         , ( "encoding", Json.Encode.string rec.encoding )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/git/blobs"
                )
        }


{-| The `content` in the response will always be Base64 encoded.

_Note_: This API supports blobs up to 100 megabytes in size.
-}
gitGetBlob :
    { toMsg : Result Http.Error Blob -> msg
    , params : { owner : String, repo : String, file_sha : String }
    }
    -> Cmd msg
gitGetBlob config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeBlob
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{file_sha}"
                config.params.file_sha
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/git/blobs/{file_sha}"
                    )
                )
        }


{-| Creates a new Git [commit object](https://git-scm.com/book/en/v1/Git-Internals-Git-Objects#Commit-Objects).

**Signature verification object**

The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:

| Name | Type | Description |
| ---- | ---- | ----------- |
| `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
| `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in the table below. |
| `signature` | `string` | The signature that was extracted from the commit. |
| `payload` | `string` | The value that was signed. |

These are the possible values for `reason` in the `verification` object:

| Value | Description |
| ----- | ----------- |
| `expired_key` | The key that made the signature is expired. |
| `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
| `gpgverify_error` | There was an error communicating with the signature verification service. |
| `gpgverify_unavailable` | The signature verification service is currently unavailable. |
| `unsigned` | The object does not include a signature. |
| `unknown_signature_type` | A non-PGP signature was found in the commit. |
| `no_user` | No user was associated with the `committer` email address in the commit. |
| `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on her/his account. |
| `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
| `unknown_key` | The key that made the signature has not been registered with any user's account. |
| `malformed_signature` | There was an error parsing the signature. |
| `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
| `valid` | None of the above errors applied, so the signature is considered to be verified. |
-}
gitCreateCommit :
    { toMsg : Result Http.Error GitCommit -> msg
    , body :
        { author : { date : String, email : String, name : String }
        , committer : { date : String, email : String, name : String }
        , message : String
        , parents : List String
        , signature : String
        , tree : String
        }
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
gitCreateCommit config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeGitCommit
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "author"
                           , (\rec0 ->
                                 Json.Encode.object
                                     [ ( "date", Json.Encode.string rec0.date )
                                     , ( "email"
                                       , Json.Encode.string rec0.email
                                       )
                                     , ( "name", Json.Encode.string rec0.name )
                                     ]
                             )
                                 rec.author
                           )
                         , ( "committer"
                           , (\rec0 ->
                                 Json.Encode.object
                                     [ ( "date", Json.Encode.string rec0.date )
                                     , ( "email"
                                       , Json.Encode.string rec0.email
                                       )
                                     , ( "name", Json.Encode.string rec0.name )
                                     ]
                             )
                                 rec.committer
                           )
                         , ( "message", Json.Encode.string rec.message )
                         , ( "parents"
                           , Json.Encode.list Json.Encode.string rec.parents
                           )
                         , ( "signature", Json.Encode.string rec.signature )
                         , ( "tree", Json.Encode.string rec.tree )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/git/commits"
                )
        }


{-| Gets a Git [commit object](https://git-scm.com/book/en/v1/Git-Internals-Git-Objects#Commit-Objects).

**Signature verification object**

The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:

| Name | Type | Description |
| ---- | ---- | ----------- |
| `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
| `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in the table below. |
| `signature` | `string` | The signature that was extracted from the commit. |
| `payload` | `string` | The value that was signed. |

These are the possible values for `reason` in the `verification` object:

| Value | Description |
| ----- | ----------- |
| `expired_key` | The key that made the signature is expired. |
| `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
| `gpgverify_error` | There was an error communicating with the signature verification service. |
| `gpgverify_unavailable` | The signature verification service is currently unavailable. |
| `unsigned` | The object does not include a signature. |
| `unknown_signature_type` | A non-PGP signature was found in the commit. |
| `no_user` | No user was associated with the `committer` email address in the commit. |
| `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on her/his account. |
| `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
| `unknown_key` | The key that made the signature has not been registered with any user's account. |
| `malformed_signature` | There was an error parsing the signature. |
| `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
| `valid` | None of the above errors applied, so the signature is considered to be verified. |
-}
gitGetCommit :
    { toMsg : Result Http.Error GitCommit -> msg
    , params : { owner : String, repo : String, commit_sha : String }
    }
    -> Cmd msg
gitGetCommit config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeGitCommit
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{commit_sha}"
                config.params.commit_sha
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/git/commits/{commit_sha}"
                    )
                )
        }


{-| Returns an array of references from your Git database that match the supplied name. The `:ref` in the URL must be formatted as `heads/<branch name>` for branches and `tags/<tag name>` for tags. If the `:ref` doesn't exist in the repository, but existing refs start with `:ref`, they will be returned as an array.

When you use this endpoint without providing a `:ref`, it will return an array of all the references from your Git database, including notes and stashes if they exist on the server. Anything in the namespace is returned, not just `heads` and `tags`.

**Note:** You need to explicitly [request a pull request](https://docs.github.com/rest/reference/pulls#get-a-pull-request) to trigger a test merge commit, which checks the mergeability of pull requests. For more information, see "[Checking mergeability of pull requests](https://docs.github.com/rest/guides/getting-started-with-the-git-database-api#checking-mergeability-of-pull-requests)".

If you request matching references for a branch named `feature` but the branch `feature` doesn't exist, the response can still include other matching head refs that start with the word `feature`, such as `featureA` and `featureB`.
-}
gitListMatchingRefs :
    { toMsg : Result Http.Error (List GitRef) -> msg
    , params : { owner : String, repo : String, ref : String }
    }
    -> Cmd msg
gitListMatchingRefs config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.list decodeGitRef)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{ref}"
                config.params.ref
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/git/matching-refs/{ref}"
                    )
                )
        }


{-| Returns a single reference from your Git database. The `:ref` in the URL must be formatted as `heads/<branch name>` for branches and `tags/<tag name>` for tags. If the `:ref` doesn't match an existing ref, a `404` is returned.

**Note:** You need to explicitly [request a pull request](https://docs.github.com/rest/reference/pulls#get-a-pull-request) to trigger a test merge commit, which checks the mergeability of pull requests. For more information, see "[Checking mergeability of pull requests](https://docs.github.com/rest/guides/getting-started-with-the-git-database-api#checking-mergeability-of-pull-requests)".
-}
gitGetRef :
    { toMsg : Result Http.Error GitRef -> msg
    , params : { owner : String, repo : String, ref : String }
    }
    -> Cmd msg
gitGetRef config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeGitRef
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{ref}"
                config.params.ref
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/git/ref/{ref}"
                    )
                )
        }


{-| Creates a reference for your repository. You are unable to create new references for empty repositories, even if the commit SHA-1 hash used exists. Empty repositories are repositories without branches. -}
gitCreateRef :
    { toMsg : Result Http.Error GitRef -> msg
    , body : { key : String, ref : String, sha : String }
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
gitCreateRef config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeGitRef
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "key", Json.Encode.string rec.key )
                         , ( "ref", Json.Encode.string rec.ref )
                         , ( "sha", Json.Encode.string rec.sha )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/git/refs"
                )
        }


gitUpdateRef :
    { toMsg : Result Http.Error GitRef -> msg
    , body : { force : Bool, sha : String }
    , params : { owner : String, repo : String, ref : String }
    }
    -> Cmd msg
gitUpdateRef config =
    Http.request
        { method = "PATCH"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeGitRef
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "force", Json.Encode.bool rec.force )
                         , ( "sha", Json.Encode.string rec.sha )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{ref}"
                config.params.ref
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/git/refs/{ref}"
                    )
                )
        }


gitDeleteRef :
    { toMsg : Result Http.Error () -> msg
    , params : { owner : String, repo : String, ref : String }
    }
    -> Cmd msg
gitDeleteRef config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{ref}"
                config.params.ref
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/git/refs/{ref}"
                    )
                )
        }


{-| Note that creating a tag object does not create the reference that makes a tag in Git. If you want to create an annotated tag in Git, you have to do this call to create the tag object, and then [create](https://docs.github.com/rest/reference/git#create-a-reference) the `refs/tags/[tag]` reference. If you want to create a lightweight tag, you only have to [create](https://docs.github.com/rest/reference/git#create-a-reference) the tag reference - this call would be unnecessary.

**Signature verification object**

The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:

| Name | Type | Description |
| ---- | ---- | ----------- |
| `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
| `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. |
| `signature` | `string` | The signature that was extracted from the commit. |
| `payload` | `string` | The value that was signed. |

These are the possible values for `reason` in the `verification` object:

| Value | Description |
| ----- | ----------- |
| `expired_key` | The key that made the signature is expired. |
| `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
| `gpgverify_error` | There was an error communicating with the signature verification service. |
| `gpgverify_unavailable` | The signature verification service is currently unavailable. |
| `unsigned` | The object does not include a signature. |
| `unknown_signature_type` | A non-PGP signature was found in the commit. |
| `no_user` | No user was associated with the `committer` email address in the commit. |
| `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on her/his account. |
| `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
| `unknown_key` | The key that made the signature has not been registered with any user's account. |
| `malformed_signature` | There was an error parsing the signature. |
| `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
| `valid` | None of the above errors applied, so the signature is considered to be verified. |
-}
gitCreateTag :
    { toMsg : Result Http.Error GitTag -> msg
    , body :
        { message : String
        , object : String
        , tag : String
        , tagger : { date : String, email : String, name : String }
        , type_ : String
        }
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
gitCreateTag config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeGitTag
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "message", Json.Encode.string rec.message )
                         , ( "object", Json.Encode.string rec.object )
                         , ( "tag", Json.Encode.string rec.tag )
                         , ( "tagger"
                           , (\rec0 ->
                                 Json.Encode.object
                                     [ ( "date", Json.Encode.string rec0.date )
                                     , ( "email"
                                       , Json.Encode.string rec0.email
                                       )
                                     , ( "name", Json.Encode.string rec0.name )
                                     ]
                             )
                                 rec.tagger
                           )
                         , ( "type", Json.Encode.string rec.type_ )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/git/tags"
                )
        }


{-| **Signature verification object**

The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:

| Name | Type | Description |
| ---- | ---- | ----------- |
| `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
| `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. |
| `signature` | `string` | The signature that was extracted from the commit. |
| `payload` | `string` | The value that was signed. |

These are the possible values for `reason` in the `verification` object:

| Value | Description |
| ----- | ----------- |
| `expired_key` | The key that made the signature is expired. |
| `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
| `gpgverify_error` | There was an error communicating with the signature verification service. |
| `gpgverify_unavailable` | The signature verification service is currently unavailable. |
| `unsigned` | The object does not include a signature. |
| `unknown_signature_type` | A non-PGP signature was found in the commit. |
| `no_user` | No user was associated with the `committer` email address in the commit. |
| `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on her/his account. |
| `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
| `unknown_key` | The key that made the signature has not been registered with any user's account. |
| `malformed_signature` | There was an error parsing the signature. |
| `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
| `valid` | None of the above errors applied, so the signature is considered to be verified. |
-}
gitGetTag :
    { toMsg : Result Http.Error GitTag -> msg
    , params : { owner : String, repo : String, tag_sha : String }
    }
    -> Cmd msg
gitGetTag config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeGitTag
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{tag_sha}"
                config.params.tag_sha
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/git/tags/{tag_sha}"
                    )
                )
        }


{-| The tree creation API accepts nested entries. If you specify both a tree and a nested path modifying that tree, this endpoint will overwrite the contents of the tree with the new path contents, and create a new tree structure.

If you use this endpoint to add, delete, or modify the file contents in a tree, you will need to commit the tree and then update a branch to point to the commit. For more information see "[Create a commit](https://docs.github.com/rest/reference/git#create-a-commit)" and "[Update a reference](https://docs.github.com/rest/reference/git#update-a-reference)."

Returns an error if you try to delete a file that does not exist.
-}
gitCreateTree :
    { toMsg : Result Http.Error GitTree -> msg
    , body :
        { base_tree : String
        , tree :
            List { content : String
            , mode : String
            , path : String
            , sha : Nullable String
            , type_ : String
            }
        }
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
gitCreateTree config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeGitTree
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "base_tree", Json.Encode.string rec.base_tree )
                         , ( "tree"
                           , Json.Encode.list
                                 (\rec0 ->
                                     Json.Encode.object
                                         [ ( "content"
                                           , Json.Encode.string rec0.content
                                           )
                                         , ( "mode"
                                           , Json.Encode.string rec0.mode
                                           )
                                         , ( "path"
                                           , Json.Encode.string rec0.path
                                           )
                                         , ( "sha"
                                           , (\nullableValue ->
                                                 case nullableValue of
                                                     Null ->
                                                         Json.Encode.null

                                                     Present value ->
                                                         Json.Encode.string
                                                             value
                                             )
                                                 rec0.sha
                                           )
                                         , ( "type"
                                           , Json.Encode.string rec0.type_
                                           )
                                         ]
                                 )
                                 rec.tree
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/git/trees"
                )
        }


{-| Returns a single tree using the SHA1 value for that tree.

If `truncated` is `true` in the response then the number of items in the `tree` array exceeded our maximum limit. If you need to fetch more items, use the non-recursive method of fetching trees, and fetch one sub-tree at a time.


**Note**: The limit for the `tree` array is 100,000 entries with a maximum size of 7 MB when using the `recursive` parameter.
-}
gitGetTree :
    { toMsg : Result Http.Error GitTree -> msg
    , params :
        { owner : String
        , repo : String
        , tree_sha : String
        , recursive : Maybe String
        }
    }
    -> Cmd msg
gitGetTree config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeGitTree
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{tree_sha}"
                    config.params.tree_sha
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/git/trees/{tree_sha}"
                        )
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (Url.Builder.string "recursive")
                        config.params.recursive
                    ]
                )
        }


{-| Lists webhooks for a repository. `last response` may return null if there have not been any deliveries within 30 days. -}
reposListWebhooks :
    { toMsg : Result Http.Error (List Hook) -> msg
    , params :
        { owner : String
        , repo : String
        , per_page : Maybe Int
        , page : Maybe Int
        }
    }
    -> Cmd msg
reposListWebhooks config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.list decodeHook)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/hooks"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Repositories can have multiple webhooks installed. Each webhook should have a unique `config`. Multiple webhooks can
share the same `config` as long as those webhooks do not have any `events` that overlap.
-}
reposCreateWebhook :
    { toMsg : Result Http.Error Hook -> msg
    , body :
        Nullable { active : Bool
        , config :
            { content_type : WebhookConfigContentType
            , digest : String
            , insecure_ssl : WebhookConfigInsecureSsl
            , secret : WebhookConfigSecret
            , token : String
            , url : WebhookConfigUrl
            }
        , events : List String
        , name : String
        }
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
reposCreateWebhook config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeHook
        , body =
            Http.jsonBody
                ((\nullableValue ->
                     case nullableValue of
                         Null ->
                             Json.Encode.null

                         Present value ->
                             (\rec ->
                                 Json.Encode.object
                                     [ ( "active", Json.Encode.bool rec.active )
                                     , ( "config"
                                       , (\rec0 ->
                                             Json.Encode.object
                                                 [ ( "content_type"
                                                   , encodeWebhookConfigContentType
                                                         rec0.content_type
                                                   )
                                                 , ( "digest"
                                                   , Json.Encode.string
                                                         rec0.digest
                                                   )
                                                 , ( "insecure_ssl"
                                                   , encodeWebhookConfigInsecureSsl
                                                         rec0.insecure_ssl
                                                   )
                                                 , ( "secret"
                                                   , encodeWebhookConfigSecret
                                                         rec0.secret
                                                   )
                                                 , ( "token"
                                                   , Json.Encode.string
                                                         rec0.token
                                                   )
                                                 , ( "url"
                                                   , encodeWebhookConfigUrl
                                                         rec0.url
                                                   )
                                                 ]
                                         )
                                             rec.config
                                       )
                                     , ( "events"
                                       , Json.Encode.list Json.Encode.string
                                             rec.events
                                       )
                                     , ( "name", Json.Encode.string rec.name )
                                     ]
                             )
                                 value
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/hooks"
                )
        }


{-| Returns a webhook configured in a repository. To get only the webhook `config` properties, see "[Get a webhook configuration for a repository](/rest/reference/repos#get-a-webhook-configuration-for-a-repository)." -}
reposGetWebhook config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeHook
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{hook_id}"
                config.params.hook_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/hooks/{hook_id}"
                    )
                )
        }


{-| Updates a webhook configured in a repository. If you previously had a `secret` set, you must provide the same `secret` or set a new `secret` or the secret will be removed. If you are only updating individual webhook `config` properties, use "[Update a webhook configuration for a repository](/rest/reference/repos#update-a-webhook-configuration-for-a-repository)." -}
reposUpdateWebhook config =
    Http.request
        { method = "PATCH"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeHook
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "active", Json.Encode.bool rec.active )
                         , ( "add_events"
                           , Json.Encode.list Json.Encode.string rec.add_events
                           )
                         , ( "config"
                           , (\rec0 ->
                                 Json.Encode.object
                                     [ ( "address"
                                       , Json.Encode.string rec0.address
                                       )
                                     , ( "content_type"
                                       , encodeWebhookConfigContentType
                                             rec0.content_type
                                       )
                                     , ( "insecure_ssl"
                                       , encodeWebhookConfigInsecureSsl
                                             rec0.insecure_ssl
                                       )
                                     , ( "room", Json.Encode.string rec0.room )
                                     , ( "secret"
                                       , encodeWebhookConfigSecret rec0.secret
                                       )
                                     , ( "url"
                                       , encodeWebhookConfigUrl rec0.url
                                       )
                                     ]
                             )
                                 rec.config
                           )
                         , ( "events"
                           , Json.Encode.list Json.Encode.string rec.events
                           )
                         , ( "remove_events"
                           , Json.Encode.list Json.Encode.string
                                 rec.remove_events
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{hook_id}"
                config.params.hook_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/hooks/{hook_id}"
                    )
                )
        }


reposDeleteWebhook config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{hook_id}"
                config.params.hook_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/hooks/{hook_id}"
                    )
                )
        }


{-| Returns the webhook configuration for a repository. To get more information about the webhook, including the `active` state and `events`, use "[Get a repository webhook](/rest/reference/orgs#get-a-repository-webhook)."

Access tokens must have the `read:repo_hook` or `repo` scope, and GitHub Apps must have the `repository_hooks:read` permission.
-}
reposGetWebhookConfigForRepo config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeWebhookConfig
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{hook_id}"
                config.params.hook_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/hooks/{hook_id}/config"
                    )
                )
        }


{-| Updates the webhook configuration for a repository. To update more information about the webhook, including the `active` state and `events`, use "[Update a repository webhook](/rest/reference/orgs#update-a-repository-webhook)."

Access tokens must have the `write:repo_hook` or `repo` scope, and GitHub Apps must have the `repository_hooks:write` permission.
-}
reposUpdateWebhookConfigForRepo config =
    Http.request
        { method = "PATCH"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeWebhookConfig
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "content_type"
                           , encodeWebhookConfigContentType rec.content_type
                           )
                         , ( "insecure_ssl"
                           , encodeWebhookConfigInsecureSsl rec.insecure_ssl
                           )
                         , ( "secret", encodeWebhookConfigSecret rec.secret )
                         , ( "url", encodeWebhookConfigUrl rec.url )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{hook_id}"
                config.params.hook_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/hooks/{hook_id}/config"
                    )
                )
        }


{-| Returns a list of webhook deliveries for a webhook configured in a repository. -}
reposListWebhookDeliveries config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeHookDeliveryItem)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{hook_id}"
                    config.params.hook_id
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/hooks/{hook_id}/deliveries"
                        )
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (Url.Builder.string "cursor")
                        config.params.cursor
                    ]
                )
        }


{-| Returns a delivery for a webhook configured in a repository. -}
reposGetWebhookDelivery config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeHookDelivery
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{delivery_id}"
                config.params.delivery_id
                (String.replace
                    "{hook_id}"
                    config.params.hook_id
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}"
                        )
                    )
                )
        }


{-| Redeliver a webhook delivery for a webhook configured in a repository. -}
reposRedeliverWebhookDelivery config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeAccepted
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{delivery_id}"
                config.params.delivery_id
                (String.replace
                    "{hook_id}"
                    config.params.hook_id
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"
                        )
                    )
                )
        }


{-| This will trigger a [ping event](https://docs.github.com/webhooks/#ping-event) to be sent to the hook. -}
reposPingWebhook config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{hook_id}"
                config.params.hook_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/hooks/{hook_id}/pings"
                    )
                )
        }


{-| This will trigger the hook with the latest push to the current repository if the hook is subscribed to `push` events. If the hook is not subscribed to `push` events, the server will respond with 204 but no test POST will be generated.

**Note**: Previously `/repos/:owner/:repo/hooks/:hook_id/test`
-}
reposTestPushWebhook config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{hook_id}"
                config.params.hook_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/hooks/{hook_id}/tests"
                    )
                )
        }


{-| View the progress of an import.

**Import status**

This section includes details about the possible values of the `status` field of the Import Progress response.

An import that does not have errors will progress through these steps:

*   `detecting` - the "detection" step of the import is in progress because the request did not include a `vcs` parameter. The import is identifying the type of source control present at the URL.
*   `importing` - the "raw" step of the import is in progress. This is where commit data is fetched from the original repository. The import progress response will include `commit_count` (the total number of raw commits that will be imported) and `percent` (0 - 100, the current progress through the import).
*   `mapping` - the "rewrite" step of the import is in progress. This is where SVN branches are converted to Git branches, and where author updates are applied. The import progress response does not include progress information.
*   `pushing` - the "push" step of the import is in progress. This is where the importer updates the repository on GitHub. The import progress response will include `push_percent`, which is the percent value reported by `git push` when it is "Writing objects".
*   `complete` - the import is complete, and the repository is ready on GitHub.

If there are problems, you will see one of these in the `status` field:

*   `auth_failed` - the import requires authentication in order to connect to the original repository. To update authentication for the import, please see the [Update an import](https://docs.github.com/rest/reference/migrations#update-an-import) section.
*   `error` - the import encountered an error. The import progress response will include the `failed_step` and an error message. Contact [GitHub Support](https://support.github.com/contact?tags=dotcom-rest-api) for more information.
*   `detection_needs_auth` - the importer requires authentication for the originating repository to continue detection. To update authentication for the import, please see the [Update an import](https://docs.github.com/rest/reference/migrations#update-an-import) section.
*   `detection_found_nothing` - the importer didn't recognize any source control at the URL. To resolve, [Cancel the import](https://docs.github.com/rest/reference/migrations#cancel-an-import) and [retry](https://docs.github.com/rest/reference/migrations#start-an-import) with the correct URL.
*   `detection_found_multiple` - the importer found several projects or repositories at the provided URL. When this is the case, the Import Progress response will also include a `project_choices` field with the possible project choices as values. To update project choice, please see the [Update an import](https://docs.github.com/rest/reference/migrations#update-an-import) section.

**The project_choices field**

When multiple projects are found at the provided URL, the response hash will include a `project_choices` field, the value of which is an array of hashes each representing a project choice. The exact key/value pairs of the project hashes will differ depending on the version control type.

**Git LFS related fields**

This section includes details about Git LFS related fields that may be present in the Import Progress response.

*   `use_lfs` - describes whether the import has been opted in or out of using Git LFS. The value can be `opt_in`, `opt_out`, or `undecided` if no action has been taken.
*   `has_large_files` - the boolean value describing whether files larger than 100MB were found during the `importing` step.
*   `large_files_size` - the total size in gigabytes of files larger than 100MB found in the originating repository.
*   `large_files_count` - the total number of files larger than 100MB found in the originating repository. To see a list of these files, make a "Get Large Files" request.
-}
migrationsGetImportStatus :
    { toMsg : Result Http.Error Import -> msg
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
migrationsGetImportStatus config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeImport
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/import"
                )
        }


{-| Start a source import to a GitHub repository using GitHub Importer. -}
migrationsStartImport :
    { toMsg : Result Http.Error Import -> msg
    , body :
        { tfvc_project : String
        , vcs : String
        , vcs_password : String
        , vcs_url : String
        , vcs_username : String
        }
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
migrationsStartImport config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeImport
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "tfvc_project"
                           , Json.Encode.string rec.tfvc_project
                           )
                         , ( "vcs", Json.Encode.string rec.vcs )
                         , ( "vcs_password"
                           , Json.Encode.string rec.vcs_password
                           )
                         , ( "vcs_url", Json.Encode.string rec.vcs_url )
                         , ( "vcs_username"
                           , Json.Encode.string rec.vcs_username
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/import"
                )
        }


{-| An import can be updated with credentials or a project choice by passing in the appropriate parameters in this API
request. If no parameters are provided, the import will be restarted.

Some servers (e.g. TFS servers) can have several projects at a single URL. In those cases the import progress will
have the status `detection_found_multiple` and the Import Progress response will include a `project_choices` array.
You can select the project to import by providing one of the objects in the `project_choices` array in the update request.
-}
migrationsUpdateImport :
    { toMsg : Result Http.Error Import -> msg
    , body :
        Nullable { tfvc_project : String
        , vcs : String
        , vcs_password : String
        , vcs_username : String
        }
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
migrationsUpdateImport config =
    Http.request
        { method = "PATCH"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeImport
        , body =
            Http.jsonBody
                ((\nullableValue ->
                     case nullableValue of
                         Null ->
                             Json.Encode.null

                         Present value ->
                             (\rec ->
                                 Json.Encode.object
                                     [ ( "tfvc_project"
                                       , Json.Encode.string rec.tfvc_project
                                       )
                                     , ( "vcs", Json.Encode.string rec.vcs )
                                     , ( "vcs_password"
                                       , Json.Encode.string rec.vcs_password
                                       )
                                     , ( "vcs_username"
                                       , Json.Encode.string rec.vcs_username
                                       )
                                     ]
                             )
                                 value
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/import"
                )
        }


{-| Stop an import for a repository. -}
migrationsCancelImport :
    { toMsg : Result Http.Error () -> msg
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
migrationsCancelImport config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/import"
                )
        }


{-| Each type of source control system represents authors in a different way. For example, a Git commit author has a display name and an email address, but a Subversion commit author just has a username. The GitHub Importer will make the author information valid, but the author might not be correct. For example, it will change the bare Subversion username `hubot` into something like `hubot <hubot@12341234-abab-fefe-8787-fedcba987654>`.

This endpoint and the [Map a commit author](https://docs.github.com/rest/reference/migrations#map-a-commit-author) endpoint allow you to provide correct Git author information.
-}
migrationsGetCommitAuthors :
    { toMsg : Result Http.Error (List PorterAuthor) -> msg
    , params : { owner : String, repo : String, since : Maybe Int }
    }
    -> Cmd msg
migrationsGetCommitAuthors config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodePorterAuthor)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/import/authors"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "since"
                                (String.fromInt mapUnpack)
                        )
                        config.params.since
                    ]
                )
        }


{-| Update an author's identity for the import. Your application can continue updating authors any time before you push new commits to the repository. -}
migrationsMapCommitAuthor config =
    Http.request
        { method = "PATCH"
        , headers = []
        , expect = Http.expectJson config.toMsg decodePorterAuthor
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "email", Json.Encode.string rec.email )
                         , ( "name", Json.Encode.string rec.name )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{author_id}"
                config.params.author_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/import/authors/{author_id}"
                    )
                )
        }


{-| List files larger than 100MB found during the import -}
migrationsGetLargeFiles :
    { toMsg : Result Http.Error (List PorterLargeFile) -> msg
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
migrationsGetLargeFiles config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodePorterLargeFile)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/import/large_files"
                )
        }


{-| You can import repositories from Subversion, Mercurial, and TFS that include files larger than 100MB. This ability is powered by [Git LFS](https://git-lfs.github.com). You can learn more about our LFS feature and working with large files [on our help site](https://docs.github.com/articles/versioning-large-files/). -}
migrationsSetLfsPreference :
    { toMsg : Result Http.Error Import -> msg
    , body : { use_lfs : String }
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
migrationsSetLfsPreference config =
    Http.request
        { method = "PATCH"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeImport
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "use_lfs", Json.Encode.string rec.use_lfs ) ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/import/lfs"
                )
        }


{-| Enables an authenticated GitHub App to find the repository's installation information. The installation's account type will be either an organization or a user account, depending which account the repository belongs to.

You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
-}
appsGetRepoInstallation :
    { toMsg : Result Http.Error Installation -> msg
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
appsGetRepoInstallation config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeInstallation
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/installation"
                )
        }


{-| Shows which type of GitHub user can interact with this repository and when the restriction expires. If there are no restrictions, you will see an empty response. -}
interactionsGetRestrictionsForRepo :
    { toMsg : Result Http.Error (EnumTwo InteractionLimitResponse {}) -> msg
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
interactionsGetRestrictionsForRepo config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Debug.todo "Enum decoder not implemented yet")
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/interaction-limits"
                )
        }


{-| Temporarily restricts interactions to a certain type of GitHub user within the given repository. You must have owner or admin access to set these restrictions. If an interaction limit is set for the user or organization that owns this repository, you will receive a `409 Conflict` response and will not be able to use this endpoint to change the interaction limit for a single repository. -}
interactionsSetRestrictionsForRepo :
    { toMsg : Result Http.Error InteractionLimitResponse -> msg
    , body : InteractionLimit
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
interactionsSetRestrictionsForRepo config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeInteractionLimitResponse
        , body = Http.jsonBody (encodeInteractionLimit config.body)
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/interaction-limits"
                )
        }


{-| Removes all interaction restrictions from the given repository. You must have owner or admin access to remove restrictions. If the interaction limit is set for the user or organization that owns this repository, you will receive a `409 Conflict` response and will not be able to use this endpoint to change the interaction limit for a single repository. -}
interactionsRemoveRestrictionsForRepo :
    { toMsg : Result Http.Error () -> msg
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
interactionsRemoveRestrictionsForRepo config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/interaction-limits"
                )
        }


{-| When authenticating as a user with admin rights to a repository, this endpoint will list all currently open repository invitations. -}
reposListInvitations :
    { toMsg : Result Http.Error (List RepositoryInvitation) -> msg
    , params :
        { owner : String
        , repo : String
        , per_page : Maybe Int
        , page : Maybe Int
        }
    }
    -> Cmd msg
reposListInvitations config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeRepositoryInvitation)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/invitations"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


reposUpdateInvitation config =
    Http.request
        { method = "PATCH"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeRepositoryInvitation
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "permissions", Json.Encode.string rec.permissions )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{invitation_id}"
                config.params.invitation_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/invitations/{invitation_id}"
                    )
                )
        }


reposDeleteInvitation config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{invitation_id}"
                config.params.invitation_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/invitations/{invitation_id}"
                    )
                )
        }


{-| List issues in a repository.

**Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a pull request. For this
reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by
the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
request id, use the "[List pull requests](https://docs.github.com/rest/reference/pulls#list-pull-requests)" endpoint.
-}
issuesListForRepo :
    { toMsg : Result Http.Error (List Issue) -> msg
    , params :
        { owner : String
        , repo : String
        , milestone : Maybe String
        , state : Maybe String
        , assignee : Maybe String
        , creator : Maybe String
        , mentioned : Maybe String
        , labels : Maybe String
        , sort : Maybe String
        , direction : Maybe String
        , since : Maybe String
        , per_page : Maybe Int
        , page : Maybe Int
        }
    }
    -> Cmd msg
issuesListForRepo config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.list decodeIssue)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/issues"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (Url.Builder.string "milestone")
                        config.params.milestone
                    , Maybe.map (Url.Builder.string "state") config.params.state
                    , Maybe.map
                        (Url.Builder.string "assignee")
                        config.params.assignee
                    , Maybe.map
                        (Url.Builder.string "creator")
                        config.params.creator
                    , Maybe.map
                        (Url.Builder.string "mentioned")
                        config.params.mentioned
                    , Maybe.map
                        (Url.Builder.string "labels")
                        config.params.labels
                    , Maybe.map (Url.Builder.string "sort") config.params.sort
                    , Maybe.map
                        (Url.Builder.string "direction")
                        config.params.direction
                    , Maybe.map (Url.Builder.string "since") config.params.since
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Any user with pull access to a repository can create an issue. If [issues are disabled in the repository](https://docs.github.com/articles/disabling-issues/), the API returns a `410 Gone` status.

This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
-}
issuesCreate :
    { toMsg : Result Http.Error Issue -> msg
    , body :
        { assignee : Nullable String
        , assignees : List String
        , body : String
        , labels : List Json.Encode.Value
        , milestone : Json.Encode.Value
        , title : Json.Encode.Value
        }
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
issuesCreate config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeIssue
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "assignee"
                           , (\nullableValue ->
                                 case nullableValue of
                                     Null ->
                                         Json.Encode.null

                                     Present value ->
                                         Json.Encode.string value
                             )
                                 rec.assignee
                           )
                         , ( "assignees"
                           , Json.Encode.list Json.Encode.string rec.assignees
                           )
                         , ( "body", Json.Encode.string rec.body )
                         , ( "labels"
                           , Json.Encode.list Basics.identity rec.labels
                           )
                         , ( "milestone", Basics.identity rec.milestone )
                         , ( "title", Basics.identity rec.title )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/issues"
                )
        }


{-| By default, Issue Comments are ordered by ascending ID. -}
issuesListCommentsForRepo :
    { toMsg : Result Http.Error (List IssueComment) -> msg
    , params :
        { owner : String
        , repo : String
        , sort : Maybe String
        , direction : Maybe String
        , since : Maybe String
        , per_page : Maybe Int
        , page : Maybe Int
        }
    }
    -> Cmd msg
issuesListCommentsForRepo config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeIssueComment)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/issues/comments"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map (Url.Builder.string "sort") config.params.sort
                    , Maybe.map
                        (Url.Builder.string "direction")
                        config.params.direction
                    , Maybe.map (Url.Builder.string "since") config.params.since
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


issuesGetComment config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeIssueComment
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{comment_id}"
                config.params.comment_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/issues/comments/{comment_id}"
                    )
                )
        }


issuesUpdateComment config =
    Http.request
        { method = "PATCH"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeIssueComment
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "body", Json.Encode.string rec.body ) ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{comment_id}"
                config.params.comment_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/issues/comments/{comment_id}"
                    )
                )
        }


issuesDeleteComment config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{comment_id}"
                config.params.comment_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/issues/comments/{comment_id}"
                    )
                )
        }


{-| List the reactions to an [issue comment](https://docs.github.com/rest/reference/issues#comments). -}
reactionsListForIssueComment config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeReaction)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{comment_id}"
                    config.params.comment_id
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"
                        )
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (Url.Builder.string "content")
                        config.params.content
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Create a reaction to an [issue comment](https://docs.github.com/rest/reference/issues#comments). A response with an HTTP `200` status means that you already added the reaction type to this issue comment. -}
reactionsCreateForIssueComment config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeReaction
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "content", Json.Encode.string rec.content ) ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{comment_id}"
                config.params.comment_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"
                    )
                )
        }


{-| **Note:** You can also specify a repository by `repository_id` using the route `DELETE delete /repositories/:repository_id/issues/comments/:comment_id/reactions/:reaction_id`.

Delete a reaction to an [issue comment](https://docs.github.com/rest/reference/issues#comments).
-}
reactionsDeleteForIssueComment config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{reaction_id}"
                config.params.reaction_id
                (String.replace
                    "{comment_id}"
                    config.params.comment_id
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}"
                        )
                    )
                )
        }


issuesListEventsForRepo :
    { toMsg : Result Http.Error (List IssueEvent) -> msg
    , params :
        { owner : String
        , repo : String
        , per_page : Maybe Int
        , page : Maybe Int
        }
    }
    -> Cmd msg
issuesListEventsForRepo config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeIssueEvent)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/issues/events"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


issuesGetEvent config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeIssueEvent
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{event_id}"
                config.params.event_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/issues/events/{event_id}"
                    )
                )
        }


{-| The API returns a [`301 Moved Permanently` status](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-redirects-redirects) if the issue was
[transferred](https://docs.github.com/articles/transferring-an-issue-to-another-repository/) to another repository. If
the issue was transferred to or deleted from a repository where the authenticated user lacks read access, the API
returns a `404 Not Found` status. If the issue was deleted from a repository where the authenticated user has read
access, the API returns a `410 Gone` status. To receive webhook events for transferred and deleted issues, subscribe
to the [`issues`](https://docs.github.com/webhooks/event-payloads/#issues) webhook.

**Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a pull request. For this
reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by
the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
request id, use the "[List pull requests](https://docs.github.com/rest/reference/pulls#list-pull-requests)" endpoint.
-}
issuesGet config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeIssue
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{issue_number}"
                config.params.issue_number
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/issues/{issue_number}"
                    )
                )
        }


{-| Issue owners and users with push access can edit an issue. -}
issuesUpdate config =
    Http.request
        { method = "PATCH"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeIssue
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "assignee"
                           , (\nullableValue ->
                                 case nullableValue of
                                     Null ->
                                         Json.Encode.null

                                     Present value ->
                                         Json.Encode.string value
                             )
                                 rec.assignee
                           )
                         , ( "assignees"
                           , Json.Encode.list Json.Encode.string rec.assignees
                           )
                         , ( "body"
                           , (\nullableValue ->
                                 case nullableValue of
                                     Null ->
                                         Json.Encode.null

                                     Present value ->
                                         Json.Encode.string value
                             )
                                 rec.body
                           )
                         , ( "labels"
                           , Json.Encode.list Basics.identity rec.labels
                           )
                         , ( "milestone", Basics.identity rec.milestone )
                         , ( "state", Json.Encode.string rec.state )
                         , ( "state_reason"
                           , (\nullableValue ->
                                 case nullableValue of
                                     Null ->
                                         Json.Encode.null

                                     Present value ->
                                         Json.Encode.string value
                             )
                                 rec.state_reason
                           )
                         , ( "title", Basics.identity rec.title )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{issue_number}"
                config.params.issue_number
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/issues/{issue_number}"
                    )
                )
        }


{-| Adds up to 10 assignees to an issue. Users already assigned to an issue are not replaced. -}
issuesAddAssignees config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeIssue
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "assignees"
                           , Json.Encode.list Json.Encode.string rec.assignees
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{issue_number}"
                config.params.issue_number
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/issues/{issue_number}/assignees"
                    )
                )
        }


{-| Removes one or more assignees from an issue. -}
issuesRemoveAssignees config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeIssue
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "assignees"
                           , Json.Encode.list Json.Encode.string rec.assignees
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{issue_number}"
                config.params.issue_number
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/issues/{issue_number}/assignees"
                    )
                )
        }


{-| Issue Comments are ordered by ascending ID. -}
issuesListComments config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeIssueComment)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{issue_number}"
                    config.params.issue_number
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/issues/{issue_number}/comments"
                        )
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map (Url.Builder.string "since") config.params.since
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details. -}
issuesCreateComment config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeIssueComment
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "body", Json.Encode.string rec.body ) ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{issue_number}"
                config.params.issue_number
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/issues/{issue_number}/comments"
                    )
                )
        }


issuesListEvents config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeIssueEventForIssue)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{issue_number}"
                    config.params.issue_number
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/issues/{issue_number}/events"
                        )
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


issuesListLabelsOnIssue config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.list decodeLabel)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{issue_number}"
                    config.params.issue_number
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/issues/{issue_number}/labels"
                        )
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


issuesAddLabels config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.list decodeLabel)
        , body = Http.jsonBody (Basics.identity config.body)
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{issue_number}"
                config.params.issue_number
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/issues/{issue_number}/labels"
                    )
                )
        }


{-| Removes any previous labels and sets the new labels for an issue. -}
issuesSetLabels config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.list decodeLabel)
        , body = Http.jsonBody (Basics.identity config.body)
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{issue_number}"
                config.params.issue_number
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/issues/{issue_number}/labels"
                    )
                )
        }


issuesRemoveAllLabels config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{issue_number}"
                config.params.issue_number
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/issues/{issue_number}/labels"
                    )
                )
        }


{-| Removes the specified label from the issue, and returns the remaining labels on the issue. This endpoint returns a `404 Not Found` status if the label does not exist. -}
issuesRemoveLabel config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.list decodeLabel)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{name}"
                config.params.name
                (String.replace
                    "{issue_number}"
                    config.params.issue_number
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/issues/{issue_number}/labels/{name}"
                        )
                    )
                )
        }


{-| Users with push access can lock an issue or pull request's conversation.

Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs)."
-}
issuesLock config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body =
            Http.jsonBody
                ((\nullableValue ->
                     case nullableValue of
                         Null ->
                             Json.Encode.null

                         Present value ->
                             (\rec ->
                                 Json.Encode.object
                                     [ ( "lock_reason"
                                       , Json.Encode.string rec.lock_reason
                                       )
                                     ]
                             )
                                 value
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{issue_number}"
                config.params.issue_number
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/issues/{issue_number}/lock"
                    )
                )
        }


{-| Users with push access can unlock an issue's conversation. -}
issuesUnlock config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{issue_number}"
                config.params.issue_number
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/issues/{issue_number}/lock"
                    )
                )
        }


{-| List the reactions to an [issue](https://docs.github.com/rest/reference/issues). -}
reactionsListForIssue config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeReaction)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{issue_number}"
                    config.params.issue_number
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/issues/{issue_number}/reactions"
                        )
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (Url.Builder.string "content")
                        config.params.content
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Create a reaction to an [issue](https://docs.github.com/rest/reference/issues/). A response with an HTTP `200` status means that you already added the reaction type to this issue. -}
reactionsCreateForIssue config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeReaction
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "content", Json.Encode.string rec.content ) ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{issue_number}"
                config.params.issue_number
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/issues/{issue_number}/reactions"
                    )
                )
        }


{-| **Note:** You can also specify a repository by `repository_id` using the route `DELETE /repositories/:repository_id/issues/:issue_number/reactions/:reaction_id`.

Delete a reaction to an [issue](https://docs.github.com/rest/reference/issues/).
-}
reactionsDeleteForIssue config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{reaction_id}"
                config.params.reaction_id
                (String.replace
                    "{issue_number}"
                    config.params.issue_number
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}"
                        )
                    )
                )
        }


issuesListEventsForTimeline config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeTimelineIssueEvents)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{issue_number}"
                    config.params.issue_number
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/issues/{issue_number}/timeline"
                        )
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


reposListDeployKeys :
    { toMsg : Result Http.Error (List DeployKey) -> msg
    , params :
        { owner : String
        , repo : String
        , per_page : Maybe Int
        , page : Maybe Int
        }
    }
    -> Cmd msg
reposListDeployKeys config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeDeployKey)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/keys"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| You can create a read-only deploy key. -}
reposCreateDeployKey :
    { toMsg : Result Http.Error DeployKey -> msg
    , body : { key : String, read_only : Bool, title : String }
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
reposCreateDeployKey config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeDeployKey
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "key", Json.Encode.string rec.key )
                         , ( "read_only", Json.Encode.bool rec.read_only )
                         , ( "title", Json.Encode.string rec.title )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/keys"
                )
        }


reposGetDeployKey config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeDeployKey
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{key_id}"
                config.params.key_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/keys/{key_id}"
                    )
                )
        }


{-| Deploy keys are immutable. If you need to update a key, remove the key and create a new one instead. -}
reposDeleteDeployKey config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{key_id}"
                config.params.key_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/keys/{key_id}"
                    )
                )
        }


issuesListLabelsForRepo :
    { toMsg : Result Http.Error (List Label) -> msg
    , params :
        { owner : String
        , repo : String
        , per_page : Maybe Int
        , page : Maybe Int
        }
    }
    -> Cmd msg
issuesListLabelsForRepo config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.list decodeLabel)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/labels"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


issuesCreateLabel :
    { toMsg : Result Http.Error Label -> msg
    , body : { color : String, description : String, name : String }
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
issuesCreateLabel config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeLabel
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "color", Json.Encode.string rec.color )
                         , ( "description", Json.Encode.string rec.description )
                         , ( "name", Json.Encode.string rec.name )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/labels"
                )
        }


issuesGetLabel :
    { toMsg : Result Http.Error Label -> msg
    , params : { owner : String, repo : String, name : String }
    }
    -> Cmd msg
issuesGetLabel config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeLabel
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{name}"
                config.params.name
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/labels/{name}"
                    )
                )
        }


issuesUpdateLabel :
    { toMsg : Result Http.Error Label -> msg
    , body : { color : String, description : String, new_name : String }
    , params : { owner : String, repo : String, name : String }
    }
    -> Cmd msg
issuesUpdateLabel config =
    Http.request
        { method = "PATCH"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeLabel
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "color", Json.Encode.string rec.color )
                         , ( "description", Json.Encode.string rec.description )
                         , ( "new_name", Json.Encode.string rec.new_name )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{name}"
                config.params.name
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/labels/{name}"
                    )
                )
        }


issuesDeleteLabel :
    { toMsg : Result Http.Error () -> msg
    , params : { owner : String, repo : String, name : String }
    }
    -> Cmd msg
issuesDeleteLabel config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{name}"
                config.params.name
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/labels/{name}"
                    )
                )
        }


{-| Lists languages for the specified repository. The value shown for each language is the number of bytes of code written in that language. -}
reposListLanguages :
    { toMsg : Result Http.Error Language -> msg
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
reposListLanguages config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeLanguage
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/languages"
                )
        }


reposEnableLfsForRepo :
    { toMsg : Result Http.Error Accepted -> msg
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
reposEnableLfsForRepo config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeAccepted
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/lfs"
                )
        }


reposDisableLfsForRepo :
    { toMsg : Result Http.Error () -> msg
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
reposDisableLfsForRepo config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/lfs"
                )
        }


{-| This method returns the contents of the repository's license file, if one is detected.

Similar to [Get repository content](https://docs.github.com/rest/reference/repos#get-repository-content), this method also supports [custom media types](https://docs.github.com/rest/overview/media-types) for retrieving the raw license content or rendered license HTML.
-}
licensesGetForRepo :
    { toMsg : Result Http.Error LicenseContent -> msg
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
licensesGetForRepo config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeLicenseContent
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/license"
                )
        }


{-| Sync a branch of a forked repository to keep it up-to-date with the upstream repository. -}
reposMergeUpstream :
    { toMsg : Result Http.Error MergedUpstream -> msg
    , body : { branch : String }
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
reposMergeUpstream config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeMergedUpstream
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "branch", Json.Encode.string rec.branch ) ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/merge-upstream"
                )
        }


reposMerge :
    { toMsg : Result Http.Error Commit -> msg
    , body : { base : String, commit_message : String, head : String }
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
reposMerge config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeCommit
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "base", Json.Encode.string rec.base )
                         , ( "commit_message"
                           , Json.Encode.string rec.commit_message
                           )
                         , ( "head", Json.Encode.string rec.head )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/merges"
                )
        }


issuesListMilestones :
    { toMsg : Result Http.Error (List Milestone) -> msg
    , params :
        { owner : String
        , repo : String
        , state : Maybe String
        , sort : Maybe String
        , direction : Maybe String
        , per_page : Maybe Int
        , page : Maybe Int
        }
    }
    -> Cmd msg
issuesListMilestones config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeMilestone)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/milestones"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map (Url.Builder.string "state") config.params.state
                    , Maybe.map (Url.Builder.string "sort") config.params.sort
                    , Maybe.map
                        (Url.Builder.string "direction")
                        config.params.direction
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


issuesCreateMilestone :
    { toMsg : Result Http.Error Milestone -> msg
    , body :
        { description : String
        , due_on : String
        , state : String
        , title : String
        }
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
issuesCreateMilestone config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeMilestone
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "description", Json.Encode.string rec.description )
                         , ( "due_on", Json.Encode.string rec.due_on )
                         , ( "state", Json.Encode.string rec.state )
                         , ( "title", Json.Encode.string rec.title )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/milestones"
                )
        }


issuesGetMilestone config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeMilestone
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{milestone_number}"
                config.params.milestone_number
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/milestones/{milestone_number}"
                    )
                )
        }


issuesUpdateMilestone config =
    Http.request
        { method = "PATCH"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeMilestone
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "description", Json.Encode.string rec.description )
                         , ( "due_on", Json.Encode.string rec.due_on )
                         , ( "state", Json.Encode.string rec.state )
                         , ( "title", Json.Encode.string rec.title )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{milestone_number}"
                config.params.milestone_number
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/milestones/{milestone_number}"
                    )
                )
        }


issuesDeleteMilestone config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{milestone_number}"
                config.params.milestone_number
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/milestones/{milestone_number}"
                    )
                )
        }


issuesListLabelsForMilestone config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.list decodeLabel)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{milestone_number}"
                    config.params.milestone_number
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/milestones/{milestone_number}/labels"
                        )
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Lists all notifications for the current user in the specified repository. -}
activityListRepoNotificationsForAuthenticatedUser :
    { toMsg : Result Http.Error (List Thread) -> msg
    , params :
        { owner : String
        , repo : String
        , all : Maybe Bool
        , participating : Maybe Bool
        , since : Maybe String
        , before : Maybe String
        , per_page : Maybe Int
        , page : Maybe Int
        }
    }
    -> Cmd msg
activityListRepoNotificationsForAuthenticatedUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.list decodeThread)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/notifications"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "all"
                                (if mapUnpack then
                                    "true"

                                 else
                                    "false"
                                )
                        )
                        config.params.all
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "participating"
                                (if mapUnpack then
                                    "true"

                                 else
                                    "false"
                                )
                        )
                        config.params.participating
                    , Maybe.map (Url.Builder.string "since") config.params.since
                    , Maybe.map
                        (Url.Builder.string "before")
                        config.params.before
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Marks all notifications in a repository as "read" for the current user. If the number of notifications is too large to complete in one request, you will receive a `202 Accepted` status and GitHub will run an asynchronous process to mark notifications as "read." To check whether any "unread" notifications remain, you can use the [List repository notifications for the authenticated user](https://docs.github.com/rest/reference/activity#list-repository-notifications-for-the-authenticated-user) endpoint and pass the query parameter `all=false`. -}
activityMarkRepoNotificationsAsRead config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\message url -> { message = message, url = url })
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "message" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "url" Json.Decode.string)
                )
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "last_read_at"
                           , Json.Encode.string rec.last_read_at
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/notifications"
                )
        }


reposGetPages :
    { toMsg : Result Http.Error Page -> msg
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
reposGetPages config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodePage
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/pages"
                )
        }


{-| Configures a GitHub Pages site. For more information, see "[About GitHub Pages](/github/working-with-github-pages/about-github-pages)." You must be an admin of the repository in order to use this operation. -}
reposCreatePagesSite :
    { toMsg : Result Http.Error Page -> msg
    , body :
        Nullable { build_type : String
        , source : { branch : String, path : String }
        }
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
reposCreatePagesSite config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodePage
        , body =
            Http.jsonBody
                ((\nullableValue ->
                     case nullableValue of
                         Null ->
                             Json.Encode.null

                         Present value ->
                             (\rec ->
                                 Json.Encode.object
                                     [ ( "build_type"
                                       , Json.Encode.string rec.build_type
                                       )
                                     , ( "source"
                                       , (\rec0 ->
                                             Json.Encode.object
                                                 [ ( "branch"
                                                   , Json.Encode.string
                                                         rec0.branch
                                                   )
                                                 , ( "path"
                                                   , Json.Encode.string
                                                         rec0.path
                                                   )
                                                 ]
                                         )
                                             rec.source
                                       )
                                     ]
                             )
                                 value
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/pages"
                )
        }


{-| Updates information for a GitHub Pages site. For more information, see "[About GitHub Pages](/github/working-with-github-pages/about-github-pages). -}
reposUpdateInformationAboutPagesSite :
    { toMsg : Result Http.Error () -> msg
    , body :
        { build_type : String
        , cname : Nullable String
        , https_enforced : Bool
        , public : Bool
        , source : EnumTwo String { branch : String, path : String }
        }
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
reposUpdateInformationAboutPagesSite config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "build_type", Json.Encode.string rec.build_type )
                         , ( "cname"
                           , (\nullableValue ->
                                 case nullableValue of
                                     Null ->
                                         Json.Encode.null

                                     Present value ->
                                         Json.Encode.string value
                             )
                                 rec.cname
                           )
                         , ( "https_enforced"
                           , Json.Encode.bool rec.https_enforced
                           )
                         , ( "public", Json.Encode.bool rec.public )
                         , ( "source"
                           , Debug.todo "encoder for enum not implemented"
                                 rec.source
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/pages"
                )
        }


{-| Deletes a GitHub Pages site. You must be an admin of the repository in order to use this operation. -}
reposDeletePagesSite :
    { toMsg : Result Http.Error () -> msg
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
reposDeletePagesSite config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/pages"
                )
        }


reposListPagesBuilds :
    { toMsg : Result Http.Error (List PageBuild) -> msg
    , params :
        { owner : String
        , repo : String
        , per_page : Maybe Int
        , page : Maybe Int
        }
    }
    -> Cmd msg
reposListPagesBuilds config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodePageBuild)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/pages/builds"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| You can request that your site be built from the latest revision on the default branch. This has the same effect as pushing a commit to your default branch, but does not require an additional commit. Manually triggering page builds can be helpful when diagnosing build warnings and failures.

Build requests are limited to one concurrent build per repository and one concurrent build per requester. If you request a build while another is still in progress, the second request will be queued until the first completes.
-}
reposRequestPagesBuild :
    { toMsg : Result Http.Error PageBuildStatus -> msg
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
reposRequestPagesBuild config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodePageBuildStatus
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/pages/builds"
                )
        }


reposGetLatestPagesBuild :
    { toMsg : Result Http.Error PageBuild -> msg
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
reposGetLatestPagesBuild config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodePageBuild
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/pages/builds/latest"
                )
        }


reposGetPagesBuild config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodePageBuild
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{build_id}"
                config.params.build_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/pages/builds/{build_id}"
                    )
                )
        }


{-| Create a GitHub Pages deployment for a repository.

Users must have write permissions. GitHub Apps must have the `pages:write` permission to use this endpoint.
-}
reposCreatePagesDeployment :
    { toMsg : Result Http.Error PageDeployment -> msg
    , body :
        { artifact_url : String
        , environment : String
        , oidc_token : String
        , pages_build_version : String
        }
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
reposCreatePagesDeployment config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodePageDeployment
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "artifact_url"
                           , Json.Encode.string rec.artifact_url
                           )
                         , ( "environment", Json.Encode.string rec.environment )
                         , ( "oidc_token", Json.Encode.string rec.oidc_token )
                         , ( "pages_build_version"
                           , Json.Encode.string rec.pages_build_version
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/pages/deployment"
                )
        }


{-| Gets a health check of the DNS settings for the `CNAME` record configured for a repository's GitHub Pages.

The first request to this endpoint returns a `202 Accepted` status and starts an asynchronous background task to get the results for the domain. After the background task completes, subsequent requests to this endpoint return a `200 OK` status with the health check results in the response.

Users must have admin or owner permissions. GitHub Apps must have the `pages:write` and `administration:write` permission to use this endpoint.
-}
reposGetPagesHealthCheck :
    { toMsg : Result Http.Error PagesHealthCheck -> msg
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
reposGetPagesHealthCheck config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodePagesHealthCheck
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/pages/health"
                )
        }


{-| Lists the projects in a repository. Returns a `404 Not Found` status if projects are disabled in the repository. If you do not have sufficient privileges to perform this action, a `401 Unauthorized` or `410 Gone` status is returned. -}
projectsListForRepo :
    { toMsg : Result Http.Error (List Project) -> msg
    , params :
        { owner : String
        , repo : String
        , state : Maybe String
        , per_page : Maybe Int
        , page : Maybe Int
        }
    }
    -> Cmd msg
projectsListForRepo config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.list decodeProject)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/projects"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map (Url.Builder.string "state") config.params.state
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Creates a repository project board. Returns a `410 Gone` status if projects are disabled in the repository or if the repository does not have existing classic projects. If you do not have sufficient privileges to perform this action, a `401 Unauthorized` or `410 Gone` status is returned. -}
projectsCreateForRepo :
    { toMsg : Result Http.Error Project -> msg
    , body : { body : String, name : String }
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
projectsCreateForRepo config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeProject
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "body", Json.Encode.string rec.body )
                         , ( "name", Json.Encode.string rec.name )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/projects"
                )
        }


{-| Draft pull requests are available in public repositories with GitHub Free and GitHub Free for organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation. -}
pullsList :
    { toMsg : Result Http.Error (List PullRequestSimple) -> msg
    , params :
        { owner : String
        , repo : String
        , state : Maybe String
        , head : Maybe String
        , base : Maybe String
        , sort : Maybe String
        , direction : Maybe String
        , per_page : Maybe Int
        , page : Maybe Int
        }
    }
    -> Cmd msg
pullsList config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodePullRequestSimple)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/pulls"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map (Url.Builder.string "state") config.params.state
                    , Maybe.map (Url.Builder.string "head") config.params.head
                    , Maybe.map (Url.Builder.string "base") config.params.base
                    , Maybe.map (Url.Builder.string "sort") config.params.sort
                    , Maybe.map
                        (Url.Builder.string "direction")
                        config.params.direction
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Draft pull requests are available in public repositories with GitHub Free and GitHub Free for organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

To open or update a pull request in a public repository, you must have write access to the head or the source branch. For organization-owned repositories, you must be a member of the organization that owns the repository to open or update a pull request.

This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-rate-limits)" for details.
-}
pullsCreate :
    { toMsg : Result Http.Error PullRequest -> msg
    , body :
        { base : String
        , body : String
        , draft : Bool
        , head : String
        , issue : Int
        , maintainer_can_modify : Bool
        , title : String
        }
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
pullsCreate config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodePullRequest
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "base", Json.Encode.string rec.base )
                         , ( "body", Json.Encode.string rec.body )
                         , ( "draft", Json.Encode.bool rec.draft )
                         , ( "head", Json.Encode.string rec.head )
                         , ( "issue", Json.Encode.int rec.issue )
                         , ( "maintainer_can_modify"
                           , Json.Encode.bool rec.maintainer_can_modify
                           )
                         , ( "title", Json.Encode.string rec.title )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/pulls"
                )
        }


{-| Lists review comments for all pull requests in a repository. By default, review comments are in ascending order by ID. -}
pullsListReviewCommentsForRepo :
    { toMsg : Result Http.Error (List PullRequestReviewComment) -> msg
    , params :
        { owner : String
        , repo : String
        , sort : Maybe String
        , direction : Maybe String
        , since : Maybe String
        , per_page : Maybe Int
        , page : Maybe Int
        }
    }
    -> Cmd msg
pullsListReviewCommentsForRepo config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodePullRequestReviewComment)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/pulls/comments"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map (Url.Builder.string "sort") config.params.sort
                    , Maybe.map
                        (Url.Builder.string "direction")
                        config.params.direction
                    , Maybe.map (Url.Builder.string "since") config.params.since
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Provides details for a review comment. -}
pullsGetReviewComment config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodePullRequestReviewComment
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{comment_id}"
                config.params.comment_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/pulls/comments/{comment_id}"
                    )
                )
        }


{-| Enables you to edit a review comment. -}
pullsUpdateReviewComment config =
    Http.request
        { method = "PATCH"
        , headers = []
        , expect = Http.expectJson config.toMsg decodePullRequestReviewComment
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "body", Json.Encode.string rec.body ) ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{comment_id}"
                config.params.comment_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/pulls/comments/{comment_id}"
                    )
                )
        }


{-| Deletes a review comment. -}
pullsDeleteReviewComment config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{comment_id}"
                config.params.comment_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/pulls/comments/{comment_id}"
                    )
                )
        }


{-| List the reactions to a [pull request review comment](https://docs.github.com/rest/reference/pulls#review-comments). -}
reactionsListForPullRequestReviewComment config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeReaction)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{comment_id}"
                    config.params.comment_id
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"
                        )
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (Url.Builder.string "content")
                        config.params.content
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Create a reaction to a [pull request review comment](https://docs.github.com/rest/reference/pulls#comments). A response with an HTTP `200` status means that you already added the reaction type to this pull request review comment. -}
reactionsCreateForPullRequestReviewComment config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeReaction
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "content", Json.Encode.string rec.content ) ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{comment_id}"
                config.params.comment_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"
                    )
                )
        }


{-| **Note:** You can also specify a repository by `repository_id` using the route `DELETE /repositories/:repository_id/pulls/comments/:comment_id/reactions/:reaction_id.`

Delete a reaction to a [pull request review comment](https://docs.github.com/rest/reference/pulls#review-comments).
-}
reactionsDeleteForPullRequestComment config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{reaction_id}"
                config.params.reaction_id
                (String.replace
                    "{comment_id}"
                    config.params.comment_id
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}"
                        )
                    )
                )
        }


{-| Draft pull requests are available in public repositories with GitHub Free and GitHub Free for organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Lists details of a pull request by providing its number.

When you get, [create](https://docs.github.com/rest/reference/pulls/#create-a-pull-request), or [edit](https://docs.github.com/rest/reference/pulls#update-a-pull-request) a pull request, GitHub creates a merge commit to test whether the pull request can be automatically merged into the base branch. This test commit is not added to the base branch or the head branch. You can review the status of the test commit using the `mergeable` key. For more information, see "[Checking mergeability of pull requests](https://docs.github.com/rest/guides/getting-started-with-the-git-database-api#checking-mergeability-of-pull-requests)".

The value of the `mergeable` attribute can be `true`, `false`, or `null`. If the value is `null`, then GitHub has started a background job to compute the mergeability. After giving the job time to complete, resubmit the request. When the job finishes, you will see a non-`null` value for the `mergeable` attribute in the response. If `mergeable` is `true`, then `merge_commit_sha` will be the SHA of the _test_ merge commit.

The value of the `merge_commit_sha` attribute changes depending on the state of the pull request. Before merging a pull request, the `merge_commit_sha` attribute holds the SHA of the _test_ merge commit. After merging a pull request, the `merge_commit_sha` attribute changes depending on how you merged the pull request:

*   If merged as a [merge commit](https://docs.github.com/articles/about-merge-methods-on-github/), `merge_commit_sha` represents the SHA of the merge commit.
*   If merged via a [squash](https://docs.github.com/articles/about-merge-methods-on-github/#squashing-your-merge-commits), `merge_commit_sha` represents the SHA of the squashed commit on the base branch.
*   If [rebased](https://docs.github.com/articles/about-merge-methods-on-github/#rebasing-and-merging-your-commits), `merge_commit_sha` represents the commit that the base branch was updated to.

Pass the appropriate [media type](https://docs.github.com/rest/overview/media-types/#commits-commit-comparison-and-pull-requests) to fetch diff and patch formats.
-}
pullsGet config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodePullRequest
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{pull_number}"
                config.params.pull_number
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/pulls/{pull_number}"
                    )
                )
        }


{-| Draft pull requests are available in public repositories with GitHub Free and GitHub Free for organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

To open or update a pull request in a public repository, you must have write access to the head or the source branch. For organization-owned repositories, you must be a member of the organization that owns the repository to open or update a pull request.
-}
pullsUpdate config =
    Http.request
        { method = "PATCH"
        , headers = []
        , expect = Http.expectJson config.toMsg decodePullRequest
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "base", Json.Encode.string rec.base )
                         , ( "body", Json.Encode.string rec.body )
                         , ( "maintainer_can_modify"
                           , Json.Encode.bool rec.maintainer_can_modify
                           )
                         , ( "state", Json.Encode.string rec.state )
                         , ( "title", Json.Encode.string rec.title )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{pull_number}"
                config.params.pull_number
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/pulls/{pull_number}"
                    )
                )
        }


{-| Creates a codespace owned by the authenticated user for the specified pull request.

You must authenticate using an access token with the `codespace` scope to use this endpoint.

GitHub Apps must have write access to the `codespaces` repository permission to use this endpoint.
-}
codespacesCreateWithPrForAuthenticatedUser config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeCodespace
        , body =
            Http.jsonBody
                ((\nullableValue ->
                     case nullableValue of
                         Null ->
                             Json.Encode.null

                         Present value ->
                             (\rec ->
                                 Json.Encode.object
                                     [ ( "client_ip"
                                       , Json.Encode.string rec.client_ip
                                       )
                                     , ( "devcontainer_path"
                                       , Json.Encode.string
                                             rec.devcontainer_path
                                       )
                                     , ( "display_name"
                                       , Json.Encode.string rec.display_name
                                       )
                                     , ( "idle_timeout_minutes"
                                       , Json.Encode.int
                                             rec.idle_timeout_minutes
                                       )
                                     , ( "location"
                                       , Json.Encode.string rec.location
                                       )
                                     , ( "machine"
                                       , Json.Encode.string rec.machine
                                       )
                                     , ( "multi_repo_permissions_opt_out"
                                       , Json.Encode.bool
                                             rec.multi_repo_permissions_opt_out
                                       )
                                     , ( "retention_period_minutes"
                                       , Json.Encode.int
                                             rec.retention_period_minutes
                                       )
                                     , ( "working_directory"
                                       , Json.Encode.string
                                             rec.working_directory
                                       )
                                     ]
                             )
                                 value
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{pull_number}"
                config.params.pull_number
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/pulls/{pull_number}/codespaces"
                    )
                )
        }


{-| Lists all review comments for a pull request. By default, review comments are in ascending order by ID. -}
pullsListReviewComments config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodePullRequestReviewComment)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{pull_number}"
                    config.params.pull_number
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/pulls/{pull_number}/comments"
                        )
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map (Url.Builder.string "sort") config.params.sort
                    , Maybe.map
                        (Url.Builder.string "direction")
                        config.params.direction
                    , Maybe.map (Url.Builder.string "since") config.params.since
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Creates a review comment in the pull request diff. To add a regular comment to a pull request timeline, see "[Create an issue comment](https://docs.github.com/rest/reference/issues#create-an-issue-comment)." We recommend creating a review comment using `line`, `side`, and optionally `start_line` and `start_side` if your comment applies to more than one line in the pull request diff.

The `position` parameter is deprecated. If you use `position`, the `line`, `side`, `start_line`, and `start_side` parameters are not required.

**Note:** The position value equals the number of lines down from the first "@@" hunk header in the file you want to add a comment. The line just below the "@@" line is position 1, the next line is position 2, and so on. The position in the diff continues to increase through lines of whitespace and additional hunks until the beginning of a new file.

This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
-}
pullsCreateReviewComment config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodePullRequestReviewComment
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "body", Json.Encode.string rec.body )
                         , ( "commit_id", Json.Encode.string rec.commit_id )
                         , ( "in_reply_to", Json.Encode.int rec.in_reply_to )
                         , ( "line", Json.Encode.int rec.line )
                         , ( "path", Json.Encode.string rec.path )
                         , ( "position", Json.Encode.int rec.position )
                         , ( "side", Json.Encode.string rec.side )
                         , ( "start_line", Json.Encode.int rec.start_line )
                         , ( "start_side", Json.Encode.string rec.start_side )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{pull_number}"
                config.params.pull_number
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/pulls/{pull_number}/comments"
                    )
                )
        }


{-| Creates a reply to a review comment for a pull request. For the `comment_id`, provide the ID of the review comment you are replying to. This must be the ID of a _top-level review comment_, not a reply to that comment. Replies to replies are not supported.

This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
-}
pullsCreateReplyForReviewComment config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodePullRequestReviewComment
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "body", Json.Encode.string rec.body ) ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{comment_id}"
                config.params.comment_id
                (String.replace
                    "{pull_number}"
                    config.params.pull_number
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies"
                        )
                    )
                )
        }


{-| Lists a maximum of 250 commits for a pull request. To receive a complete commit list for pull requests with more than 250 commits, use the [List commits](https://docs.github.com/rest/reference/repos#list-commits) endpoint. -}
pullsListCommits config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.list decodeCommit)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{pull_number}"
                    config.params.pull_number
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/pulls/{pull_number}/commits"
                        )
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| **Note:** Responses include a maximum of 3000 files. The paginated response returns 30 files per page by default. -}
pullsListFiles config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeDiffEntry)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{pull_number}"
                    config.params.pull_number
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/pulls/{pull_number}/files"
                        )
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


pullsCheckIfMerged config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{pull_number}"
                config.params.pull_number
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/pulls/{pull_number}/merge"
                    )
                )
        }


{-| This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details. -}
pullsMerge config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectJson config.toMsg decodePullRequestMergeResult
        , body =
            Http.jsonBody
                ((\nullableValue ->
                     case nullableValue of
                         Null ->
                             Json.Encode.null

                         Present value ->
                             (\rec ->
                                 Json.Encode.object
                                     [ ( "commit_message"
                                       , Json.Encode.string rec.commit_message
                                       )
                                     , ( "commit_title"
                                       , Json.Encode.string rec.commit_title
                                       )
                                     , ( "merge_method"
                                       , Json.Encode.string rec.merge_method
                                       )
                                     , ( "sha", Json.Encode.string rec.sha )
                                     ]
                             )
                                 value
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{pull_number}"
                config.params.pull_number
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/pulls/{pull_number}/merge"
                    )
                )
        }


{-| Gets the users or teams whose review is requested for a pull request. Once a requested reviewer submits a review, they are no longer considered a requested reviewer. Their review will instead be returned by the [List reviews for a pull request](https://docs.github.com/rest/pulls/reviews#list-reviews-for-a-pull-request) operation. -}
pullsListRequestedReviewers config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodePullRequestReviewRequest
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{pull_number}"
                config.params.pull_number
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
                    )
                )
        }


{-| This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details. -}
pullsRequestReviewers config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodePullRequestSimple
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "reviewers"
                           , Json.Encode.list Json.Encode.string rec.reviewers
                           )
                         , ( "team_reviewers"
                           , Json.Encode.list Json.Encode.string
                                 rec.team_reviewers
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{pull_number}"
                config.params.pull_number
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
                    )
                )
        }


pullsRemoveRequestedReviewers config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectJson config.toMsg decodePullRequestSimple
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "reviewers"
                           , Json.Encode.list Json.Encode.string rec.reviewers
                           )
                         , ( "team_reviewers"
                           , Json.Encode.list Json.Encode.string
                                 rec.team_reviewers
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{pull_number}"
                config.params.pull_number
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
                    )
                )
        }


{-| The list of reviews returns in chronological order. -}
pullsListReviews config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodePullRequestReview)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{pull_number}"
                    config.params.pull_number
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/pulls/{pull_number}/reviews"
                        )
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.

Pull request reviews created in the `PENDING` state are not submitted and therefore do not include the `submitted_at` property in the response. To create a pending review for a pull request, leave the `event` parameter blank. For more information about submitting a `PENDING` review, see "[Submit a review for a pull request](https://docs.github.com/rest/pulls#submit-a-review-for-a-pull-request)."

**Note:** To comment on a specific line in a file, you need to first determine the _position_ of that line in the diff. The GitHub REST API v3 offers the `application/vnd.github.v3.diff` [media type](https://docs.github.com/rest/overview/media-types#commits-commit-comparison-and-pull-requests). To see a pull request diff, add this media type to the `Accept` header of a call to the [single pull request](https://docs.github.com/rest/reference/pulls#get-a-pull-request) endpoint.

The `position` value equals the number of lines down from the first "@@" hunk header in the file you want to add a comment. The line just below the "@@" line is position 1, the next line is position 2, and so on. The position in the diff continues to increase through lines of whitespace and additional hunks until the beginning of a new file.
-}
pullsCreateReview config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodePullRequestReview
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "body", Json.Encode.string rec.body )
                         , ( "comments"
                           , Json.Encode.list
                                 (\rec0 ->
                                     Json.Encode.object
                                         [ ( "body"
                                           , Json.Encode.string rec0.body
                                           )
                                         , ( "line", Json.Encode.int rec0.line )
                                         , ( "path"
                                           , Json.Encode.string rec0.path
                                           )
                                         , ( "position"
                                           , Json.Encode.int rec0.position
                                           )
                                         , ( "side"
                                           , Json.Encode.string rec0.side
                                           )
                                         , ( "start_line"
                                           , Json.Encode.int rec0.start_line
                                           )
                                         , ( "start_side"
                                           , Json.Encode.string rec0.start_side
                                           )
                                         ]
                                 )
                                 rec.comments
                           )
                         , ( "commit_id", Json.Encode.string rec.commit_id )
                         , ( "event", Json.Encode.string rec.event )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{pull_number}"
                config.params.pull_number
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/pulls/{pull_number}/reviews"
                    )
                )
        }


pullsGetReview config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodePullRequestReview
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{review_id}"
                config.params.review_id
                (String.replace
                    "{pull_number}"
                    config.params.pull_number
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
                        )
                    )
                )
        }


{-| Update the review summary comment with new text. -}
pullsUpdateReview config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectJson config.toMsg decodePullRequestReview
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "body", Json.Encode.string rec.body ) ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{review_id}"
                config.params.review_id
                (String.replace
                    "{pull_number}"
                    config.params.pull_number
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
                        )
                    )
                )
        }


pullsDeletePendingReview config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectJson config.toMsg decodePullRequestReview
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{review_id}"
                config.params.review_id
                (String.replace
                    "{pull_number}"
                    config.params.pull_number
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
                        )
                    )
                )
        }


{-| List comments for a specific pull request review. -}
pullsListCommentsForReview config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeReviewComment)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{review_id}"
                    config.params.review_id
                    (String.replace
                        "{pull_number}"
                        config.params.pull_number
                        (String.replace
                            "{repo}"
                            config.params.repo
                            (String.replace
                                "{owner}"
                                config.params.owner
                                "https://api.github.com/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments"
                            )
                        )
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| **Note:** To dismiss a pull request review on a [protected branch](https://docs.github.com/rest/reference/repos#branches), you must be a repository administrator or be included in the list of people or teams who can dismiss pull request reviews. -}
pullsDismissReview config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectJson config.toMsg decodePullRequestReview
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "event", Json.Encode.string rec.event )
                         , ( "message", Json.Encode.string rec.message )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{review_id}"
                config.params.review_id
                (String.replace
                    "{pull_number}"
                    config.params.pull_number
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals"
                        )
                    )
                )
        }


{-| Submits a pending review for a pull request. For more information about creating a pending review for a pull request, see "[Create a review for a pull request](https://docs.github.com/rest/pulls#create-a-review-for-a-pull-request)." -}
pullsSubmitReview config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodePullRequestReview
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "body", Json.Encode.string rec.body )
                         , ( "event", Json.Encode.string rec.event )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{review_id}"
                config.params.review_id
                (String.replace
                    "{pull_number}"
                    config.params.pull_number
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events"
                        )
                    )
                )
        }


{-| Updates the pull request branch with the latest upstream changes by merging HEAD from the base branch into the pull request branch. -}
pullsUpdateBranch config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\message url -> { message = message, url = url })
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "message" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "url" Json.Decode.string)
                )
        , body =
            Http.jsonBody
                ((\nullableValue ->
                     case nullableValue of
                         Null ->
                             Json.Encode.null

                         Present value ->
                             (\rec ->
                                 Json.Encode.object
                                     [ ( "expected_head_sha"
                                       , Json.Encode.string
                                             rec.expected_head_sha
                                       )
                                     ]
                             )
                                 value
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{pull_number}"
                config.params.pull_number
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/pulls/{pull_number}/update-branch"
                    )
                )
        }


{-| Gets the preferred README for a repository.

READMEs support [custom media types](https://docs.github.com/rest/reference/repos#custom-media-types) for retrieving the raw content or rendered HTML.
-}
reposGetReadme :
    { toMsg : Result Http.Error ContentFile -> msg
    , params : { owner : String, repo : String, ref : Maybe String }
    }
    -> Cmd msg
reposGetReadme config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeContentFile
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/readme"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map (Url.Builder.string "ref") config.params.ref ]
                )
        }


{-| Gets the README from a repository directory.

READMEs support [custom media types](https://docs.github.com/rest/reference/repos#custom-media-types) for retrieving the raw content or rendered HTML.
-}
reposGetReadmeInDirectory :
    { toMsg : Result Http.Error ContentFile -> msg
    , params :
        { owner : String, repo : String, dir : String, ref : Maybe String }
    }
    -> Cmd msg
reposGetReadmeInDirectory config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeContentFile
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{dir}"
                    config.params.dir
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/readme/{dir}"
                        )
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map (Url.Builder.string "ref") config.params.ref ]
                )
        }


{-| This returns a list of releases, which does not include regular Git tags that have not been associated with a release. To get a list of Git tags, use the [Repository Tags API](https://docs.github.com/rest/reference/repos#list-repository-tags).

Information about published releases are available to everyone. Only users with push access will receive listings for draft releases.
-}
reposListReleases :
    { toMsg : Result Http.Error (List Release) -> msg
    , params :
        { owner : String
        , repo : String
        , per_page : Maybe Int
        , page : Maybe Int
        }
    }
    -> Cmd msg
reposListReleases config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.list decodeRelease)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/releases"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Users with push access to the repository can create a release.

This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
-}
reposCreateRelease :
    { toMsg : Result Http.Error Release -> msg
    , body :
        { body : String
        , discussion_category_name : String
        , draft : Bool
        , generate_release_notes : Bool
        , name : String
        , prerelease : Bool
        , tag_name : String
        , target_commitish : String
        }
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
reposCreateRelease config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeRelease
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "body", Json.Encode.string rec.body )
                         , ( "discussion_category_name"
                           , Json.Encode.string rec.discussion_category_name
                           )
                         , ( "draft", Json.Encode.bool rec.draft )
                         , ( "generate_release_notes"
                           , Json.Encode.bool rec.generate_release_notes
                           )
                         , ( "name", Json.Encode.string rec.name )
                         , ( "prerelease", Json.Encode.bool rec.prerelease )
                         , ( "tag_name", Json.Encode.string rec.tag_name )
                         , ( "target_commitish"
                           , Json.Encode.string rec.target_commitish
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/releases"
                )
        }


{-| To download the asset's binary content, set the `Accept` header of the request to [`application/octet-stream`](https://docs.github.com/rest/overview/media-types). The API will either redirect the client to the location, or stream it directly if possible. API clients should handle both a `200` or `302` response. -}
reposGetReleaseAsset config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeReleaseAsset
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{asset_id}"
                config.params.asset_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/releases/assets/{asset_id}"
                    )
                )
        }


{-| Users with push access to the repository can edit a release asset. -}
reposUpdateReleaseAsset config =
    Http.request
        { method = "PATCH"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeReleaseAsset
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "label", Json.Encode.string rec.label )
                         , ( "name", Json.Encode.string rec.name )
                         , ( "state", Json.Encode.string rec.state )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{asset_id}"
                config.params.asset_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/releases/assets/{asset_id}"
                    )
                )
        }


reposDeleteReleaseAsset config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{asset_id}"
                config.params.asset_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/releases/assets/{asset_id}"
                    )
                )
        }


{-| Generate a name and body describing a [release](https://docs.github.com/rest/reference/repos#releases). The body content will be markdown formatted and contain information like the changes since last release and users who contributed. The generated release notes are not saved anywhere. They are intended to be generated and used when creating a new release. -}
reposGenerateReleaseNotes :
    { toMsg : Result Http.Error ReleaseNotesContent -> msg
    , body :
        { configuration_file_path : String
        , previous_tag_name : String
        , tag_name : String
        , target_commitish : String
        }
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
reposGenerateReleaseNotes config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeReleaseNotesContent
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "configuration_file_path"
                           , Json.Encode.string rec.configuration_file_path
                           )
                         , ( "previous_tag_name"
                           , Json.Encode.string rec.previous_tag_name
                           )
                         , ( "tag_name", Json.Encode.string rec.tag_name )
                         , ( "target_commitish"
                           , Json.Encode.string rec.target_commitish
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/releases/generate-notes"
                )
        }


{-| View the latest published full release for the repository.

The latest release is the most recent non-prerelease, non-draft release, sorted by the `created_at` attribute. The `created_at` attribute is the date of the commit used for the release, and not the date when the release was drafted or published.
-}
reposGetLatestRelease :
    { toMsg : Result Http.Error Release -> msg
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
reposGetLatestRelease config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeRelease
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/releases/latest"
                )
        }


{-| Get a published release with the specified tag. -}
reposGetReleaseByTag :
    { toMsg : Result Http.Error Release -> msg
    , params : { owner : String, repo : String, tag : String }
    }
    -> Cmd msg
reposGetReleaseByTag config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeRelease
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{tag}"
                config.params.tag
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/releases/tags/{tag}"
                    )
                )
        }


{-| **Note:** This returns an `upload_url` key corresponding to the endpoint for uploading release assets. This key is a [hypermedia resource](https://docs.github.com/rest/overview/resources-in-the-rest-api#hypermedia). -}
reposGetRelease config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeRelease
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{release_id}"
                config.params.release_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/releases/{release_id}"
                    )
                )
        }


{-| Users with push access to the repository can edit a release. -}
reposUpdateRelease config =
    Http.request
        { method = "PATCH"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeRelease
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "body", Json.Encode.string rec.body )
                         , ( "discussion_category_name"
                           , Json.Encode.string rec.discussion_category_name
                           )
                         , ( "draft", Json.Encode.bool rec.draft )
                         , ( "name", Json.Encode.string rec.name )
                         , ( "prerelease", Json.Encode.bool rec.prerelease )
                         , ( "tag_name", Json.Encode.string rec.tag_name )
                         , ( "target_commitish"
                           , Json.Encode.string rec.target_commitish
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{release_id}"
                config.params.release_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/releases/{release_id}"
                    )
                )
        }


{-| Users with push access to the repository can delete a release. -}
reposDeleteRelease config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{release_id}"
                config.params.release_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/releases/{release_id}"
                    )
                )
        }


reposListReleaseAssets config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeReleaseAsset)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{release_id}"
                    config.params.release_id
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/releases/{release_id}/assets"
                        )
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| This endpoint makes use of [a Hypermedia relation](https://docs.github.com/rest/overview/resources-in-the-rest-api#hypermedia) to determine which URL to access. The endpoint you call to upload release assets is specific to your release. Use the `upload_url` returned in
the response of the [Create a release endpoint](https://docs.github.com/rest/reference/repos#create-a-release) to upload a release asset.

You need to use an HTTP client which supports [SNI](http://en.wikipedia.org/wiki/Server_Name_Indication) to make calls to this endpoint.

Most libraries will set the required `Content-Length` header automatically. Use the required `Content-Type` header to provide the media type of the asset. For a list of media types, see [Media Types](https://www.iana.org/assignments/media-types/media-types.xhtml). For example: 

`application/zip`

GitHub expects the asset data in its raw binary form, rather than JSON. You will send the raw binary content of the asset as the request body. Everything else about the endpoint is the same as the rest of the API. For example,
you'll still need to pass your authentication to be able to upload an asset.

When an upstream failure occurs, you will receive a `502 Bad Gateway` status. This may leave an empty asset with a state of `starter`. It can be safely deleted.

**Notes:**
*   GitHub renames asset filenames that have special characters, non-alphanumeric characters, and leading or trailing periods. The "[List assets for a release](https://docs.github.com/rest/reference/repos#list-assets-for-a-release)"
endpoint lists the renamed filenames. For more information and help, contact [GitHub Support](https://support.github.com/contact?tags=dotcom-rest-api).
*   If you upload an asset with the same filename as another uploaded asset, you'll receive an error and must delete the old file before you can re-upload the new asset.
-}
reposUploadReleaseAsset config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeReleaseAsset
        , body = Http.stringBody "*/*" config.body
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{release_id}"
                    config.params.release_id
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/releases/{release_id}/assets"
                        )
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Just (Url.Builder.string "name" config.params.name)
                    , Maybe.map (Url.Builder.string "label") config.params.label
                    ]
                )
        }


{-| List the reactions to a [release](https://docs.github.com/rest/reference/repos#releases). -}
reactionsListForRelease config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeReaction)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{release_id}"
                    config.params.release_id
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/releases/{release_id}/reactions"
                        )
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (Url.Builder.string "content")
                        config.params.content
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Create a reaction to a [release](https://docs.github.com/rest/reference/repos#releases). A response with a `Status: 200 OK` means that you already added the reaction type to this release. -}
reactionsCreateForRelease config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeReaction
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "content", Json.Encode.string rec.content ) ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{release_id}"
                config.params.release_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/releases/{release_id}/reactions"
                    )
                )
        }


{-| **Note:** You can also specify a repository by `repository_id` using the route `DELETE delete /repositories/:repository_id/releases/:release_id/reactions/:reaction_id`.

Delete a reaction to a [release](https://docs.github.com/rest/reference/repos#releases).
-}
reactionsDeleteForRelease config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{reaction_id}"
                config.params.reaction_id
                (String.replace
                    "{release_id}"
                    config.params.release_id
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/releases/{release_id}/reactions/{reaction_id}"
                        )
                    )
                )
        }


{-| Lists secret scanning alerts for an eligible repository, from newest to oldest.
To use this endpoint, you must be an administrator for the repository or for the organization that owns the repository, and you must use a personal access token with the `repo` scope or `security_events` scope.
For public repositories, you may instead use the `public_repo` scope.

GitHub Apps must have the `secret_scanning_alerts` read permission to use this endpoint.
-}
secretScanningListAlertsForRepo :
    { toMsg : Result Http.Error (List SecretScanningAlert) -> msg
    , params :
        { owner : String
        , repo : String
        , state : Maybe String
        , secret_type : Maybe String
        , resolution : Maybe String
        , sort : Maybe String
        , direction : Maybe String
        , page : Maybe Int
        , per_page : Maybe Int
        , before : Maybe String
        , after : Maybe String
        }
    }
    -> Cmd msg
secretScanningListAlertsForRepo config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeSecretScanningAlert)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/secret-scanning/alerts"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map (Url.Builder.string "state") config.params.state
                    , Maybe.map
                        (Url.Builder.string "secret_type")
                        config.params.secret_type
                    , Maybe.map
                        (Url.Builder.string "resolution")
                        config.params.resolution
                    , Maybe.map (Url.Builder.string "sort") config.params.sort
                    , Maybe.map
                        (Url.Builder.string "direction")
                        config.params.direction
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (Url.Builder.string "before")
                        config.params.before
                    , Maybe.map (Url.Builder.string "after") config.params.after
                    ]
                )
        }


{-| Gets a single secret scanning alert detected in an eligible repository.
To use this endpoint, you must be an administrator for the repository or for the organization that owns the repository, and you must use a personal access token with the `repo` scope or `security_events` scope.
For public repositories, you may instead use the `public_repo` scope.

GitHub Apps must have the `secret_scanning_alerts` read permission to use this endpoint.
-}
secretScanningGetAlert config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeSecretScanningAlert
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{alert_number}"
                config.params.alert_number
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"
                    )
                )
        }


{-| Updates the status of a secret scanning alert in an eligible repository.
To use this endpoint, you must be an administrator for the repository or for the organization that owns the repository, and you must use a personal access token with the `repo` scope or `security_events` scope.
For public repositories, you may instead use the `public_repo` scope.

GitHub Apps must have the `secret_scanning_alerts` write permission to use this endpoint.
-}
secretScanningUpdateAlert config =
    Http.request
        { method = "PATCH"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeSecretScanningAlert
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "resolution"
                           , encodeSecretScanningAlertResolution rec.resolution
                           )
                         , ( "resolution_comment"
                           , encodeSecretScanningAlertResolutionComment
                                 rec.resolution_comment
                           )
                         , ( "state", encodeSecretScanningAlertState rec.state )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{alert_number}"
                config.params.alert_number
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"
                    )
                )
        }


{-| Lists all locations for a given secret scanning alert for an eligible repository.
To use this endpoint, you must be an administrator for the repository or for the organization that owns the repository, and you must use a personal access token with the `repo` scope or `security_events` scope.
For public repositories, you may instead use the `public_repo` scope.

GitHub Apps must have the `secret_scanning_alerts` read permission to use this endpoint.
-}
secretScanningListLocationsForAlert config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeSecretScanningLocation)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{alert_number}"
                    config.params.alert_number
                    (String.replace
                        "{repo}"
                        config.params.repo
                        (String.replace
                            "{owner}"
                            config.params.owner
                            "https://api.github.com/repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations"
                        )
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    ]
                )
        }


{-| Lists the people that have starred the repository.

You can also find out _when_ stars were created by passing the following custom [media type](https://docs.github.com/rest/overview/media-types/) via the `Accept` header: `application/vnd.github.star+json`.
-}
activityListStargazersForRepo :
    { toMsg :
        Result Http.Error (EnumTwo (List SimpleUser) (List Stargazer)) -> msg
    , params :
        { owner : String
        , repo : String
        , per_page : Maybe Int
        , page : Maybe Int
        }
    }
    -> Cmd msg
activityListStargazersForRepo config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Debug.todo "Enum decoder not implemented yet")
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/stargazers"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Returns a weekly aggregate of the number of additions and deletions pushed to a repository. -}
reposGetCodeFrequencyStats :
    { toMsg : Result Http.Error (List CodeFrequencyStat) -> msg
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
reposGetCodeFrequencyStats config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeCodeFrequencyStat)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/stats/code_frequency"
                )
        }


{-| Returns the last year of commit activity grouped by week. The `days` array is a group of commits per day, starting on `Sunday`. -}
reposGetCommitActivityStats :
    { toMsg : Result Http.Error (List CommitActivity) -> msg
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
reposGetCommitActivityStats config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeCommitActivity)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/stats/commit_activity"
                )
        }


{-| Returns the `total` number of commits authored by the contributor. In addition, the response includes a Weekly Hash (`weeks` array) with the following information:

*   `w` - Start of the week, given as a [Unix timestamp](http://en.wikipedia.org/wiki/Unix_time).
*   `a` - Number of additions
*   `d` - Number of deletions
*   `c` - Number of commits
-}
reposGetContributorsStats :
    { toMsg : Result Http.Error (List ContributorActivity) -> msg
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
reposGetContributorsStats config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeContributorActivity)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/stats/contributors"
                )
        }


{-| Returns the total commit counts for the `owner` and total commit counts in `all`. `all` is everyone combined, including the `owner` in the last 52 weeks. If you'd like to get the commit counts for non-owners, you can subtract `owner` from `all`.

The array order is oldest week (index 0) to most recent week.
-}
reposGetParticipationStats :
    { toMsg : Result Http.Error ParticipationStats -> msg
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
reposGetParticipationStats config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeParticipationStats
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/stats/participation"
                )
        }


{-| Each array contains the day number, hour number, and number of commits:

*   `0-6`: Sunday - Saturday
*   `0-23`: Hour of day
*   Number of commits

For example, `[2, 14, 25]` indicates that there were 25 total commits, during the 2:00pm hour on Tuesdays. All times are based on the time zone of individual commits.
-}
reposGetPunchCardStats :
    { toMsg : Result Http.Error (List CodeFrequencyStat) -> msg
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
reposGetPunchCardStats config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeCodeFrequencyStat)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/stats/punch_card"
                )
        }


{-| Users with push access in a repository can create commit statuses for a given SHA.

Note: there is a limit of 1000 statuses per `sha` and `context` within a repository. Attempts to create more than 1000 statuses will result in a validation error.
-}
reposCreateCommitStatus :
    { toMsg : Result Http.Error Status -> msg
    , body :
        { context : String
        , description : Nullable String
        , state : String
        , target_url : Nullable String
        }
    , params : { owner : String, repo : String, sha : String }
    }
    -> Cmd msg
reposCreateCommitStatus config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeStatus
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "context", Json.Encode.string rec.context )
                         , ( "description"
                           , (\nullableValue ->
                                 case nullableValue of
                                     Null ->
                                         Json.Encode.null

                                     Present value ->
                                         Json.Encode.string value
                             )
                                 rec.description
                           )
                         , ( "state", Json.Encode.string rec.state )
                         , ( "target_url"
                           , (\nullableValue ->
                                 case nullableValue of
                                     Null ->
                                         Json.Encode.null

                                     Present value ->
                                         Json.Encode.string value
                             )
                                 rec.target_url
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{sha}"
                config.params.sha
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/statuses/{sha}"
                    )
                )
        }


{-| Lists the people watching the specified repository. -}
activityListWatchersForRepo :
    { toMsg : Result Http.Error (List SimpleUser) -> msg
    , params :
        { owner : String
        , repo : String
        , per_page : Maybe Int
        , page : Maybe Int
        }
    }
    -> Cmd msg
activityListWatchersForRepo config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeSimpleUser)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/subscribers"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


activityGetRepoSubscription :
    { toMsg : Result Http.Error RepositorySubscription -> msg
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
activityGetRepoSubscription config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeRepositorySubscription
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/subscription"
                )
        }


{-| If you would like to watch a repository, set `subscribed` to `true`. If you would like to ignore notifications made within a repository, set `ignored` to `true`. If you would like to stop watching a repository, [delete the repository's subscription](https://docs.github.com/rest/reference/activity#delete-a-repository-subscription) completely. -}
activitySetRepoSubscription :
    { toMsg : Result Http.Error RepositorySubscription -> msg
    , body : { ignored : Bool, subscribed : Bool }
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
activitySetRepoSubscription config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeRepositorySubscription
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "ignored", Json.Encode.bool rec.ignored )
                         , ( "subscribed", Json.Encode.bool rec.subscribed )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/subscription"
                )
        }


{-| This endpoint should only be used to stop watching a repository. To control whether or not you wish to receive notifications from a repository, [set the repository's subscription manually](https://docs.github.com/rest/reference/activity#set-a-repository-subscription). -}
activityDeleteRepoSubscription :
    { toMsg : Result Http.Error () -> msg
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
activityDeleteRepoSubscription config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/subscription"
                )
        }


reposListTags :
    { toMsg : Result Http.Error (List Tag) -> msg
    , params :
        { owner : String
        , repo : String
        , per_page : Maybe Int
        , page : Maybe Int
        }
    }
    -> Cmd msg
reposListTags config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.list decodeTag)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/tags"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| This returns the tag protection states of a repository.

This information is only available to repository administrators.
-}
reposListTagProtection :
    { toMsg : Result Http.Error (List TagProtection) -> msg
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
reposListTagProtection config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeTagProtection)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/tags/protection"
                )
        }


{-| This creates a tag protection state for a repository.
This endpoint is only available to repository administrators.
-}
reposCreateTagProtection :
    { toMsg : Result Http.Error TagProtection -> msg
    , body : { pattern : String }
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
reposCreateTagProtection config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeTagProtection
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "pattern", Json.Encode.string rec.pattern ) ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/tags/protection"
                )
        }


{-| This deletes a tag protection state for a repository.
This endpoint is only available to repository administrators.
-}
reposDeleteTagProtection config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{tag_protection_id}"
                config.params.tag_protection_id
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/tags/protection/{tag_protection_id}"
                    )
                )
        }


reposListTeams :
    { toMsg : Result Http.Error (List Team) -> msg
    , params :
        { owner : String
        , repo : String
        , per_page : Maybe Int
        , page : Maybe Int
        }
    }
    -> Cmd msg
reposListTeams config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.list decodeTeam)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/teams"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


reposGetAllTopics :
    { toMsg : Result Http.Error Topic -> msg
    , params :
        { owner : String
        , repo : String
        , page : Maybe Int
        , per_page : Maybe Int
        }
    }
    -> Cmd msg
reposGetAllTopics config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeTopic
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/topics"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    ]
                )
        }


reposReplaceAllTopics :
    { toMsg : Result Http.Error Topic -> msg
    , body : { names : List String }
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
reposReplaceAllTopics config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeTopic
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "names"
                           , Json.Encode.list Json.Encode.string rec.names
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/topics"
                )
        }


{-| Get the total number of clones and breakdown per day or week for the last 14 days. Timestamps are aligned to UTC midnight of the beginning of the day or week. Week begins on Monday. -}
reposGetClones :
    { toMsg : Result Http.Error CloneTraffic -> msg
    , params : { owner : String, repo : String, per : Maybe String }
    }
    -> Cmd msg
reposGetClones config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeCloneTraffic
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/traffic/clones"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map (Url.Builder.string "per") config.params.per ]
                )
        }


{-| Get the top 10 popular contents over the last 14 days. -}
reposGetTopPaths :
    { toMsg : Result Http.Error (List ContentTraffic) -> msg
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
reposGetTopPaths config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeContentTraffic)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/traffic/popular/paths"
                )
        }


{-| Get the top 10 referrers over the last 14 days. -}
reposGetTopReferrers :
    { toMsg : Result Http.Error (List ReferrerTraffic) -> msg
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
reposGetTopReferrers config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeReferrerTraffic)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/traffic/popular/referrers"
                )
        }


{-| Get the total number of views and breakdown per day or week for the last 14 days. Timestamps are aligned to UTC midnight of the beginning of the day or week. Week begins on Monday. -}
reposGetViews :
    { toMsg : Result Http.Error ViewTraffic -> msg
    , params : { owner : String, repo : String, per : Maybe String }
    }
    -> Cmd msg
reposGetViews config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeViewTraffic
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{repo}"
                    config.params.repo
                    (String.replace
                        "{owner}"
                        config.params.owner
                        "https://api.github.com/repos/{owner}/{repo}/traffic/views"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map (Url.Builder.string "per") config.params.per ]
                )
        }


{-| A transfer request will need to be accepted by the new owner when transferring a personal repository to another user. The response will contain the original `owner`, and the transfer will continue asynchronously. For more details on the requirements to transfer personal and organization-owned repositories, see [about repository transfers](https://docs.github.com/articles/about-repository-transfers/). -}
reposTransfer :
    { toMsg : Result Http.Error MinimalRepository -> msg
    , body : { new_owner : String, team_ids : List Int }
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
reposTransfer config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeMinimalRepository
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "new_owner", Json.Encode.string rec.new_owner )
                         , ( "team_ids"
                           , Json.Encode.list Json.Encode.int rec.team_ids
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/transfer"
                )
        }


{-| Shows whether dependency alerts are enabled or disabled for a repository. The authenticated user must have admin read access to the repository. For more information, see "[About security alerts for vulnerable dependencies](https://docs.github.com/en/articles/about-security-alerts-for-vulnerable-dependencies)". -}
reposCheckVulnerabilityAlerts :
    { toMsg : Result Http.Error () -> msg
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
reposCheckVulnerabilityAlerts config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/vulnerability-alerts"
                )
        }


{-| Enables dependency alerts and the dependency graph for a repository. The authenticated user must have admin access to the repository. For more information, see "[About security alerts for vulnerable dependencies](https://docs.github.com/en/articles/about-security-alerts-for-vulnerable-dependencies)". -}
reposEnableVulnerabilityAlerts :
    { toMsg : Result Http.Error () -> msg
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
reposEnableVulnerabilityAlerts config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/vulnerability-alerts"
                )
        }


{-| Disables dependency alerts and the dependency graph for a repository. The authenticated user must have admin access to the repository. For more information, see "[About security alerts for vulnerable dependencies](https://docs.github.com/en/articles/about-security-alerts-for-vulnerable-dependencies)". -}
reposDisableVulnerabilityAlerts :
    { toMsg : Result Http.Error () -> msg
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
reposDisableVulnerabilityAlerts config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/repos/{owner}/{repo}/vulnerability-alerts"
                )
        }


{-| Creates a new repository using a repository template. Use the `template_owner` and `template_repo` route parameters to specify the repository to use as the template. If the repository is not public, the authenticated user must own or be a member of an organization that owns the repository. To check if a repository is available to use as a template, get the repository's information using the [Get a repository](https://docs.github.com/rest/reference/repos#get-a-repository) endpoint and check that the `is_template` key is `true`.

**OAuth scope requirements**

When using [OAuth](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/), authorizations must include:

*   `public_repo` scope or `repo` scope to create a public repository. Note: For GitHub AE, use `repo` scope to create an internal repository.
*   `repo` scope to create a private repository
-}
reposCreateUsingTemplate :
    { toMsg : Result Http.Error Repository -> msg
    , body :
        { description : String
        , include_all_branches : Bool
        , name : String
        , owner : String
        , private : Bool
        }
    , params : { template_owner : String, template_repo : String }
    }
    -> Cmd msg
reposCreateUsingTemplate config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeRepository
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "description", Json.Encode.string rec.description )
                         , ( "include_all_branches"
                           , Json.Encode.bool rec.include_all_branches
                           )
                         , ( "name", Json.Encode.string rec.name )
                         , ( "owner", Json.Encode.string rec.owner )
                         , ( "private", Json.Encode.bool rec.private )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{template_repo}"
                config.params.template_repo
                (String.replace
                    "{template_owner}"
                    config.params.template_owner
                    "https://api.github.com/repos/{template_owner}/{template_repo}/generate"
                )
        }


{-| Lists all public repositories in the order that they were created.

Note:
- For GitHub Enterprise Server, this endpoint will only list repositories available to all users on the enterprise.
- Pagination is powered exclusively by the `since` parameter. Use the [Link header](https://docs.github.com/rest/overview/resources-in-the-rest-api#link-header) to get the URL for the next page of repositories.
-}
reposListPublic :
    { toMsg : Result Http.Error (List MinimalRepository) -> msg
    , params : { since : Maybe Int }
    }
    -> Cmd msg
reposListPublic config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeMinimalRepository)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                "https://api.github.com/repositories"
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "since"
                                (String.fromInt mapUnpack)
                        )
                        config.params.since
                    ]
                )
        }


{-| Lists all secrets available in an environment without revealing their encrypted values. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository permission to use this endpoint. -}
actionsListEnvironmentSecrets config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\secrets total_count ->
                      { secrets = secrets, total_count = total_count }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "secrets"
                            (Json.Decode.list decodeActionsSecret)
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.int)
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{environment_name}"
                    config.params.environment_name
                    (String.replace
                        "{repository_id}"
                        config.params.repository_id
                        "https://api.github.com/repositories/{repository_id}/environments/{environment_name}/secrets"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Get the public key for an environment, which you need to encrypt environment secrets. You need to encrypt a secret before you can create or update secrets. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `secrets` repository permission to use this endpoint. -}
actionsGetEnvironmentPublicKey config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeActionsPublicKey
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{environment_name}"
                config.params.environment_name
                (String.replace
                    "{repository_id}"
                    config.params.repository_id
                    "https://api.github.com/repositories/{repository_id}/environments/{environment_name}/secrets/public-key"
                )
        }


{-| Gets a single environment secret without revealing its encrypted value. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository permission to use this endpoint. -}
actionsGetEnvironmentSecret config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeActionsSecret
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{secret_name}"
                config.params.secret_name
                (String.replace
                    "{environment_name}"
                    config.params.environment_name
                    (String.replace
                        "{repository_id}"
                        config.params.repository_id
                        "https://api.github.com/repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"
                    )
                )
        }


{-| Creates or updates an environment secret with an encrypted value. Encrypt your secret using
[LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must authenticate using an access
token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository permission to use
this endpoint.

#### Example encrypting a secret using Node.js

Encrypt your secret using the [tweetsodium](https://github.com/github/tweetsodium) library.

```
const sodium = require('tweetsodium');

const key = "base64-encoded-public-key";
const value = "plain-text-secret";

// Convert the message and key to Uint8Array's (Buffer implements that interface)
const messageBytes = Buffer.from(value);
const keyBytes = Buffer.from(key, 'base64');

// Encrypt using LibSodium.
const encryptedBytes = sodium.seal(messageBytes, keyBytes);

// Base64 the encrypted secret
const encrypted = Buffer.from(encryptedBytes).toString('base64');

console.log(encrypted);
```


#### Example encrypting a secret using Python

Encrypt your secret using [pynacl](https://pynacl.readthedocs.io/en/latest/public/#nacl-public-sealedbox) with Python 3.

```
from base64 import b64encode
from nacl import encoding, public

def encrypt(public_key: str, secret_value: str) -> str:
  """Encrypt a Unicode string using the public key."""
  public_key = public.PublicKey(public_key.encode("utf-8"), encoding.Base64Encoder())
  sealed_box = public.SealedBox(public_key)
  encrypted = sealed_box.encrypt(secret_value.encode("utf-8"))
  return b64encode(encrypted).decode("utf-8")
```

#### Example encrypting a secret using C#

Encrypt your secret using the [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package.

```
var secretValue = System.Text.Encoding.UTF8.GetBytes("mySecret");
var publicKey = Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=");

var sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);

Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));
```

#### Example encrypting a secret using Ruby

Encrypt your secret using the [rbnacl](https://github.com/RubyCrypto/rbnacl) gem.

```ruby
require "rbnacl"
require "base64"

key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=")
public_key = RbNaCl::PublicKey.new(key)

box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
encrypted_secret = box.encrypt("my_secret")

# Print the base64 encoded secret
puts Base64.strict_encode64(encrypted_secret)
```
-}
actionsCreateOrUpdateEnvironmentSecret config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeEmptyObject
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "encrypted_value"
                           , Json.Encode.string rec.encrypted_value
                           )
                         , ( "key_id", Json.Encode.string rec.key_id )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{secret_name}"
                config.params.secret_name
                (String.replace
                    "{environment_name}"
                    config.params.environment_name
                    (String.replace
                        "{repository_id}"
                        config.params.repository_id
                        "https://api.github.com/repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"
                    )
                )
        }


{-| Deletes a secret in an environment using the secret name. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository permission to use this endpoint. -}
actionsDeleteEnvironmentSecret config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{secret_name}"
                config.params.secret_name
                (String.replace
                    "{environment_name}"
                    config.params.environment_name
                    (String.replace
                        "{repository_id}"
                        config.params.repository_id
                        "https://api.github.com/repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"
                    )
                )
        }


{-| Searches for query terms inside of a file. This method returns up to 100 results [per page](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination).

When searching for code, you can get text match metadata for the file **content** and file **path** fields when you pass the `text-match` media type. For more details about how to receive highlighted search results, see [Text match metadata](https://docs.github.com/rest/reference/search#text-match-metadata).

For example, if you want to find the definition of the `addClass` function inside [jQuery](https://github.com/jquery/jquery) repository, your query would look something like this:

`q=addClass+in:file+language:js+repo:jquery/jquery`

This query searches for the keyword `addClass` within a file's contents. The query limits the search to files where the language is JavaScript in the `jquery/jquery` repository.

#### Considerations for code search

Due to the complexity of searching code, there are a few restrictions on how searches are performed:

*   Only the _default branch_ is considered. In most cases, this will be the `master` branch.
*   Only files smaller than 384 KB are searchable.
*   You must always include at least one search term when searching source code. For example, searching for [`language:go`](https://github.com/search?utf8=%E2%9C%93&q=language%3Ago&type=Code) is not valid, while [`amazing
language:go`](https://github.com/search?utf8=%E2%9C%93&q=amazing+language%3Ago&type=Code) is.
-}
searchCode config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\incomplete_results items total_count ->
                      { incomplete_results = incomplete_results
                      , items = items
                      , total_count = total_count
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "incomplete_results" Json.Decode.bool
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "items"
                            (Json.Decode.list decodeCodeSearchResultItem)
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.int)
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                "https://api.github.com/search/code"
                []
                (List.filterMap
                    Basics.identity
                    [ Just (Url.Builder.string "q" config.params.q)
                    , Maybe.map (Url.Builder.string "sort") config.params.sort
                    , Maybe.map (Url.Builder.string "order") config.params.order
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Find commits via various criteria on the default branch (usually `master`). This method returns up to 100 results [per page](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination).

When searching for commits, you can get text match metadata for the **message** field when you provide the `text-match` media type. For more details about how to receive highlighted search results, see [Text match
metadata](https://docs.github.com/rest/reference/search#text-match-metadata).

For example, if you want to find commits related to CSS in the [octocat/Spoon-Knife](https://github.com/octocat/Spoon-Knife) repository. Your query would look something like this:

`q=repo:octocat/Spoon-Knife+css`
-}
searchCommits config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\incomplete_results items total_count ->
                      { incomplete_results = incomplete_results
                      , items = items
                      , total_count = total_count
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "incomplete_results" Json.Decode.bool
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "items"
                            (Json.Decode.list decodeCommitSearchResultItem)
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.int)
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                "https://api.github.com/search/commits"
                []
                (List.filterMap
                    Basics.identity
                    [ Just (Url.Builder.string "q" config.params.q)
                    , Maybe.map (Url.Builder.string "sort") config.params.sort
                    , Maybe.map (Url.Builder.string "order") config.params.order
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Find issues by state and keyword. This method returns up to 100 results [per page](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination).

When searching for issues, you can get text match metadata for the issue **title**, issue **body**, and issue **comment body** fields when you pass the `text-match` media type. For more details about how to receive highlighted
search results, see [Text match metadata](https://docs.github.com/rest/reference/search#text-match-metadata).

For example, if you want to find the oldest unresolved Python bugs on Windows. Your query might look something like this.

`q=windows+label:bug+language:python+state:open&sort=created&order=asc`

This query searches for the keyword `windows`, within any open issue that is labeled as `bug`. The search runs across repositories whose primary language is Python. The results are sorted by creation date in ascending order, which means the oldest issues appear first in the search results.

**Note:** For [user-to-server](https://docs.github.com/developers/apps/identifying-and-authorizing-users-for-github-apps#user-to-server-requests) GitHub App requests, you can't retrieve a combination of issues and pull requests in a single query. Requests that don't include the `is:issue` or `is:pull-request` qualifier will receive an HTTP `422 Unprocessable Entity` response. To get results for both issues and pull requests, you must send separate queries for issues and pull requests. For more information about the `is` qualifier, see "[Searching only issues or pull requests](https://docs.github.com/github/searching-for-information-on-github/searching-issues-and-pull-requests#search-only-issues-or-pull-requests)."
-}
searchIssuesAndPullRequests config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\incomplete_results items total_count ->
                      { incomplete_results = incomplete_results
                      , items = items
                      , total_count = total_count
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "incomplete_results" Json.Decode.bool
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "items"
                            (Json.Decode.list decodeIssueSearchResultItem)
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.int)
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                "https://api.github.com/search/issues"
                []
                (List.filterMap
                    Basics.identity
                    [ Just (Url.Builder.string "q" config.params.q)
                    , Maybe.map (Url.Builder.string "sort") config.params.sort
                    , Maybe.map (Url.Builder.string "order") config.params.order
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Find labels in a repository with names or descriptions that match search keywords. Returns up to 100 results [per page](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination).

When searching for labels, you can get text match metadata for the label **name** and **description** fields when you pass the `text-match` media type. For more details about how to receive highlighted search results, see [Text match metadata](https://docs.github.com/rest/reference/search#text-match-metadata).

For example, if you want to find labels in the `linguist` repository that match `bug`, `defect`, or `enhancement`. Your query might look like this:

`q=bug+defect+enhancement&repository_id=64778136`

The labels that best match the query appear first in the search results.
-}
searchLabels config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\incomplete_results items total_count ->
                      { incomplete_results = incomplete_results
                      , items = items
                      , total_count = total_count
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "incomplete_results" Json.Decode.bool
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "items"
                            (Json.Decode.list decodeLabelSearchResultItem)
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.int)
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                "https://api.github.com/search/labels"
                []
                (List.filterMap
                    Basics.identity
                    [ Just
                        (Url.Builder.string
                            "repository_id"
                            (String.fromInt config.params.repository_id)
                        )
                    , Just (Url.Builder.string "q" config.params.q)
                    , Maybe.map (Url.Builder.string "sort") config.params.sort
                    , Maybe.map (Url.Builder.string "order") config.params.order
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Find repositories via various criteria. This method returns up to 100 results [per page](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination).

When searching for repositories, you can get text match metadata for the **name** and **description** fields when you pass the `text-match` media type. For more details about how to receive highlighted search results, see [Text match metadata](https://docs.github.com/rest/reference/search#text-match-metadata).

For example, if you want to search for popular Tetris repositories written in assembly code, your query might look like this:

`q=tetris+language:assembly&sort=stars&order=desc`

This query searches for repositories with the word `tetris` in the name, the description, or the README. The results are limited to repositories where the primary language is assembly. The results are sorted by stars in descending order, so that the most popular repositories appear first in the search results.
-}
searchRepos config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\incomplete_results items total_count ->
                      { incomplete_results = incomplete_results
                      , items = items
                      , total_count = total_count
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "incomplete_results" Json.Decode.bool
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "items"
                            (Json.Decode.list decodeRepoSearchResultItem)
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.int)
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                "https://api.github.com/search/repositories"
                []
                (List.filterMap
                    Basics.identity
                    [ Just (Url.Builder.string "q" config.params.q)
                    , Maybe.map (Url.Builder.string "sort") config.params.sort
                    , Maybe.map (Url.Builder.string "order") config.params.order
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Find topics via various criteria. Results are sorted by best match. This method returns up to 100 results [per page](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination). See "[Searching topics](https://docs.github.com/articles/searching-topics/)" for a detailed list of qualifiers.

When searching for topics, you can get text match metadata for the topic's **short\_description**, **description**, **name**, or **display\_name** field when you pass the `text-match` media type. For more details about how to receive highlighted search results, see [Text match metadata](https://docs.github.com/rest/reference/search#text-match-metadata).

For example, if you want to search for topics related to Ruby that are featured on https://github.com/topics. Your query might look like this:

`q=ruby+is:featured`

This query searches for topics with the keyword `ruby` and limits the results to find only topics that are featured. The topics that are the best match for the query appear first in the search results.
-}
searchTopics config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\incomplete_results items total_count ->
                      { incomplete_results = incomplete_results
                      , items = items
                      , total_count = total_count
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "incomplete_results" Json.Decode.bool
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "items"
                            (Json.Decode.list decodeTopicSearchResultItem)
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.int)
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                "https://api.github.com/search/topics"
                []
                (List.filterMap
                    Basics.identity
                    [ Just (Url.Builder.string "q" config.params.q)
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Find users via various criteria. This method returns up to 100 results [per page](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination).

When searching for users, you can get text match metadata for the issue **login**, public **email**, and **name** fields when you pass the `text-match` media type. For more details about highlighting search results, see [Text match metadata](https://docs.github.com/rest/reference/search#text-match-metadata). For more details about how to receive highlighted search results, see [Text match metadata](https://docs.github.com/rest/reference/search#text-match-metadata).

For example, if you're looking for a list of popular users, you might try this query:

`q=tom+repos:%3E42+followers:%3E1000`

This query searches for users with the name `tom`. The results are restricted to users with more than 42 repositories and over 1,000 followers.
-}
searchUsers config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\incomplete_results items total_count ->
                      { incomplete_results = incomplete_results
                      , items = items
                      , total_count = total_count
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "incomplete_results" Json.Decode.bool
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "items"
                            (Json.Decode.list decodeUserSearchResultItem)
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.int)
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                "https://api.github.com/search/users"
                []
                (List.filterMap
                    Basics.identity
                    [ Just (Url.Builder.string "q" config.params.q)
                    , Maybe.map (Url.Builder.string "sort") config.params.sort
                    , Maybe.map (Url.Builder.string "order") config.params.order
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the [Get a team by name](https://docs.github.com/rest/reference/teams#get-a-team-by-name) endpoint. -}
teamsGetLegacy config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeTeamFull
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{team_id}"
                config.params.team_id
                "https://api.github.com/teams/{team_id}"
        }


{-| **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Update a team](https://docs.github.com/rest/reference/teams#update-a-team) endpoint.

To edit a team, the authenticated user must either be an organization owner or a team maintainer.

**Note:** With nested teams, the `privacy` for parent teams cannot be `secret`.
-}
teamsUpdateLegacy config =
    Http.request
        { method = "PATCH"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeTeamFull
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "description", Json.Encode.string rec.description )
                         , ( "name", Json.Encode.string rec.name )
                         , ( "parent_team_id"
                           , (\nullableValue ->
                                 case nullableValue of
                                     Null ->
                                         Json.Encode.null

                                     Present value ->
                                         Json.Encode.int value
                             )
                                 rec.parent_team_id
                           )
                         , ( "permission", Json.Encode.string rec.permission )
                         , ( "privacy", Json.Encode.string rec.privacy )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{team_id}"
                config.params.team_id
                "https://api.github.com/teams/{team_id}"
        }


{-| **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Delete a team](https://docs.github.com/rest/reference/teams#delete-a-team) endpoint.

To delete a team, the authenticated user must be an organization owner or team maintainer.

If you are an organization owner, deleting a parent team will delete all of its child teams as well.
-}
teamsDeleteLegacy config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{team_id}"
                config.params.team_id
                "https://api.github.com/teams/{team_id}"
        }


{-| **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List discussions`](https://docs.github.com/rest/reference/teams#list-discussions) endpoint.

List all discussions on a team's page. OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
-}
teamsListDiscussionsLegacy config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeTeamDiscussion)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{team_id}"
                    config.params.team_id
                    "https://api.github.com/teams/{team_id}/discussions"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (Url.Builder.string "direction")
                        config.params.direction
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`Create a discussion`](https://docs.github.com/rest/reference/teams#create-a-discussion) endpoint.

Creates a new discussion post on a team's page. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).

This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
-}
teamsCreateDiscussionLegacy config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeTeamDiscussion
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "body", Json.Encode.string rec.body )
                         , ( "private", Json.Encode.bool rec.private )
                         , ( "title", Json.Encode.string rec.title )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{team_id}"
                config.params.team_id
                "https://api.github.com/teams/{team_id}/discussions"
        }


{-| **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Get a discussion](https://docs.github.com/rest/reference/teams#get-a-discussion) endpoint.

Get a specific discussion on a team's page. OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
-}
teamsGetDiscussionLegacy config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeTeamDiscussion
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{discussion_number}"
                config.params.discussion_number
                (String.replace
                    "{team_id}"
                    config.params.team_id
                    "https://api.github.com/teams/{team_id}/discussions/{discussion_number}"
                )
        }


{-| **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Update a discussion](https://docs.github.com/rest/reference/teams#update-a-discussion) endpoint.

Edits the title and body text of a discussion post. Only the parameters you provide are updated. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
-}
teamsUpdateDiscussionLegacy config =
    Http.request
        { method = "PATCH"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeTeamDiscussion
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "body", Json.Encode.string rec.body )
                         , ( "title", Json.Encode.string rec.title )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{discussion_number}"
                config.params.discussion_number
                (String.replace
                    "{team_id}"
                    config.params.team_id
                    "https://api.github.com/teams/{team_id}/discussions/{discussion_number}"
                )
        }


{-| **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`Delete a discussion`](https://docs.github.com/rest/reference/teams#delete-a-discussion) endpoint.

Delete a discussion from a team's page. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
-}
teamsDeleteDiscussionLegacy config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{discussion_number}"
                config.params.discussion_number
                (String.replace
                    "{team_id}"
                    config.params.team_id
                    "https://api.github.com/teams/{team_id}/discussions/{discussion_number}"
                )
        }


{-| **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [List discussion comments](https://docs.github.com/rest/reference/teams#list-discussion-comments) endpoint.

List all comments on a team discussion. OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
-}
teamsListDiscussionCommentsLegacy config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeTeamDiscussionComment)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{discussion_number}"
                    config.params.discussion_number
                    (String.replace
                        "{team_id}"
                        config.params.team_id
                        "https://api.github.com/teams/{team_id}/discussions/{discussion_number}/comments"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (Url.Builder.string "direction")
                        config.params.direction
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Create a discussion comment](https://docs.github.com/rest/reference/teams#create-a-discussion-comment) endpoint.

Creates a new comment on a team discussion. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).

This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
-}
teamsCreateDiscussionCommentLegacy config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeTeamDiscussionComment
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "body", Json.Encode.string rec.body ) ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{discussion_number}"
                config.params.discussion_number
                (String.replace
                    "{team_id}"
                    config.params.team_id
                    "https://api.github.com/teams/{team_id}/discussions/{discussion_number}/comments"
                )
        }


{-| **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Get a discussion comment](https://docs.github.com/rest/reference/teams#get-a-discussion-comment) endpoint.

Get a specific comment on a team discussion. OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
-}
teamsGetDiscussionCommentLegacy config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeTeamDiscussionComment
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{comment_number}"
                config.params.comment_number
                (String.replace
                    "{discussion_number}"
                    config.params.discussion_number
                    (String.replace
                        "{team_id}"
                        config.params.team_id
                        "https://api.github.com/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}"
                    )
                )
        }


{-| **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Update a discussion comment](https://docs.github.com/rest/reference/teams#update-a-discussion-comment) endpoint.

Edits the body text of a discussion comment. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
-}
teamsUpdateDiscussionCommentLegacy config =
    Http.request
        { method = "PATCH"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeTeamDiscussionComment
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "body", Json.Encode.string rec.body ) ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{comment_number}"
                config.params.comment_number
                (String.replace
                    "{discussion_number}"
                    config.params.discussion_number
                    (String.replace
                        "{team_id}"
                        config.params.team_id
                        "https://api.github.com/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}"
                    )
                )
        }


{-| **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Delete a discussion comment](https://docs.github.com/rest/reference/teams#delete-a-discussion-comment) endpoint.

Deletes a comment on a team discussion. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
-}
teamsDeleteDiscussionCommentLegacy config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{comment_number}"
                config.params.comment_number
                (String.replace
                    "{discussion_number}"
                    config.params.discussion_number
                    (String.replace
                        "{team_id}"
                        config.params.team_id
                        "https://api.github.com/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}"
                    )
                )
        }


{-| **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List reactions for a team discussion comment`](https://docs.github.com/rest/reference/reactions#list-reactions-for-a-team-discussion-comment) endpoint.

List the reactions to a [team discussion comment](https://docs.github.com/rest/reference/teams#discussion-comments). OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
-}
reactionsListForTeamDiscussionCommentLegacy config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeReaction)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{comment_number}"
                    config.params.comment_number
                    (String.replace
                        "{discussion_number}"
                        config.params.discussion_number
                        (String.replace
                            "{team_id}"
                            config.params.team_id
                            "https://api.github.com/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions"
                        )
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (Url.Builder.string "content")
                        config.params.content
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new "[Create reaction for a team discussion comment](https://docs.github.com/rest/reference/reactions#create-reaction-for-a-team-discussion-comment)" endpoint.

Create a reaction to a [team discussion comment](https://docs.github.com/rest/reference/teams#discussion-comments). OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). A response with an HTTP `200` status means that you already added the reaction type to this team discussion comment.
-}
reactionsCreateForTeamDiscussionCommentLegacy config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeReaction
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "content", Json.Encode.string rec.content ) ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{comment_number}"
                config.params.comment_number
                (String.replace
                    "{discussion_number}"
                    config.params.discussion_number
                    (String.replace
                        "{team_id}"
                        config.params.team_id
                        "https://api.github.com/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions"
                    )
                )
        }


{-| **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List reactions for a team discussion`](https://docs.github.com/rest/reference/reactions#list-reactions-for-a-team-discussion) endpoint.

List the reactions to a [team discussion](https://docs.github.com/rest/reference/teams#discussions). OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
-}
reactionsListForTeamDiscussionLegacy config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeReaction)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{discussion_number}"
                    config.params.discussion_number
                    (String.replace
                        "{team_id}"
                        config.params.team_id
                        "https://api.github.com/teams/{team_id}/discussions/{discussion_number}/reactions"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (Url.Builder.string "content")
                        config.params.content
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`Create reaction for a team discussion`](https://docs.github.com/rest/reference/reactions#create-reaction-for-a-team-discussion) endpoint.

Create a reaction to a [team discussion](https://docs.github.com/rest/reference/teams#discussions). OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). A response with an HTTP `200` status means that you already added the reaction type to this team discussion.
-}
reactionsCreateForTeamDiscussionLegacy config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeReaction
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "content", Json.Encode.string rec.content ) ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{discussion_number}"
                config.params.discussion_number
                (String.replace
                    "{team_id}"
                    config.params.team_id
                    "https://api.github.com/teams/{team_id}/discussions/{discussion_number}/reactions"
                )
        }


{-| **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List pending team invitations`](https://docs.github.com/rest/reference/teams#list-pending-team-invitations) endpoint.

The return hash contains a `role` field which refers to the Organization Invitation role and will be one of the following values: `direct_member`, `admin`, `billing_manager`, `hiring_manager`, or `reinstate`. If the invitee is not a GitHub member, the `login` field in the return hash will be `null`.
-}
teamsListPendingInvitationsLegacy config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeOrganizationInvitation)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{team_id}"
                    config.params.team_id
                    "https://api.github.com/teams/{team_id}/invitations"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List team members`](https://docs.github.com/rest/reference/teams#list-team-members) endpoint.

Team members will include the members of child teams.
-}
teamsListMembersLegacy config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeSimpleUser)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{team_id}"
                    config.params.team_id
                    "https://api.github.com/teams/{team_id}/members"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map (Url.Builder.string "role") config.params.role
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| The "Get team member" endpoint (described below) is deprecated.

We recommend using the [Get team membership for a user](https://docs.github.com/rest/reference/teams#get-team-membership-for-a-user) endpoint instead. It allows you to get both active and pending memberships.

To list members in a team, the team must be visible to the authenticated user.
-}
teamsGetMemberLegacy config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{username}"
                config.params.username
                (String.replace
                    "{team_id}"
                    config.params.team_id
                    "https://api.github.com/teams/{team_id}/members/{username}"
                )
        }


{-| The "Add team member" endpoint (described below) is deprecated.

We recommend using the [Add or update team membership for a user](https://docs.github.com/rest/reference/teams#add-or-update-team-membership-for-a-user) endpoint instead. It allows you to invite new organization members to your teams.

Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

To add someone to a team, the authenticated user must be an organization owner or a team maintainer in the team they're changing. The person being added to the team must be a member of the team's organization.

**Note:** When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see an error if you attempt to use the API for making changes to the team's membership. If you have access to manage group membership in your IdP, you can manage GitHub team membership through your identity provider, which automatically adds and removes team members in an organization. For more information, see "[Synchronizing teams between your identity provider and GitHub](https://docs.github.com/articles/synchronizing-teams-between-your-identity-provider-and-github/)."

Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs)."
-}
teamsAddMemberLegacy config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{username}"
                config.params.username
                (String.replace
                    "{team_id}"
                    config.params.team_id
                    "https://api.github.com/teams/{team_id}/members/{username}"
                )
        }


{-| The "Remove team member" endpoint (described below) is deprecated.

We recommend using the [Remove team membership for a user](https://docs.github.com/rest/reference/teams#remove-team-membership-for-a-user) endpoint instead. It allows you to remove both active and pending memberships.

Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

To remove a team member, the authenticated user must have 'admin' permissions to the team or be an owner of the org that the team is associated with. Removing a team member does not delete the user, it just removes them from the team.

**Note:** When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see an error if you attempt to use the API for making changes to the team's membership. If you have access to manage group membership in your IdP, you can manage GitHub team membership through your identity provider, which automatically adds and removes team members in an organization. For more information, see "[Synchronizing teams between your identity provider and GitHub](https://docs.github.com/articles/synchronizing-teams-between-your-identity-provider-and-github/)."
-}
teamsRemoveMemberLegacy config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{username}"
                config.params.username
                (String.replace
                    "{team_id}"
                    config.params.team_id
                    "https://api.github.com/teams/{team_id}/members/{username}"
                )
        }


{-| **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Get team membership for a user](https://docs.github.com/rest/reference/teams#get-team-membership-for-a-user) endpoint.

Team members will include the members of child teams.

To get a user's membership with a team, the team must be visible to the authenticated user.

**Note:**
The response contains the `state` of the membership and the member's `role`.

The `role` for organization owners is set to `maintainer`. For more information about `maintainer` roles, see [Create a team](https://docs.github.com/rest/reference/teams#create-a-team).
-}
teamsGetMembershipForUserLegacy config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeTeamMembership
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{username}"
                config.params.username
                (String.replace
                    "{team_id}"
                    config.params.team_id
                    "https://api.github.com/teams/{team_id}/memberships/{username}"
                )
        }


{-| **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Add or update team membership for a user](https://docs.github.com/rest/reference/teams#add-or-update-team-membership-for-a-user) endpoint.

Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

If the user is already a member of the team's organization, this endpoint will add the user to the team. To add a membership between an organization member and a team, the authenticated user must be an organization owner or a team maintainer.

**Note:** When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see an error if you attempt to use the API for making changes to the team's membership. If you have access to manage group membership in your IdP, you can manage GitHub team membership through your identity provider, which automatically adds and removes team members in an organization. For more information, see "[Synchronizing teams between your identity provider and GitHub](https://docs.github.com/articles/synchronizing-teams-between-your-identity-provider-and-github/)."

If the user is unaffiliated with the team's organization, this endpoint will send an invitation to the user via email. This newly-created membership will be in the "pending" state until the user accepts the invitation, at which point the membership will transition to the "active" state and the user will be added as a member of the team. To add a membership between an unaffiliated user and a team, the authenticated user must be an organization owner.

If the user is already a member of the team, this endpoint will update the role of the team member's role. To update the membership of a team member, the authenticated user must be an organization owner or a team maintainer.
-}
teamsAddOrUpdateMembershipForUserLegacy config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeTeamMembership
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "role", Json.Encode.string rec.role ) ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{username}"
                config.params.username
                (String.replace
                    "{team_id}"
                    config.params.team_id
                    "https://api.github.com/teams/{team_id}/memberships/{username}"
                )
        }


{-| **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Remove team membership for a user](https://docs.github.com/rest/reference/teams#remove-team-membership-for-a-user) endpoint.

Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

To remove a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with. Removing team membership does not delete the user, it just removes their membership from the team.

**Note:** When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see an error if you attempt to use the API for making changes to the team's membership. If you have access to manage group membership in your IdP, you can manage GitHub team membership through your identity provider, which automatically adds and removes team members in an organization. For more information, see "[Synchronizing teams between your identity provider and GitHub](https://docs.github.com/articles/synchronizing-teams-between-your-identity-provider-and-github/)."
-}
teamsRemoveMembershipForUserLegacy config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{username}"
                config.params.username
                (String.replace
                    "{team_id}"
                    config.params.team_id
                    "https://api.github.com/teams/{team_id}/memberships/{username}"
                )
        }


{-| **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List team projects`](https://docs.github.com/rest/reference/teams#list-team-projects) endpoint.

Lists the organization projects for a team.
-}
teamsListProjectsLegacy config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeTeamProject)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{team_id}"
                    config.params.team_id
                    "https://api.github.com/teams/{team_id}/projects"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Check team permissions for a project](https://docs.github.com/rest/reference/teams#check-team-permissions-for-a-project) endpoint.

Checks whether a team has `read`, `write`, or `admin` permissions for an organization project. The response includes projects inherited from a parent team.
-}
teamsCheckPermissionsForProjectLegacy config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeTeamProject
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{project_id}"
                config.params.project_id
                (String.replace
                    "{team_id}"
                    config.params.team_id
                    "https://api.github.com/teams/{team_id}/projects/{project_id}"
                )
        }


{-| **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Add or update team project permissions](https://docs.github.com/rest/reference/teams#add-or-update-team-project-permissions) endpoint.

Adds an organization project to a team. To add a project to a team or update the team's permission on a project, the authenticated user must have `admin` permissions for the project. The project and team must be part of the same organization.
-}
teamsAddOrUpdateProjectPermissionsLegacy config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "permission", Json.Encode.string rec.permission ) ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{project_id}"
                config.params.project_id
                (String.replace
                    "{team_id}"
                    config.params.team_id
                    "https://api.github.com/teams/{team_id}/projects/{project_id}"
                )
        }


{-| **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Remove a project from a team](https://docs.github.com/rest/reference/teams#remove-a-project-from-a-team) endpoint.

Removes an organization project from a team. An organization owner or a team maintainer can remove any project from the team. To remove a project from a team as an organization member, the authenticated user must have `read` access to both the team and project, or `admin` access to the team or project. **Note:** This endpoint removes the project from the team, but does not delete it.
-}
teamsRemoveProjectLegacy config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{project_id}"
                config.params.project_id
                (String.replace
                    "{team_id}"
                    config.params.team_id
                    "https://api.github.com/teams/{team_id}/projects/{project_id}"
                )
        }


{-| **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [List team repositories](https://docs.github.com/rest/reference/teams#list-team-repositories) endpoint. -}
teamsListReposLegacy config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeMinimalRepository)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{team_id}"
                    config.params.team_id
                    "https://api.github.com/teams/{team_id}/repos"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| **Note**: Repositories inherited through a parent team will also be checked.

**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Check team permissions for a repository](https://docs.github.com/rest/reference/teams#check-team-permissions-for-a-repository) endpoint.

You can also get information about the specified repository, including what permissions the team grants on it, by passing the following custom [media type](https://docs.github.com/rest/overview/media-types/) via the `Accept` header:
-}
teamsCheckPermissionsForRepoLegacy config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeTeamRepository
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    (String.replace
                        "{team_id}"
                        config.params.team_id
                        "https://api.github.com/teams/{team_id}/repos/{owner}/{repo}"
                    )
                )
        }


{-| **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new "[Add or update team repository permissions](https://docs.github.com/rest/reference/teams#add-or-update-team-repository-permissions)" endpoint.

To add a repository to a team or update the team's permission on a repository, the authenticated user must have admin access to the repository, and must be able to see the team. The repository must be owned by the organization, or a direct fork of a repository owned by the organization. You will get a `422 Unprocessable Entity` status if you attempt to add a repository to a team that is not owned by the organization.

Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs)."
-}
teamsAddOrUpdateRepoPermissionsLegacy config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "permission", Json.Encode.string rec.permission ) ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    (String.replace
                        "{team_id}"
                        config.params.team_id
                        "https://api.github.com/teams/{team_id}/repos/{owner}/{repo}"
                    )
                )
        }


{-| **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Remove a repository from a team](https://docs.github.com/rest/reference/teams#remove-a-repository-from-a-team) endpoint.

If the authenticated user is an organization owner or a team maintainer, they can remove any repositories from the team. To remove a repository from a team as an organization member, the authenticated user must have admin access to the repository and must be able to see the team. NOTE: This does not delete the repository, it just removes it from the team.
-}
teamsRemoveRepoLegacy config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    (String.replace
                        "{team_id}"
                        config.params.team_id
                        "https://api.github.com/teams/{team_id}/repos/{owner}/{repo}"
                    )
                )
        }


{-| **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List child teams`](https://docs.github.com/rest/reference/teams#list-child-teams) endpoint. -}
teamsListChildLegacy config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.list decodeTeam)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{team_id}"
                    config.params.team_id
                    "https://api.github.com/teams/{team_id}/teams"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| If the authenticated user is authenticated through basic authentication or OAuth with the `user` scope, then the response lists public and private profile information.

If the authenticated user is authenticated through OAuth without the `user` scope, then the response lists only public profile information.
-}
usersGetAuthenticated :
    { toMsg : Result Http.Error Json.Encode.Value -> msg } -> Cmd msg
usersGetAuthenticated config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg Json.Decode.value
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url = "https://api.github.com/user"
        }


{-| **Note:** If your email is set to private and you send an `email` parameter as part of this request to update your profile, your privacy settings are still enforced: the email address will not be displayed on your public profile or via the API. -}
usersUpdateAuthenticated :
    { toMsg : Result Http.Error PrivateUser -> msg
    , body :
        { bio : String
        , blog : String
        , company : String
        , email : String
        , hireable : Bool
        , location : String
        , name : String
        , twitter_username : Nullable String
        }
    }
    -> Cmd msg
usersUpdateAuthenticated config =
    Http.request
        { method = "PATCH"
        , headers = []
        , expect = Http.expectJson config.toMsg decodePrivateUser
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "bio", Json.Encode.string rec.bio )
                         , ( "blog", Json.Encode.string rec.blog )
                         , ( "company", Json.Encode.string rec.company )
                         , ( "email", Json.Encode.string rec.email )
                         , ( "hireable", Json.Encode.bool rec.hireable )
                         , ( "location", Json.Encode.string rec.location )
                         , ( "name", Json.Encode.string rec.name )
                         , ( "twitter_username"
                           , (\nullableValue ->
                                 case nullableValue of
                                     Null ->
                                         Json.Encode.null

                                     Present value ->
                                         Json.Encode.string value
                             )
                                 rec.twitter_username
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url = "https://api.github.com/user"
        }


{-| List the users you've blocked on your personal account. -}
usersListBlockedByAuthenticatedUser :
    { toMsg : Result Http.Error (List SimpleUser) -> msg } -> Cmd msg
usersListBlockedByAuthenticatedUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeSimpleUser)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url = "https://api.github.com/user/blocks"
        }


usersCheckBlocked :
    { toMsg : Result Http.Error () -> msg, params : { username : String } }
    -> Cmd msg
usersCheckBlocked config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{username}"
                config.params.username
                "https://api.github.com/user/blocks/{username}"
        }


usersBlock :
    { toMsg : Result Http.Error () -> msg, params : { username : String } }
    -> Cmd msg
usersBlock config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{username}"
                config.params.username
                "https://api.github.com/user/blocks/{username}"
        }


usersUnblock :
    { toMsg : Result Http.Error () -> msg, params : { username : String } }
    -> Cmd msg
usersUnblock config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{username}"
                config.params.username
                "https://api.github.com/user/blocks/{username}"
        }


{-| Lists the authenticated user's codespaces.

You must authenticate using an access token with the `codespace` scope to use this endpoint.

GitHub Apps must have read access to the `codespaces` repository permission to use this endpoint.
-}
codespacesListForAuthenticatedUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\codespaces total_count ->
                      { codespaces = codespaces, total_count = total_count }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "codespaces"
                            (Json.Decode.list decodeCodespace)
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.int)
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                "https://api.github.com/user/codespaces"
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "repository_id"
                                (String.fromInt mapUnpack)
                        )
                        config.params.repository_id
                    ]
                )
        }


{-| Creates a new codespace, owned by the authenticated user.

This endpoint requires either a `repository_id` OR a `pull_request` but not both.

You must authenticate using an access token with the `codespace` scope to use this endpoint.

GitHub Apps must have write access to the `codespaces` repository permission to use this endpoint.
-}
codespacesCreateForAuthenticatedUser :
    { toMsg : Result Http.Error Codespace -> msg, body : Json.Encode.Value }
    -> Cmd msg
codespacesCreateForAuthenticatedUser config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeCodespace
        , body = Http.jsonBody (Basics.identity config.body)
        , timeout = Nothing
        , tracker = Nothing
        , url = "https://api.github.com/user/codespaces"
        }


{-| Lists all secrets available for a user's Codespaces without revealing their
encrypted values.

You must authenticate using an access token with the `codespace` or `codespace:secrets` scope to use this endpoint. User must have Codespaces access to use this endpoint.

GitHub Apps must have read access to the `codespaces_user_secrets` user permission to use this endpoint.
-}
codespacesListSecretsForAuthenticatedUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\secrets total_count ->
                      { secrets = secrets, total_count = total_count }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "secrets"
                            (Json.Decode.list decodeCodespacesSecret)
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.int)
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                "https://api.github.com/user/codespaces/secrets"
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before you can create or update secrets.

You must authenticate using an access token with the `codespace` or `codespace:secrets` scope to use this endpoint. User must have Codespaces access to use this endpoint.

GitHub Apps must have read access to the `codespaces_user_secrets` user permission to use this endpoint.
-}
codespacesGetPublicKeyForAuthenticatedUser :
    { toMsg : Result Http.Error CodespacesUserPublicKey -> msg } -> Cmd msg
codespacesGetPublicKeyForAuthenticatedUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeCodespacesUserPublicKey
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url = "https://api.github.com/user/codespaces/secrets/public-key"
        }


{-| Gets a secret available to a user's codespaces without revealing its encrypted value.

You must authenticate using an access token with the `codespace` or `codespace:secrets` scope to use this endpoint. User must have Codespaces access to use this endpoint.

GitHub Apps must have read access to the `codespaces_user_secrets` user permission to use this endpoint.
-}
codespacesGetSecretForAuthenticatedUser :
    { toMsg : Result Http.Error CodespacesSecret -> msg
    , params : { secret_name : String }
    }
    -> Cmd msg
codespacesGetSecretForAuthenticatedUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeCodespacesSecret
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{secret_name}"
                config.params.secret_name
                "https://api.github.com/user/codespaces/secrets/{secret_name}"
        }


{-| Creates or updates a secret for a user's codespace with an encrypted value. Encrypt your secret using
[LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages).

You must authenticate using an access token with the `codespace` or `codespace:secrets` scope to use this endpoint. User must also have Codespaces access to use this endpoint.

GitHub Apps must have read access to the `codespaces_user_secrets` user permission and `codespaces_secrets` repository permission on all referenced repositories to use this endpoint.

#### Example encrypting a secret using Node.js

Encrypt your secret using the [tweetsodium](https://github.com/github/tweetsodium) library.

```
const sodium = require('tweetsodium');

const key = "base64-encoded-public-key";
const value = "plain-text-secret";

// Convert the message and key to Uint8Array's (Buffer implements that interface)
const messageBytes = Buffer.from(value);
const keyBytes = Buffer.from(key, 'base64');

// Encrypt using LibSodium.
const encryptedBytes = sodium.seal(messageBytes, keyBytes);

// Base64 the encrypted secret
const encrypted = Buffer.from(encryptedBytes).toString('base64');

console.log(encrypted);
```


#### Example encrypting a secret using Python

Encrypt your secret using [pynacl](https://pynacl.readthedocs.io/en/latest/public/#nacl-public-sealedbox) with Python 3.

```
from base64 import b64encode
from nacl import encoding, public

def encrypt(public_key: str, secret_value: str) -> str:
  """Encrypt a Unicode string using the public key."""
  public_key = public.PublicKey(public_key.encode("utf-8"), encoding.Base64Encoder())
  sealed_box = public.SealedBox(public_key)
  encrypted = sealed_box.encrypt(secret_value.encode("utf-8"))
  return b64encode(encrypted).decode("utf-8")
```

#### Example encrypting a secret using C#

Encrypt your secret using the [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package.

```
var secretValue = System.Text.Encoding.UTF8.GetBytes("mySecret");
var publicKey = Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=");

var sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);

Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));
```

#### Example encrypting a secret using Ruby

Encrypt your secret using the [rbnacl](https://github.com/RubyCrypto/rbnacl) gem.

```ruby
require "rbnacl"
require "base64"

key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=")
public_key = RbNaCl::PublicKey.new(key)

box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
encrypted_secret = box.encrypt("my_secret")

# Print the base64 encoded secret
puts Base64.strict_encode64(encrypted_secret)
```
-}
codespacesCreateOrUpdateSecretForAuthenticatedUser :
    { toMsg : Result Http.Error {} -> msg
    , body :
        { encrypted_value : String
        , key_id : String
        , selected_repository_ids : List String
        }
    , params : { secret_name : String }
    }
    -> Cmd msg
codespacesCreateOrUpdateSecretForAuthenticatedUser config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.succeed {})
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "encrypted_value"
                           , Json.Encode.string rec.encrypted_value
                           )
                         , ( "key_id", Json.Encode.string rec.key_id )
                         , ( "selected_repository_ids"
                           , Json.Encode.list Json.Encode.string
                                 rec.selected_repository_ids
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{secret_name}"
                config.params.secret_name
                "https://api.github.com/user/codespaces/secrets/{secret_name}"
        }


{-| Deletes a secret from a user's codespaces using the secret name. Deleting the secret will remove access from all codespaces that were allowed to access the secret.

You must authenticate using an access token with the `codespace` or `codespace:secrets` scope to use this endpoint. User must have Codespaces access to use this endpoint.

GitHub Apps must have write access to the `codespaces_user_secrets` user permission to use this endpoint.
-}
codespacesDeleteSecretForAuthenticatedUser :
    { toMsg : Result Http.Error () -> msg, params : { secret_name : String } }
    -> Cmd msg
codespacesDeleteSecretForAuthenticatedUser config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{secret_name}"
                config.params.secret_name
                "https://api.github.com/user/codespaces/secrets/{secret_name}"
        }


{-| List the repositories that have been granted the ability to use a user's codespace secret.

You must authenticate using an access token with the `codespace` or `codespace:secrets` scope to use this endpoint. User must have Codespaces access to use this endpoint.

GitHub Apps must have read access to the `codespaces_user_secrets` user permission and write access to the `codespaces_secrets` repository permission on all referenced repositories to use this endpoint.
-}
codespacesListRepositoriesForSecretForAuthenticatedUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\repositories total_count ->
                      { repositories = repositories, total_count = total_count }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "repositories"
                            (Json.Decode.list decodeMinimalRepository)
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.int)
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{secret_name}"
                config.params.secret_name
                "https://api.github.com/user/codespaces/secrets/{secret_name}/repositories"
        }


{-| Select the repositories that will use a user's codespace secret.

You must authenticate using an access token with the `codespace` or `codespace:secrets` scope to use this endpoint. User must have Codespaces access to use this endpoint.

GitHub Apps must have write access to the `codespaces_user_secrets` user permission and write access to the `codespaces_secrets` repository permission on all referenced repositories to use this endpoint.
-}
codespacesSetRepositoriesForSecretForAuthenticatedUser :
    { toMsg : Result Http.Error () -> msg
    , body : { selected_repository_ids : List Int }
    , params : { secret_name : String }
    }
    -> Cmd msg
codespacesSetRepositoriesForSecretForAuthenticatedUser config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "selected_repository_ids"
                           , Json.Encode.list Json.Encode.int
                                 rec.selected_repository_ids
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{secret_name}"
                config.params.secret_name
                "https://api.github.com/user/codespaces/secrets/{secret_name}/repositories"
        }


{-| Adds a repository to the selected repositories for a user's codespace secret.
You must authenticate using an access token with the `codespace` or `codespace:secrets` scope to use this endpoint. User must have Codespaces access to use this endpoint.
GitHub Apps must have write access to the `codespaces_user_secrets` user permission and write access to the `codespaces_secrets` repository permission on the referenced repository to use this endpoint.
-}
codespacesAddRepositoryForSecretForAuthenticatedUser config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repository_id}"
                config.params.repository_id
                (String.replace
                    "{secret_name}"
                    config.params.secret_name
                    "https://api.github.com/user/codespaces/secrets/{secret_name}/repositories/{repository_id}"
                )
        }


{-| Removes a repository from the selected repositories for a user's codespace secret.
You must authenticate using an access token with the `codespace` or `codespace:secrets` scope to use this endpoint. User must have Codespaces access to use this endpoint.
GitHub Apps must have write access to the `codespaces_user_secrets` user permission to use this endpoint.
-}
codespacesRemoveRepositoryForSecretForAuthenticatedUser config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repository_id}"
                config.params.repository_id
                (String.replace
                    "{secret_name}"
                    config.params.secret_name
                    "https://api.github.com/user/codespaces/secrets/{secret_name}/repositories/{repository_id}"
                )
        }


{-| Gets information about a user's codespace.

You must authenticate using an access token with the `codespace` scope to use this endpoint.

GitHub Apps must have read access to the `codespaces` repository permission to use this endpoint.
-}
codespacesGetForAuthenticatedUser :
    { toMsg : Result Http.Error Codespace -> msg
    , params : { codespace_name : String }
    }
    -> Cmd msg
codespacesGetForAuthenticatedUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeCodespace
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{codespace_name}"
                config.params.codespace_name
                "https://api.github.com/user/codespaces/{codespace_name}"
        }


{-| Updates a codespace owned by the authenticated user. Currently only the codespace's machine type and recent folders can be modified using this endpoint.

If you specify a new machine type it will be applied the next time your codespace is started.

You must authenticate using an access token with the `codespace` scope to use this endpoint.

GitHub Apps must have write access to the `codespaces` repository permission to use this endpoint.
-}
codespacesUpdateForAuthenticatedUser :
    { toMsg : Result Http.Error Codespace -> msg
    , body :
        { display_name : String
        , machine : String
        , recent_folders : List String
        }
    , params : { codespace_name : String }
    }
    -> Cmd msg
codespacesUpdateForAuthenticatedUser config =
    Http.request
        { method = "PATCH"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeCodespace
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "display_name"
                           , Json.Encode.string rec.display_name
                           )
                         , ( "machine", Json.Encode.string rec.machine )
                         , ( "recent_folders"
                           , Json.Encode.list Json.Encode.string
                                 rec.recent_folders
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{codespace_name}"
                config.params.codespace_name
                "https://api.github.com/user/codespaces/{codespace_name}"
        }


{-| Deletes a user's codespace.

You must authenticate using an access token with the `codespace` scope to use this endpoint.

GitHub Apps must have write access to the `codespaces` repository permission to use this endpoint.
-}
codespacesDeleteForAuthenticatedUser :
    { toMsg : Result Http.Error Accepted -> msg
    , params : { codespace_name : String }
    }
    -> Cmd msg
codespacesDeleteForAuthenticatedUser config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeAccepted
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{codespace_name}"
                config.params.codespace_name
                "https://api.github.com/user/codespaces/{codespace_name}"
        }


{-| Triggers an export of the specified codespace and returns a URL and ID where the status of the export can be monitored.

You must authenticate using a personal access token with the `codespace` scope to use this endpoint.

GitHub Apps must have write access to the `codespaces_lifecycle_admin` repository permission to use this endpoint.
-}
codespacesExportForAuthenticatedUser :
    { toMsg : Result Http.Error CodespaceExportDetails -> msg
    , params : { codespace_name : String }
    }
    -> Cmd msg
codespacesExportForAuthenticatedUser config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeCodespaceExportDetails
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{codespace_name}"
                config.params.codespace_name
                "https://api.github.com/user/codespaces/{codespace_name}/exports"
        }


{-| Gets information about an export of a codespace.

You must authenticate using a personal access token with the `codespace` scope to use this endpoint.

GitHub Apps must have read access to the `codespaces_lifecycle_admin` repository permission to use this endpoint.
-}
codespacesGetExportDetailsForAuthenticatedUser :
    { toMsg : Result Http.Error CodespaceExportDetails -> msg
    , params : { codespace_name : String, export_id : String }
    }
    -> Cmd msg
codespacesGetExportDetailsForAuthenticatedUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeCodespaceExportDetails
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{export_id}"
                config.params.export_id
                (String.replace
                    "{codespace_name}"
                    config.params.codespace_name
                    "https://api.github.com/user/codespaces/{codespace_name}/exports/{export_id}"
                )
        }


{-| List the machine types a codespace can transition to use.

You must authenticate using an access token with the `codespace` scope to use this endpoint.

GitHub Apps must have read access to the `codespaces_metadata` repository permission to use this endpoint.
-}
codespacesCodespaceMachinesForAuthenticatedUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\machines total_count ->
                      { machines = machines, total_count = total_count }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "machines"
                            (Json.Decode.list decodeCodespaceMachine)
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.int)
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{codespace_name}"
                config.params.codespace_name
                "https://api.github.com/user/codespaces/{codespace_name}/machines"
        }


{-| Starts a user's codespace.

You must authenticate using an access token with the `codespace` scope to use this endpoint.

GitHub Apps must have write access to the `codespaces_lifecycle_admin` repository permission to use this endpoint.
-}
codespacesStartForAuthenticatedUser :
    { toMsg : Result Http.Error Codespace -> msg
    , params : { codespace_name : String }
    }
    -> Cmd msg
codespacesStartForAuthenticatedUser config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeCodespace
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{codespace_name}"
                config.params.codespace_name
                "https://api.github.com/user/codespaces/{codespace_name}/start"
        }


{-| Stops a user's codespace.

You must authenticate using an access token with the `codespace` scope to use this endpoint.

GitHub Apps must have write access to the `codespaces_lifecycle_admin` repository permission to use this endpoint.
-}
codespacesStopForAuthenticatedUser :
    { toMsg : Result Http.Error Codespace -> msg
    , params : { codespace_name : String }
    }
    -> Cmd msg
codespacesStopForAuthenticatedUser config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeCodespace
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{codespace_name}"
                config.params.codespace_name
                "https://api.github.com/user/codespaces/{codespace_name}/stop"
        }


{-| Sets the visibility for your primary email addresses. -}
usersSetPrimaryEmailVisibilityForAuthenticatedUser :
    { toMsg : Result Http.Error (List Email) -> msg
    , body : { visibility : String }
    }
    -> Cmd msg
usersSetPrimaryEmailVisibilityForAuthenticatedUser config =
    Http.request
        { method = "PATCH"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.list decodeEmail)
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "visibility", Json.Encode.string rec.visibility ) ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url = "https://api.github.com/user/email/visibility"
        }


{-| Lists all of your email addresses, and specifies which one is visible to the public. This endpoint is accessible with the `user:email` scope. -}
usersListEmailsForAuthenticatedUser :
    { toMsg : Result Http.Error (List Email) -> msg
    , params : { per_page : Maybe Int, page : Maybe Int }
    }
    -> Cmd msg
usersListEmailsForAuthenticatedUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.list decodeEmail)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                "https://api.github.com/user/emails"
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| This endpoint is accessible with the `user` scope. -}
usersAddEmailForAuthenticatedUser :
    { toMsg : Result Http.Error (List Email) -> msg, body : Json.Encode.Value }
    -> Cmd msg
usersAddEmailForAuthenticatedUser config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.list decodeEmail)
        , body = Http.jsonBody (Basics.identity config.body)
        , timeout = Nothing
        , tracker = Nothing
        , url = "https://api.github.com/user/emails"
        }


{-| This endpoint is accessible with the `user` scope. -}
usersDeleteEmailForAuthenticatedUser :
    { toMsg : Result Http.Error () -> msg, body : Json.Encode.Value } -> Cmd msg
usersDeleteEmailForAuthenticatedUser config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.jsonBody (Basics.identity config.body)
        , timeout = Nothing
        , tracker = Nothing
        , url = "https://api.github.com/user/emails"
        }


{-| Lists the people following the authenticated user. -}
usersListFollowersForAuthenticatedUser :
    { toMsg : Result Http.Error (List SimpleUser) -> msg
    , params : { per_page : Maybe Int, page : Maybe Int }
    }
    -> Cmd msg
usersListFollowersForAuthenticatedUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeSimpleUser)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                "https://api.github.com/user/followers"
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Lists the people who the authenticated user follows. -}
usersListFollowedByAuthenticatedUser :
    { toMsg : Result Http.Error (List SimpleUser) -> msg
    , params : { per_page : Maybe Int, page : Maybe Int }
    }
    -> Cmd msg
usersListFollowedByAuthenticatedUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeSimpleUser)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                "https://api.github.com/user/following"
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


usersCheckPersonIsFollowedByAuthenticated :
    { toMsg : Result Http.Error () -> msg, params : { username : String } }
    -> Cmd msg
usersCheckPersonIsFollowedByAuthenticated config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{username}"
                config.params.username
                "https://api.github.com/user/following/{username}"
        }


{-| Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs)."

Following a user requires the user to be logged in and authenticated with basic auth or OAuth with the `user:follow` scope.
-}
usersFollow :
    { toMsg : Result Http.Error () -> msg, params : { username : String } }
    -> Cmd msg
usersFollow config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{username}"
                config.params.username
                "https://api.github.com/user/following/{username}"
        }


{-| Unfollowing a user requires the user to be logged in and authenticated with basic auth or OAuth with the `user:follow` scope. -}
usersUnfollow :
    { toMsg : Result Http.Error () -> msg, params : { username : String } }
    -> Cmd msg
usersUnfollow config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{username}"
                config.params.username
                "https://api.github.com/user/following/{username}"
        }


{-| Lists the current user's GPG keys. Requires that you are authenticated via Basic Auth or via OAuth with at least `read:gpg_key` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). -}
usersListGpgKeysForAuthenticatedUser :
    { toMsg : Result Http.Error (List GpgKey) -> msg
    , params : { per_page : Maybe Int, page : Maybe Int }
    }
    -> Cmd msg
usersListGpgKeysForAuthenticatedUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.list decodeGpgKey)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                "https://api.github.com/user/gpg_keys"
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Adds a GPG key to the authenticated user's GitHub account. Requires that you are authenticated via Basic Auth, or OAuth with at least `write:gpg_key` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). -}
usersCreateGpgKeyForAuthenticatedUser :
    { toMsg : Result Http.Error GpgKey -> msg
    , body : { armored_public_key : String, name : String }
    }
    -> Cmd msg
usersCreateGpgKeyForAuthenticatedUser config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeGpgKey
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "armored_public_key"
                           , Json.Encode.string rec.armored_public_key
                           )
                         , ( "name", Json.Encode.string rec.name )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url = "https://api.github.com/user/gpg_keys"
        }


{-| View extended details for a single GPG key. Requires that you are authenticated via Basic Auth or via OAuth with at least `read:gpg_key` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). -}
usersGetGpgKeyForAuthenticatedUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeGpgKey
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{gpg_key_id}"
                config.params.gpg_key_id
                "https://api.github.com/user/gpg_keys/{gpg_key_id}"
        }


{-| Removes a GPG key from the authenticated user's GitHub account. Requires that you are authenticated via Basic Auth or via OAuth with at least `admin:gpg_key` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). -}
usersDeleteGpgKeyForAuthenticatedUser config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{gpg_key_id}"
                config.params.gpg_key_id
                "https://api.github.com/user/gpg_keys/{gpg_key_id}"
        }


{-| Lists installations of your GitHub App that the authenticated user has explicit permission (`:read`, `:write`, or `:admin`) to access.

You must use a [user-to-server OAuth access token](https://docs.github.com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/#identifying-users-on-your-site), created for a user who has authorized your GitHub App, to access this endpoint.

The authenticated user has explicit permission to access repositories they own, repositories where they are a collaborator, and repositories that they can access through an organization membership.

You can find the permissions for the installation under the `permissions` key.
-}
appsListInstallationsForAuthenticatedUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\installations total_count ->
                      { installations = installations
                      , total_count = total_count
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "installations"
                            (Json.Decode.list decodeInstallation)
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.int)
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                "https://api.github.com/user/installations"
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| List repositories that the authenticated user has explicit permission (`:read`, `:write`, or `:admin`) to access for an installation.

The authenticated user has explicit permission to access repositories they own, repositories where they are a collaborator, and repositories that they can access through an organization membership.

You must use a [user-to-server OAuth access token](https://docs.github.com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/#identifying-users-on-your-site), created for a user who has authorized your GitHub App, to access this endpoint.

The access the user has to each repository is included in the hash under the `permissions` key.
-}
appsListInstallationReposForAuthenticatedUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.succeed
                  (\repositories repository_selection total_count ->
                      { repositories = repositories
                      , repository_selection = repository_selection
                      , total_count = total_count
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "repositories"
                            (Json.Decode.list decodeRepository)
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "repository_selection"
                            Json.Decode.string
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total_count" Json.Decode.int)
                )
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{installation_id}"
                    config.params.installation_id
                    "https://api.github.com/user/installations/{installation_id}/repositories"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Add a single repository to an installation. The authenticated user must have admin access to the repository.

You must use a personal access token (which you can create via the [command line](https://docs.github.com/github/authenticating-to-github/creating-a-personal-access-token) or [Basic Authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication)) to access this endpoint.
-}
appsAddRepoToInstallationForAuthenticatedUser config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repository_id}"
                config.params.repository_id
                (String.replace
                    "{installation_id}"
                    config.params.installation_id
                    "https://api.github.com/user/installations/{installation_id}/repositories/{repository_id}"
                )
        }


{-| Remove a single repository from an installation. The authenticated user must have admin access to the repository.

You must use a personal access token (which you can create via the [command line](https://docs.github.com/github/authenticating-to-github/creating-a-personal-access-token) or [Basic Authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication)) to access this endpoint.
-}
appsRemoveRepoFromInstallationForAuthenticatedUser config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repository_id}"
                config.params.repository_id
                (String.replace
                    "{installation_id}"
                    config.params.installation_id
                    "https://api.github.com/user/installations/{installation_id}/repositories/{repository_id}"
                )
        }


{-| Shows which type of GitHub user can interact with your public repositories and when the restriction expires. -}
interactionsGetRestrictionsForAuthenticatedUser :
    { toMsg : Result Http.Error (EnumTwo InteractionLimitResponse {}) -> msg }
    -> Cmd msg
interactionsGetRestrictionsForAuthenticatedUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Debug.todo "Enum decoder not implemented yet")
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url = "https://api.github.com/user/interaction-limits"
        }


{-| Temporarily restricts which type of GitHub user can interact with your public repositories. Setting the interaction limit at the user level will overwrite any interaction limits that are set for individual repositories owned by the user. -}
interactionsSetRestrictionsForAuthenticatedUser :
    { toMsg : Result Http.Error InteractionLimitResponse -> msg
    , body : InteractionLimit
    }
    -> Cmd msg
interactionsSetRestrictionsForAuthenticatedUser config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeInteractionLimitResponse
        , body = Http.jsonBody (encodeInteractionLimit config.body)
        , timeout = Nothing
        , tracker = Nothing
        , url = "https://api.github.com/user/interaction-limits"
        }


{-| Removes any interaction restrictions from your public repositories. -}
interactionsRemoveRestrictionsForAuthenticatedUser :
    { toMsg : Result Http.Error () -> msg } -> Cmd msg
interactionsRemoveRestrictionsForAuthenticatedUser config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url = "https://api.github.com/user/interaction-limits"
        }


{-| List issues across owned and member repositories assigned to the authenticated user.

**Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a pull request. For this
reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by
the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
request id, use the "[List pull requests](https://docs.github.com/rest/reference/pulls#list-pull-requests)" endpoint.
-}
issuesListForAuthenticatedUser :
    { toMsg : Result Http.Error (List Issue) -> msg
    , params :
        { filter : Maybe String
        , state : Maybe String
        , labels : Maybe String
        , sort : Maybe String
        , direction : Maybe String
        , since : Maybe String
        , per_page : Maybe Int
        , page : Maybe Int
        }
    }
    -> Cmd msg
issuesListForAuthenticatedUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.list decodeIssue)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                "https://api.github.com/user/issues"
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (Url.Builder.string "filter")
                        config.params.filter
                    , Maybe.map (Url.Builder.string "state") config.params.state
                    , Maybe.map
                        (Url.Builder.string "labels")
                        config.params.labels
                    , Maybe.map (Url.Builder.string "sort") config.params.sort
                    , Maybe.map
                        (Url.Builder.string "direction")
                        config.params.direction
                    , Maybe.map (Url.Builder.string "since") config.params.since
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Lists the public SSH keys for the authenticated user's GitHub account. Requires that you are authenticated via Basic Auth or via OAuth with at least `read:public_key` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). -}
usersListPublicSshKeysForAuthenticatedUser :
    { toMsg : Result Http.Error (List Key) -> msg
    , params : { per_page : Maybe Int, page : Maybe Int }
    }
    -> Cmd msg
usersListPublicSshKeysForAuthenticatedUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.list decodeKey)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                "https://api.github.com/user/keys"
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Adds a public SSH key to the authenticated user's GitHub account. Requires that you are authenticated via Basic Auth, or OAuth with at least `write:public_key` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). -}
usersCreatePublicSshKeyForAuthenticatedUser :
    { toMsg : Result Http.Error Key -> msg
    , body : { key : String, title : String }
    }
    -> Cmd msg
usersCreatePublicSshKeyForAuthenticatedUser config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeKey
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "key", Json.Encode.string rec.key )
                         , ( "title", Json.Encode.string rec.title )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url = "https://api.github.com/user/keys"
        }


{-| View extended details for a single public SSH key. Requires that you are authenticated via Basic Auth or via OAuth with at least `read:public_key` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). -}
usersGetPublicSshKeyForAuthenticatedUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeKey
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{key_id}"
                config.params.key_id
                "https://api.github.com/user/keys/{key_id}"
        }


{-| Removes a public SSH key from the authenticated user's GitHub account. Requires that you are authenticated via Basic Auth or via OAuth with at least `admin:public_key` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). -}
usersDeletePublicSshKeyForAuthenticatedUser config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{key_id}"
                config.params.key_id
                "https://api.github.com/user/keys/{key_id}"
        }


{-| Lists the active subscriptions for the authenticated user. You must use a [user-to-server OAuth access token](https://docs.github.com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/#identifying-users-on-your-site), created for a user who has authorized your GitHub App, to access this endpoint. . OAuth Apps must authenticate using an [OAuth token](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/). -}
appsListSubscriptionsForAuthenticatedUser :
    { toMsg : Result Http.Error (List UserMarketplacePurchase) -> msg
    , params : { per_page : Maybe Int, page : Maybe Int }
    }
    -> Cmd msg
appsListSubscriptionsForAuthenticatedUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeUserMarketplacePurchase)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                "https://api.github.com/user/marketplace_purchases"
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Lists the active subscriptions for the authenticated user. You must use a [user-to-server OAuth access token](https://docs.github.com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/#identifying-users-on-your-site), created for a user who has authorized your GitHub App, to access this endpoint. . OAuth Apps must authenticate using an [OAuth token](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/). -}
appsListSubscriptionsForAuthenticatedUserStubbed :
    { toMsg : Result Http.Error (List UserMarketplacePurchase) -> msg
    , params : { per_page : Maybe Int, page : Maybe Int }
    }
    -> Cmd msg
appsListSubscriptionsForAuthenticatedUserStubbed config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeUserMarketplacePurchase)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                "https://api.github.com/user/marketplace_purchases/stubbed"
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


orgsListMembershipsForAuthenticatedUser :
    { toMsg : Result Http.Error (List OrgMembership) -> msg
    , params : { state : Maybe String, per_page : Maybe Int, page : Maybe Int }
    }
    -> Cmd msg
orgsListMembershipsForAuthenticatedUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeOrgMembership)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                "https://api.github.com/user/memberships/orgs"
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map (Url.Builder.string "state") config.params.state
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


orgsGetMembershipForAuthenticatedUser :
    { toMsg : Result Http.Error OrgMembership -> msg
    , params : { org : String }
    }
    -> Cmd msg
orgsGetMembershipForAuthenticatedUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeOrgMembership
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{org}"
                config.params.org
                "https://api.github.com/user/memberships/orgs/{org}"
        }


orgsUpdateMembershipForAuthenticatedUser :
    { toMsg : Result Http.Error OrgMembership -> msg
    , body : { state : String }
    , params : { org : String }
    }
    -> Cmd msg
orgsUpdateMembershipForAuthenticatedUser config =
    Http.request
        { method = "PATCH"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeOrgMembership
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "state", Json.Encode.string rec.state ) ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{org}"
                config.params.org
                "https://api.github.com/user/memberships/orgs/{org}"
        }


{-| Lists all migrations a user has started. -}
migrationsListForAuthenticatedUser :
    { toMsg : Result Http.Error (List Migration) -> msg
    , params : { per_page : Maybe Int, page : Maybe Int }
    }
    -> Cmd msg
migrationsListForAuthenticatedUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeMigration)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                "https://api.github.com/user/migrations"
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Initiates the generation of a user migration archive. -}
migrationsStartForAuthenticatedUser :
    { toMsg : Result Http.Error Migration -> msg
    , body :
        { exclude : List String
        , exclude_attachments : Bool
        , exclude_git_data : Bool
        , exclude_metadata : Bool
        , exclude_owner_projects : Bool
        , exclude_releases : Bool
        , lock_repositories : Bool
        , org_metadata_only : Bool
        , repositories : List String
        }
    }
    -> Cmd msg
migrationsStartForAuthenticatedUser config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeMigration
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "exclude"
                           , Json.Encode.list Json.Encode.string rec.exclude
                           )
                         , ( "exclude_attachments"
                           , Json.Encode.bool rec.exclude_attachments
                           )
                         , ( "exclude_git_data"
                           , Json.Encode.bool rec.exclude_git_data
                           )
                         , ( "exclude_metadata"
                           , Json.Encode.bool rec.exclude_metadata
                           )
                         , ( "exclude_owner_projects"
                           , Json.Encode.bool rec.exclude_owner_projects
                           )
                         , ( "exclude_releases"
                           , Json.Encode.bool rec.exclude_releases
                           )
                         , ( "lock_repositories"
                           , Json.Encode.bool rec.lock_repositories
                           )
                         , ( "org_metadata_only"
                           , Json.Encode.bool rec.org_metadata_only
                           )
                         , ( "repositories"
                           , Json.Encode.list Json.Encode.string
                                 rec.repositories
                           )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url = "https://api.github.com/user/migrations"
        }


{-| Fetches a single user migration. The response includes the `state` of the migration, which can be one of the following values:

*   `pending` - the migration hasn't started yet.
*   `exporting` - the migration is in progress.
*   `exported` - the migration finished successfully.
*   `failed` - the migration failed.

Once the migration has been `exported` you can [download the migration archive](https://docs.github.com/rest/reference/migrations#download-a-user-migration-archive).
-}
migrationsGetStatusForAuthenticatedUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeMigration
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{migration_id}"
                    config.params.migration_id
                    "https://api.github.com/user/migrations/{migration_id}"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "exclude"
                                (Debug.todo
                                    "Params of type \"(List String)\" (in helper)"
                                )
                        )
                        config.params.exclude
                    ]
                )
        }


{-| Deletes a previous migration archive. Downloadable migration archives are automatically deleted after seven days. Migration metadata, which is returned in the [List user migrations](https://docs.github.com/rest/reference/migrations#list-user-migrations) and [Get a user migration status](https://docs.github.com/rest/reference/migrations#get-a-user-migration-status) endpoints, will continue to be available even after an archive is deleted. -}
migrationsDeleteArchiveForAuthenticatedUser config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{migration_id}"
                config.params.migration_id
                "https://api.github.com/user/migrations/{migration_id}/archive"
        }


{-| Unlocks a repository. You can lock repositories when you [start a user migration](https://docs.github.com/rest/reference/migrations#start-a-user-migration). Once the migration is complete you can unlock each repository to begin using it again or [delete the repository](https://docs.github.com/rest/reference/repos#delete-a-repository) if you no longer need the source data. Returns a status of `404 Not Found` if the repository is not locked. -}
migrationsUnlockRepoForAuthenticatedUser config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo_name}"
                config.params.repo_name
                (String.replace
                    "{migration_id}"
                    config.params.migration_id
                    "https://api.github.com/user/migrations/{migration_id}/repos/{repo_name}/lock"
                )
        }


{-| Lists all the repositories for this user migration. -}
migrationsListReposForAuthenticatedUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeMinimalRepository)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{migration_id}"
                    config.params.migration_id
                    "https://api.github.com/user/migrations/{migration_id}/repositories"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| List organizations for the authenticated user.

**OAuth scope requirements**

This only lists organizations that your authorization allows you to operate on in some way (e.g., you can list teams with `read:org` scope, you can publicize your organization membership with `user` scope, etc.). Therefore, this API requires at least `user` or `read:org` scope. OAuth requests with insufficient scope receive a `403 Forbidden` response.
-}
orgsListForAuthenticatedUser :
    { toMsg : Result Http.Error (List OrganizationSimple) -> msg
    , params : { per_page : Maybe Int, page : Maybe Int }
    }
    -> Cmd msg
orgsListForAuthenticatedUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeOrganizationSimple)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                "https://api.github.com/user/orgs"
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Lists packages owned by the authenticated user within the user's namespace.

To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
If `package_type` is not `container`, your token must also include the `repo` scope.
-}
packagesListPackagesForAuthenticatedUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.list decodePackage)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                "https://api.github.com/user/packages"
                []
                (List.filterMap
                    Basics.identity
                    [ Just
                        (Url.Builder.string
                            "package_type"
                            config.params.package_type
                        )
                    , Maybe.map
                        (Url.Builder.string "visibility")
                        config.params.visibility
                    ]
                )
        }


{-| Gets a specific package for a package owned by the authenticated user.

To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
If `package_type` is not `container`, your token must also include the `repo` scope.
-}
packagesGetPackageForAuthenticatedUser :
    { toMsg : Result Http.Error Package -> msg
    , params : { package_type : String, package_name : String }
    }
    -> Cmd msg
packagesGetPackageForAuthenticatedUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodePackage
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{package_name}"
                config.params.package_name
                (String.replace
                    "{package_type}"
                    config.params.package_type
                    "https://api.github.com/user/packages/{package_type}/{package_name}"
                )
        }


{-| Deletes a package owned by the authenticated user. You cannot delete a public package if any version of the package has more than 5,000 downloads. In this scenario, contact GitHub support for further assistance.

To use this endpoint, you must authenticate using an access token with the `packages:read` and `packages:delete` scopes.
If `package_type` is not `container`, your token must also include the `repo` scope.
-}
packagesDeletePackageForAuthenticatedUser :
    { toMsg : Result Http.Error () -> msg
    , params : { package_type : String, package_name : String }
    }
    -> Cmd msg
packagesDeletePackageForAuthenticatedUser config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{package_name}"
                config.params.package_name
                (String.replace
                    "{package_type}"
                    config.params.package_type
                    "https://api.github.com/user/packages/{package_type}/{package_name}"
                )
        }


{-| Restores a package owned by the authenticated user.

You can restore a deleted package under the following conditions:
  - The package was deleted within the last 30 days.
  - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.

To use this endpoint, you must authenticate using an access token with the `packages:read` and `packages:write` scopes. If `package_type` is not `container`, your token must also include the `repo` scope.
-}
packagesRestorePackageForAuthenticatedUser :
    { toMsg : Result Http.Error () -> msg
    , params :
        { package_type : String, package_name : String, token : Maybe String }
    }
    -> Cmd msg
packagesRestorePackageForAuthenticatedUser config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{package_name}"
                    config.params.package_name
                    (String.replace
                        "{package_type}"
                        config.params.package_type
                        "https://api.github.com/user/packages/{package_type}/{package_name}/restore"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map (Url.Builder.string "token") config.params.token
                    ]
                )
        }


{-| Lists package versions for a package owned by the authenticated user.

To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
If `package_type` is not `container`, your token must also include the `repo` scope.
-}
packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser :
    { toMsg : Result Http.Error (List PackageVersion) -> msg
    , params :
        { package_type : String
        , package_name : String
        , page : Maybe Int
        , per_page : Maybe Int
        , state : Maybe String
        }
    }
    -> Cmd msg
packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodePackageVersion)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{package_name}"
                    config.params.package_name
                    (String.replace
                        "{package_type}"
                        config.params.package_type
                        "https://api.github.com/user/packages/{package_type}/{package_name}/versions"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map (Url.Builder.string "state") config.params.state
                    ]
                )
        }


{-| Gets a specific package version for a package owned by the authenticated user.

To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
If `package_type` is not `container`, your token must also include the `repo` scope.
-}
packagesGetPackageVersionForAuthenticatedUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodePackageVersion
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{package_version_id}"
                config.params.package_version_id
                (String.replace
                    "{package_name}"
                    config.params.package_name
                    (String.replace
                        "{package_type}"
                        config.params.package_type
                        "https://api.github.com/user/packages/{package_type}/{package_name}/versions/{package_version_id}"
                    )
                )
        }


{-| Deletes a specific package version for a package owned by the authenticated user.  If the package is public and the package version has more than 5,000 downloads, you cannot delete the package version. In this scenario, contact GitHub support for further assistance.

To use this endpoint, you must have admin permissions in the organization and authenticate using an access token with the `packages:read` and `packages:delete` scopes.
If `package_type` is not `container`, your token must also include the `repo` scope.
-}
packagesDeletePackageVersionForAuthenticatedUser config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{package_version_id}"
                config.params.package_version_id
                (String.replace
                    "{package_name}"
                    config.params.package_name
                    (String.replace
                        "{package_type}"
                        config.params.package_type
                        "https://api.github.com/user/packages/{package_type}/{package_name}/versions/{package_version_id}"
                    )
                )
        }


{-| Restores a package version owned by the authenticated user.

You can restore a deleted package version under the following conditions:
  - The package was deleted within the last 30 days.
  - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.

To use this endpoint, you must authenticate using an access token with the `packages:read` and `packages:write` scopes. If `package_type` is not `container`, your token must also include the `repo` scope.
-}
packagesRestorePackageVersionForAuthenticatedUser config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{package_version_id}"
                config.params.package_version_id
                (String.replace
                    "{package_name}"
                    config.params.package_name
                    (String.replace
                        "{package_type}"
                        config.params.package_type
                        "https://api.github.com/user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
                    )
                )
        }


{-| Creates a user project board. Returns a `410 Gone` status if the user does not have existing classic projects. If you do not have sufficient privileges to perform this action, a `401 Unauthorized` or `410 Gone` status is returned. -}
projectsCreateForAuthenticatedUser :
    { toMsg : Result Http.Error Project -> msg
    , body : { body : Nullable String, name : String }
    }
    -> Cmd msg
projectsCreateForAuthenticatedUser config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeProject
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "body"
                           , (\nullableValue ->
                                 case nullableValue of
                                     Null ->
                                         Json.Encode.null

                                     Present value ->
                                         Json.Encode.string value
                             )
                                 rec.body
                           )
                         , ( "name", Json.Encode.string rec.name )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url = "https://api.github.com/user/projects"
        }


{-| Lists your publicly visible email address, which you can set with the [Set primary email visibility for the authenticated user](https://docs.github.com/rest/reference/users#set-primary-email-visibility-for-the-authenticated-user) endpoint. This endpoint is accessible with the `user:email` scope. -}
usersListPublicEmailsForAuthenticatedUser :
    { toMsg : Result Http.Error (List Email) -> msg
    , params : { per_page : Maybe Int, page : Maybe Int }
    }
    -> Cmd msg
usersListPublicEmailsForAuthenticatedUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.list decodeEmail)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                "https://api.github.com/user/public_emails"
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Lists repositories that the authenticated user has explicit permission (`:read`, `:write`, or `:admin`) to access.

The authenticated user has explicit permission to access repositories they own, repositories where they are a collaborator, and repositories that they can access through an organization membership.
-}
reposListForAuthenticatedUser :
    { toMsg : Result Http.Error (List Repository) -> msg
    , params :
        { visibility : Maybe String
        , affiliation : Maybe String
        , type_ : Maybe String
        , sort : Maybe String
        , direction : Maybe String
        , per_page : Maybe Int
        , page : Maybe Int
        , since : Maybe String
        , before : Maybe String
        }
    }
    -> Cmd msg
reposListForAuthenticatedUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeRepository)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                "https://api.github.com/user/repos"
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (Url.Builder.string "visibility")
                        config.params.visibility
                    , Maybe.map
                        (Url.Builder.string "affiliation")
                        config.params.affiliation
                    , Maybe.map (Url.Builder.string "type") config.params.type_
                    , Maybe.map (Url.Builder.string "sort") config.params.sort
                    , Maybe.map
                        (Url.Builder.string "direction")
                        config.params.direction
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    , Maybe.map (Url.Builder.string "since") config.params.since
                    , Maybe.map
                        (Url.Builder.string "before")
                        config.params.before
                    ]
                )
        }


{-| Creates a new repository for the authenticated user.

**OAuth scope requirements**

When using [OAuth](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/), authorizations must include:

*   `public_repo` scope or `repo` scope to create a public repository. Note: For GitHub AE, use `repo` scope to create an internal repository.
*   `repo` scope to create a private repository.
-}
reposCreateForAuthenticatedUser :
    { toMsg : Result Http.Error Repository -> msg
    , body :
        { allow_auto_merge : Bool
        , allow_merge_commit : Bool
        , allow_rebase_merge : Bool
        , allow_squash_merge : Bool
        , auto_init : Bool
        , delete_branch_on_merge : Bool
        , description : String
        , gitignore_template : String
        , has_downloads : Bool
        , has_issues : Bool
        , has_projects : Bool
        , has_wiki : Bool
        , homepage : String
        , is_template : Bool
        , license_template : String
        , merge_commit_message : String
        , merge_commit_title : String
        , name : String
        , private : Bool
        , squash_merge_commit_message : String
        , squash_merge_commit_title : String
        , team_id : Int
        }
    }
    -> Cmd msg
reposCreateForAuthenticatedUser config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeRepository
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "allow_auto_merge"
                           , Json.Encode.bool rec.allow_auto_merge
                           )
                         , ( "allow_merge_commit"
                           , Json.Encode.bool rec.allow_merge_commit
                           )
                         , ( "allow_rebase_merge"
                           , Json.Encode.bool rec.allow_rebase_merge
                           )
                         , ( "allow_squash_merge"
                           , Json.Encode.bool rec.allow_squash_merge
                           )
                         , ( "auto_init", Json.Encode.bool rec.auto_init )
                         , ( "delete_branch_on_merge"
                           , Json.Encode.bool rec.delete_branch_on_merge
                           )
                         , ( "description", Json.Encode.string rec.description )
                         , ( "gitignore_template"
                           , Json.Encode.string rec.gitignore_template
                           )
                         , ( "has_downloads"
                           , Json.Encode.bool rec.has_downloads
                           )
                         , ( "has_issues", Json.Encode.bool rec.has_issues )
                         , ( "has_projects", Json.Encode.bool rec.has_projects )
                         , ( "has_wiki", Json.Encode.bool rec.has_wiki )
                         , ( "homepage", Json.Encode.string rec.homepage )
                         , ( "is_template", Json.Encode.bool rec.is_template )
                         , ( "license_template"
                           , Json.Encode.string rec.license_template
                           )
                         , ( "merge_commit_message"
                           , Json.Encode.string rec.merge_commit_message
                           )
                         , ( "merge_commit_title"
                           , Json.Encode.string rec.merge_commit_title
                           )
                         , ( "name", Json.Encode.string rec.name )
                         , ( "private", Json.Encode.bool rec.private )
                         , ( "squash_merge_commit_message"
                           , Json.Encode.string rec.squash_merge_commit_message
                           )
                         , ( "squash_merge_commit_title"
                           , Json.Encode.string rec.squash_merge_commit_title
                           )
                         , ( "team_id", Json.Encode.int rec.team_id )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url = "https://api.github.com/user/repos"
        }


{-| When authenticating as a user, this endpoint will list all currently open repository invitations for that user. -}
reposListInvitationsForAuthenticatedUser :
    { toMsg : Result Http.Error (List RepositoryInvitation) -> msg
    , params : { per_page : Maybe Int, page : Maybe Int }
    }
    -> Cmd msg
reposListInvitationsForAuthenticatedUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeRepositoryInvitation)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                "https://api.github.com/user/repository_invitations"
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


reposAcceptInvitationForAuthenticatedUser config =
    Http.request
        { method = "PATCH"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{invitation_id}"
                config.params.invitation_id
                "https://api.github.com/user/repository_invitations/{invitation_id}"
        }


reposDeclineInvitationForAuthenticatedUser config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{invitation_id}"
                config.params.invitation_id
                "https://api.github.com/user/repository_invitations/{invitation_id}"
        }


{-| Lists the SSH signing keys for the authenticated user's GitHub account. You must authenticate with Basic Authentication, or you must authenticate with OAuth with at least `read:ssh_signing_key` scope. For more information, see "[Understanding scopes for OAuth apps](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/)." -}
usersListSshSigningKeysForAuthenticatedUser :
    { toMsg : Result Http.Error (List SshSigningKey) -> msg
    , params : { per_page : Maybe Int, page : Maybe Int }
    }
    -> Cmd msg
usersListSshSigningKeysForAuthenticatedUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeSshSigningKey)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                "https://api.github.com/user/ssh_signing_keys"
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Creates an SSH signing key for the authenticated user's GitHub account. You must authenticate with Basic Authentication, or you must authenticate with OAuth with at least `write:ssh_signing_key` scope. For more information, see "[Understanding scopes for OAuth apps](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/)." -}
usersCreateSshSigningKeyForAuthenticatedUser :
    { toMsg : Result Http.Error SshSigningKey -> msg
    , body : { key : String, title : String }
    }
    -> Cmd msg
usersCreateSshSigningKeyForAuthenticatedUser config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeSshSigningKey
        , body =
            Http.jsonBody
                ((\rec ->
                     Json.Encode.object
                         [ ( "key", Json.Encode.string rec.key )
                         , ( "title", Json.Encode.string rec.title )
                         ]
                 )
                    config.body
                )
        , timeout = Nothing
        , tracker = Nothing
        , url = "https://api.github.com/user/ssh_signing_keys"
        }


{-| Gets extended details for an SSH signing key. You must authenticate with Basic Authentication, or you must authenticate with OAuth with at least `read:ssh_signing_key` scope. For more information, see "[Understanding scopes for OAuth apps](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/)." -}
usersGetSshSigningKeyForAuthenticatedUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeSshSigningKey
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{ssh_signing_key_id}"
                config.params.ssh_signing_key_id
                "https://api.github.com/user/ssh_signing_keys/{ssh_signing_key_id}"
        }


{-| Deletes an SSH signing key from the authenticated user's GitHub account. You must authenticate with Basic Authentication, or you must authenticate with OAuth with at least `admin:ssh_signing_key` scope. For more information, see "[Understanding scopes for OAuth apps](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/)." -}
usersDeleteSshSigningKeyForAuthenticatedUser config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{ssh_signing_key_id}"
                config.params.ssh_signing_key_id
                "https://api.github.com/user/ssh_signing_keys/{ssh_signing_key_id}"
        }


{-| Lists repositories the authenticated user has starred.

You can also find out _when_ stars were created by passing the following custom [media type](https://docs.github.com/rest/overview/media-types/) via the `Accept` header: `application/vnd.github.star+json`.
-}
activityListReposStarredByAuthenticatedUser :
    { toMsg : Result Http.Error (List Repository) -> msg
    , params :
        { sort : Maybe String
        , direction : Maybe String
        , per_page : Maybe Int
        , page : Maybe Int
        }
    }
    -> Cmd msg
activityListReposStarredByAuthenticatedUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeRepository)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                "https://api.github.com/user/starred"
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map (Url.Builder.string "sort") config.params.sort
                    , Maybe.map
                        (Url.Builder.string "direction")
                        config.params.direction
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


activityCheckRepoIsStarredByAuthenticatedUser :
    { toMsg : Result Http.Error () -> msg
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
activityCheckRepoIsStarredByAuthenticatedUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/user/starred/{owner}/{repo}"
                )
        }


{-| Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs)." -}
activityStarRepoForAuthenticatedUser :
    { toMsg : Result Http.Error () -> msg
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
activityStarRepoForAuthenticatedUser config =
    Http.request
        { method = "PUT"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/user/starred/{owner}/{repo}"
                )
        }


activityUnstarRepoForAuthenticatedUser :
    { toMsg : Result Http.Error () -> msg
    , params : { owner : String, repo : String }
    }
    -> Cmd msg
activityUnstarRepoForAuthenticatedUser config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{repo}"
                config.params.repo
                (String.replace
                    "{owner}"
                    config.params.owner
                    "https://api.github.com/user/starred/{owner}/{repo}"
                )
        }


{-| Lists repositories the authenticated user is watching. -}
activityListWatchedReposForAuthenticatedUser :
    { toMsg : Result Http.Error (List MinimalRepository) -> msg
    , params : { per_page : Maybe Int, page : Maybe Int }
    }
    -> Cmd msg
activityListWatchedReposForAuthenticatedUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeMinimalRepository)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                "https://api.github.com/user/subscriptions"
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| List all of the teams across all of the organizations to which the authenticated user belongs. This method requires `user`, `repo`, or `read:org` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/) when authenticating via [OAuth](https://docs.github.com/apps/building-oauth-apps/). -}
teamsListForAuthenticatedUser :
    { toMsg : Result Http.Error (List TeamFull) -> msg
    , params : { per_page : Maybe Int, page : Maybe Int }
    }
    -> Cmd msg
teamsListForAuthenticatedUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeTeamFull)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                "https://api.github.com/user/teams"
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Lists all users, in the order that they signed up on GitHub. This list includes personal user accounts and organization accounts.

Note: Pagination is powered exclusively by the `since` parameter. Use the [Link header](https://docs.github.com/rest/overview/resources-in-the-rest-api#link-header) to get the URL for the next page of users.
-}
usersList :
    { toMsg : Result Http.Error (List SimpleUser) -> msg
    , params : { since : Maybe Int, per_page : Maybe Int }
    }
    -> Cmd msg
usersList config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeSimpleUser)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                "https://api.github.com/users"
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "since"
                                (String.fromInt mapUnpack)
                        )
                        config.params.since
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    ]
                )
        }


{-| Provides publicly available information about someone with a GitHub account.

GitHub Apps with the `Plan` user permission can use this endpoint to retrieve information about a user's GitHub plan. The GitHub App must be authenticated as a user. See "[Identifying and authorizing users for GitHub Apps](https://docs.github.com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/)" for details about authentication. For an example response, see 'Response with GitHub plan information' below"

The `email` key in the following response is the publicly visible email address from your GitHub [profile page](https://github.com/settings/profile). When setting up your profile, you can select a primary email address to be public which provides an email entry for this endpoint. If you do not set a public email address for `email`, then it will have a value of `null`. You only see publicly visible email addresses when authenticated with GitHub. For more information, see [Authentication](https://docs.github.com/rest/overview/resources-in-the-rest-api#authentication).

The Emails API enables you to list all of your email addresses, and toggle a primary email to be visible publicly. For more information, see "[Emails API](https://docs.github.com/rest/reference/users#emails)".
-}
usersGetByUsername :
    { toMsg : Result Http.Error Json.Encode.Value -> msg
    , params : { username : String }
    }
    -> Cmd msg
usersGetByUsername config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg Json.Decode.value
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{username}"
                config.params.username
                "https://api.github.com/users/{username}"
        }


{-| If you are authenticated as the given user, you will see your private events. Otherwise, you'll only see public events. -}
activityListEventsForAuthenticatedUser :
    { toMsg : Result Http.Error (List Event) -> msg
    , params : { username : String, per_page : Maybe Int, page : Maybe Int }
    }
    -> Cmd msg
activityListEventsForAuthenticatedUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.list decodeEvent)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{username}"
                    config.params.username
                    "https://api.github.com/users/{username}/events"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| This is the user's organization dashboard. You must be authenticated as the user to view this. -}
activityListOrgEventsForAuthenticatedUser :
    { toMsg : Result Http.Error (List Event) -> msg
    , params :
        { username : String
        , org : String
        , per_page : Maybe Int
        , page : Maybe Int
        }
    }
    -> Cmd msg
activityListOrgEventsForAuthenticatedUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.list decodeEvent)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{org}"
                    config.params.org
                    (String.replace
                        "{username}"
                        config.params.username
                        "https://api.github.com/users/{username}/events/orgs/{org}"
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


activityListPublicEventsForUser :
    { toMsg : Result Http.Error (List Event) -> msg
    , params : { username : String, per_page : Maybe Int, page : Maybe Int }
    }
    -> Cmd msg
activityListPublicEventsForUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.list decodeEvent)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{username}"
                    config.params.username
                    "https://api.github.com/users/{username}/events/public"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Lists the people following the specified user. -}
usersListFollowersForUser :
    { toMsg : Result Http.Error (List SimpleUser) -> msg
    , params : { username : String, per_page : Maybe Int, page : Maybe Int }
    }
    -> Cmd msg
usersListFollowersForUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeSimpleUser)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{username}"
                    config.params.username
                    "https://api.github.com/users/{username}/followers"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Lists the people who the specified user follows. -}
usersListFollowingForUser :
    { toMsg : Result Http.Error (List SimpleUser) -> msg
    , params : { username : String, per_page : Maybe Int, page : Maybe Int }
    }
    -> Cmd msg
usersListFollowingForUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeSimpleUser)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{username}"
                    config.params.username
                    "https://api.github.com/users/{username}/following"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


usersCheckFollowingForUser :
    { toMsg : Result Http.Error () -> msg
    , params : { username : String, target_user : String }
    }
    -> Cmd msg
usersCheckFollowingForUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{target_user}"
                config.params.target_user
                (String.replace
                    "{username}"
                    config.params.username
                    "https://api.github.com/users/{username}/following/{target_user}"
                )
        }


{-| Lists public gists for the specified user: -}
gistsListForUser :
    { toMsg : Result Http.Error (List BaseGist) -> msg
    , params :
        { username : String
        , since : Maybe String
        , per_page : Maybe Int
        , page : Maybe Int
        }
    }
    -> Cmd msg
gistsListForUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeBaseGist)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{username}"
                    config.params.username
                    "https://api.github.com/users/{username}/gists"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map (Url.Builder.string "since") config.params.since
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Lists the GPG keys for a user. This information is accessible by anyone. -}
usersListGpgKeysForUser :
    { toMsg : Result Http.Error (List GpgKey) -> msg
    , params : { username : String, per_page : Maybe Int, page : Maybe Int }
    }
    -> Cmd msg
usersListGpgKeysForUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.list decodeGpgKey)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{username}"
                    config.params.username
                    "https://api.github.com/users/{username}/gpg_keys"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Provides hovercard information when authenticated through basic auth or OAuth with the `repo` scope. You can find out more about someone in relation to their pull requests, issues, repositories, and organizations.

The `subject_type` and `subject_id` parameters provide context for the person's hovercard, which returns more information than without the parameters. For example, if you wanted to find out more about `octocat` who owns the `Spoon-Knife` repository via cURL, it would look like this:

```shell
 curl -u username:token
  https://api.github.com/users/octocat/hovercard?subject_type=repository&subject_id=1300192
```
-}
usersGetContextForUser :
    { toMsg : Result Http.Error Hovercard -> msg
    , params :
        { username : String
        , subject_type : Maybe String
        , subject_id : Maybe String
        }
    }
    -> Cmd msg
usersGetContextForUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeHovercard
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{username}"
                    config.params.username
                    "https://api.github.com/users/{username}/hovercard"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (Url.Builder.string "subject_type")
                        config.params.subject_type
                    , Maybe.map
                        (Url.Builder.string "subject_id")
                        config.params.subject_id
                    ]
                )
        }


{-| Enables an authenticated GitHub App to find the users installation information.

You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
-}
appsGetUserInstallation :
    { toMsg : Result Http.Error Installation -> msg
    , params : { username : String }
    }
    -> Cmd msg
appsGetUserInstallation config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeInstallation
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{username}"
                config.params.username
                "https://api.github.com/users/{username}/installation"
        }


{-| Lists the _verified_ public SSH keys for a user. This is accessible by anyone. -}
usersListPublicKeysForUser :
    { toMsg : Result Http.Error (List KeySimple) -> msg
    , params : { username : String, per_page : Maybe Int, page : Maybe Int }
    }
    -> Cmd msg
usersListPublicKeysForUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeKeySimple)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{username}"
                    config.params.username
                    "https://api.github.com/users/{username}/keys"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| List [public organization memberships](https://docs.github.com/articles/publicizing-or-concealing-organization-membership) for the specified user.

This method only lists _public_ memberships, regardless of authentication. If you need to fetch all of the organization memberships (public and private) for the authenticated user, use the [List organizations for the authenticated user](https://docs.github.com/rest/reference/orgs#list-organizations-for-the-authenticated-user) API instead.
-}
orgsListForUser :
    { toMsg : Result Http.Error (List OrganizationSimple) -> msg
    , params : { username : String, per_page : Maybe Int, page : Maybe Int }
    }
    -> Cmd msg
orgsListForUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeOrganizationSimple)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{username}"
                    config.params.username
                    "https://api.github.com/users/{username}/orgs"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Lists all packages in a user's namespace for which the requesting user has access.

To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
If `package_type` is not `container`, your token must also include the `repo` scope.
-}
packagesListPackagesForUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.list decodePackage)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{username}"
                    config.params.username
                    "https://api.github.com/users/{username}/packages"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Just
                        (Url.Builder.string
                            "package_type"
                            config.params.package_type
                        )
                    , Maybe.map
                        (Url.Builder.string "visibility")
                        config.params.visibility
                    ]
                )
        }


{-| Gets a specific package metadata for a public package owned by a user.

To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
If `package_type` is not `container`, your token must also include the `repo` scope.
-}
packagesGetPackageForUser :
    { toMsg : Result Http.Error Package -> msg
    , params :
        { package_type : String, package_name : String, username : String }
    }
    -> Cmd msg
packagesGetPackageForUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodePackage
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{username}"
                config.params.username
                (String.replace
                    "{package_name}"
                    config.params.package_name
                    (String.replace
                        "{package_type}"
                        config.params.package_type
                        "https://api.github.com/users/{username}/packages/{package_type}/{package_name}"
                    )
                )
        }


{-| Deletes an entire package for a user. You cannot delete a public package if any version of the package has more than 5,000 downloads. In this scenario, contact GitHub support for further assistance.

To use this endpoint, you must authenticate using an access token with the `packages:read` and `packages:delete` scopes. In addition:
- If `package_type` is not `container`, your token must also include the `repo` scope.
- If `package_type` is `container`, you must also have admin permissions to the container you want to delete.
-}
packagesDeletePackageForUser :
    { toMsg : Result Http.Error () -> msg
    , params :
        { package_type : String, package_name : String, username : String }
    }
    -> Cmd msg
packagesDeletePackageForUser config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{username}"
                config.params.username
                (String.replace
                    "{package_name}"
                    config.params.package_name
                    (String.replace
                        "{package_type}"
                        config.params.package_type
                        "https://api.github.com/users/{username}/packages/{package_type}/{package_name}"
                    )
                )
        }


{-| Restores an entire package for a user.

You can restore a deleted package under the following conditions:
  - The package was deleted within the last 30 days.
  - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.

To use this endpoint, you must authenticate using an access token with the `packages:read` and `packages:write` scopes. In addition:
- If `package_type` is not `container`, your token must also include the `repo` scope.
- If `package_type` is `container`, you must also have admin permissions to the container that you want to restore.
-}
packagesRestorePackageForUser :
    { toMsg : Result Http.Error () -> msg
    , params :
        { package_type : String
        , package_name : String
        , username : String
        , token : Maybe String
        }
    }
    -> Cmd msg
packagesRestorePackageForUser config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{username}"
                    config.params.username
                    (String.replace
                        "{package_name}"
                        config.params.package_name
                        (String.replace
                            "{package_type}"
                            config.params.package_type
                            "https://api.github.com/users/{username}/packages/{package_type}/{package_name}/restore"
                        )
                    )
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map (Url.Builder.string "token") config.params.token
                    ]
                )
        }


{-| Lists package versions for a public package owned by a specified user.

To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
If `package_type` is not `container`, your token must also include the `repo` scope.
-}
packagesGetAllPackageVersionsForPackageOwnedByUser :
    { toMsg : Result Http.Error (List PackageVersion) -> msg
    , params :
        { package_type : String, package_name : String, username : String }
    }
    -> Cmd msg
packagesGetAllPackageVersionsForPackageOwnedByUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodePackageVersion)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{username}"
                config.params.username
                (String.replace
                    "{package_name}"
                    config.params.package_name
                    (String.replace
                        "{package_type}"
                        config.params.package_type
                        "https://api.github.com/users/{username}/packages/{package_type}/{package_name}/versions"
                    )
                )
        }


{-| Gets a specific package version for a public package owned by a specified user.

At this time, to use this endpoint, you must authenticate using an access token with the `packages:read` scope.
If `package_type` is not `container`, your token must also include the `repo` scope.
-}
packagesGetPackageVersionForUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodePackageVersion
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{username}"
                config.params.username
                (String.replace
                    "{package_version_id}"
                    config.params.package_version_id
                    (String.replace
                        "{package_name}"
                        config.params.package_name
                        (String.replace
                            "{package_type}"
                            config.params.package_type
                            "https://api.github.com/users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
                        )
                    )
                )
        }


{-| Deletes a specific package version for a user. If the package is public and the package version has more than 5,000 downloads, you cannot delete the package version. In this scenario, contact GitHub support for further assistance.

To use this endpoint, you must authenticate using an access token with the `packages:read` and `packages:delete` scopes. In addition:
- If `package_type` is not `container`, your token must also include the `repo` scope.
- If `package_type` is `container`, you must also have admin permissions to the container you want to delete.
-}
packagesDeletePackageVersionForUser config =
    Http.request
        { method = "DELETE"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{package_version_id}"
                config.params.package_version_id
                (String.replace
                    "{username}"
                    config.params.username
                    (String.replace
                        "{package_name}"
                        config.params.package_name
                        (String.replace
                            "{package_type}"
                            config.params.package_type
                            "https://api.github.com/users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
                        )
                    )
                )
        }


{-| Restores a specific package version for a user.

You can restore a deleted package under the following conditions:
  - The package was deleted within the last 30 days.
  - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.

To use this endpoint, you must authenticate using an access token with the `packages:read` and `packages:write` scopes. In addition:
- If `package_type` is not `container`, your token must also include the `repo` scope.
- If `package_type` is `container`, you must also have admin permissions to the container that you want to restore.
-}
packagesRestorePackageVersionForUser config =
    Http.request
        { method = "POST"
        , headers = []
        , expect = Http.expectWhatever config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{package_version_id}"
                config.params.package_version_id
                (String.replace
                    "{username}"
                    config.params.username
                    (String.replace
                        "{package_name}"
                        config.params.package_name
                        (String.replace
                            "{package_type}"
                            config.params.package_type
                            "https://api.github.com/users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
                        )
                    )
                )
        }


projectsListForUser :
    { toMsg : Result Http.Error (List Project) -> msg
    , params :
        { username : String
        , state : Maybe String
        , per_page : Maybe Int
        , page : Maybe Int
        }
    }
    -> Cmd msg
projectsListForUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.list decodeProject)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{username}"
                    config.params.username
                    "https://api.github.com/users/{username}/projects"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map (Url.Builder.string "state") config.params.state
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| These are events that you've received by watching repos and following users. If you are authenticated as the given user, you will see private events. Otherwise, you'll only see public events. -}
activityListReceivedEventsForUser :
    { toMsg : Result Http.Error (List Event) -> msg
    , params : { username : String, per_page : Maybe Int, page : Maybe Int }
    }
    -> Cmd msg
activityListReceivedEventsForUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.list decodeEvent)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{username}"
                    config.params.username
                    "https://api.github.com/users/{username}/received_events"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


activityListReceivedPublicEventsForUser :
    { toMsg : Result Http.Error (List Event) -> msg
    , params : { username : String, per_page : Maybe Int, page : Maybe Int }
    }
    -> Cmd msg
activityListReceivedPublicEventsForUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg (Json.Decode.list decodeEvent)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{username}"
                    config.params.username
                    "https://api.github.com/users/{username}/received_events/public"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Lists public repositories for the specified user. Note: For GitHub AE, this endpoint will list internal repositories for the specified user. -}
reposListForUser :
    { toMsg : Result Http.Error (List MinimalRepository) -> msg
    , params :
        { username : String
        , type_ : Maybe String
        , sort : Maybe String
        , direction : Maybe String
        , per_page : Maybe Int
        , page : Maybe Int
        }
    }
    -> Cmd msg
reposListForUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeMinimalRepository)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{username}"
                    config.params.username
                    "https://api.github.com/users/{username}/repos"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map (Url.Builder.string "type") config.params.type_
                    , Maybe.map (Url.Builder.string "sort") config.params.sort
                    , Maybe.map
                        (Url.Builder.string "direction")
                        config.params.direction
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Gets the summary of the free and paid GitHub Actions minutes used.

Paid minutes only apply to workflows in private repositories that use GitHub-hosted runners. Minutes used is listed for each GitHub-hosted runner operating system. Any job re-runs are also included in the usage. The usage returned includes any minute multipliers for macOS and Windows runners, and is rounded up to the nearest whole minute. For more information, see "[Managing billing for GitHub Actions](https://docs.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)".

Access tokens must have the `user` scope.
-}
billingGetGithubActionsBillingUser :
    { toMsg : Result Http.Error ActionsBillingUsage -> msg
    , params : { username : String }
    }
    -> Cmd msg
billingGetGithubActionsBillingUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeActionsBillingUsage
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{username}"
                config.params.username
                "https://api.github.com/users/{username}/settings/billing/actions"
        }


{-| Gets the free and paid storage used for GitHub Packages in gigabytes.

Paid minutes only apply to packages stored for private repositories. For more information, see "[Managing billing for GitHub Packages](https://docs.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."

Access tokens must have the `user` scope.
-}
billingGetGithubPackagesBillingUser :
    { toMsg : Result Http.Error PackagesBillingUsage -> msg
    , params : { username : String }
    }
    -> Cmd msg
billingGetGithubPackagesBillingUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodePackagesBillingUsage
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{username}"
                config.params.username
                "https://api.github.com/users/{username}/settings/billing/packages"
        }


{-| Gets the estimated paid and estimated total storage used for GitHub Actions and GitHub Packages.

Paid minutes only apply to packages stored for private repositories. For more information, see "[Managing billing for GitHub Packages](https://docs.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."

Access tokens must have the `user` scope.
-}
billingGetSharedStorageBillingUser :
    { toMsg : Result Http.Error CombinedBillingUsage -> msg
    , params : { username : String }
    }
    -> Cmd msg
billingGetSharedStorageBillingUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectJson config.toMsg decodeCombinedBillingUsage
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            String.replace
                "{username}"
                config.params.username
                "https://api.github.com/users/{username}/settings/billing/shared-storage"
        }


{-| Lists the SSH signing keys for a user. This operation is accessible by anyone. -}
usersListSshSigningKeysForUser :
    { toMsg : Result Http.Error (List SshSigningKey) -> msg
    , params : { username : String, per_page : Maybe Int, page : Maybe Int }
    }
    -> Cmd msg
usersListSshSigningKeysForUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson config.toMsg (Json.Decode.list decodeSshSigningKey)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{username}"
                    config.params.username
                    "https://api.github.com/users/{username}/ssh_signing_keys"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Lists repositories a user has starred.

You can also find out _when_ stars were created by passing the following custom [media type](https://docs.github.com/rest/overview/media-types/) via the `Accept` header: `application/vnd.github.star+json`.
-}
activityListReposStarredByUser :
    { toMsg :
        Result Http.Error (EnumTwo (List StarredRepository) (List Repository))
        -> msg
    , params :
        { username : String
        , sort : Maybe String
        , direction : Maybe String
        , per_page : Maybe Int
        , page : Maybe Int
        }
    }
    -> Cmd msg
activityListReposStarredByUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Debug.todo "Enum decoder not implemented yet")
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{username}"
                    config.params.username
                    "https://api.github.com/users/{username}/starred"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map (Url.Builder.string "sort") config.params.sort
                    , Maybe.map
                        (Url.Builder.string "direction")
                        config.params.direction
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Lists repositories a user is watching. -}
activityListReposWatchedByUser :
    { toMsg : Result Http.Error (List MinimalRepository) -> msg
    , params : { username : String, per_page : Maybe Int, page : Maybe Int }
    }
    -> Cmd msg
activityListReposWatchedByUser config =
    Http.request
        { method = "GET"
        , headers = []
        , expect =
            Http.expectJson
                config.toMsg
                (Json.Decode.list decodeMinimalRepository)
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url =
            Url.Builder.crossOrigin
                (String.replace
                    "{username}"
                    config.params.username
                    "https://api.github.com/users/{username}/subscriptions"
                )
                []
                (List.filterMap
                    Basics.identity
                    [ Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string
                                "per_page"
                                (String.fromInt mapUnpack)
                        )
                        config.params.per_page
                    , Maybe.map
                        (\mapUnpack ->
                            Url.Builder.string "page" (String.fromInt mapUnpack)
                        )
                        config.params.page
                    ]
                )
        }


{-| Get a random sentence from the Zen of GitHub -}
metaGetZen : { toMsg : Result Http.Error String -> msg } -> Cmd msg
metaGetZen config =
    Http.request
        { method = "GET"
        , headers = []
        , expect = Http.expectString config.toMsg
        , body = Http.emptyBody
        , timeout = Nothing
        , tracker = Nothing
        , url = "https://api.github.com/zen"
        }


type Nullable value
    = Null
    | Present value


type alias WorkflowUsage =
    { billable :
        { mACOS : { total_ms : Int }
        , uBUNTU : { total_ms : Int }
        , wINDOWS : { total_ms : Int }
        }
    }


decodeWorkflowUsage : Json.Decode.Decoder WorkflowUsage
decodeWorkflowUsage =
    Json.Decode.succeed (\billable -> { billable = billable })
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "billable"
                (Json.Decode.succeed
                  (\mACOS uBUNTU wINDOWS ->
                      { mACOS = mACOS, uBUNTU = uBUNTU, wINDOWS = wINDOWS }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "MACOS"
                            (Json.Decode.succeed
                                (\total_ms -> { total_ms = total_ms })
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "total_ms"
                                        Json.Decode.int
                                    )
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "UBUNTU"
                            (Json.Decode.succeed
                                (\total_ms -> { total_ms = total_ms })
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "total_ms"
                                        Json.Decode.int
                                    )
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "WINDOWS"
                            (Json.Decode.succeed
                                (\total_ms -> { total_ms = total_ms })
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "total_ms"
                                        Json.Decode.int
                                    )
                            )
                        )
                )
            )


encodeWorkflowUsage : WorkflowUsage -> Json.Encode.Value
encodeWorkflowUsage rec =
    Json.Encode.object
        [ ( "billable"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "MACOS"
                      , (\rec_0_1_1_1_0_1_1_0_0 ->
                            Json.Encode.object
                                [ ( "total_ms"
                                  , Json.Encode.int
                                        rec_0_1_1_1_0_1_1_0_0.total_ms
                                  )
                                ]
                        )
                            rec0.mACOS
                      )
                    , ( "UBUNTU"
                      , (\rec_0_2_1_1_0_1_1_0_0 ->
                            Json.Encode.object
                                [ ( "total_ms"
                                  , Json.Encode.int
                                        rec_0_2_1_1_0_1_1_0_0.total_ms
                                  )
                                ]
                        )
                            rec0.uBUNTU
                      )
                    , ( "WINDOWS"
                      , (\rec_0_3_1_1_0_1_1_0_0 ->
                            Json.Encode.object
                                [ ( "total_ms"
                                  , Json.Encode.int
                                        rec_0_3_1_1_0_1_1_0_0.total_ms
                                  )
                                ]
                        )
                            rec0.wINDOWS
                      )
                    ]
            )
                rec.billable
          )
        ]


type alias WorkflowRunUsage =
    { billable :
        { mACOS :
            { job_runs : List { duration_ms : Int, job_id : Int }
            , jobs : Int
            , total_ms : Int
            }
        , uBUNTU :
            { job_runs : List { duration_ms : Int, job_id : Int }
            , jobs : Int
            , total_ms : Int
            }
        , wINDOWS :
            { job_runs : List { duration_ms : Int, job_id : Int }
            , jobs : Int
            , total_ms : Int
            }
        }
    , run_duration_ms : Int
    }


decodeWorkflowRunUsage : Json.Decode.Decoder WorkflowRunUsage
decodeWorkflowRunUsage =
    Json.Decode.succeed
     (\billable run_duration_ms ->
         { billable = billable, run_duration_ms = run_duration_ms }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "billable"
                (Json.Decode.succeed
                  (\mACOS uBUNTU wINDOWS ->
                      { mACOS = mACOS, uBUNTU = uBUNTU, wINDOWS = wINDOWS }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "MACOS"
                            (Json.Decode.succeed
                              (\job_runs jobs total_ms ->
                                  { job_runs = job_runs
                                  , jobs = jobs
                                  , total_ms = total_ms
                                  }
                              )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "job_runs"
                                        (Json.Decode.list
                                            (Json.Decode.succeed
                                              (\duration_ms job_id ->
                                                  { duration_ms = duration_ms
                                                  , job_id = job_id
                                                  }
                                              )
                                                |> Json.Decode.Extra.andMap
                                                    (Json.Decode.field
                                                        "duration_ms"
                                                        Json.Decode.int
                                                    )
                                                |> Json.Decode.Extra.andMap
                                                    (Json.Decode.field
                                                        "job_id"
                                                        Json.Decode.int
                                                    )
                                            )
                                        )
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field "jobs" Json.Decode.int)
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "total_ms"
                                        Json.Decode.int
                                    )
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "UBUNTU"
                            (Json.Decode.succeed
                              (\job_runs jobs total_ms ->
                                  { job_runs = job_runs
                                  , jobs = jobs
                                  , total_ms = total_ms
                                  }
                              )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "job_runs"
                                        (Json.Decode.list
                                            (Json.Decode.succeed
                                              (\duration_ms job_id ->
                                                  { duration_ms = duration_ms
                                                  , job_id = job_id
                                                  }
                                              )
                                                |> Json.Decode.Extra.andMap
                                                    (Json.Decode.field
                                                        "duration_ms"
                                                        Json.Decode.int
                                                    )
                                                |> Json.Decode.Extra.andMap
                                                    (Json.Decode.field
                                                        "job_id"
                                                        Json.Decode.int
                                                    )
                                            )
                                        )
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field "jobs" Json.Decode.int)
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "total_ms"
                                        Json.Decode.int
                                    )
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "WINDOWS"
                            (Json.Decode.succeed
                              (\job_runs jobs total_ms ->
                                  { job_runs = job_runs
                                  , jobs = jobs
                                  , total_ms = total_ms
                                  }
                              )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "job_runs"
                                        (Json.Decode.list
                                            (Json.Decode.succeed
                                              (\duration_ms job_id ->
                                                  { duration_ms = duration_ms
                                                  , job_id = job_id
                                                  }
                                              )
                                                |> Json.Decode.Extra.andMap
                                                    (Json.Decode.field
                                                        "duration_ms"
                                                        Json.Decode.int
                                                    )
                                                |> Json.Decode.Extra.andMap
                                                    (Json.Decode.field
                                                        "job_id"
                                                        Json.Decode.int
                                                    )
                                            )
                                        )
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field "jobs" Json.Decode.int)
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "total_ms"
                                        Json.Decode.int
                                    )
                            )
                        )
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "run_duration_ms" Json.Decode.int)


encodeWorkflowRunUsage : WorkflowRunUsage -> Json.Encode.Value
encodeWorkflowRunUsage rec =
    Json.Encode.object
        [ ( "billable"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "MACOS"
                      , (\rec_0_1_1_1_0_1_1_0_0 ->
                            Json.Encode.object
                                [ ( "job_runs"
                                  , Json.Encode.list
                                        (\rec_1_0_1_1_1_0_1_1_1_0_1_1_0_0 ->
                                            Json.Encode.object
                                                [ ( "duration_ms"
                                                  , Json.Encode.int
                                                        rec_1_0_1_1_1_0_1_1_1_0_1_1_0_0.duration_ms
                                                  )
                                                , ( "job_id"
                                                  , Json.Encode.int
                                                        rec_1_0_1_1_1_0_1_1_1_0_1_1_0_0.job_id
                                                  )
                                                ]
                                        )
                                        rec_0_1_1_1_0_1_1_0_0.job_runs
                                  )
                                , ( "jobs"
                                  , Json.Encode.int rec_0_1_1_1_0_1_1_0_0.jobs
                                  )
                                , ( "total_ms"
                                  , Json.Encode.int
                                        rec_0_1_1_1_0_1_1_0_0.total_ms
                                  )
                                ]
                        )
                            rec0.mACOS
                      )
                    , ( "UBUNTU"
                      , (\rec_0_2_1_1_0_1_1_0_0 ->
                            Json.Encode.object
                                [ ( "job_runs"
                                  , Json.Encode.list
                                        (\rec_1_0_1_1_1_0_2_1_1_0_1_1_0_0 ->
                                            Json.Encode.object
                                                [ ( "duration_ms"
                                                  , Json.Encode.int
                                                        rec_1_0_1_1_1_0_2_1_1_0_1_1_0_0.duration_ms
                                                  )
                                                , ( "job_id"
                                                  , Json.Encode.int
                                                        rec_1_0_1_1_1_0_2_1_1_0_1_1_0_0.job_id
                                                  )
                                                ]
                                        )
                                        rec_0_2_1_1_0_1_1_0_0.job_runs
                                  )
                                , ( "jobs"
                                  , Json.Encode.int rec_0_2_1_1_0_1_1_0_0.jobs
                                  )
                                , ( "total_ms"
                                  , Json.Encode.int
                                        rec_0_2_1_1_0_1_1_0_0.total_ms
                                  )
                                ]
                        )
                            rec0.uBUNTU
                      )
                    , ( "WINDOWS"
                      , (\rec_0_3_1_1_0_1_1_0_0 ->
                            Json.Encode.object
                                [ ( "job_runs"
                                  , Json.Encode.list
                                        (\rec_1_0_1_1_1_0_3_1_1_0_1_1_0_0 ->
                                            Json.Encode.object
                                                [ ( "duration_ms"
                                                  , Json.Encode.int
                                                        rec_1_0_1_1_1_0_3_1_1_0_1_1_0_0.duration_ms
                                                  )
                                                , ( "job_id"
                                                  , Json.Encode.int
                                                        rec_1_0_1_1_1_0_3_1_1_0_1_1_0_0.job_id
                                                  )
                                                ]
                                        )
                                        rec_0_3_1_1_0_1_1_0_0.job_runs
                                  )
                                , ( "jobs"
                                  , Json.Encode.int rec_0_3_1_1_0_1_1_0_0.jobs
                                  )
                                , ( "total_ms"
                                  , Json.Encode.int
                                        rec_0_3_1_1_0_1_1_0_0.total_ms
                                  )
                                ]
                        )
                            rec0.wINDOWS
                      )
                    ]
            )
                rec.billable
          )
        , ( "run_duration_ms", Json.Encode.int rec.run_duration_ms )
        ]


type alias WorkflowRun =
    { actor : SimpleUser
    , artifacts_url : String
    , cancel_url : String
    , check_suite_id : Int
    , check_suite_node_id : String
    , check_suite_url : String
    , conclusion : Nullable String
    , created_at : String
    , display_title : String
    , event : String
    , head_branch : Nullable String
    , head_commit : Nullable SimpleCommit
    , head_repository : MinimalRepository
    , head_repository_id : Int
    , head_sha : String
    , html_url : String
    , id : Int
    , jobs_url : String
    , logs_url : String
    , name : Nullable String
    , node_id : String
    , path : String
    , previous_attempt_url : Nullable String
    , pull_requests : Nullable (List PullRequestMinimal)
    , referenced_workflows : Nullable (List ReferencedWorkflow)
    , repository : MinimalRepository
    , rerun_url : String
    , run_attempt : Int
    , run_number : Int
    , run_started_at : String
    , status : Nullable String
    , triggering_actor : SimpleUser
    , updated_at : String
    , url : String
    , workflow_id : Int
    , workflow_url : String
    }


decodeWorkflowRun : Json.Decode.Decoder WorkflowRun
decodeWorkflowRun =
    Json.Decode.succeed
     (\actor artifacts_url cancel_url check_suite_id check_suite_node_id check_suite_url conclusion created_at display_title event head_branch head_commit head_repository head_repository_id head_sha html_url id jobs_url logs_url name node_id path previous_attempt_url pull_requests referenced_workflows repository rerun_url run_attempt run_number run_started_at status triggering_actor updated_at url workflow_id workflow_url ->
         { actor = actor
         , artifacts_url = artifacts_url
         , cancel_url = cancel_url
         , check_suite_id = check_suite_id
         , check_suite_node_id = check_suite_node_id
         , check_suite_url = check_suite_url
         , conclusion = conclusion
         , created_at = created_at
         , display_title = display_title
         , event = event
         , head_branch = head_branch
         , head_commit = head_commit
         , head_repository = head_repository
         , head_repository_id = head_repository_id
         , head_sha = head_sha
         , html_url = html_url
         , id = id
         , jobs_url = jobs_url
         , logs_url = logs_url
         , name = name
         , node_id = node_id
         , path = path
         , previous_attempt_url = previous_attempt_url
         , pull_requests = pull_requests
         , referenced_workflows = referenced_workflows
         , repository = repository
         , rerun_url = rerun_url
         , run_attempt = run_attempt
         , run_number = run_number
         , run_started_at = run_started_at
         , status = status
         , triggering_actor = triggering_actor
         , updated_at = updated_at
         , url = url
         , workflow_id = workflow_id
         , workflow_url = workflow_url
         }
     )
        |> Json.Decode.Extra.andMap (Json.Decode.field "actor" decodeSimpleUser)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "artifacts_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "cancel_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "check_suite_id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "check_suite_node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "check_suite_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "conclusion"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "display_title" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "event" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "head_branch"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "head_commit"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleCommit
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "head_repository" decodeMinimalRepository)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "head_repository_id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "head_sha" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "jobs_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "logs_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "name"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "path" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "previous_attempt_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "pull_requests"
                (Json.Decode.oneOf
                    [ Json.Decode.map
                        Present
                        (Json.Decode.list decodePullRequestMinimal)
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "referenced_workflows"
                (Json.Decode.oneOf
                    [ Json.Decode.map
                        Present
                        (Json.Decode.list decodeReferencedWorkflow)
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "repository" decodeMinimalRepository)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "rerun_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "run_attempt" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "run_number" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "run_started_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "status"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "triggering_actor" decodeSimpleUser)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "workflow_id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "workflow_url" Json.Decode.string)


encodeWorkflowRun : WorkflowRun -> Json.Encode.Value
encodeWorkflowRun rec =
    Json.Encode.object
        [ ( "actor", encodeSimpleUser rec.actor )
        , ( "artifacts_url", Json.Encode.string rec.artifacts_url )
        , ( "cancel_url", Json.Encode.string rec.cancel_url )
        , ( "check_suite_id", Json.Encode.int rec.check_suite_id )
        , ( "check_suite_node_id", Json.Encode.string rec.check_suite_node_id )
        , ( "check_suite_url", Json.Encode.string rec.check_suite_url )
        , ( "conclusion"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.conclusion
          )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "display_title", Json.Encode.string rec.display_title )
        , ( "event", Json.Encode.string rec.event )
        , ( "head_branch"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.head_branch
          )
        , ( "head_commit"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleCommit value
            )
                rec.head_commit
          )
        , ( "head_repository", encodeMinimalRepository rec.head_repository )
        , ( "head_repository_id", Json.Encode.int rec.head_repository_id )
        , ( "head_sha", Json.Encode.string rec.head_sha )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "id", Json.Encode.int rec.id )
        , ( "jobs_url", Json.Encode.string rec.jobs_url )
        , ( "logs_url", Json.Encode.string rec.logs_url )
        , ( "name"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.name
          )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "path", Json.Encode.string rec.path )
        , ( "previous_attempt_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.previous_attempt_url
          )
        , ( "pull_requests"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.list encodePullRequestMinimal value
            )
                rec.pull_requests
          )
        , ( "referenced_workflows"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.list encodeReferencedWorkflow value
            )
                rec.referenced_workflows
          )
        , ( "repository", encodeMinimalRepository rec.repository )
        , ( "rerun_url", Json.Encode.string rec.rerun_url )
        , ( "run_attempt", Json.Encode.int rec.run_attempt )
        , ( "run_number", Json.Encode.int rec.run_number )
        , ( "run_started_at", Json.Encode.string rec.run_started_at )
        , ( "status"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.status
          )
        , ( "triggering_actor", encodeSimpleUser rec.triggering_actor )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        , ( "url", Json.Encode.string rec.url )
        , ( "workflow_id", Json.Encode.int rec.workflow_id )
        , ( "workflow_url", Json.Encode.string rec.workflow_url )
        ]


type alias Workflow =
    { badge_url : String
    , created_at : String
    , deleted_at : String
    , html_url : String
    , id : Int
    , name : String
    , node_id : String
    , path : String
    , state : String
    , updated_at : String
    , url : String
    }


decodeWorkflow : Json.Decode.Decoder Workflow
decodeWorkflow =
    Json.Decode.succeed
     (\badge_url created_at deleted_at html_url id name node_id path state updated_at url ->
         { badge_url = badge_url
         , created_at = created_at
         , deleted_at = deleted_at
         , html_url = html_url
         , id = id
         , name = name
         , node_id = node_id
         , path = path
         , state = state
         , updated_at = updated_at
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "badge_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "deleted_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "path" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "state" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeWorkflow : Workflow -> Json.Encode.Value
encodeWorkflow rec =
    Json.Encode.object
        [ ( "badge_url", Json.Encode.string rec.badge_url )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "deleted_at", Json.Encode.string rec.deleted_at )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "id", Json.Encode.int rec.id )
        , ( "name", Json.Encode.string rec.name )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "path", Json.Encode.string rec.path )
        , ( "state", Json.Encode.string rec.state )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias WebhookMergeGroupChecksRequested =
    { action : String
    , installation : SimpleInstallation
    , merge_group : { base_ref : String, head_ref : String, head_sha : String }
    , organization : OrganizationSimple
    , repository : Repository
    , sender : SimpleUser
    }


decodeWebhookMergeGroupChecksRequested :
    Json.Decode.Decoder WebhookMergeGroupChecksRequested
decodeWebhookMergeGroupChecksRequested =
    Json.Decode.succeed
     (\action installation merge_group organization repository sender ->
         { action = action
         , installation = installation
         , merge_group = merge_group
         , organization = organization
         , repository = repository
         , sender = sender
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "action" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "installation" decodeSimpleInstallation)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "merge_group"
                (Json.Decode.succeed
                  (\base_ref head_ref head_sha ->
                      { base_ref = base_ref
                      , head_ref = head_ref
                      , head_sha = head_sha
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "base_ref" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "head_ref" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "head_sha" Json.Decode.string)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "organization" decodeOrganizationSimple)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "repository" decodeRepository)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "sender" decodeSimpleUser)


encodeWebhookMergeGroupChecksRequested :
    WebhookMergeGroupChecksRequested -> Json.Encode.Value
encodeWebhookMergeGroupChecksRequested rec =
    Json.Encode.object
        [ ( "action", Json.Encode.string rec.action )
        , ( "installation", encodeSimpleInstallation rec.installation )
        , ( "merge_group"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "base_ref", Json.Encode.string rec0.base_ref )
                    , ( "head_ref", Json.Encode.string rec0.head_ref )
                    , ( "head_sha", Json.Encode.string rec0.head_sha )
                    ]
            )
                rec.merge_group
          )
        , ( "organization", encodeOrganizationSimple rec.organization )
        , ( "repository", encodeRepository rec.repository )
        , ( "sender", encodeSimpleUser rec.sender )
        ]


type alias WebhookDependabotAlertReopened =
    { action : String
    , alert : DependabotAlert
    , enterprise : Enterprise
    , installation : SimpleInstallation
    , organization : OrganizationSimple
    , repository : Repository
    , sender : SimpleUser
    }


decodeWebhookDependabotAlertReopened :
    Json.Decode.Decoder WebhookDependabotAlertReopened
decodeWebhookDependabotAlertReopened =
    Json.Decode.succeed
     (\action alert enterprise installation organization repository sender ->
         { action = action
         , alert = alert
         , enterprise = enterprise
         , installation = installation
         , organization = organization
         , repository = repository
         , sender = sender
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "action" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "alert" decodeDependabotAlert)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "enterprise" decodeEnterprise)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "installation" decodeSimpleInstallation)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "organization" decodeOrganizationSimple)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "repository" decodeRepository)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "sender" decodeSimpleUser)


encodeWebhookDependabotAlertReopened :
    WebhookDependabotAlertReopened -> Json.Encode.Value
encodeWebhookDependabotAlertReopened rec =
    Json.Encode.object
        [ ( "action", Json.Encode.string rec.action )
        , ( "alert", encodeDependabotAlert rec.alert )
        , ( "enterprise", encodeEnterprise rec.enterprise )
        , ( "installation", encodeSimpleInstallation rec.installation )
        , ( "organization", encodeOrganizationSimple rec.organization )
        , ( "repository", encodeRepository rec.repository )
        , ( "sender", encodeSimpleUser rec.sender )
        ]


type alias WebhookDependabotAlertReintroduced =
    { action : String
    , alert : DependabotAlert
    , enterprise : Enterprise
    , installation : SimpleInstallation
    , organization : OrganizationSimple
    , repository : Repository
    , sender : SimpleUser
    }


decodeWebhookDependabotAlertReintroduced :
    Json.Decode.Decoder WebhookDependabotAlertReintroduced
decodeWebhookDependabotAlertReintroduced =
    Json.Decode.succeed
     (\action alert enterprise installation organization repository sender ->
         { action = action
         , alert = alert
         , enterprise = enterprise
         , installation = installation
         , organization = organization
         , repository = repository
         , sender = sender
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "action" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "alert" decodeDependabotAlert)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "enterprise" decodeEnterprise)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "installation" decodeSimpleInstallation)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "organization" decodeOrganizationSimple)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "repository" decodeRepository)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "sender" decodeSimpleUser)


encodeWebhookDependabotAlertReintroduced :
    WebhookDependabotAlertReintroduced -> Json.Encode.Value
encodeWebhookDependabotAlertReintroduced rec =
    Json.Encode.object
        [ ( "action", Json.Encode.string rec.action )
        , ( "alert", encodeDependabotAlert rec.alert )
        , ( "enterprise", encodeEnterprise rec.enterprise )
        , ( "installation", encodeSimpleInstallation rec.installation )
        , ( "organization", encodeOrganizationSimple rec.organization )
        , ( "repository", encodeRepository rec.repository )
        , ( "sender", encodeSimpleUser rec.sender )
        ]


type alias WebhookDependabotAlertFixed =
    { action : String
    , alert : DependabotAlert
    , enterprise : Enterprise
    , installation : SimpleInstallation
    , organization : OrganizationSimple
    , repository : Repository
    , sender : SimpleUser
    }


decodeWebhookDependabotAlertFixed :
    Json.Decode.Decoder WebhookDependabotAlertFixed
decodeWebhookDependabotAlertFixed =
    Json.Decode.succeed
     (\action alert enterprise installation organization repository sender ->
         { action = action
         , alert = alert
         , enterprise = enterprise
         , installation = installation
         , organization = organization
         , repository = repository
         , sender = sender
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "action" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "alert" decodeDependabotAlert)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "enterprise" decodeEnterprise)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "installation" decodeSimpleInstallation)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "organization" decodeOrganizationSimple)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "repository" decodeRepository)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "sender" decodeSimpleUser)


encodeWebhookDependabotAlertFixed :
    WebhookDependabotAlertFixed -> Json.Encode.Value
encodeWebhookDependabotAlertFixed rec =
    Json.Encode.object
        [ ( "action", Json.Encode.string rec.action )
        , ( "alert", encodeDependabotAlert rec.alert )
        , ( "enterprise", encodeEnterprise rec.enterprise )
        , ( "installation", encodeSimpleInstallation rec.installation )
        , ( "organization", encodeOrganizationSimple rec.organization )
        , ( "repository", encodeRepository rec.repository )
        , ( "sender", encodeSimpleUser rec.sender )
        ]


type alias WebhookDependabotAlertDismissed =
    { action : String
    , alert : DependabotAlert
    , enterprise : Enterprise
    , installation : SimpleInstallation
    , organization : OrganizationSimple
    , repository : Repository
    , sender : SimpleUser
    }


decodeWebhookDependabotAlertDismissed :
    Json.Decode.Decoder WebhookDependabotAlertDismissed
decodeWebhookDependabotAlertDismissed =
    Json.Decode.succeed
     (\action alert enterprise installation organization repository sender ->
         { action = action
         , alert = alert
         , enterprise = enterprise
         , installation = installation
         , organization = organization
         , repository = repository
         , sender = sender
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "action" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "alert" decodeDependabotAlert)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "enterprise" decodeEnterprise)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "installation" decodeSimpleInstallation)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "organization" decodeOrganizationSimple)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "repository" decodeRepository)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "sender" decodeSimpleUser)


encodeWebhookDependabotAlertDismissed :
    WebhookDependabotAlertDismissed -> Json.Encode.Value
encodeWebhookDependabotAlertDismissed rec =
    Json.Encode.object
        [ ( "action", Json.Encode.string rec.action )
        , ( "alert", encodeDependabotAlert rec.alert )
        , ( "enterprise", encodeEnterprise rec.enterprise )
        , ( "installation", encodeSimpleInstallation rec.installation )
        , ( "organization", encodeOrganizationSimple rec.organization )
        , ( "repository", encodeRepository rec.repository )
        , ( "sender", encodeSimpleUser rec.sender )
        ]


type alias WebhookDependabotAlertCreated =
    { action : String
    , alert : DependabotAlert
    , enterprise : Enterprise
    , installation : SimpleInstallation
    , organization : OrganizationSimple
    , repository : Repository
    , sender : SimpleUser
    }


decodeWebhookDependabotAlertCreated :
    Json.Decode.Decoder WebhookDependabotAlertCreated
decodeWebhookDependabotAlertCreated =
    Json.Decode.succeed
     (\action alert enterprise installation organization repository sender ->
         { action = action
         , alert = alert
         , enterprise = enterprise
         , installation = installation
         , organization = organization
         , repository = repository
         , sender = sender
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "action" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "alert" decodeDependabotAlert)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "enterprise" decodeEnterprise)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "installation" decodeSimpleInstallation)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "organization" decodeOrganizationSimple)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "repository" decodeRepository)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "sender" decodeSimpleUser)


encodeWebhookDependabotAlertCreated :
    WebhookDependabotAlertCreated -> Json.Encode.Value
encodeWebhookDependabotAlertCreated rec =
    Json.Encode.object
        [ ( "action", Json.Encode.string rec.action )
        , ( "alert", encodeDependabotAlert rec.alert )
        , ( "enterprise", encodeEnterprise rec.enterprise )
        , ( "installation", encodeSimpleInstallation rec.installation )
        , ( "organization", encodeOrganizationSimple rec.organization )
        , ( "repository", encodeRepository rec.repository )
        , ( "sender", encodeSimpleUser rec.sender )
        ]


type alias WebhookConfigUrl =
    String


decodeWebhookConfigUrl : Json.Decode.Decoder WebhookConfigUrl
decodeWebhookConfigUrl =
    Json.Decode.string


encodeWebhookConfigUrl : WebhookConfigUrl -> Json.Encode.Value
encodeWebhookConfigUrl =
    Json.Encode.string


type alias WebhookConfigSecret =
    String


decodeWebhookConfigSecret : Json.Decode.Decoder WebhookConfigSecret
decodeWebhookConfigSecret =
    Json.Decode.string


encodeWebhookConfigSecret : WebhookConfigSecret -> Json.Encode.Value
encodeWebhookConfigSecret =
    Json.Encode.string


type alias WebhookConfigInsecureSsl =
    Json.Encode.Value


decodeWebhookConfigInsecureSsl : Json.Decode.Decoder WebhookConfigInsecureSsl
decodeWebhookConfigInsecureSsl =
    Json.Decode.value


encodeWebhookConfigInsecureSsl : WebhookConfigInsecureSsl -> Json.Encode.Value
encodeWebhookConfigInsecureSsl =
    Basics.identity


type alias WebhookConfigContentType =
    String


decodeWebhookConfigContentType : Json.Decode.Decoder WebhookConfigContentType
decodeWebhookConfigContentType =
    Json.Decode.string


encodeWebhookConfigContentType : WebhookConfigContentType -> Json.Encode.Value
encodeWebhookConfigContentType =
    Json.Encode.string


type alias WebhookConfig =
    { content_type : WebhookConfigContentType
    , insecure_ssl : WebhookConfigInsecureSsl
    , secret : WebhookConfigSecret
    , url : WebhookConfigUrl
    }


decodeWebhookConfig : Json.Decode.Decoder WebhookConfig
decodeWebhookConfig =
    Json.Decode.succeed
     (\content_type insecure_ssl secret url ->
         { content_type = content_type
         , insecure_ssl = insecure_ssl
         , secret = secret
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "content_type" decodeWebhookConfigContentType)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "insecure_ssl" decodeWebhookConfigInsecureSsl)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "secret" decodeWebhookConfigSecret)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "url" decodeWebhookConfigUrl)


encodeWebhookConfig : WebhookConfig -> Json.Encode.Value
encodeWebhookConfig rec =
    Json.Encode.object
        [ ( "content_type", encodeWebhookConfigContentType rec.content_type )
        , ( "insecure_ssl", encodeWebhookConfigInsecureSsl rec.insecure_ssl )
        , ( "secret", encodeWebhookConfigSecret rec.secret )
        , ( "url", encodeWebhookConfigUrl rec.url )
        ]


type alias WaitTimer =
    Int


decodeWaitTimer : Json.Decode.Decoder WaitTimer
decodeWaitTimer =
    Json.Decode.int


encodeWaitTimer : WaitTimer -> Json.Encode.Value
encodeWaitTimer =
    Json.Encode.int


type alias ViewTraffic =
    { count : Int, uniques : Int, views : List Traffic }


decodeViewTraffic : Json.Decode.Decoder ViewTraffic
decodeViewTraffic =
    Json.Decode.succeed
     (\count uniques views ->
         { count = count, uniques = uniques, views = views }
     )
        |> Json.Decode.Extra.andMap (Json.Decode.field "count" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "uniques" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "views" (Json.Decode.list decodeTraffic))


encodeViewTraffic : ViewTraffic -> Json.Encode.Value
encodeViewTraffic rec =
    Json.Encode.object
        [ ( "count", Json.Encode.int rec.count )
        , ( "uniques", Json.Encode.int rec.uniques )
        , ( "views", Json.Encode.list encodeTraffic rec.views )
        ]


type alias Verification =
    { payload : Nullable String
    , reason : String
    , signature : Nullable String
    , verified : Bool
    }


decodeVerification : Json.Decode.Decoder Verification
decodeVerification =
    Json.Decode.succeed
     (\payload reason signature verified ->
         { payload = payload
         , reason = reason
         , signature = signature
         , verified = verified
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "payload"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "reason" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "signature"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "verified" Json.Decode.bool)


encodeVerification : Verification -> Json.Encode.Value
encodeVerification rec =
    Json.Encode.object
        [ ( "payload"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.payload
          )
        , ( "reason", Json.Encode.string rec.reason )
        , ( "signature"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.signature
          )
        , ( "verified", Json.Encode.bool rec.verified )
        ]


type alias ValidationErrorSimple =
    { documentation_url : String, errors : List String, message : String }


decodeValidationErrorSimple : Json.Decode.Decoder ValidationErrorSimple
decodeValidationErrorSimple =
    Json.Decode.succeed
     (\documentation_url errors message ->
         { documentation_url = documentation_url
         , errors = errors
         , message = message
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "documentation_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "errors" (Json.Decode.list Json.Decode.string))
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "message" Json.Decode.string)


encodeValidationErrorSimple : ValidationErrorSimple -> Json.Encode.Value
encodeValidationErrorSimple rec =
    Json.Encode.object
        [ ( "documentation_url", Json.Encode.string rec.documentation_url )
        , ( "errors", Json.Encode.list Json.Encode.string rec.errors )
        , ( "message", Json.Encode.string rec.message )
        ]


type alias ValidationError =
    { documentation_url : String
    , errors :
        List { code : String
        , field : String
        , index : Int
        , message : String
        , resource : String
        , value : Json.Encode.Value
        }
    , message : String
    }


decodeValidationError : Json.Decode.Decoder ValidationError
decodeValidationError =
    Json.Decode.succeed
     (\documentation_url errors message ->
         { documentation_url = documentation_url
         , errors = errors
         , message = message
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "documentation_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "errors"
                (Json.Decode.list
                    (Json.Decode.succeed
                      (\code field index message resource value ->
                          { code = code
                          , field = field
                          , index = index
                          , message = message
                          , resource = resource
                          , value = value
                          }
                      )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "code" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "field" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "index" Json.Decode.int)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "message" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "resource" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "value" Json.Decode.value)
                    )
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "message" Json.Decode.string)


encodeValidationError : ValidationError -> Json.Encode.Value
encodeValidationError rec =
    Json.Encode.object
        [ ( "documentation_url", Json.Encode.string rec.documentation_url )
        , ( "errors"
          , Json.Encode.list
                (\rec0 ->
                    Json.Encode.object
                        [ ( "code", Json.Encode.string rec0.code )
                        , ( "field", Json.Encode.string rec0.field )
                        , ( "index", Json.Encode.int rec0.index )
                        , ( "message", Json.Encode.string rec0.message )
                        , ( "resource", Json.Encode.string rec0.resource )
                        , ( "value", Basics.identity rec0.value )
                        ]
                )
                rec.errors
          )
        , ( "message", Json.Encode.string rec.message )
        ]


type alias UserSearchResultItem =
    { avatar_url : String
    , bio : Nullable String
    , blog : Nullable String
    , company : Nullable String
    , created_at : String
    , email : Nullable String
    , events_url : String
    , followers : Int
    , followers_url : String
    , following : Int
    , following_url : String
    , gists_url : String
    , gravatar_id : Nullable String
    , hireable : Nullable Bool
    , html_url : String
    , id : Int
    , location : Nullable String
    , login : String
    , name : Nullable String
    , node_id : String
    , organizations_url : String
    , public_gists : Int
    , public_repos : Int
    , received_events_url : String
    , repos_url : String
    , score : Float
    , site_admin : Bool
    , starred_url : String
    , subscriptions_url : String
    , suspended_at : Nullable String
    , text_matches : SearchResultTextMatches
    , type_ : String
    , updated_at : String
    , url : String
    }


decodeUserSearchResultItem : Json.Decode.Decoder UserSearchResultItem
decodeUserSearchResultItem =
    Json.Decode.succeed
     (\avatar_url bio blog company created_at email events_url followers followers_url following following_url gists_url gravatar_id hireable html_url id location login name node_id organizations_url public_gists public_repos received_events_url repos_url score site_admin starred_url subscriptions_url suspended_at text_matches type_ updated_at url ->
         { avatar_url = avatar_url
         , bio = bio
         , blog = blog
         , company = company
         , created_at = created_at
         , email = email
         , events_url = events_url
         , followers = followers
         , followers_url = followers_url
         , following = following
         , following_url = following_url
         , gists_url = gists_url
         , gravatar_id = gravatar_id
         , hireable = hireable
         , html_url = html_url
         , id = id
         , location = location
         , login = login
         , name = name
         , node_id = node_id
         , organizations_url = organizations_url
         , public_gists = public_gists
         , public_repos = public_repos
         , received_events_url = received_events_url
         , repos_url = repos_url
         , score = score
         , site_admin = site_admin
         , starred_url = starred_url
         , subscriptions_url = subscriptions_url
         , suspended_at = suspended_at
         , text_matches = text_matches
         , type_ = type_
         , updated_at = updated_at
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "avatar_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "bio"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "blog"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "company"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "email"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "events_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "followers" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "followers_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "following" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "following_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "gists_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "gravatar_id"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "hireable"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.bool
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "location"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "login" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "name"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "organizations_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "public_gists" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "public_repos" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "received_events_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "repos_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "score" Json.Decode.float)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "site_admin" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "starred_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "subscriptions_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "suspended_at"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "text_matches" decodeSearchResultTextMatches)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "type" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeUserSearchResultItem : UserSearchResultItem -> Json.Encode.Value
encodeUserSearchResultItem rec =
    Json.Encode.object
        [ ( "avatar_url", Json.Encode.string rec.avatar_url )
        , ( "bio"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.bio
          )
        , ( "blog"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.blog
          )
        , ( "company"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.company
          )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "email"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.email
          )
        , ( "events_url", Json.Encode.string rec.events_url )
        , ( "followers", Json.Encode.int rec.followers )
        , ( "followers_url", Json.Encode.string rec.followers_url )
        , ( "following", Json.Encode.int rec.following )
        , ( "following_url", Json.Encode.string rec.following_url )
        , ( "gists_url", Json.Encode.string rec.gists_url )
        , ( "gravatar_id"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.gravatar_id
          )
        , ( "hireable"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.bool value
            )
                rec.hireable
          )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "id", Json.Encode.int rec.id )
        , ( "location"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.location
          )
        , ( "login", Json.Encode.string rec.login )
        , ( "name"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.name
          )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "organizations_url", Json.Encode.string rec.organizations_url )
        , ( "public_gists", Json.Encode.int rec.public_gists )
        , ( "public_repos", Json.Encode.int rec.public_repos )
        , ( "received_events_url", Json.Encode.string rec.received_events_url )
        , ( "repos_url", Json.Encode.string rec.repos_url )
        , ( "score", Json.Encode.float rec.score )
        , ( "site_admin", Json.Encode.bool rec.site_admin )
        , ( "starred_url", Json.Encode.string rec.starred_url )
        , ( "subscriptions_url", Json.Encode.string rec.subscriptions_url )
        , ( "suspended_at"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.suspended_at
          )
        , ( "text_matches", encodeSearchResultTextMatches rec.text_matches )
        , ( "type", Json.Encode.string rec.type_ )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias UserMarketplacePurchase =
    { account : MarketplaceAccount
    , billing_cycle : String
    , free_trial_ends_on : Nullable String
    , next_billing_date : Nullable String
    , on_free_trial : Bool
    , plan : MarketplaceListingPlan
    , unit_count : Nullable Int
    , updated_at : Nullable String
    }


decodeUserMarketplacePurchase : Json.Decode.Decoder UserMarketplacePurchase
decodeUserMarketplacePurchase =
    Json.Decode.succeed
     (\account billing_cycle free_trial_ends_on next_billing_date on_free_trial plan unit_count updated_at ->
         { account = account
         , billing_cycle = billing_cycle
         , free_trial_ends_on = free_trial_ends_on
         , next_billing_date = next_billing_date
         , on_free_trial = on_free_trial
         , plan = plan
         , unit_count = unit_count
         , updated_at = updated_at
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "account" decodeMarketplaceAccount)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "billing_cycle" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "free_trial_ends_on"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "next_billing_date"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "on_free_trial" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "plan" decodeMarketplaceListingPlan)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "unit_count"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.int
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "updated_at"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )


encodeUserMarketplacePurchase : UserMarketplacePurchase -> Json.Encode.Value
encodeUserMarketplacePurchase rec =
    Json.Encode.object
        [ ( "account", encodeMarketplaceAccount rec.account )
        , ( "billing_cycle", Json.Encode.string rec.billing_cycle )
        , ( "free_trial_ends_on"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.free_trial_ends_on
          )
        , ( "next_billing_date"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.next_billing_date
          )
        , ( "on_free_trial", Json.Encode.bool rec.on_free_trial )
        , ( "plan", encodeMarketplaceListingPlan rec.plan )
        , ( "unit_count"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.int value
            )
                rec.unit_count
          )
        , ( "updated_at"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.updated_at
          )
        ]


type alias UnlabeledIssueEvent =
    { actor : SimpleUser
    , commit_id : Nullable String
    , commit_url : Nullable String
    , created_at : String
    , event : String
    , id : Int
    , label : { color : String, name : String }
    , node_id : String
    , performed_via_github_app : Nullable Integration
    , url : String
    }


decodeUnlabeledIssueEvent : Json.Decode.Decoder UnlabeledIssueEvent
decodeUnlabeledIssueEvent =
    Json.Decode.succeed
     (\actor commit_id commit_url created_at event id label node_id performed_via_github_app url ->
         { actor = actor
         , commit_id = commit_id
         , commit_url = commit_url
         , created_at = created_at
         , event = event
         , id = id
         , label = label
         , node_id = node_id
         , performed_via_github_app = performed_via_github_app
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap (Json.Decode.field "actor" decodeSimpleUser)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "commit_id"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "commit_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "event" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "label"
                (Json.Decode.succeed
                  (\color name -> { color = color, name = name })
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "color" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "name" Json.Decode.string)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "performed_via_github_app"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeIntegration
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeUnlabeledIssueEvent : UnlabeledIssueEvent -> Json.Encode.Value
encodeUnlabeledIssueEvent rec =
    Json.Encode.object
        [ ( "actor", encodeSimpleUser rec.actor )
        , ( "commit_id"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.commit_id
          )
        , ( "commit_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.commit_url
          )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "event", Json.Encode.string rec.event )
        , ( "id", Json.Encode.int rec.id )
        , ( "label"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "color", Json.Encode.string rec0.color )
                    , ( "name", Json.Encode.string rec0.name )
                    ]
            )
                rec.label
          )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "performed_via_github_app"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeIntegration value
            )
                rec.performed_via_github_app
          )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias UnassignedIssueEvent =
    { actor : SimpleUser
    , assignee : SimpleUser
    , assigner : SimpleUser
    , commit_id : Nullable String
    , commit_url : Nullable String
    , created_at : String
    , event : String
    , id : Int
    , node_id : String
    , performed_via_github_app : Nullable Integration
    , url : String
    }


decodeUnassignedIssueEvent : Json.Decode.Decoder UnassignedIssueEvent
decodeUnassignedIssueEvent =
    Json.Decode.succeed
     (\actor assignee assigner commit_id commit_url created_at event id node_id performed_via_github_app url ->
         { actor = actor
         , assignee = assignee
         , assigner = assigner
         , commit_id = commit_id
         , commit_url = commit_url
         , created_at = created_at
         , event = event
         , id = id
         , node_id = node_id
         , performed_via_github_app = performed_via_github_app
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap (Json.Decode.field "actor" decodeSimpleUser)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "assignee" decodeSimpleUser)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "assigner" decodeSimpleUser)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "commit_id"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "commit_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "event" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "performed_via_github_app"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeIntegration
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeUnassignedIssueEvent : UnassignedIssueEvent -> Json.Encode.Value
encodeUnassignedIssueEvent rec =
    Json.Encode.object
        [ ( "actor", encodeSimpleUser rec.actor )
        , ( "assignee", encodeSimpleUser rec.assignee )
        , ( "assigner", encodeSimpleUser rec.assigner )
        , ( "commit_id"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.commit_id
          )
        , ( "commit_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.commit_url
          )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "event", Json.Encode.string rec.event )
        , ( "id", Json.Encode.int rec.id )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "performed_via_github_app"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeIntegration value
            )
                rec.performed_via_github_app
          )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias Traffic =
    { count : Int, timestamp : String, uniques : Int }


decodeTraffic : Json.Decode.Decoder Traffic
decodeTraffic =
    Json.Decode.succeed
     (\count timestamp uniques ->
         { count = count, timestamp = timestamp, uniques = uniques }
     )
        |> Json.Decode.Extra.andMap (Json.Decode.field "count" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "timestamp" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "uniques" Json.Decode.int)


encodeTraffic : Traffic -> Json.Encode.Value
encodeTraffic rec =
    Json.Encode.object
        [ ( "count", Json.Encode.int rec.count )
        , ( "timestamp", Json.Encode.string rec.timestamp )
        , ( "uniques", Json.Encode.int rec.uniques )
        ]


type alias TopicSearchResultItem =
    { aliases :
        Nullable (List { topic_relation :
            { id : Int, name : String, relation_type : String, topic_id : Int }
        })
    , created_at : String
    , created_by : Nullable String
    , curated : Bool
    , description : Nullable String
    , display_name : Nullable String
    , featured : Bool
    , logo_url : Nullable String
    , name : String
    , related :
        Nullable (List { topic_relation :
            { id : Int, name : String, relation_type : String, topic_id : Int }
        })
    , released : Nullable String
    , repository_count : Nullable Int
    , score : Float
    , short_description : Nullable String
    , text_matches : SearchResultTextMatches
    , updated_at : String
    }


decodeTopicSearchResultItem : Json.Decode.Decoder TopicSearchResultItem
decodeTopicSearchResultItem =
    Json.Decode.succeed
     (\aliases created_at created_by curated description display_name featured logo_url name related released repository_count score short_description text_matches updated_at ->
         { aliases = aliases
         , created_at = created_at
         , created_by = created_by
         , curated = curated
         , description = description
         , display_name = display_name
         , featured = featured
         , logo_url = logo_url
         , name = name
         , related = related
         , released = released
         , repository_count = repository_count
         , score = score
         , short_description = short_description
         , text_matches = text_matches
         , updated_at = updated_at
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "aliases"
                (Json.Decode.oneOf
                    [ Json.Decode.map
                        Present
                        (Json.Decode.list
                            (Json.Decode.succeed
                                (\topic_relation ->
                                    { topic_relation = topic_relation }
                                )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "topic_relation"
                                        (Json.Decode.succeed
                                          (\id name relation_type topic_id ->
                                              { id = id
                                              , name = name
                                              , relation_type = relation_type
                                              , topic_id = topic_id
                                              }
                                          )
                                            |> Json.Decode.Extra.andMap
                                                (Json.Decode.field
                                                    "id"
                                                    Json.Decode.int
                                                )
                                            |> Json.Decode.Extra.andMap
                                                (Json.Decode.field
                                                    "name"
                                                    Json.Decode.string
                                                )
                                            |> Json.Decode.Extra.andMap
                                                (Json.Decode.field
                                                    "relation_type"
                                                    Json.Decode.string
                                                )
                                            |> Json.Decode.Extra.andMap
                                                (Json.Decode.field
                                                    "topic_id"
                                                    Json.Decode.int
                                                )
                                        )
                                    )
                            )
                        )
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "created_by"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "curated" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "description"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "display_name"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "featured" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "logo_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "related"
                (Json.Decode.oneOf
                    [ Json.Decode.map
                        Present
                        (Json.Decode.list
                            (Json.Decode.succeed
                                (\topic_relation ->
                                    { topic_relation = topic_relation }
                                )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "topic_relation"
                                        (Json.Decode.succeed
                                          (\id name relation_type topic_id ->
                                              { id = id
                                              , name = name
                                              , relation_type = relation_type
                                              , topic_id = topic_id
                                              }
                                          )
                                            |> Json.Decode.Extra.andMap
                                                (Json.Decode.field
                                                    "id"
                                                    Json.Decode.int
                                                )
                                            |> Json.Decode.Extra.andMap
                                                (Json.Decode.field
                                                    "name"
                                                    Json.Decode.string
                                                )
                                            |> Json.Decode.Extra.andMap
                                                (Json.Decode.field
                                                    "relation_type"
                                                    Json.Decode.string
                                                )
                                            |> Json.Decode.Extra.andMap
                                                (Json.Decode.field
                                                    "topic_id"
                                                    Json.Decode.int
                                                )
                                        )
                                    )
                            )
                        )
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "released"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "repository_count"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.int
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "score" Json.Decode.float)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "short_description"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "text_matches" decodeSearchResultTextMatches)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)


encodeTopicSearchResultItem : TopicSearchResultItem -> Json.Encode.Value
encodeTopicSearchResultItem rec =
    Json.Encode.object
        [ ( "aliases"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.list
                            (\rec0 ->
                                Json.Encode.object
                                    [ ( "topic_relation"
                                      , (\rec_0_1_1_1_1_0_0_1_0_0_1_1_0_0 ->
                                            Json.Encode.object
                                                [ ( "id"
                                                  , Json.Encode.int
                                                        rec_0_1_1_1_1_0_0_1_0_0_1_1_0_0.id
                                                  )
                                                , ( "name"
                                                  , Json.Encode.string
                                                        rec_0_1_1_1_1_0_0_1_0_0_1_1_0_0.name
                                                  )
                                                , ( "relation_type"
                                                  , Json.Encode.string
                                                        rec_0_1_1_1_1_0_0_1_0_0_1_1_0_0.relation_type
                                                  )
                                                , ( "topic_id"
                                                  , Json.Encode.int
                                                        rec_0_1_1_1_1_0_0_1_0_0_1_1_0_0.topic_id
                                                  )
                                                ]
                                        )
                                            rec0.topic_relation
                                      )
                                    ]
                            )
                            value
            )
                rec.aliases
          )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "created_by"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.created_by
          )
        , ( "curated", Json.Encode.bool rec.curated )
        , ( "description"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.description
          )
        , ( "display_name"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.display_name
          )
        , ( "featured", Json.Encode.bool rec.featured )
        , ( "logo_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.logo_url
          )
        , ( "name", Json.Encode.string rec.name )
        , ( "related"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.list
                            (\rec0 ->
                                Json.Encode.object
                                    [ ( "topic_relation"
                                      , (\rec_0_1_1_1_1_0_0_1_0_0_10_1_0_0 ->
                                            Json.Encode.object
                                                [ ( "id"
                                                  , Json.Encode.int
                                                        rec_0_1_1_1_1_0_0_1_0_0_10_1_0_0.id
                                                  )
                                                , ( "name"
                                                  , Json.Encode.string
                                                        rec_0_1_1_1_1_0_0_1_0_0_10_1_0_0.name
                                                  )
                                                , ( "relation_type"
                                                  , Json.Encode.string
                                                        rec_0_1_1_1_1_0_0_1_0_0_10_1_0_0.relation_type
                                                  )
                                                , ( "topic_id"
                                                  , Json.Encode.int
                                                        rec_0_1_1_1_1_0_0_1_0_0_10_1_0_0.topic_id
                                                  )
                                                ]
                                        )
                                            rec0.topic_relation
                                      )
                                    ]
                            )
                            value
            )
                rec.related
          )
        , ( "released"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.released
          )
        , ( "repository_count"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.int value
            )
                rec.repository_count
          )
        , ( "score", Json.Encode.float rec.score )
        , ( "short_description"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.short_description
          )
        , ( "text_matches", encodeSearchResultTextMatches rec.text_matches )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        ]


type alias Topic =
    { names : List String }


decodeTopic : Json.Decode.Decoder Topic
decodeTopic =
    Json.Decode.succeed (\names -> { names = names })
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "names" (Json.Decode.list Json.Decode.string))


encodeTopic : Topic -> Json.Encode.Value
encodeTopic rec =
    Json.Encode.object
        [ ( "names", Json.Encode.list Json.Encode.string rec.names ) ]


type alias TimelineUnassignedIssueEvent =
    { actor : SimpleUser
    , assignee : SimpleUser
    , commit_id : Nullable String
    , commit_url : Nullable String
    , created_at : String
    , event : String
    , id : Int
    , node_id : String
    , performed_via_github_app : Nullable Integration
    , url : String
    }


decodeTimelineUnassignedIssueEvent :
    Json.Decode.Decoder TimelineUnassignedIssueEvent
decodeTimelineUnassignedIssueEvent =
    Json.Decode.succeed
     (\actor assignee commit_id commit_url created_at event id node_id performed_via_github_app url ->
         { actor = actor
         , assignee = assignee
         , commit_id = commit_id
         , commit_url = commit_url
         , created_at = created_at
         , event = event
         , id = id
         , node_id = node_id
         , performed_via_github_app = performed_via_github_app
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap (Json.Decode.field "actor" decodeSimpleUser)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "assignee" decodeSimpleUser)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "commit_id"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "commit_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "event" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "performed_via_github_app"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeIntegration
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeTimelineUnassignedIssueEvent :
    TimelineUnassignedIssueEvent -> Json.Encode.Value
encodeTimelineUnassignedIssueEvent rec =
    Json.Encode.object
        [ ( "actor", encodeSimpleUser rec.actor )
        , ( "assignee", encodeSimpleUser rec.assignee )
        , ( "commit_id"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.commit_id
          )
        , ( "commit_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.commit_url
          )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "event", Json.Encode.string rec.event )
        , ( "id", Json.Encode.int rec.id )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "performed_via_github_app"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeIntegration value
            )
                rec.performed_via_github_app
          )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias TimelineReviewedEvent =
    { _links : { html : { href : String }, pull_request : { href : String } }
    , author_association : AuthorAssociation
    , body : Nullable String
    , body_html : String
    , body_text : String
    , commit_id : String
    , event : String
    , html_url : String
    , id : Int
    , node_id : String
    , pull_request_url : String
    , state : String
    , submitted_at : String
    , user : SimpleUser
    }


decodeTimelineReviewedEvent : Json.Decode.Decoder TimelineReviewedEvent
decodeTimelineReviewedEvent =
    Json.Decode.succeed
     (\_links author_association body body_html body_text commit_id event html_url id node_id pull_request_url state submitted_at user ->
         { _links = _links
         , author_association = author_association
         , body = body
         , body_html = body_html
         , body_text = body_text
         , commit_id = commit_id
         , event = event
         , html_url = html_url
         , id = id
         , node_id = node_id
         , pull_request_url = pull_request_url
         , state = state
         , submitted_at = submitted_at
         , user = user
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "_links"
                (Json.Decode.succeed
                  (\html pull_request ->
                      { html = html, pull_request = pull_request }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "html"
                            (Json.Decode.succeed (\href -> { href = href })
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field "href" Json.Decode.string
                                    )
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "pull_request"
                            (Json.Decode.succeed (\href -> { href = href })
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field "href" Json.Decode.string
                                    )
                            )
                        )
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "author_association" decodeAuthorAssociation)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "body"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "body_html" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "body_text" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "commit_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "event" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "pull_request_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "state" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "submitted_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "user" decodeSimpleUser)


encodeTimelineReviewedEvent : TimelineReviewedEvent -> Json.Encode.Value
encodeTimelineReviewedEvent rec =
    Json.Encode.object
        [ ( "_links"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "html"
                      , (\rec_0_1_1_1_0_1_1_0_0 ->
                            Json.Encode.object
                                [ ( "href"
                                  , Json.Encode.string
                                        rec_0_1_1_1_0_1_1_0_0.href
                                  )
                                ]
                        )
                            rec0.html
                      )
                    , ( "pull_request"
                      , (\rec_0_2_1_1_0_1_1_0_0 ->
                            Json.Encode.object
                                [ ( "href"
                                  , Json.Encode.string
                                        rec_0_2_1_1_0_1_1_0_0.href
                                  )
                                ]
                        )
                            rec0.pull_request
                      )
                    ]
            )
                rec._links
          )
        , ( "author_association"
          , encodeAuthorAssociation rec.author_association
          )
        , ( "body"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.body
          )
        , ( "body_html", Json.Encode.string rec.body_html )
        , ( "body_text", Json.Encode.string rec.body_text )
        , ( "commit_id", Json.Encode.string rec.commit_id )
        , ( "event", Json.Encode.string rec.event )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "id", Json.Encode.int rec.id )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "pull_request_url", Json.Encode.string rec.pull_request_url )
        , ( "state", Json.Encode.string rec.state )
        , ( "submitted_at", Json.Encode.string rec.submitted_at )
        , ( "user", encodeSimpleUser rec.user )
        ]


type alias TimelineLineCommentedEvent =
    { comments : List PullRequestReviewComment
    , event : String
    , node_id : String
    }


decodeTimelineLineCommentedEvent :
    Json.Decode.Decoder TimelineLineCommentedEvent
decodeTimelineLineCommentedEvent =
    Json.Decode.succeed
     (\comments event node_id ->
         { comments = comments, event = event, node_id = node_id }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "comments"
                (Json.Decode.list decodePullRequestReviewComment)
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "event" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)


encodeTimelineLineCommentedEvent :
    TimelineLineCommentedEvent -> Json.Encode.Value
encodeTimelineLineCommentedEvent rec =
    Json.Encode.object
        [ ( "comments"
          , Json.Encode.list encodePullRequestReviewComment rec.comments
          )
        , ( "event", Json.Encode.string rec.event )
        , ( "node_id", Json.Encode.string rec.node_id )
        ]


type alias TimelineIssueEvents =
    {}


decodeTimelineIssueEvents : Json.Decode.Decoder TimelineIssueEvents
decodeTimelineIssueEvents =
    Json.Decode.succeed {}


encodeTimelineIssueEvents : TimelineIssueEvents -> Json.Encode.Value
encodeTimelineIssueEvents rec =
    Json.Encode.object []


type alias TimelineCrossReferencedEvent =
    { actor : SimpleUser
    , created_at : String
    , event : String
    , source : { issue : Issue, type_ : String }
    , updated_at : String
    }


decodeTimelineCrossReferencedEvent :
    Json.Decode.Decoder TimelineCrossReferencedEvent
decodeTimelineCrossReferencedEvent =
    Json.Decode.succeed
     (\actor created_at event source updated_at ->
         { actor = actor
         , created_at = created_at
         , event = event
         , source = source
         , updated_at = updated_at
         }
     )
        |> Json.Decode.Extra.andMap (Json.Decode.field "actor" decodeSimpleUser)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "event" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "source"
                (Json.Decode.succeed
                  (\issue type_ -> { issue = issue, type_ = type_ })
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "issue" decodeIssue)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "type" Json.Decode.string)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)


encodeTimelineCrossReferencedEvent :
    TimelineCrossReferencedEvent -> Json.Encode.Value
encodeTimelineCrossReferencedEvent rec =
    Json.Encode.object
        [ ( "actor", encodeSimpleUser rec.actor )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "event", Json.Encode.string rec.event )
        , ( "source"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "issue", encodeIssue rec0.issue )
                    , ( "type", Json.Encode.string rec0.type_ )
                    ]
            )
                rec.source
          )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        ]


type alias TimelineCommittedEvent =
    { author : { date : String, email : String, name : String }
    , committer : { date : String, email : String, name : String }
    , event : String
    , html_url : String
    , message : String
    , node_id : String
    , parents : List { html_url : String, sha : String, url : String }
    , sha : String
    , tree : { sha : String, url : String }
    , url : String
    , verification :
        { payload : Nullable String
        , reason : String
        , signature : Nullable String
        , verified : Bool
        }
    }


decodeTimelineCommittedEvent : Json.Decode.Decoder TimelineCommittedEvent
decodeTimelineCommittedEvent =
    Json.Decode.succeed
     (\author committer event html_url message node_id parents sha tree url verification ->
         { author = author
         , committer = committer
         , event = event
         , html_url = html_url
         , message = message
         , node_id = node_id
         , parents = parents
         , sha = sha
         , tree = tree
         , url = url
         , verification = verification
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "author"
                (Json.Decode.succeed
                  (\date email name ->
                      { date = date, email = email, name = name }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "date" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "email" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "name" Json.Decode.string)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "committer"
                (Json.Decode.succeed
                  (\date email name ->
                      { date = date, email = email, name = name }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "date" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "email" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "name" Json.Decode.string)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "event" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "message" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "parents"
                (Json.Decode.list
                    (Json.Decode.succeed
                      (\html_url sha url ->
                          { html_url = html_url, sha = sha, url = url }
                      )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "html_url" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "sha" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "url" Json.Decode.string)
                    )
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "sha" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "tree"
                (Json.Decode.succeed (\sha url -> { sha = sha, url = url })
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "sha" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "url" Json.Decode.string)
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "verification"
                (Json.Decode.succeed
                  (\payload reason signature verified ->
                      { payload = payload
                      , reason = reason
                      , signature = signature
                      , verified = verified
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "payload"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.string
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "reason" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "signature"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.string
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "verified" Json.Decode.bool)
                )
            )


encodeTimelineCommittedEvent : TimelineCommittedEvent -> Json.Encode.Value
encodeTimelineCommittedEvent rec =
    Json.Encode.object
        [ ( "author"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "date", Json.Encode.string rec0.date )
                    , ( "email", Json.Encode.string rec0.email )
                    , ( "name", Json.Encode.string rec0.name )
                    ]
            )
                rec.author
          )
        , ( "committer"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "date", Json.Encode.string rec0.date )
                    , ( "email", Json.Encode.string rec0.email )
                    , ( "name", Json.Encode.string rec0.name )
                    ]
            )
                rec.committer
          )
        , ( "event", Json.Encode.string rec.event )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "message", Json.Encode.string rec.message )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "parents"
          , Json.Encode.list
                (\rec0 ->
                    Json.Encode.object
                        [ ( "html_url", Json.Encode.string rec0.html_url )
                        , ( "sha", Json.Encode.string rec0.sha )
                        , ( "url", Json.Encode.string rec0.url )
                        ]
                )
                rec.parents
          )
        , ( "sha", Json.Encode.string rec.sha )
        , ( "tree"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "sha", Json.Encode.string rec0.sha )
                    , ( "url", Json.Encode.string rec0.url )
                    ]
            )
                rec.tree
          )
        , ( "url", Json.Encode.string rec.url )
        , ( "verification"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "payload"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.string value
                        )
                            rec0.payload
                      )
                    , ( "reason", Json.Encode.string rec0.reason )
                    , ( "signature"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.string value
                        )
                            rec0.signature
                      )
                    , ( "verified", Json.Encode.bool rec0.verified )
                    ]
            )
                rec.verification
          )
        ]


type alias TimelineCommitCommentedEvent =
    { comments : List CommitComment
    , commit_id : String
    , event : String
    , node_id : String
    }


decodeTimelineCommitCommentedEvent :
    Json.Decode.Decoder TimelineCommitCommentedEvent
decodeTimelineCommitCommentedEvent =
    Json.Decode.succeed
     (\comments commit_id event node_id ->
         { comments = comments
         , commit_id = commit_id
         , event = event
         , node_id = node_id
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "comments" (Json.Decode.list decodeCommitComment)
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "commit_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "event" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)


encodeTimelineCommitCommentedEvent :
    TimelineCommitCommentedEvent -> Json.Encode.Value
encodeTimelineCommitCommentedEvent rec =
    Json.Encode.object
        [ ( "comments", Json.Encode.list encodeCommitComment rec.comments )
        , ( "commit_id", Json.Encode.string rec.commit_id )
        , ( "event", Json.Encode.string rec.event )
        , ( "node_id", Json.Encode.string rec.node_id )
        ]


type alias TimelineCommentEvent =
    { actor : SimpleUser
    , author_association : AuthorAssociation
    , body : String
    , body_html : String
    , body_text : String
    , created_at : String
    , event : String
    , html_url : String
    , id : Int
    , issue_url : String
    , node_id : String
    , performed_via_github_app : Nullable Integration
    , reactions : ReactionRollup
    , updated_at : String
    , url : String
    , user : SimpleUser
    }


decodeTimelineCommentEvent : Json.Decode.Decoder TimelineCommentEvent
decodeTimelineCommentEvent =
    Json.Decode.succeed
     (\actor author_association body body_html body_text created_at event html_url id issue_url node_id performed_via_github_app reactions updated_at url user ->
         { actor = actor
         , author_association = author_association
         , body = body
         , body_html = body_html
         , body_text = body_text
         , created_at = created_at
         , event = event
         , html_url = html_url
         , id = id
         , issue_url = issue_url
         , node_id = node_id
         , performed_via_github_app = performed_via_github_app
         , reactions = reactions
         , updated_at = updated_at
         , url = url
         , user = user
         }
     )
        |> Json.Decode.Extra.andMap (Json.Decode.field "actor" decodeSimpleUser)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "author_association" decodeAuthorAssociation)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "body" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "body_html" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "body_text" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "event" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "issue_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "performed_via_github_app"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeIntegration
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "reactions" decodeReactionRollup)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "user" decodeSimpleUser)


encodeTimelineCommentEvent : TimelineCommentEvent -> Json.Encode.Value
encodeTimelineCommentEvent rec =
    Json.Encode.object
        [ ( "actor", encodeSimpleUser rec.actor )
        , ( "author_association"
          , encodeAuthorAssociation rec.author_association
          )
        , ( "body", Json.Encode.string rec.body )
        , ( "body_html", Json.Encode.string rec.body_html )
        , ( "body_text", Json.Encode.string rec.body_text )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "event", Json.Encode.string rec.event )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "id", Json.Encode.int rec.id )
        , ( "issue_url", Json.Encode.string rec.issue_url )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "performed_via_github_app"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeIntegration value
            )
                rec.performed_via_github_app
          )
        , ( "reactions", encodeReactionRollup rec.reactions )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        , ( "url", Json.Encode.string rec.url )
        , ( "user", encodeSimpleUser rec.user )
        ]


type alias TimelineAssignedIssueEvent =
    { actor : SimpleUser
    , assignee : SimpleUser
    , commit_id : Nullable String
    , commit_url : Nullable String
    , created_at : String
    , event : String
    , id : Int
    , node_id : String
    , performed_via_github_app : Nullable Integration
    , url : String
    }


decodeTimelineAssignedIssueEvent :
    Json.Decode.Decoder TimelineAssignedIssueEvent
decodeTimelineAssignedIssueEvent =
    Json.Decode.succeed
     (\actor assignee commit_id commit_url created_at event id node_id performed_via_github_app url ->
         { actor = actor
         , assignee = assignee
         , commit_id = commit_id
         , commit_url = commit_url
         , created_at = created_at
         , event = event
         , id = id
         , node_id = node_id
         , performed_via_github_app = performed_via_github_app
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap (Json.Decode.field "actor" decodeSimpleUser)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "assignee" decodeSimpleUser)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "commit_id"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "commit_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "event" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "performed_via_github_app"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeIntegration
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeTimelineAssignedIssueEvent :
    TimelineAssignedIssueEvent -> Json.Encode.Value
encodeTimelineAssignedIssueEvent rec =
    Json.Encode.object
        [ ( "actor", encodeSimpleUser rec.actor )
        , ( "assignee", encodeSimpleUser rec.assignee )
        , ( "commit_id"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.commit_id
          )
        , ( "commit_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.commit_url
          )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "event", Json.Encode.string rec.event )
        , ( "id", Json.Encode.int rec.id )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "performed_via_github_app"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeIntegration value
            )
                rec.performed_via_github_app
          )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias ThreadSubscription =
    { created_at : Nullable String
    , ignored : Bool
    , reason : Nullable String
    , repository_url : String
    , subscribed : Bool
    , thread_url : String
    , url : String
    }


decodeThreadSubscription : Json.Decode.Decoder ThreadSubscription
decodeThreadSubscription =
    Json.Decode.succeed
     (\created_at ignored reason repository_url subscribed thread_url url ->
         { created_at = created_at
         , ignored = ignored
         , reason = reason
         , repository_url = repository_url
         , subscribed = subscribed
         , thread_url = thread_url
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "created_at"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "ignored" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "reason"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "repository_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "subscribed" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "thread_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeThreadSubscription : ThreadSubscription -> Json.Encode.Value
encodeThreadSubscription rec =
    Json.Encode.object
        [ ( "created_at"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.created_at
          )
        , ( "ignored", Json.Encode.bool rec.ignored )
        , ( "reason"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.reason
          )
        , ( "repository_url", Json.Encode.string rec.repository_url )
        , ( "subscribed", Json.Encode.bool rec.subscribed )
        , ( "thread_url", Json.Encode.string rec.thread_url )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias Thread =
    { id : String
    , last_read_at : Nullable String
    , reason : String
    , repository : MinimalRepository
    , subject :
        { latest_comment_url : String
        , title : String
        , type_ : String
        , url : String
        }
    , subscription_url : String
    , unread : Bool
    , updated_at : String
    , url : String
    }


decodeThread : Json.Decode.Decoder Thread
decodeThread =
    Json.Decode.succeed
     (\id last_read_at reason repository subject subscription_url unread updated_at url ->
         { id = id
         , last_read_at = last_read_at
         , reason = reason
         , repository = repository
         , subject = subject
         , subscription_url = subscription_url
         , unread = unread
         , updated_at = updated_at
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "last_read_at"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "reason" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "repository" decodeMinimalRepository)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "subject"
                (Json.Decode.succeed
                  (\latest_comment_url title type_ url ->
                      { latest_comment_url = latest_comment_url
                      , title = title
                      , type_ = type_
                      , url = url
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "latest_comment_url"
                            Json.Decode.string
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "title" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "type" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "url" Json.Decode.string)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "subscription_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "unread" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeThread : Thread -> Json.Encode.Value
encodeThread rec =
    Json.Encode.object
        [ ( "id", Json.Encode.string rec.id )
        , ( "last_read_at"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.last_read_at
          )
        , ( "reason", Json.Encode.string rec.reason )
        , ( "repository", encodeMinimalRepository rec.repository )
        , ( "subject"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "latest_comment_url"
                      , Json.Encode.string rec0.latest_comment_url
                      )
                    , ( "title", Json.Encode.string rec0.title )
                    , ( "type", Json.Encode.string rec0.type_ )
                    , ( "url", Json.Encode.string rec0.url )
                    ]
            )
                rec.subject
          )
        , ( "subscription_url", Json.Encode.string rec.subscription_url )
        , ( "unread", Json.Encode.bool rec.unread )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias TeamSimple =
    { description : Nullable String
    , html_url : String
    , id : Int
    , ldap_dn : String
    , members_url : String
    , name : String
    , node_id : String
    , permission : String
    , privacy : String
    , repositories_url : String
    , slug : String
    , url : String
    }


decodeTeamSimple : Json.Decode.Decoder TeamSimple
decodeTeamSimple =
    Json.Decode.succeed
     (\description html_url id ldap_dn members_url name node_id permission privacy repositories_url slug url ->
         { description = description
         , html_url = html_url
         , id = id
         , ldap_dn = ldap_dn
         , members_url = members_url
         , name = name
         , node_id = node_id
         , permission = permission
         , privacy = privacy
         , repositories_url = repositories_url
         , slug = slug
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "description"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "ldap_dn" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "members_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "permission" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "privacy" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "repositories_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "slug" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeTeamSimple : TeamSimple -> Json.Encode.Value
encodeTeamSimple rec =
    Json.Encode.object
        [ ( "description"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.description
          )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "id", Json.Encode.int rec.id )
        , ( "ldap_dn", Json.Encode.string rec.ldap_dn )
        , ( "members_url", Json.Encode.string rec.members_url )
        , ( "name", Json.Encode.string rec.name )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "permission", Json.Encode.string rec.permission )
        , ( "privacy", Json.Encode.string rec.privacy )
        , ( "repositories_url", Json.Encode.string rec.repositories_url )
        , ( "slug", Json.Encode.string rec.slug )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias TeamRepository =
    { allow_auto_merge : Bool
    , allow_forking : Bool
    , allow_merge_commit : Bool
    , allow_rebase_merge : Bool
    , allow_squash_merge : Bool
    , archive_url : String
    , archived : Bool
    , assignees_url : String
    , blobs_url : String
    , branches_url : String
    , clone_url : String
    , collaborators_url : String
    , comments_url : String
    , commits_url : String
    , compare_url : String
    , contents_url : String
    , contributors_url : String
    , created_at : Nullable String
    , default_branch : String
    , delete_branch_on_merge : Bool
    , deployments_url : String
    , description : Nullable String
    , disabled : Bool
    , downloads_url : String
    , events_url : String
    , fork : Bool
    , forks : Int
    , forks_count : Int
    , forks_url : String
    , full_name : String
    , git_commits_url : String
    , git_refs_url : String
    , git_tags_url : String
    , git_url : String
    , has_downloads : Bool
    , has_issues : Bool
    , has_pages : Bool
    , has_projects : Bool
    , has_wiki : Bool
    , homepage : Nullable String
    , hooks_url : String
    , html_url : String
    , id : Int
    , is_template : Bool
    , issue_comment_url : String
    , issue_events_url : String
    , issues_url : String
    , keys_url : String
    , labels_url : String
    , language : Nullable String
    , languages_url : String
    , license : Nullable LicenseSimple
    , master_branch : String
    , merges_url : String
    , milestones_url : String
    , mirror_url : Nullable String
    , name : String
    , network_count : Int
    , node_id : String
    , notifications_url : String
    , open_issues : Int
    , open_issues_count : Int
    , owner : Nullable SimpleUser
    , permissions :
        { admin : Bool
        , maintain : Bool
        , pull : Bool
        , push : Bool
        , triage : Bool
        }
    , private : Bool
    , pulls_url : String
    , pushed_at : Nullable String
    , releases_url : String
    , role_name : String
    , size : Int
    , ssh_url : String
    , stargazers_count : Int
    , stargazers_url : String
    , statuses_url : String
    , subscribers_count : Int
    , subscribers_url : String
    , subscription_url : String
    , svn_url : String
    , tags_url : String
    , teams_url : String
    , temp_clone_token : String
    , template_repository : Nullable Repository
    , topics : List String
    , trees_url : String
    , updated_at : Nullable String
    , url : String
    , visibility : String
    , watchers : Int
    , watchers_count : Int
    , web_commit_signoff_required : Bool
    }


decodeTeamRepository : Json.Decode.Decoder TeamRepository
decodeTeamRepository =
    Json.Decode.succeed
     (\allow_auto_merge allow_forking allow_merge_commit allow_rebase_merge allow_squash_merge archive_url archived assignees_url blobs_url branches_url clone_url collaborators_url comments_url commits_url compare_url contents_url contributors_url created_at default_branch delete_branch_on_merge deployments_url description disabled downloads_url events_url fork forks forks_count forks_url full_name git_commits_url git_refs_url git_tags_url git_url has_downloads has_issues has_pages has_projects has_wiki homepage hooks_url html_url id is_template issue_comment_url issue_events_url issues_url keys_url labels_url language languages_url license master_branch merges_url milestones_url mirror_url name network_count node_id notifications_url open_issues open_issues_count owner permissions private pulls_url pushed_at releases_url role_name size ssh_url stargazers_count stargazers_url statuses_url subscribers_count subscribers_url subscription_url svn_url tags_url teams_url temp_clone_token template_repository topics trees_url updated_at url visibility watchers watchers_count web_commit_signoff_required ->
         { allow_auto_merge = allow_auto_merge
         , allow_forking = allow_forking
         , allow_merge_commit = allow_merge_commit
         , allow_rebase_merge = allow_rebase_merge
         , allow_squash_merge = allow_squash_merge
         , archive_url = archive_url
         , archived = archived
         , assignees_url = assignees_url
         , blobs_url = blobs_url
         , branches_url = branches_url
         , clone_url = clone_url
         , collaborators_url = collaborators_url
         , comments_url = comments_url
         , commits_url = commits_url
         , compare_url = compare_url
         , contents_url = contents_url
         , contributors_url = contributors_url
         , created_at = created_at
         , default_branch = default_branch
         , delete_branch_on_merge = delete_branch_on_merge
         , deployments_url = deployments_url
         , description = description
         , disabled = disabled
         , downloads_url = downloads_url
         , events_url = events_url
         , fork = fork
         , forks = forks
         , forks_count = forks_count
         , forks_url = forks_url
         , full_name = full_name
         , git_commits_url = git_commits_url
         , git_refs_url = git_refs_url
         , git_tags_url = git_tags_url
         , git_url = git_url
         , has_downloads = has_downloads
         , has_issues = has_issues
         , has_pages = has_pages
         , has_projects = has_projects
         , has_wiki = has_wiki
         , homepage = homepage
         , hooks_url = hooks_url
         , html_url = html_url
         , id = id
         , is_template = is_template
         , issue_comment_url = issue_comment_url
         , issue_events_url = issue_events_url
         , issues_url = issues_url
         , keys_url = keys_url
         , labels_url = labels_url
         , language = language
         , languages_url = languages_url
         , license = license
         , master_branch = master_branch
         , merges_url = merges_url
         , milestones_url = milestones_url
         , mirror_url = mirror_url
         , name = name
         , network_count = network_count
         , node_id = node_id
         , notifications_url = notifications_url
         , open_issues = open_issues
         , open_issues_count = open_issues_count
         , owner = owner
         , permissions = permissions
         , private = private
         , pulls_url = pulls_url
         , pushed_at = pushed_at
         , releases_url = releases_url
         , role_name = role_name
         , size = size
         , ssh_url = ssh_url
         , stargazers_count = stargazers_count
         , stargazers_url = stargazers_url
         , statuses_url = statuses_url
         , subscribers_count = subscribers_count
         , subscribers_url = subscribers_url
         , subscription_url = subscription_url
         , svn_url = svn_url
         , tags_url = tags_url
         , teams_url = teams_url
         , temp_clone_token = temp_clone_token
         , template_repository = template_repository
         , topics = topics
         , trees_url = trees_url
         , updated_at = updated_at
         , url = url
         , visibility = visibility
         , watchers = watchers
         , watchers_count = watchers_count
         , web_commit_signoff_required = web_commit_signoff_required
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "allow_auto_merge" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "allow_forking" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "allow_merge_commit" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "allow_rebase_merge" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "allow_squash_merge" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "archive_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "archived" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "assignees_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "blobs_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "branches_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "clone_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "collaborators_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "comments_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "commits_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "compare_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "contents_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "contributors_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "created_at"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "default_branch" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "delete_branch_on_merge" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "deployments_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "description"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "disabled" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "downloads_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "events_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "fork" Json.Decode.bool)
        |> Json.Decode.Extra.andMap (Json.Decode.field "forks" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "forks_count" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "forks_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "full_name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "git_commits_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "git_refs_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "git_tags_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "git_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "has_downloads" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "has_issues" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "has_pages" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "has_projects" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "has_wiki" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "homepage"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "hooks_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "is_template" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "issue_comment_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "issue_events_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "issues_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "keys_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "labels_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "language"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "languages_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "license"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeLicenseSimple
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "master_branch" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "merges_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "milestones_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "mirror_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "network_count" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "notifications_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "open_issues" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "open_issues_count" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "owner"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "permissions"
                (Json.Decode.succeed
                  (\admin maintain pull push triage ->
                      { admin = admin
                      , maintain = maintain
                      , pull = pull
                      , push = push
                      , triage = triage
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "admin" Json.Decode.bool)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "maintain" Json.Decode.bool)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "pull" Json.Decode.bool)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "push" Json.Decode.bool)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "triage" Json.Decode.bool)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "private" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "pulls_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "pushed_at"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "releases_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "role_name" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "size" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "ssh_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "stargazers_count" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "stargazers_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "statuses_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "subscribers_count" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "subscribers_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "subscription_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "svn_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "tags_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "teams_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "temp_clone_token" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "template_repository"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeRepository
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "topics" (Json.Decode.list Json.Decode.string))
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "trees_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "updated_at"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "visibility" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "watchers" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "watchers_count" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "web_commit_signoff_required" Json.Decode.bool)


encodeTeamRepository : TeamRepository -> Json.Encode.Value
encodeTeamRepository rec =
    Json.Encode.object
        [ ( "allow_auto_merge", Json.Encode.bool rec.allow_auto_merge )
        , ( "allow_forking", Json.Encode.bool rec.allow_forking )
        , ( "allow_merge_commit", Json.Encode.bool rec.allow_merge_commit )
        , ( "allow_rebase_merge", Json.Encode.bool rec.allow_rebase_merge )
        , ( "allow_squash_merge", Json.Encode.bool rec.allow_squash_merge )
        , ( "archive_url", Json.Encode.string rec.archive_url )
        , ( "archived", Json.Encode.bool rec.archived )
        , ( "assignees_url", Json.Encode.string rec.assignees_url )
        , ( "blobs_url", Json.Encode.string rec.blobs_url )
        , ( "branches_url", Json.Encode.string rec.branches_url )
        , ( "clone_url", Json.Encode.string rec.clone_url )
        , ( "collaborators_url", Json.Encode.string rec.collaborators_url )
        , ( "comments_url", Json.Encode.string rec.comments_url )
        , ( "commits_url", Json.Encode.string rec.commits_url )
        , ( "compare_url", Json.Encode.string rec.compare_url )
        , ( "contents_url", Json.Encode.string rec.contents_url )
        , ( "contributors_url", Json.Encode.string rec.contributors_url )
        , ( "created_at"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.created_at
          )
        , ( "default_branch", Json.Encode.string rec.default_branch )
        , ( "delete_branch_on_merge"
          , Json.Encode.bool rec.delete_branch_on_merge
          )
        , ( "deployments_url", Json.Encode.string rec.deployments_url )
        , ( "description"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.description
          )
        , ( "disabled", Json.Encode.bool rec.disabled )
        , ( "downloads_url", Json.Encode.string rec.downloads_url )
        , ( "events_url", Json.Encode.string rec.events_url )
        , ( "fork", Json.Encode.bool rec.fork )
        , ( "forks", Json.Encode.int rec.forks )
        , ( "forks_count", Json.Encode.int rec.forks_count )
        , ( "forks_url", Json.Encode.string rec.forks_url )
        , ( "full_name", Json.Encode.string rec.full_name )
        , ( "git_commits_url", Json.Encode.string rec.git_commits_url )
        , ( "git_refs_url", Json.Encode.string rec.git_refs_url )
        , ( "git_tags_url", Json.Encode.string rec.git_tags_url )
        , ( "git_url", Json.Encode.string rec.git_url )
        , ( "has_downloads", Json.Encode.bool rec.has_downloads )
        , ( "has_issues", Json.Encode.bool rec.has_issues )
        , ( "has_pages", Json.Encode.bool rec.has_pages )
        , ( "has_projects", Json.Encode.bool rec.has_projects )
        , ( "has_wiki", Json.Encode.bool rec.has_wiki )
        , ( "homepage"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.homepage
          )
        , ( "hooks_url", Json.Encode.string rec.hooks_url )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "id", Json.Encode.int rec.id )
        , ( "is_template", Json.Encode.bool rec.is_template )
        , ( "issue_comment_url", Json.Encode.string rec.issue_comment_url )
        , ( "issue_events_url", Json.Encode.string rec.issue_events_url )
        , ( "issues_url", Json.Encode.string rec.issues_url )
        , ( "keys_url", Json.Encode.string rec.keys_url )
        , ( "labels_url", Json.Encode.string rec.labels_url )
        , ( "language"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.language
          )
        , ( "languages_url", Json.Encode.string rec.languages_url )
        , ( "license"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeLicenseSimple value
            )
                rec.license
          )
        , ( "master_branch", Json.Encode.string rec.master_branch )
        , ( "merges_url", Json.Encode.string rec.merges_url )
        , ( "milestones_url", Json.Encode.string rec.milestones_url )
        , ( "mirror_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.mirror_url
          )
        , ( "name", Json.Encode.string rec.name )
        , ( "network_count", Json.Encode.int rec.network_count )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "notifications_url", Json.Encode.string rec.notifications_url )
        , ( "open_issues", Json.Encode.int rec.open_issues )
        , ( "open_issues_count", Json.Encode.int rec.open_issues_count )
        , ( "owner"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.owner
          )
        , ( "permissions"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "admin", Json.Encode.bool rec0.admin )
                    , ( "maintain", Json.Encode.bool rec0.maintain )
                    , ( "pull", Json.Encode.bool rec0.pull )
                    , ( "push", Json.Encode.bool rec0.push )
                    , ( "triage", Json.Encode.bool rec0.triage )
                    ]
            )
                rec.permissions
          )
        , ( "private", Json.Encode.bool rec.private )
        , ( "pulls_url", Json.Encode.string rec.pulls_url )
        , ( "pushed_at"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.pushed_at
          )
        , ( "releases_url", Json.Encode.string rec.releases_url )
        , ( "role_name", Json.Encode.string rec.role_name )
        , ( "size", Json.Encode.int rec.size )
        , ( "ssh_url", Json.Encode.string rec.ssh_url )
        , ( "stargazers_count", Json.Encode.int rec.stargazers_count )
        , ( "stargazers_url", Json.Encode.string rec.stargazers_url )
        , ( "statuses_url", Json.Encode.string rec.statuses_url )
        , ( "subscribers_count", Json.Encode.int rec.subscribers_count )
        , ( "subscribers_url", Json.Encode.string rec.subscribers_url )
        , ( "subscription_url", Json.Encode.string rec.subscription_url )
        , ( "svn_url", Json.Encode.string rec.svn_url )
        , ( "tags_url", Json.Encode.string rec.tags_url )
        , ( "teams_url", Json.Encode.string rec.teams_url )
        , ( "temp_clone_token", Json.Encode.string rec.temp_clone_token )
        , ( "template_repository"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeRepository value
            )
                rec.template_repository
          )
        , ( "topics", Json.Encode.list Json.Encode.string rec.topics )
        , ( "trees_url", Json.Encode.string rec.trees_url )
        , ( "updated_at"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.updated_at
          )
        , ( "url", Json.Encode.string rec.url )
        , ( "visibility", Json.Encode.string rec.visibility )
        , ( "watchers", Json.Encode.int rec.watchers )
        , ( "watchers_count", Json.Encode.int rec.watchers_count )
        , ( "web_commit_signoff_required"
          , Json.Encode.bool rec.web_commit_signoff_required
          )
        ]


type alias TeamProject =
    { body : Nullable String
    , columns_url : String
    , created_at : String
    , creator : SimpleUser
    , html_url : String
    , id : Int
    , name : String
    , node_id : String
    , number : Int
    , organization_permission : String
    , owner_url : String
    , permissions : { admin : Bool, read : Bool, write : Bool }
    , private : Bool
    , state : String
    , updated_at : String
    , url : String
    }


decodeTeamProject : Json.Decode.Decoder TeamProject
decodeTeamProject =
    Json.Decode.succeed
     (\body columns_url created_at creator html_url id name node_id number organization_permission owner_url permissions private state updated_at url ->
         { body = body
         , columns_url = columns_url
         , created_at = created_at
         , creator = creator
         , html_url = html_url
         , id = id
         , name = name
         , node_id = node_id
         , number = number
         , organization_permission = organization_permission
         , owner_url = owner_url
         , permissions = permissions
         , private = private
         , state = state
         , updated_at = updated_at
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "body"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "columns_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "creator" decodeSimpleUser)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "number" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "organization_permission" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "owner_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "permissions"
                (Json.Decode.succeed
                  (\admin read write ->
                      { admin = admin, read = read, write = write }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "admin" Json.Decode.bool)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "read" Json.Decode.bool)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "write" Json.Decode.bool)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "private" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "state" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeTeamProject : TeamProject -> Json.Encode.Value
encodeTeamProject rec =
    Json.Encode.object
        [ ( "body"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.body
          )
        , ( "columns_url", Json.Encode.string rec.columns_url )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "creator", encodeSimpleUser rec.creator )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "id", Json.Encode.int rec.id )
        , ( "name", Json.Encode.string rec.name )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "number", Json.Encode.int rec.number )
        , ( "organization_permission"
          , Json.Encode.string rec.organization_permission
          )
        , ( "owner_url", Json.Encode.string rec.owner_url )
        , ( "permissions"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "admin", Json.Encode.bool rec0.admin )
                    , ( "read", Json.Encode.bool rec0.read )
                    , ( "write", Json.Encode.bool rec0.write )
                    ]
            )
                rec.permissions
          )
        , ( "private", Json.Encode.bool rec.private )
        , ( "state", Json.Encode.string rec.state )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias TeamOrganization =
    { avatar_url : String
    , billing_email : Nullable String
    , blog : String
    , collaborators : Nullable Int
    , company : String
    , created_at : String
    , default_repository_permission : Nullable String
    , description : Nullable String
    , disk_usage : Nullable Int
    , email : String
    , events_url : String
    , followers : Int
    , following : Int
    , has_organization_projects : Bool
    , has_repository_projects : Bool
    , hooks_url : String
    , html_url : String
    , id : Int
    , is_verified : Bool
    , issues_url : String
    , location : String
    , login : String
    , members_allowed_repository_creation_type : String
    , members_can_create_internal_repositories : Bool
    , members_can_create_pages : Bool
    , members_can_create_private_pages : Bool
    , members_can_create_private_repositories : Bool
    , members_can_create_public_pages : Bool
    , members_can_create_public_repositories : Bool
    , members_can_create_repositories : Nullable Bool
    , members_can_fork_private_repositories : Nullable Bool
    , members_url : String
    , name : String
    , node_id : String
    , owned_private_repos : Int
    , plan :
        { filled_seats : Int
        , name : String
        , private_repos : Int
        , seats : Int
        , space : Int
        }
    , private_gists : Nullable Int
    , public_gists : Int
    , public_members_url : String
    , public_repos : Int
    , repos_url : String
    , total_private_repos : Int
    , twitter_username : Nullable String
    , two_factor_requirement_enabled : Nullable Bool
    , type_ : String
    , updated_at : String
    , url : String
    , web_commit_signoff_required : Bool
    }


decodeTeamOrganization : Json.Decode.Decoder TeamOrganization
decodeTeamOrganization =
    Json.Decode.succeed
     (\avatar_url billing_email blog collaborators company created_at default_repository_permission description disk_usage email events_url followers following has_organization_projects has_repository_projects hooks_url html_url id is_verified issues_url location login members_allowed_repository_creation_type members_can_create_internal_repositories members_can_create_pages members_can_create_private_pages members_can_create_private_repositories members_can_create_public_pages members_can_create_public_repositories members_can_create_repositories members_can_fork_private_repositories members_url name node_id owned_private_repos plan private_gists public_gists public_members_url public_repos repos_url total_private_repos twitter_username two_factor_requirement_enabled type_ updated_at url web_commit_signoff_required ->
         { avatar_url = avatar_url
         , billing_email = billing_email
         , blog = blog
         , collaborators = collaborators
         , company = company
         , created_at = created_at
         , default_repository_permission = default_repository_permission
         , description = description
         , disk_usage = disk_usage
         , email = email
         , events_url = events_url
         , followers = followers
         , following = following
         , has_organization_projects = has_organization_projects
         , has_repository_projects = has_repository_projects
         , hooks_url = hooks_url
         , html_url = html_url
         , id = id
         , is_verified = is_verified
         , issues_url = issues_url
         , location = location
         , login = login
         , members_allowed_repository_creation_type =
             members_allowed_repository_creation_type
         , members_can_create_internal_repositories =
             members_can_create_internal_repositories
         , members_can_create_pages = members_can_create_pages
         , members_can_create_private_pages = members_can_create_private_pages
         , members_can_create_private_repositories =
             members_can_create_private_repositories
         , members_can_create_public_pages = members_can_create_public_pages
         , members_can_create_public_repositories =
             members_can_create_public_repositories
         , members_can_create_repositories = members_can_create_repositories
         , members_can_fork_private_repositories =
             members_can_fork_private_repositories
         , members_url = members_url
         , name = name
         , node_id = node_id
         , owned_private_repos = owned_private_repos
         , plan = plan
         , private_gists = private_gists
         , public_gists = public_gists
         , public_members_url = public_members_url
         , public_repos = public_repos
         , repos_url = repos_url
         , total_private_repos = total_private_repos
         , twitter_username = twitter_username
         , two_factor_requirement_enabled = two_factor_requirement_enabled
         , type_ = type_
         , updated_at = updated_at
         , url = url
         , web_commit_signoff_required = web_commit_signoff_required
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "avatar_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "billing_email"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "blog" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "collaborators"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.int
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "company" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "default_repository_permission"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "description"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "disk_usage"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.int
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "email" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "events_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "followers" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "following" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "has_organization_projects" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "has_repository_projects" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "hooks_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "is_verified" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "issues_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "location" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "login" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "members_allowed_repository_creation_type"
                Json.Decode.string
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "members_can_create_internal_repositories"
                Json.Decode.bool
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "members_can_create_pages" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "members_can_create_private_pages"
                Json.Decode.bool
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "members_can_create_private_repositories"
                Json.Decode.bool
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "members_can_create_public_pages"
                Json.Decode.bool
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "members_can_create_public_repositories"
                Json.Decode.bool
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "members_can_create_repositories"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.bool
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "members_can_fork_private_repositories"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.bool
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "members_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "owned_private_repos" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "plan"
                (Json.Decode.succeed
                  (\filled_seats name private_repos seats space ->
                      { filled_seats = filled_seats
                      , name = name
                      , private_repos = private_repos
                      , seats = seats
                      , space = space
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "filled_seats" Json.Decode.int)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "name" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "private_repos" Json.Decode.int)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "seats" Json.Decode.int)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "space" Json.Decode.int)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "private_gists"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.int
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "public_gists" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "public_members_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "public_repos" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "repos_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "total_private_repos" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "twitter_username"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "two_factor_requirement_enabled"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.bool
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "type" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "web_commit_signoff_required" Json.Decode.bool)


encodeTeamOrganization : TeamOrganization -> Json.Encode.Value
encodeTeamOrganization rec =
    Json.Encode.object
        [ ( "avatar_url", Json.Encode.string rec.avatar_url )
        , ( "billing_email"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.billing_email
          )
        , ( "blog", Json.Encode.string rec.blog )
        , ( "collaborators"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.int value
            )
                rec.collaborators
          )
        , ( "company", Json.Encode.string rec.company )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "default_repository_permission"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.default_repository_permission
          )
        , ( "description"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.description
          )
        , ( "disk_usage"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.int value
            )
                rec.disk_usage
          )
        , ( "email", Json.Encode.string rec.email )
        , ( "events_url", Json.Encode.string rec.events_url )
        , ( "followers", Json.Encode.int rec.followers )
        , ( "following", Json.Encode.int rec.following )
        , ( "has_organization_projects"
          , Json.Encode.bool rec.has_organization_projects
          )
        , ( "has_repository_projects"
          , Json.Encode.bool rec.has_repository_projects
          )
        , ( "hooks_url", Json.Encode.string rec.hooks_url )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "id", Json.Encode.int rec.id )
        , ( "is_verified", Json.Encode.bool rec.is_verified )
        , ( "issues_url", Json.Encode.string rec.issues_url )
        , ( "location", Json.Encode.string rec.location )
        , ( "login", Json.Encode.string rec.login )
        , ( "members_allowed_repository_creation_type"
          , Json.Encode.string rec.members_allowed_repository_creation_type
          )
        , ( "members_can_create_internal_repositories"
          , Json.Encode.bool rec.members_can_create_internal_repositories
          )
        , ( "members_can_create_pages"
          , Json.Encode.bool rec.members_can_create_pages
          )
        , ( "members_can_create_private_pages"
          , Json.Encode.bool rec.members_can_create_private_pages
          )
        , ( "members_can_create_private_repositories"
          , Json.Encode.bool rec.members_can_create_private_repositories
          )
        , ( "members_can_create_public_pages"
          , Json.Encode.bool rec.members_can_create_public_pages
          )
        , ( "members_can_create_public_repositories"
          , Json.Encode.bool rec.members_can_create_public_repositories
          )
        , ( "members_can_create_repositories"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.bool value
            )
                rec.members_can_create_repositories
          )
        , ( "members_can_fork_private_repositories"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.bool value
            )
                rec.members_can_fork_private_repositories
          )
        , ( "members_url", Json.Encode.string rec.members_url )
        , ( "name", Json.Encode.string rec.name )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "owned_private_repos", Json.Encode.int rec.owned_private_repos )
        , ( "plan"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "filled_seats", Json.Encode.int rec0.filled_seats )
                    , ( "name", Json.Encode.string rec0.name )
                    , ( "private_repos", Json.Encode.int rec0.private_repos )
                    , ( "seats", Json.Encode.int rec0.seats )
                    , ( "space", Json.Encode.int rec0.space )
                    ]
            )
                rec.plan
          )
        , ( "private_gists"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.int value
            )
                rec.private_gists
          )
        , ( "public_gists", Json.Encode.int rec.public_gists )
        , ( "public_members_url", Json.Encode.string rec.public_members_url )
        , ( "public_repos", Json.Encode.int rec.public_repos )
        , ( "repos_url", Json.Encode.string rec.repos_url )
        , ( "total_private_repos", Json.Encode.int rec.total_private_repos )
        , ( "twitter_username"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.twitter_username
          )
        , ( "two_factor_requirement_enabled"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.bool value
            )
                rec.two_factor_requirement_enabled
          )
        , ( "type", Json.Encode.string rec.type_ )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        , ( "url", Json.Encode.string rec.url )
        , ( "web_commit_signoff_required"
          , Json.Encode.bool rec.web_commit_signoff_required
          )
        ]


type alias TeamMembership =
    { role : String, state : String, url : String }


decodeTeamMembership : Json.Decode.Decoder TeamMembership
decodeTeamMembership =
    Json.Decode.succeed
     (\role state url -> { role = role, state = state, url = url })
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "role" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "state" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeTeamMembership : TeamMembership -> Json.Encode.Value
encodeTeamMembership rec =
    Json.Encode.object
        [ ( "role", Json.Encode.string rec.role )
        , ( "state", Json.Encode.string rec.state )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias TeamFull =
    { created_at : String
    , description : Nullable String
    , html_url : String
    , id : Int
    , ldap_dn : String
    , members_count : Int
    , members_url : String
    , name : String
    , node_id : String
    , organization : TeamOrganization
    , parent : Nullable TeamSimple
    , permission : String
    , privacy : String
    , repos_count : Int
    , repositories_url : String
    , slug : String
    , updated_at : String
    , url : String
    }


decodeTeamFull : Json.Decode.Decoder TeamFull
decodeTeamFull =
    Json.Decode.succeed
     (\created_at description html_url id ldap_dn members_count members_url name node_id organization parent permission privacy repos_count repositories_url slug updated_at url ->
         { created_at = created_at
         , description = description
         , html_url = html_url
         , id = id
         , ldap_dn = ldap_dn
         , members_count = members_count
         , members_url = members_url
         , name = name
         , node_id = node_id
         , organization = organization
         , parent = parent
         , permission = permission
         , privacy = privacy
         , repos_count = repos_count
         , repositories_url = repositories_url
         , slug = slug
         , updated_at = updated_at
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "description"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "ldap_dn" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "members_count" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "members_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "organization" decodeTeamOrganization)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "parent"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeTeamSimple
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "permission" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "privacy" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "repos_count" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "repositories_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "slug" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeTeamFull : TeamFull -> Json.Encode.Value
encodeTeamFull rec =
    Json.Encode.object
        [ ( "created_at", Json.Encode.string rec.created_at )
        , ( "description"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.description
          )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "id", Json.Encode.int rec.id )
        , ( "ldap_dn", Json.Encode.string rec.ldap_dn )
        , ( "members_count", Json.Encode.int rec.members_count )
        , ( "members_url", Json.Encode.string rec.members_url )
        , ( "name", Json.Encode.string rec.name )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "organization", encodeTeamOrganization rec.organization )
        , ( "parent"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeTeamSimple value
            )
                rec.parent
          )
        , ( "permission", Json.Encode.string rec.permission )
        , ( "privacy", Json.Encode.string rec.privacy )
        , ( "repos_count", Json.Encode.int rec.repos_count )
        , ( "repositories_url", Json.Encode.string rec.repositories_url )
        , ( "slug", Json.Encode.string rec.slug )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias TeamDiscussionComment =
    { author : Nullable SimpleUser
    , body : String
    , body_html : String
    , body_version : String
    , created_at : String
    , discussion_url : String
    , html_url : String
    , last_edited_at : Nullable String
    , node_id : String
    , number : Int
    , reactions : ReactionRollup
    , updated_at : String
    , url : String
    }


decodeTeamDiscussionComment : Json.Decode.Decoder TeamDiscussionComment
decodeTeamDiscussionComment =
    Json.Decode.succeed
     (\author body body_html body_version created_at discussion_url html_url last_edited_at node_id number reactions updated_at url ->
         { author = author
         , body = body
         , body_html = body_html
         , body_version = body_version
         , created_at = created_at
         , discussion_url = discussion_url
         , html_url = html_url
         , last_edited_at = last_edited_at
         , node_id = node_id
         , number = number
         , reactions = reactions
         , updated_at = updated_at
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "author"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "body" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "body_html" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "body_version" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "discussion_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "last_edited_at"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "number" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "reactions" decodeReactionRollup)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeTeamDiscussionComment : TeamDiscussionComment -> Json.Encode.Value
encodeTeamDiscussionComment rec =
    Json.Encode.object
        [ ( "author"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.author
          )
        , ( "body", Json.Encode.string rec.body )
        , ( "body_html", Json.Encode.string rec.body_html )
        , ( "body_version", Json.Encode.string rec.body_version )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "discussion_url", Json.Encode.string rec.discussion_url )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "last_edited_at"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.last_edited_at
          )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "number", Json.Encode.int rec.number )
        , ( "reactions", encodeReactionRollup rec.reactions )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias TeamDiscussion =
    { author : Nullable SimpleUser
    , body : String
    , body_html : String
    , body_version : String
    , comments_count : Int
    , comments_url : String
    , created_at : String
    , html_url : String
    , last_edited_at : Nullable String
    , node_id : String
    , number : Int
    , pinned : Bool
    , private : Bool
    , reactions : ReactionRollup
    , team_url : String
    , title : String
    , updated_at : String
    , url : String
    }


decodeTeamDiscussion : Json.Decode.Decoder TeamDiscussion
decodeTeamDiscussion =
    Json.Decode.succeed
     (\author body body_html body_version comments_count comments_url created_at html_url last_edited_at node_id number pinned private reactions team_url title updated_at url ->
         { author = author
         , body = body
         , body_html = body_html
         , body_version = body_version
         , comments_count = comments_count
         , comments_url = comments_url
         , created_at = created_at
         , html_url = html_url
         , last_edited_at = last_edited_at
         , node_id = node_id
         , number = number
         , pinned = pinned
         , private = private
         , reactions = reactions
         , team_url = team_url
         , title = title
         , updated_at = updated_at
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "author"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "body" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "body_html" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "body_version" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "comments_count" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "comments_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "last_edited_at"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "number" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "pinned" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "private" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "reactions" decodeReactionRollup)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "team_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "title" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeTeamDiscussion : TeamDiscussion -> Json.Encode.Value
encodeTeamDiscussion rec =
    Json.Encode.object
        [ ( "author"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.author
          )
        , ( "body", Json.Encode.string rec.body )
        , ( "body_html", Json.Encode.string rec.body_html )
        , ( "body_version", Json.Encode.string rec.body_version )
        , ( "comments_count", Json.Encode.int rec.comments_count )
        , ( "comments_url", Json.Encode.string rec.comments_url )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "last_edited_at"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.last_edited_at
          )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "number", Json.Encode.int rec.number )
        , ( "pinned", Json.Encode.bool rec.pinned )
        , ( "private", Json.Encode.bool rec.private )
        , ( "reactions", encodeReactionRollup rec.reactions )
        , ( "team_url", Json.Encode.string rec.team_url )
        , ( "title", Json.Encode.string rec.title )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias Team =
    { description : Nullable String
    , html_url : String
    , id : Int
    , members_url : String
    , name : String
    , node_id : String
    , parent : Nullable TeamSimple
    , permission : String
    , permissions :
        { admin : Bool
        , maintain : Bool
        , pull : Bool
        , push : Bool
        , triage : Bool
        }
    , privacy : String
    , repositories_url : String
    , slug : String
    , url : String
    }


decodeTeam : Json.Decode.Decoder Team
decodeTeam =
    Json.Decode.succeed
     (\description html_url id members_url name node_id parent permission permissions privacy repositories_url slug url ->
         { description = description
         , html_url = html_url
         , id = id
         , members_url = members_url
         , name = name
         , node_id = node_id
         , parent = parent
         , permission = permission
         , permissions = permissions
         , privacy = privacy
         , repositories_url = repositories_url
         , slug = slug
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "description"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "members_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "parent"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeTeamSimple
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "permission" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "permissions"
                (Json.Decode.succeed
                  (\admin maintain pull push triage ->
                      { admin = admin
                      , maintain = maintain
                      , pull = pull
                      , push = push
                      , triage = triage
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "admin" Json.Decode.bool)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "maintain" Json.Decode.bool)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "pull" Json.Decode.bool)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "push" Json.Decode.bool)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "triage" Json.Decode.bool)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "privacy" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "repositories_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "slug" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeTeam : Team -> Json.Encode.Value
encodeTeam rec =
    Json.Encode.object
        [ ( "description"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.description
          )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "id", Json.Encode.int rec.id )
        , ( "members_url", Json.Encode.string rec.members_url )
        , ( "name", Json.Encode.string rec.name )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "parent"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeTeamSimple value
            )
                rec.parent
          )
        , ( "permission", Json.Encode.string rec.permission )
        , ( "permissions"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "admin", Json.Encode.bool rec0.admin )
                    , ( "maintain", Json.Encode.bool rec0.maintain )
                    , ( "pull", Json.Encode.bool rec0.pull )
                    , ( "push", Json.Encode.bool rec0.push )
                    , ( "triage", Json.Encode.bool rec0.triage )
                    ]
            )
                rec.permissions
          )
        , ( "privacy", Json.Encode.string rec.privacy )
        , ( "repositories_url", Json.Encode.string rec.repositories_url )
        , ( "slug", Json.Encode.string rec.slug )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias TagProtection =
    { created_at : String
    , enabled : Bool
    , id : Int
    , pattern : String
    , updated_at : String
    }


decodeTagProtection : Json.Decode.Decoder TagProtection
decodeTagProtection =
    Json.Decode.succeed
     (\created_at enabled id pattern updated_at ->
         { created_at = created_at
         , enabled = enabled
         , id = id
         , pattern = pattern
         , updated_at = updated_at
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "enabled" Json.Decode.bool)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "pattern" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)


encodeTagProtection : TagProtection -> Json.Encode.Value
encodeTagProtection rec =
    Json.Encode.object
        [ ( "created_at", Json.Encode.string rec.created_at )
        , ( "enabled", Json.Encode.bool rec.enabled )
        , ( "id", Json.Encode.int rec.id )
        , ( "pattern", Json.Encode.string rec.pattern )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        ]


type alias Tag =
    { commit : { sha : String, url : String }
    , name : String
    , node_id : String
    , tarball_url : String
    , zipball_url : String
    }


decodeTag : Json.Decode.Decoder Tag
decodeTag =
    Json.Decode.succeed
     (\commit name node_id tarball_url zipball_url ->
         { commit = commit
         , name = name
         , node_id = node_id
         , tarball_url = tarball_url
         , zipball_url = zipball_url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "commit"
                (Json.Decode.succeed (\sha url -> { sha = sha, url = url })
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "sha" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "url" Json.Decode.string)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "tarball_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "zipball_url" Json.Decode.string)


encodeTag : Tag -> Json.Encode.Value
encodeTag rec =
    Json.Encode.object
        [ ( "commit"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "sha", Json.Encode.string rec0.sha )
                    , ( "url", Json.Encode.string rec0.url )
                    ]
            )
                rec.commit
          )
        , ( "name", Json.Encode.string rec.name )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "tarball_url", Json.Encode.string rec.tarball_url )
        , ( "zipball_url", Json.Encode.string rec.zipball_url )
        ]


type alias StatusCheckPolicy =
    { checks : List { app_id : Nullable Int, context : String }
    , contexts : List String
    , contexts_url : String
    , strict : Bool
    , url : String
    }


decodeStatusCheckPolicy : Json.Decode.Decoder StatusCheckPolicy
decodeStatusCheckPolicy =
    Json.Decode.succeed
     (\checks contexts contexts_url strict url ->
         { checks = checks
         , contexts = contexts
         , contexts_url = contexts_url
         , strict = strict
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "checks"
                (Json.Decode.list
                    (Json.Decode.succeed
                      (\app_id context -> { app_id = app_id, context = context }
                      )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field
                                "app_id"
                                (Json.Decode.oneOf
                                    [ Json.Decode.map Present Json.Decode.int
                                    , Json.Decode.null Null
                                    ]
                                )
                            )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "context" Json.Decode.string)
                    )
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "contexts" (Json.Decode.list Json.Decode.string))
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "contexts_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "strict" Json.Decode.bool)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeStatusCheckPolicy : StatusCheckPolicy -> Json.Encode.Value
encodeStatusCheckPolicy rec =
    Json.Encode.object
        [ ( "checks"
          , Json.Encode.list
                (\rec0 ->
                    Json.Encode.object
                        [ ( "app_id"
                          , (\nullableValue ->
                                case nullableValue of
                                    Null ->
                                        Json.Encode.null

                                    Present value ->
                                        Json.Encode.int value
                            )
                                rec0.app_id
                          )
                        , ( "context", Json.Encode.string rec0.context )
                        ]
                )
                rec.checks
          )
        , ( "contexts", Json.Encode.list Json.Encode.string rec.contexts )
        , ( "contexts_url", Json.Encode.string rec.contexts_url )
        , ( "strict", Json.Encode.bool rec.strict )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias Status =
    { avatar_url : Nullable String
    , context : String
    , created_at : String
    , creator : Nullable SimpleUser
    , description : Nullable String
    , id : Int
    , node_id : String
    , state : String
    , target_url : Nullable String
    , updated_at : String
    , url : String
    }


decodeStatus : Json.Decode.Decoder Status
decodeStatus =
    Json.Decode.succeed
     (\avatar_url context created_at creator description id node_id state target_url updated_at url ->
         { avatar_url = avatar_url
         , context = context
         , created_at = created_at
         , creator = creator
         , description = description
         , id = id
         , node_id = node_id
         , state = state
         , target_url = target_url
         , updated_at = updated_at
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "avatar_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "context" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "creator"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "description"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "state" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "target_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeStatus : Status -> Json.Encode.Value
encodeStatus rec =
    Json.Encode.object
        [ ( "avatar_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.avatar_url
          )
        , ( "context", Json.Encode.string rec.context )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "creator"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.creator
          )
        , ( "description"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.description
          )
        , ( "id", Json.Encode.int rec.id )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "state", Json.Encode.string rec.state )
        , ( "target_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.target_url
          )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias StateChangeIssueEvent =
    { actor : SimpleUser
    , commit_id : Nullable String
    , commit_url : Nullable String
    , created_at : String
    , event : String
    , id : Int
    , node_id : String
    , performed_via_github_app : Nullable Integration
    , state_reason : Nullable String
    , url : String
    }


decodeStateChangeIssueEvent : Json.Decode.Decoder StateChangeIssueEvent
decodeStateChangeIssueEvent =
    Json.Decode.succeed
     (\actor commit_id commit_url created_at event id node_id performed_via_github_app state_reason url ->
         { actor = actor
         , commit_id = commit_id
         , commit_url = commit_url
         , created_at = created_at
         , event = event
         , id = id
         , node_id = node_id
         , performed_via_github_app = performed_via_github_app
         , state_reason = state_reason
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap (Json.Decode.field "actor" decodeSimpleUser)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "commit_id"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "commit_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "event" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "performed_via_github_app"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeIntegration
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "state_reason"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeStateChangeIssueEvent : StateChangeIssueEvent -> Json.Encode.Value
encodeStateChangeIssueEvent rec =
    Json.Encode.object
        [ ( "actor", encodeSimpleUser rec.actor )
        , ( "commit_id"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.commit_id
          )
        , ( "commit_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.commit_url
          )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "event", Json.Encode.string rec.event )
        , ( "id", Json.Encode.int rec.id )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "performed_via_github_app"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeIntegration value
            )
                rec.performed_via_github_app
          )
        , ( "state_reason"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.state_reason
          )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias StarredRepository =
    { repo : Repository, starred_at : String }


decodeStarredRepository : Json.Decode.Decoder StarredRepository
decodeStarredRepository =
    Json.Decode.succeed
     (\repo starred_at -> { repo = repo, starred_at = starred_at })
        |> Json.Decode.Extra.andMap (Json.Decode.field "repo" decodeRepository)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "starred_at" Json.Decode.string)


encodeStarredRepository : StarredRepository -> Json.Encode.Value
encodeStarredRepository rec =
    Json.Encode.object
        [ ( "repo", encodeRepository rec.repo )
        , ( "starred_at", Json.Encode.string rec.starred_at )
        ]


type alias Stargazer =
    { starred_at : String, user : Nullable SimpleUser }


decodeStargazer : Json.Decode.Decoder Stargazer
decodeStargazer =
    Json.Decode.succeed
     (\starred_at user -> { starred_at = starred_at, user = user })
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "starred_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "user"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )


encodeStargazer : Stargazer -> Json.Encode.Value
encodeStargazer rec =
    Json.Encode.object
        [ ( "starred_at", Json.Encode.string rec.starred_at )
        , ( "user"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.user
          )
        ]


type alias SshSigningKey =
    { created_at : String, id : Int, key : String, title : String }


decodeSshSigningKey : Json.Decode.Decoder SshSigningKey
decodeSshSigningKey =
    Json.Decode.succeed
     (\created_at id key title ->
         { created_at = created_at, id = id, key = key, title = title }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap (Json.Decode.field "key" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "title" Json.Decode.string)


encodeSshSigningKey : SshSigningKey -> Json.Encode.Value
encodeSshSigningKey rec =
    Json.Encode.object
        [ ( "created_at", Json.Encode.string rec.created_at )
        , ( "id", Json.Encode.int rec.id )
        , ( "key", Json.Encode.string rec.key )
        , ( "title", Json.Encode.string rec.title )
        ]


type alias Snapshot =
    { detector : { name : String, url : String, version : String }
    , job : { correlator : String, html_url : String, id : String }
    , manifests : {}
    , metadata : Metadata
    , ref : String
    , scanned : String
    , sha : String
    , version : Int
    }


decodeSnapshot : Json.Decode.Decoder Snapshot
decodeSnapshot =
    Json.Decode.succeed
     (\detector job manifests metadata ref scanned sha version ->
         { detector = detector
         , job = job
         , manifests = manifests
         , metadata = metadata
         , ref = ref
         , scanned = scanned
         , sha = sha
         , version = version
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "detector"
                (Json.Decode.succeed
                  (\name url version ->
                      { name = name, url = url, version = version }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "name" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "url" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "version" Json.Decode.string)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "job"
                (Json.Decode.succeed
                  (\correlator html_url id ->
                      { correlator = correlator, html_url = html_url, id = id }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "correlator" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "html_url" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "id" Json.Decode.string)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "manifests" (Json.Decode.succeed {}))
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "metadata" decodeMetadata)
        |> Json.Decode.Extra.andMap (Json.Decode.field "ref" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "scanned" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "sha" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "version" Json.Decode.int)


encodeSnapshot : Snapshot -> Json.Encode.Value
encodeSnapshot rec =
    Json.Encode.object
        [ ( "detector"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "name", Json.Encode.string rec0.name )
                    , ( "url", Json.Encode.string rec0.url )
                    , ( "version", Json.Encode.string rec0.version )
                    ]
            )
                rec.detector
          )
        , ( "job"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "correlator", Json.Encode.string rec0.correlator )
                    , ( "html_url", Json.Encode.string rec0.html_url )
                    , ( "id", Json.Encode.string rec0.id )
                    ]
            )
                rec.job
          )
        , ( "manifests", (\rec0 -> Json.Encode.object []) rec.manifests )
        , ( "metadata", encodeMetadata rec.metadata )
        , ( "ref", Json.Encode.string rec.ref )
        , ( "scanned", Json.Encode.string rec.scanned )
        , ( "sha", Json.Encode.string rec.sha )
        , ( "version", Json.Encode.int rec.version )
        ]


type alias SimpleUser =
    { avatar_url : String
    , email : Nullable String
    , events_url : String
    , followers_url : String
    , following_url : String
    , gists_url : String
    , gravatar_id : Nullable String
    , html_url : String
    , id : Int
    , login : String
    , name : Nullable String
    , node_id : String
    , organizations_url : String
    , received_events_url : String
    , repos_url : String
    , site_admin : Bool
    , starred_at : String
    , starred_url : String
    , subscriptions_url : String
    , type_ : String
    , url : String
    }


decodeSimpleUser : Json.Decode.Decoder SimpleUser
decodeSimpleUser =
    Json.Decode.succeed
     (\avatar_url email events_url followers_url following_url gists_url gravatar_id html_url id login name node_id organizations_url received_events_url repos_url site_admin starred_at starred_url subscriptions_url type_ url ->
         { avatar_url = avatar_url
         , email = email
         , events_url = events_url
         , followers_url = followers_url
         , following_url = following_url
         , gists_url = gists_url
         , gravatar_id = gravatar_id
         , html_url = html_url
         , id = id
         , login = login
         , name = name
         , node_id = node_id
         , organizations_url = organizations_url
         , received_events_url = received_events_url
         , repos_url = repos_url
         , site_admin = site_admin
         , starred_at = starred_at
         , starred_url = starred_url
         , subscriptions_url = subscriptions_url
         , type_ = type_
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "avatar_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "email"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "events_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "followers_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "following_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "gists_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "gravatar_id"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "login" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "name"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "organizations_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "received_events_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "repos_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "site_admin" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "starred_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "starred_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "subscriptions_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "type" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeSimpleUser : SimpleUser -> Json.Encode.Value
encodeSimpleUser rec =
    Json.Encode.object
        [ ( "avatar_url", Json.Encode.string rec.avatar_url )
        , ( "email"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.email
          )
        , ( "events_url", Json.Encode.string rec.events_url )
        , ( "followers_url", Json.Encode.string rec.followers_url )
        , ( "following_url", Json.Encode.string rec.following_url )
        , ( "gists_url", Json.Encode.string rec.gists_url )
        , ( "gravatar_id"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.gravatar_id
          )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "id", Json.Encode.int rec.id )
        , ( "login", Json.Encode.string rec.login )
        , ( "name"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.name
          )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "organizations_url", Json.Encode.string rec.organizations_url )
        , ( "received_events_url", Json.Encode.string rec.received_events_url )
        , ( "repos_url", Json.Encode.string rec.repos_url )
        , ( "site_admin", Json.Encode.bool rec.site_admin )
        , ( "starred_at", Json.Encode.string rec.starred_at )
        , ( "starred_url", Json.Encode.string rec.starred_url )
        , ( "subscriptions_url", Json.Encode.string rec.subscriptions_url )
        , ( "type", Json.Encode.string rec.type_ )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias SimpleRepository =
    { archive_url : String
    , assignees_url : String
    , blobs_url : String
    , branches_url : String
    , collaborators_url : String
    , comments_url : String
    , commits_url : String
    , compare_url : String
    , contents_url : String
    , contributors_url : String
    , deployments_url : String
    , description : Nullable String
    , downloads_url : String
    , events_url : String
    , fork : Bool
    , forks_url : String
    , full_name : String
    , git_commits_url : String
    , git_refs_url : String
    , git_tags_url : String
    , hooks_url : String
    , html_url : String
    , id : Int
    , issue_comment_url : String
    , issue_events_url : String
    , issues_url : String
    , keys_url : String
    , labels_url : String
    , languages_url : String
    , merges_url : String
    , milestones_url : String
    , name : String
    , node_id : String
    , notifications_url : String
    , owner : SimpleUser
    , private : Bool
    , pulls_url : String
    , releases_url : String
    , stargazers_url : String
    , statuses_url : String
    , subscribers_url : String
    , subscription_url : String
    , tags_url : String
    , teams_url : String
    , trees_url : String
    , url : String
    }


decodeSimpleRepository : Json.Decode.Decoder SimpleRepository
decodeSimpleRepository =
    Json.Decode.succeed
     (\archive_url assignees_url blobs_url branches_url collaborators_url comments_url commits_url compare_url contents_url contributors_url deployments_url description downloads_url events_url fork forks_url full_name git_commits_url git_refs_url git_tags_url hooks_url html_url id issue_comment_url issue_events_url issues_url keys_url labels_url languages_url merges_url milestones_url name node_id notifications_url owner private pulls_url releases_url stargazers_url statuses_url subscribers_url subscription_url tags_url teams_url trees_url url ->
         { archive_url = archive_url
         , assignees_url = assignees_url
         , blobs_url = blobs_url
         , branches_url = branches_url
         , collaborators_url = collaborators_url
         , comments_url = comments_url
         , commits_url = commits_url
         , compare_url = compare_url
         , contents_url = contents_url
         , contributors_url = contributors_url
         , deployments_url = deployments_url
         , description = description
         , downloads_url = downloads_url
         , events_url = events_url
         , fork = fork
         , forks_url = forks_url
         , full_name = full_name
         , git_commits_url = git_commits_url
         , git_refs_url = git_refs_url
         , git_tags_url = git_tags_url
         , hooks_url = hooks_url
         , html_url = html_url
         , id = id
         , issue_comment_url = issue_comment_url
         , issue_events_url = issue_events_url
         , issues_url = issues_url
         , keys_url = keys_url
         , labels_url = labels_url
         , languages_url = languages_url
         , merges_url = merges_url
         , milestones_url = milestones_url
         , name = name
         , node_id = node_id
         , notifications_url = notifications_url
         , owner = owner
         , private = private
         , pulls_url = pulls_url
         , releases_url = releases_url
         , stargazers_url = stargazers_url
         , statuses_url = statuses_url
         , subscribers_url = subscribers_url
         , subscription_url = subscription_url
         , tags_url = tags_url
         , teams_url = teams_url
         , trees_url = trees_url
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "archive_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "assignees_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "blobs_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "branches_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "collaborators_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "comments_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "commits_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "compare_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "contents_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "contributors_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "deployments_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "description"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "downloads_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "events_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "fork" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "forks_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "full_name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "git_commits_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "git_refs_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "git_tags_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "hooks_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "issue_comment_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "issue_events_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "issues_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "keys_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "labels_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "languages_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "merges_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "milestones_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "notifications_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "owner" decodeSimpleUser)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "private" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "pulls_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "releases_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "stargazers_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "statuses_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "subscribers_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "subscription_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "tags_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "teams_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "trees_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeSimpleRepository : SimpleRepository -> Json.Encode.Value
encodeSimpleRepository rec =
    Json.Encode.object
        [ ( "archive_url", Json.Encode.string rec.archive_url )
        , ( "assignees_url", Json.Encode.string rec.assignees_url )
        , ( "blobs_url", Json.Encode.string rec.blobs_url )
        , ( "branches_url", Json.Encode.string rec.branches_url )
        , ( "collaborators_url", Json.Encode.string rec.collaborators_url )
        , ( "comments_url", Json.Encode.string rec.comments_url )
        , ( "commits_url", Json.Encode.string rec.commits_url )
        , ( "compare_url", Json.Encode.string rec.compare_url )
        , ( "contents_url", Json.Encode.string rec.contents_url )
        , ( "contributors_url", Json.Encode.string rec.contributors_url )
        , ( "deployments_url", Json.Encode.string rec.deployments_url )
        , ( "description"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.description
          )
        , ( "downloads_url", Json.Encode.string rec.downloads_url )
        , ( "events_url", Json.Encode.string rec.events_url )
        , ( "fork", Json.Encode.bool rec.fork )
        , ( "forks_url", Json.Encode.string rec.forks_url )
        , ( "full_name", Json.Encode.string rec.full_name )
        , ( "git_commits_url", Json.Encode.string rec.git_commits_url )
        , ( "git_refs_url", Json.Encode.string rec.git_refs_url )
        , ( "git_tags_url", Json.Encode.string rec.git_tags_url )
        , ( "hooks_url", Json.Encode.string rec.hooks_url )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "id", Json.Encode.int rec.id )
        , ( "issue_comment_url", Json.Encode.string rec.issue_comment_url )
        , ( "issue_events_url", Json.Encode.string rec.issue_events_url )
        , ( "issues_url", Json.Encode.string rec.issues_url )
        , ( "keys_url", Json.Encode.string rec.keys_url )
        , ( "labels_url", Json.Encode.string rec.labels_url )
        , ( "languages_url", Json.Encode.string rec.languages_url )
        , ( "merges_url", Json.Encode.string rec.merges_url )
        , ( "milestones_url", Json.Encode.string rec.milestones_url )
        , ( "name", Json.Encode.string rec.name )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "notifications_url", Json.Encode.string rec.notifications_url )
        , ( "owner", encodeSimpleUser rec.owner )
        , ( "private", Json.Encode.bool rec.private )
        , ( "pulls_url", Json.Encode.string rec.pulls_url )
        , ( "releases_url", Json.Encode.string rec.releases_url )
        , ( "stargazers_url", Json.Encode.string rec.stargazers_url )
        , ( "statuses_url", Json.Encode.string rec.statuses_url )
        , ( "subscribers_url", Json.Encode.string rec.subscribers_url )
        , ( "subscription_url", Json.Encode.string rec.subscription_url )
        , ( "tags_url", Json.Encode.string rec.tags_url )
        , ( "teams_url", Json.Encode.string rec.teams_url )
        , ( "trees_url", Json.Encode.string rec.trees_url )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias SimpleInstallation =
    { id : Int, node_id : String }


decodeSimpleInstallation : Json.Decode.Decoder SimpleInstallation
decodeSimpleInstallation =
    Json.Decode.succeed (\id node_id -> { id = id, node_id = node_id })
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)


encodeSimpleInstallation : SimpleInstallation -> Json.Encode.Value
encodeSimpleInstallation rec =
    Json.Encode.object
        [ ( "id", Json.Encode.int rec.id )
        , ( "node_id", Json.Encode.string rec.node_id )
        ]


type alias SimpleCommitStatus =
    { avatar_url : Nullable String
    , context : String
    , created_at : String
    , description : Nullable String
    , id : Int
    , node_id : String
    , required : Nullable Bool
    , state : String
    , target_url : Nullable String
    , updated_at : String
    , url : String
    }


decodeSimpleCommitStatus : Json.Decode.Decoder SimpleCommitStatus
decodeSimpleCommitStatus =
    Json.Decode.succeed
     (\avatar_url context created_at description id node_id required state target_url updated_at url ->
         { avatar_url = avatar_url
         , context = context
         , created_at = created_at
         , description = description
         , id = id
         , node_id = node_id
         , required = required
         , state = state
         , target_url = target_url
         , updated_at = updated_at
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "avatar_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "context" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "description"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "required"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.bool
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "state" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "target_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeSimpleCommitStatus : SimpleCommitStatus -> Json.Encode.Value
encodeSimpleCommitStatus rec =
    Json.Encode.object
        [ ( "avatar_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.avatar_url
          )
        , ( "context", Json.Encode.string rec.context )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "description"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.description
          )
        , ( "id", Json.Encode.int rec.id )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "required"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.bool value
            )
                rec.required
          )
        , ( "state", Json.Encode.string rec.state )
        , ( "target_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.target_url
          )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias SimpleCommit =
    { author : Nullable { email : String, name : String }
    , committer : Nullable { email : String, name : String }
    , id : String
    , message : String
    , timestamp : String
    , tree_id : String
    }


decodeSimpleCommit : Json.Decode.Decoder SimpleCommit
decodeSimpleCommit =
    Json.Decode.succeed
     (\author committer id message timestamp tree_id ->
         { author = author
         , committer = committer
         , id = id
         , message = message
         , timestamp = timestamp
         , tree_id = tree_id
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "author"
                (Json.Decode.oneOf
                    [ Json.Decode.map
                        Present
                        (Json.Decode.succeed
                          (\email name -> { email = email, name = name })
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "email" Json.Decode.string)
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "name" Json.Decode.string)
                        )
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "committer"
                (Json.Decode.oneOf
                    [ Json.Decode.map
                        Present
                        (Json.Decode.succeed
                          (\email name -> { email = email, name = name })
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "email" Json.Decode.string)
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "name" Json.Decode.string)
                        )
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "message" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "timestamp" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "tree_id" Json.Decode.string)


encodeSimpleCommit : SimpleCommit -> Json.Encode.Value
encodeSimpleCommit rec =
    Json.Encode.object
        [ ( "author"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        (\rec0 ->
                            Json.Encode.object
                                [ ( "email", Json.Encode.string rec0.email )
                                , ( "name", Json.Encode.string rec0.name )
                                ]
                        )
                            value
            )
                rec.author
          )
        , ( "committer"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        (\rec0 ->
                            Json.Encode.object
                                [ ( "email", Json.Encode.string rec0.email )
                                , ( "name", Json.Encode.string rec0.name )
                                ]
                        )
                            value
            )
                rec.committer
          )
        , ( "id", Json.Encode.string rec.id )
        , ( "message", Json.Encode.string rec.message )
        , ( "timestamp", Json.Encode.string rec.timestamp )
        , ( "tree_id", Json.Encode.string rec.tree_id )
        ]


type alias ShortBranch =
    { commit : { sha : String, url : String }
    , name : String
    , protected : Bool
    , protection : BranchProtection
    , protection_url : String
    }


decodeShortBranch : Json.Decode.Decoder ShortBranch
decodeShortBranch =
    Json.Decode.succeed
     (\commit name protected protection protection_url ->
         { commit = commit
         , name = name
         , protected = protected
         , protection = protection
         , protection_url = protection_url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "commit"
                (Json.Decode.succeed (\sha url -> { sha = sha, url = url })
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "sha" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "url" Json.Decode.string)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "protected" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "protection" decodeBranchProtection)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "protection_url" Json.Decode.string)


encodeShortBranch : ShortBranch -> Json.Encode.Value
encodeShortBranch rec =
    Json.Encode.object
        [ ( "commit"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "sha", Json.Encode.string rec0.sha )
                    , ( "url", Json.Encode.string rec0.url )
                    ]
            )
                rec.commit
          )
        , ( "name", Json.Encode.string rec.name )
        , ( "protected", Json.Encode.bool rec.protected )
        , ( "protection", encodeBranchProtection rec.protection )
        , ( "protection_url", Json.Encode.string rec.protection_url )
        ]


type alias ShortBlob =
    { sha : String, url : String }


decodeShortBlob : Json.Decode.Decoder ShortBlob
decodeShortBlob =
    Json.Decode.succeed (\sha url -> { sha = sha, url = url })
        |> Json.Decode.Extra.andMap (Json.Decode.field "sha" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeShortBlob : ShortBlob -> Json.Encode.Value
encodeShortBlob rec =
    Json.Encode.object
        [ ( "sha", Json.Encode.string rec.sha )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias ServerStatistics =
    List { collection_date : String
    , dormant_users : { dormancy_threshold : String, total_dormant_users : Int }
    , ghe_stats :
        { comments :
            { total_commit_comments : Int
            , total_gist_comments : Int
            , total_issue_comments : Int
            , total_pull_request_comments : Int
            }
        , gists : { private_gists : Int, public_gists : Int, total_gists : Int }
        , hooks :
            { active_hooks : Int, inactive_hooks : Int, total_hooks : Int }
        , issues :
            { closed_issues : Int, open_issues : Int, total_issues : Int }
        , milestones :
            { closed_milestones : Int
            , open_milestones : Int
            , total_milestones : Int
            }
        , orgs :
            { disabled_orgs : Int
            , total_orgs : Int
            , total_team_members : Int
            , total_teams : Int
            }
        , pages : { total_pages : Int }
        , pulls :
            { mergeable_pulls : Int
            , merged_pulls : Int
            , total_pulls : Int
            , unmergeable_pulls : Int
            }
        , repos :
            { fork_repos : Int
            , org_repos : Int
            , root_repos : Int
            , total_pushes : Int
            , total_repos : Int
            , total_wikis : Int
            }
        , users :
            { admin_users : Int, suspended_users : Int, total_users : Int }
        }
    , ghes_version : String
    , github_connect : { features_enabled : List String }
    , host_name : String
    , schema_version : String
    , server_id : String
    }


decodeServerStatistics : Json.Decode.Decoder ServerStatistics
decodeServerStatistics =
    Json.Decode.list
        (Json.Decode.succeed
          (\collection_date dormant_users ghe_stats ghes_version github_connect host_name schema_version server_id ->
              { collection_date = collection_date
              , dormant_users = dormant_users
              , ghe_stats = ghe_stats
              , ghes_version = ghes_version
              , github_connect = github_connect
              , host_name = host_name
              , schema_version = schema_version
              , server_id = server_id
              }
          )
            |> Json.Decode.Extra.andMap
                (Json.Decode.field "collection_date" Json.Decode.string)
            |> Json.Decode.Extra.andMap
                (Json.Decode.field
                    "dormant_users"
                    (Json.Decode.succeed
                      (\dormancy_threshold total_dormant_users ->
                          { dormancy_threshold = dormancy_threshold
                          , total_dormant_users = total_dormant_users
                          }
                      )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field
                                "dormancy_threshold"
                                Json.Decode.string
                            )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field
                                "total_dormant_users"
                                Json.Decode.int
                            )
                    )
                )
            |> Json.Decode.Extra.andMap
                (Json.Decode.field
                    "ghe_stats"
                    (Json.Decode.succeed
                      (\comments gists hooks issues milestones orgs pages pulls repos users ->
                          { comments = comments
                          , gists = gists
                          , hooks = hooks
                          , issues = issues
                          , milestones = milestones
                          , orgs = orgs
                          , pages = pages
                          , pulls = pulls
                          , repos = repos
                          , users = users
                          }
                      )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field
                                "comments"
                                (Json.Decode.succeed
                                  (\total_commit_comments total_gist_comments total_issue_comments total_pull_request_comments ->
                                      { total_commit_comments =
                                          total_commit_comments
                                      , total_gist_comments =
                                          total_gist_comments
                                      , total_issue_comments =
                                          total_issue_comments
                                      , total_pull_request_comments =
                                          total_pull_request_comments
                                      }
                                  )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "total_commit_comments"
                                            Json.Decode.int
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "total_gist_comments"
                                            Json.Decode.int
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "total_issue_comments"
                                            Json.Decode.int
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "total_pull_request_comments"
                                            Json.Decode.int
                                        )
                                )
                            )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field
                                "gists"
                                (Json.Decode.succeed
                                  (\private_gists public_gists total_gists ->
                                      { private_gists = private_gists
                                      , public_gists = public_gists
                                      , total_gists = total_gists
                                      }
                                  )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "private_gists"
                                            Json.Decode.int
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "public_gists"
                                            Json.Decode.int
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "total_gists"
                                            Json.Decode.int
                                        )
                                )
                            )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field
                                "hooks"
                                (Json.Decode.succeed
                                  (\active_hooks inactive_hooks total_hooks ->
                                      { active_hooks = active_hooks
                                      , inactive_hooks = inactive_hooks
                                      , total_hooks = total_hooks
                                      }
                                  )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "active_hooks"
                                            Json.Decode.int
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "inactive_hooks"
                                            Json.Decode.int
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "total_hooks"
                                            Json.Decode.int
                                        )
                                )
                            )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field
                                "issues"
                                (Json.Decode.succeed
                                  (\closed_issues open_issues total_issues ->
                                      { closed_issues = closed_issues
                                      , open_issues = open_issues
                                      , total_issues = total_issues
                                      }
                                  )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "closed_issues"
                                            Json.Decode.int
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "open_issues"
                                            Json.Decode.int
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "total_issues"
                                            Json.Decode.int
                                        )
                                )
                            )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field
                                "milestones"
                                (Json.Decode.succeed
                                  (\closed_milestones open_milestones total_milestones ->
                                      { closed_milestones = closed_milestones
                                      , open_milestones = open_milestones
                                      , total_milestones = total_milestones
                                      }
                                  )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "closed_milestones"
                                            Json.Decode.int
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "open_milestones"
                                            Json.Decode.int
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "total_milestones"
                                            Json.Decode.int
                                        )
                                )
                            )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field
                                "orgs"
                                (Json.Decode.succeed
                                  (\disabled_orgs total_orgs total_team_members total_teams ->
                                      { disabled_orgs = disabled_orgs
                                      , total_orgs = total_orgs
                                      , total_team_members = total_team_members
                                      , total_teams = total_teams
                                      }
                                  )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "disabled_orgs"
                                            Json.Decode.int
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "total_orgs"
                                            Json.Decode.int
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "total_team_members"
                                            Json.Decode.int
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "total_teams"
                                            Json.Decode.int
                                        )
                                )
                            )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field
                                "pages"
                                (Json.Decode.succeed
                                    (\total_pages ->
                                        { total_pages = total_pages }
                                    )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "total_pages"
                                            Json.Decode.int
                                        )
                                )
                            )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field
                                "pulls"
                                (Json.Decode.succeed
                                  (\mergeable_pulls merged_pulls total_pulls unmergeable_pulls ->
                                      { mergeable_pulls = mergeable_pulls
                                      , merged_pulls = merged_pulls
                                      , total_pulls = total_pulls
                                      , unmergeable_pulls = unmergeable_pulls
                                      }
                                  )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "mergeable_pulls"
                                            Json.Decode.int
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "merged_pulls"
                                            Json.Decode.int
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "total_pulls"
                                            Json.Decode.int
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "unmergeable_pulls"
                                            Json.Decode.int
                                        )
                                )
                            )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field
                                "repos"
                                (Json.Decode.succeed
                                  (\fork_repos org_repos root_repos total_pushes total_repos total_wikis ->
                                      { fork_repos = fork_repos
                                      , org_repos = org_repos
                                      , root_repos = root_repos
                                      , total_pushes = total_pushes
                                      , total_repos = total_repos
                                      , total_wikis = total_wikis
                                      }
                                  )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "fork_repos"
                                            Json.Decode.int
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "org_repos"
                                            Json.Decode.int
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "root_repos"
                                            Json.Decode.int
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "total_pushes"
                                            Json.Decode.int
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "total_repos"
                                            Json.Decode.int
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "total_wikis"
                                            Json.Decode.int
                                        )
                                )
                            )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field
                                "users"
                                (Json.Decode.succeed
                                  (\admin_users suspended_users total_users ->
                                      { admin_users = admin_users
                                      , suspended_users = suspended_users
                                      , total_users = total_users
                                      }
                                  )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "admin_users"
                                            Json.Decode.int
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "suspended_users"
                                            Json.Decode.int
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "total_users"
                                            Json.Decode.int
                                        )
                                )
                            )
                    )
                )
            |> Json.Decode.Extra.andMap
                (Json.Decode.field "ghes_version" Json.Decode.string)
            |> Json.Decode.Extra.andMap
                (Json.Decode.field
                    "github_connect"
                    (Json.Decode.succeed
                        (\features_enabled ->
                            { features_enabled = features_enabled }
                        )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field
                                "features_enabled"
                                (Json.Decode.list Json.Decode.string)
                            )
                    )
                )
            |> Json.Decode.Extra.andMap
                (Json.Decode.field "host_name" Json.Decode.string)
            |> Json.Decode.Extra.andMap
                (Json.Decode.field "schema_version" Json.Decode.string)
            |> Json.Decode.Extra.andMap
                (Json.Decode.field "server_id" Json.Decode.string)
        )


encodeServerStatistics : ServerStatistics -> Json.Encode.Value
encodeServerStatistics =
    Json.Encode.list
        (\rec ->
            Json.Encode.object
                [ ( "collection_date", Json.Encode.string rec.collection_date )
                , ( "dormant_users"
                  , (\rec0 ->
                        Json.Encode.object
                            [ ( "dormancy_threshold"
                              , Json.Encode.string rec0.dormancy_threshold
                              )
                            , ( "total_dormant_users"
                              , Json.Encode.int rec0.total_dormant_users
                              )
                            ]
                    )
                        rec.dormant_users
                  )
                , ( "ghe_stats"
                  , (\rec0 ->
                        Json.Encode.object
                            [ ( "comments"
                              , (\rec_0_1_1_1_0_3_1_0_1_0 ->
                                    Json.Encode.object
                                        [ ( "total_commit_comments"
                                          , Json.Encode.int
                                                rec_0_1_1_1_0_3_1_0_1_0.total_commit_comments
                                          )
                                        , ( "total_gist_comments"
                                          , Json.Encode.int
                                                rec_0_1_1_1_0_3_1_0_1_0.total_gist_comments
                                          )
                                        , ( "total_issue_comments"
                                          , Json.Encode.int
                                                rec_0_1_1_1_0_3_1_0_1_0.total_issue_comments
                                          )
                                        , ( "total_pull_request_comments"
                                          , Json.Encode.int
                                                rec_0_1_1_1_0_3_1_0_1_0.total_pull_request_comments
                                          )
                                        ]
                                )
                                    rec0.comments
                              )
                            , ( "gists"
                              , (\rec_0_2_1_1_0_3_1_0_1_0 ->
                                    Json.Encode.object
                                        [ ( "private_gists"
                                          , Json.Encode.int
                                                rec_0_2_1_1_0_3_1_0_1_0.private_gists
                                          )
                                        , ( "public_gists"
                                          , Json.Encode.int
                                                rec_0_2_1_1_0_3_1_0_1_0.public_gists
                                          )
                                        , ( "total_gists"
                                          , Json.Encode.int
                                                rec_0_2_1_1_0_3_1_0_1_0.total_gists
                                          )
                                        ]
                                )
                                    rec0.gists
                              )
                            , ( "hooks"
                              , (\rec_0_3_1_1_0_3_1_0_1_0 ->
                                    Json.Encode.object
                                        [ ( "active_hooks"
                                          , Json.Encode.int
                                                rec_0_3_1_1_0_3_1_0_1_0.active_hooks
                                          )
                                        , ( "inactive_hooks"
                                          , Json.Encode.int
                                                rec_0_3_1_1_0_3_1_0_1_0.inactive_hooks
                                          )
                                        , ( "total_hooks"
                                          , Json.Encode.int
                                                rec_0_3_1_1_0_3_1_0_1_0.total_hooks
                                          )
                                        ]
                                )
                                    rec0.hooks
                              )
                            , ( "issues"
                              , (\rec_0_4_1_1_0_3_1_0_1_0 ->
                                    Json.Encode.object
                                        [ ( "closed_issues"
                                          , Json.Encode.int
                                                rec_0_4_1_1_0_3_1_0_1_0.closed_issues
                                          )
                                        , ( "open_issues"
                                          , Json.Encode.int
                                                rec_0_4_1_1_0_3_1_0_1_0.open_issues
                                          )
                                        , ( "total_issues"
                                          , Json.Encode.int
                                                rec_0_4_1_1_0_3_1_0_1_0.total_issues
                                          )
                                        ]
                                )
                                    rec0.issues
                              )
                            , ( "milestones"
                              , (\rec_0_5_1_1_0_3_1_0_1_0 ->
                                    Json.Encode.object
                                        [ ( "closed_milestones"
                                          , Json.Encode.int
                                                rec_0_5_1_1_0_3_1_0_1_0.closed_milestones
                                          )
                                        , ( "open_milestones"
                                          , Json.Encode.int
                                                rec_0_5_1_1_0_3_1_0_1_0.open_milestones
                                          )
                                        , ( "total_milestones"
                                          , Json.Encode.int
                                                rec_0_5_1_1_0_3_1_0_1_0.total_milestones
                                          )
                                        ]
                                )
                                    rec0.milestones
                              )
                            , ( "orgs"
                              , (\rec_0_6_1_1_0_3_1_0_1_0 ->
                                    Json.Encode.object
                                        [ ( "disabled_orgs"
                                          , Json.Encode.int
                                                rec_0_6_1_1_0_3_1_0_1_0.disabled_orgs
                                          )
                                        , ( "total_orgs"
                                          , Json.Encode.int
                                                rec_0_6_1_1_0_3_1_0_1_0.total_orgs
                                          )
                                        , ( "total_team_members"
                                          , Json.Encode.int
                                                rec_0_6_1_1_0_3_1_0_1_0.total_team_members
                                          )
                                        , ( "total_teams"
                                          , Json.Encode.int
                                                rec_0_6_1_1_0_3_1_0_1_0.total_teams
                                          )
                                        ]
                                )
                                    rec0.orgs
                              )
                            , ( "pages"
                              , (\rec_0_7_1_1_0_3_1_0_1_0 ->
                                    Json.Encode.object
                                        [ ( "total_pages"
                                          , Json.Encode.int
                                                rec_0_7_1_1_0_3_1_0_1_0.total_pages
                                          )
                                        ]
                                )
                                    rec0.pages
                              )
                            , ( "pulls"
                              , (\rec_0_8_1_1_0_3_1_0_1_0 ->
                                    Json.Encode.object
                                        [ ( "mergeable_pulls"
                                          , Json.Encode.int
                                                rec_0_8_1_1_0_3_1_0_1_0.mergeable_pulls
                                          )
                                        , ( "merged_pulls"
                                          , Json.Encode.int
                                                rec_0_8_1_1_0_3_1_0_1_0.merged_pulls
                                          )
                                        , ( "total_pulls"
                                          , Json.Encode.int
                                                rec_0_8_1_1_0_3_1_0_1_0.total_pulls
                                          )
                                        , ( "unmergeable_pulls"
                                          , Json.Encode.int
                                                rec_0_8_1_1_0_3_1_0_1_0.unmergeable_pulls
                                          )
                                        ]
                                )
                                    rec0.pulls
                              )
                            , ( "repos"
                              , (\rec_0_9_1_1_0_3_1_0_1_0 ->
                                    Json.Encode.object
                                        [ ( "fork_repos"
                                          , Json.Encode.int
                                                rec_0_9_1_1_0_3_1_0_1_0.fork_repos
                                          )
                                        , ( "org_repos"
                                          , Json.Encode.int
                                                rec_0_9_1_1_0_3_1_0_1_0.org_repos
                                          )
                                        , ( "root_repos"
                                          , Json.Encode.int
                                                rec_0_9_1_1_0_3_1_0_1_0.root_repos
                                          )
                                        , ( "total_pushes"
                                          , Json.Encode.int
                                                rec_0_9_1_1_0_3_1_0_1_0.total_pushes
                                          )
                                        , ( "total_repos"
                                          , Json.Encode.int
                                                rec_0_9_1_1_0_3_1_0_1_0.total_repos
                                          )
                                        , ( "total_wikis"
                                          , Json.Encode.int
                                                rec_0_9_1_1_0_3_1_0_1_0.total_wikis
                                          )
                                        ]
                                )
                                    rec0.repos
                              )
                            , ( "users"
                              , (\rec_0_10_1_1_0_3_1_0_1_0 ->
                                    Json.Encode.object
                                        [ ( "admin_users"
                                          , Json.Encode.int
                                                rec_0_10_1_1_0_3_1_0_1_0.admin_users
                                          )
                                        , ( "suspended_users"
                                          , Json.Encode.int
                                                rec_0_10_1_1_0_3_1_0_1_0.suspended_users
                                          )
                                        , ( "total_users"
                                          , Json.Encode.int
                                                rec_0_10_1_1_0_3_1_0_1_0.total_users
                                          )
                                        ]
                                )
                                    rec0.users
                              )
                            ]
                    )
                        rec.ghe_stats
                  )
                , ( "ghes_version", Json.Encode.string rec.ghes_version )
                , ( "github_connect"
                  , (\rec0 ->
                        Json.Encode.object
                            [ ( "features_enabled"
                              , Json.Encode.list Json.Encode.string
                                    rec0.features_enabled
                              )
                            ]
                    )
                        rec.github_connect
                  )
                , ( "host_name", Json.Encode.string rec.host_name )
                , ( "schema_version", Json.Encode.string rec.schema_version )
                , ( "server_id", Json.Encode.string rec.server_id )
                ]
        )


type alias SelectedActionsUrl =
    String


decodeSelectedActionsUrl : Json.Decode.Decoder SelectedActionsUrl
decodeSelectedActionsUrl =
    Json.Decode.string


encodeSelectedActionsUrl : SelectedActionsUrl -> Json.Encode.Value
encodeSelectedActionsUrl =
    Json.Encode.string


type alias SelectedActions =
    { github_owned_allowed : Bool
    , patterns_allowed : List String
    , verified_allowed : Bool
    }


decodeSelectedActions : Json.Decode.Decoder SelectedActions
decodeSelectedActions =
    Json.Decode.succeed
     (\github_owned_allowed patterns_allowed verified_allowed ->
         { github_owned_allowed = github_owned_allowed
         , patterns_allowed = patterns_allowed
         , verified_allowed = verified_allowed
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "github_owned_allowed" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "patterns_allowed"
                (Json.Decode.list Json.Decode.string)
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "verified_allowed" Json.Decode.bool)


encodeSelectedActions : SelectedActions -> Json.Encode.Value
encodeSelectedActions rec =
    Json.Encode.object
        [ ( "github_owned_allowed", Json.Encode.bool rec.github_owned_allowed )
        , ( "patterns_allowed"
          , Json.Encode.list Json.Encode.string rec.patterns_allowed
          )
        , ( "verified_allowed", Json.Encode.bool rec.verified_allowed )
        ]


type alias SecurityAndAnalysis =
    Nullable { advanced_security : { status : String }
    , secret_scanning : { status : String }
    , secret_scanning_push_protection : { status : String }
    }


decodeSecurityAndAnalysis : Json.Decode.Decoder SecurityAndAnalysis
decodeSecurityAndAnalysis =
    Json.Decode.oneOf
        [ Json.Decode.map
            Present
            (Json.Decode.succeed
              (\advanced_security secret_scanning secret_scanning_push_protection ->
                  { advanced_security = advanced_security
                  , secret_scanning = secret_scanning
                  , secret_scanning_push_protection =
                      secret_scanning_push_protection
                  }
              )
                |> Json.Decode.Extra.andMap
                    (Json.Decode.field
                        "advanced_security"
                        (Json.Decode.succeed (\status -> { status = status })
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "status" Json.Decode.string)
                        )
                    )
                |> Json.Decode.Extra.andMap
                    (Json.Decode.field
                        "secret_scanning"
                        (Json.Decode.succeed (\status -> { status = status })
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "status" Json.Decode.string)
                        )
                    )
                |> Json.Decode.Extra.andMap
                    (Json.Decode.field
                        "secret_scanning_push_protection"
                        (Json.Decode.succeed (\status -> { status = status })
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "status" Json.Decode.string)
                        )
                    )
            )
        , Json.Decode.null Null
        ]


encodeSecurityAndAnalysis : SecurityAndAnalysis -> Json.Encode.Value
encodeSecurityAndAnalysis nullableValue =
    case nullableValue of
        Null ->
            Json.Encode.null

        Present value ->
            (\rec ->
                Json.Encode.object
                    [ ( "advanced_security"
                      , (\rec0 ->
                            Json.Encode.object
                                [ ( "status", Json.Encode.string rec0.status ) ]
                        )
                            rec.advanced_security
                      )
                    , ( "secret_scanning"
                      , (\rec0 ->
                            Json.Encode.object
                                [ ( "status", Json.Encode.string rec0.status ) ]
                        )
                            rec.secret_scanning
                      )
                    , ( "secret_scanning_push_protection"
                      , (\rec0 ->
                            Json.Encode.object
                                [ ( "status", Json.Encode.string rec0.status ) ]
                        )
                            rec.secret_scanning_push_protection
                      )
                    ]
            )
                value


type alias SecretScanningLocationCommit =
    { blob_sha : String
    , blob_url : String
    , commit_sha : String
    , commit_url : String
    , end_column : Float
    , end_line : Float
    , path : String
    , start_column : Float
    , start_line : Float
    }


decodeSecretScanningLocationCommit :
    Json.Decode.Decoder SecretScanningLocationCommit
decodeSecretScanningLocationCommit =
    Json.Decode.succeed
     (\blob_sha blob_url commit_sha commit_url end_column end_line path start_column start_line ->
         { blob_sha = blob_sha
         , blob_url = blob_url
         , commit_sha = commit_sha
         , commit_url = commit_url
         , end_column = end_column
         , end_line = end_line
         , path = path
         , start_column = start_column
         , start_line = start_line
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "blob_sha" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "blob_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "commit_sha" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "commit_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "end_column" Json.Decode.float)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "end_line" Json.Decode.float)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "path" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "start_column" Json.Decode.float)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "start_line" Json.Decode.float)


encodeSecretScanningLocationCommit :
    SecretScanningLocationCommit -> Json.Encode.Value
encodeSecretScanningLocationCommit rec =
    Json.Encode.object
        [ ( "blob_sha", Json.Encode.string rec.blob_sha )
        , ( "blob_url", Json.Encode.string rec.blob_url )
        , ( "commit_sha", Json.Encode.string rec.commit_sha )
        , ( "commit_url", Json.Encode.string rec.commit_url )
        , ( "end_column", Json.Encode.float rec.end_column )
        , ( "end_line", Json.Encode.float rec.end_line )
        , ( "path", Json.Encode.string rec.path )
        , ( "start_column", Json.Encode.float rec.start_column )
        , ( "start_line", Json.Encode.float rec.start_line )
        ]


type alias SecretScanningLocation =
    { details : Json.Encode.Value, type_ : String }


decodeSecretScanningLocation : Json.Decode.Decoder SecretScanningLocation
decodeSecretScanningLocation =
    Json.Decode.succeed (\details type_ -> { details = details, type_ = type_ })
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "details" Json.Decode.value)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "type" Json.Decode.string)


encodeSecretScanningLocation : SecretScanningLocation -> Json.Encode.Value
encodeSecretScanningLocation rec =
    Json.Encode.object
        [ ( "details", Basics.identity rec.details )
        , ( "type", Json.Encode.string rec.type_ )
        ]


type alias SecretScanningAlertState =
    String


decodeSecretScanningAlertState : Json.Decode.Decoder SecretScanningAlertState
decodeSecretScanningAlertState =
    Json.Decode.string


encodeSecretScanningAlertState : SecretScanningAlertState -> Json.Encode.Value
encodeSecretScanningAlertState =
    Json.Encode.string


type alias SecretScanningAlertResolutionComment =
    Nullable String


decodeSecretScanningAlertResolutionComment :
    Json.Decode.Decoder SecretScanningAlertResolutionComment
decodeSecretScanningAlertResolutionComment =
    Json.Decode.oneOf
        [ Json.Decode.map Present Json.Decode.string, Json.Decode.null Null ]


encodeSecretScanningAlertResolutionComment :
    SecretScanningAlertResolutionComment -> Json.Encode.Value
encodeSecretScanningAlertResolutionComment nullableValue =
    case nullableValue of
        Null ->
            Json.Encode.null

        Present value ->
            Json.Encode.string value


type alias SecretScanningAlertResolution =
    Nullable String


decodeSecretScanningAlertResolution :
    Json.Decode.Decoder SecretScanningAlertResolution
decodeSecretScanningAlertResolution =
    Json.Decode.oneOf
        [ Json.Decode.map Present Json.Decode.string, Json.Decode.null Null ]


encodeSecretScanningAlertResolution :
    SecretScanningAlertResolution -> Json.Encode.Value
encodeSecretScanningAlertResolution nullableValue =
    case nullableValue of
        Null ->
            Json.Encode.null

        Present value ->
            Json.Encode.string value


type alias SecretScanningAlert =
    { created_at : AlertCreatedAt
    , html_url : AlertHtmlUrl
    , locations_url : String
    , number : AlertNumber
    , push_protection_bypassed : Nullable Bool
    , push_protection_bypassed_at : Nullable String
    , push_protection_bypassed_by : Nullable SimpleUser
    , resolution : SecretScanningAlertResolution
    , resolution_comment : Nullable String
    , resolved_at : Nullable String
    , resolved_by : Nullable SimpleUser
    , secret : String
    , secret_type : String
    , secret_type_display_name : String
    , state : SecretScanningAlertState
    , updated_at : AlertUpdatedAt
    , url : AlertUrl
    }


decodeSecretScanningAlert : Json.Decode.Decoder SecretScanningAlert
decodeSecretScanningAlert =
    Json.Decode.succeed
     (\created_at html_url locations_url number push_protection_bypassed push_protection_bypassed_at push_protection_bypassed_by resolution resolution_comment resolved_at resolved_by secret secret_type secret_type_display_name state updated_at url ->
         { created_at = created_at
         , html_url = html_url
         , locations_url = locations_url
         , number = number
         , push_protection_bypassed = push_protection_bypassed
         , push_protection_bypassed_at = push_protection_bypassed_at
         , push_protection_bypassed_by = push_protection_bypassed_by
         , resolution = resolution
         , resolution_comment = resolution_comment
         , resolved_at = resolved_at
         , resolved_by = resolved_by
         , secret = secret
         , secret_type = secret_type
         , secret_type_display_name = secret_type_display_name
         , state = state
         , updated_at = updated_at
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" decodeAlertCreatedAt)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" decodeAlertHtmlUrl)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "locations_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "number" decodeAlertNumber)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "push_protection_bypassed"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.bool
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "push_protection_bypassed_at"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "push_protection_bypassed_by"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "resolution" decodeSecretScanningAlertResolution)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "resolution_comment"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "resolved_at"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "resolved_by"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "secret" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "secret_type" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "secret_type_display_name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "state" decodeSecretScanningAlertState)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" decodeAlertUpdatedAt)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" decodeAlertUrl)


encodeSecretScanningAlert : SecretScanningAlert -> Json.Encode.Value
encodeSecretScanningAlert rec =
    Json.Encode.object
        [ ( "created_at", encodeAlertCreatedAt rec.created_at )
        , ( "html_url", encodeAlertHtmlUrl rec.html_url )
        , ( "locations_url", Json.Encode.string rec.locations_url )
        , ( "number", encodeAlertNumber rec.number )
        , ( "push_protection_bypassed"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.bool value
            )
                rec.push_protection_bypassed
          )
        , ( "push_protection_bypassed_at"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.push_protection_bypassed_at
          )
        , ( "push_protection_bypassed_by"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.push_protection_bypassed_by
          )
        , ( "resolution", encodeSecretScanningAlertResolution rec.resolution )
        , ( "resolution_comment"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.resolution_comment
          )
        , ( "resolved_at"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.resolved_at
          )
        , ( "resolved_by"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.resolved_by
          )
        , ( "secret", Json.Encode.string rec.secret )
        , ( "secret_type", Json.Encode.string rec.secret_type )
        , ( "secret_type_display_name"
          , Json.Encode.string rec.secret_type_display_name
          )
        , ( "state", encodeSecretScanningAlertState rec.state )
        , ( "updated_at", encodeAlertUpdatedAt rec.updated_at )
        , ( "url", encodeAlertUrl rec.url )
        ]


type alias SearchResultTextMatches =
    List { fragment : String
    , matches : List { indices : List Int, text : String }
    , object_type : Nullable String
    , object_url : String
    , property : String
    }


decodeSearchResultTextMatches : Json.Decode.Decoder SearchResultTextMatches
decodeSearchResultTextMatches =
    Json.Decode.list
        (Json.Decode.succeed
          (\fragment matches object_type object_url property ->
              { fragment = fragment
              , matches = matches
              , object_type = object_type
              , object_url = object_url
              , property = property
              }
          )
            |> Json.Decode.Extra.andMap
                (Json.Decode.field "fragment" Json.Decode.string)
            |> Json.Decode.Extra.andMap
                (Json.Decode.field
                    "matches"
                    (Json.Decode.list
                        (Json.Decode.succeed
                          (\indices text -> { indices = indices, text = text })
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "indices"
                                    (Json.Decode.list Json.Decode.int)
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "text" Json.Decode.string)
                        )
                    )
                )
            |> Json.Decode.Extra.andMap
                (Json.Decode.field
                    "object_type"
                    (Json.Decode.oneOf
                        [ Json.Decode.map Present Json.Decode.string
                        , Json.Decode.null Null
                        ]
                    )
                )
            |> Json.Decode.Extra.andMap
                (Json.Decode.field "object_url" Json.Decode.string)
            |> Json.Decode.Extra.andMap
                (Json.Decode.field "property" Json.Decode.string)
        )


encodeSearchResultTextMatches : SearchResultTextMatches -> Json.Encode.Value
encodeSearchResultTextMatches =
    Json.Encode.list
        (\rec ->
            Json.Encode.object
                [ ( "fragment", Json.Encode.string rec.fragment )
                , ( "matches"
                  , Json.Encode.list
                        (\rec0 ->
                            Json.Encode.object
                                [ ( "indices"
                                  , Json.Encode.list Json.Encode.int
                                        rec0.indices
                                  )
                                , ( "text", Json.Encode.string rec0.text )
                                ]
                        )
                        rec.matches
                  )
                , ( "object_type"
                  , (\nullableValue ->
                        case nullableValue of
                            Null ->
                                Json.Encode.null

                            Present value ->
                                Json.Encode.string value
                    )
                        rec.object_type
                  )
                , ( "object_url", Json.Encode.string rec.object_url )
                , ( "property", Json.Encode.string rec.property )
                ]
        )


type alias ScopedInstallation =
    { account : SimpleUser
    , has_multiple_single_files : Bool
    , permissions : AppPermissions
    , repositories_url : String
    , repository_selection : String
    , single_file_name : Nullable String
    , single_file_paths : List String
    }


decodeScopedInstallation : Json.Decode.Decoder ScopedInstallation
decodeScopedInstallation =
    Json.Decode.succeed
     (\account has_multiple_single_files permissions repositories_url repository_selection single_file_name single_file_paths ->
         { account = account
         , has_multiple_single_files = has_multiple_single_files
         , permissions = permissions
         , repositories_url = repositories_url
         , repository_selection = repository_selection
         , single_file_name = single_file_name
         , single_file_paths = single_file_paths
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "account" decodeSimpleUser)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "has_multiple_single_files" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "permissions" decodeAppPermissions)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "repositories_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "repository_selection" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "single_file_name"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "single_file_paths"
                (Json.Decode.list Json.Decode.string)
            )


encodeScopedInstallation : ScopedInstallation -> Json.Encode.Value
encodeScopedInstallation rec =
    Json.Encode.object
        [ ( "account", encodeSimpleUser rec.account )
        , ( "has_multiple_single_files"
          , Json.Encode.bool rec.has_multiple_single_files
          )
        , ( "permissions", encodeAppPermissions rec.permissions )
        , ( "repositories_url", Json.Encode.string rec.repositories_url )
        , ( "repository_selection"
          , Json.Encode.string rec.repository_selection
          )
        , ( "single_file_name"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.single_file_name
          )
        , ( "single_file_paths"
          , Json.Encode.list Json.Encode.string rec.single_file_paths
          )
        ]


type alias ScimError =
    { detail : Nullable String
    , documentation_url : Nullable String
    , message : Nullable String
    , schemas : List String
    , scimType : Nullable String
    , status : Int
    }


decodeScimError : Json.Decode.Decoder ScimError
decodeScimError =
    Json.Decode.succeed
     (\detail documentation_url message schemas scimType status ->
         { detail = detail
         , documentation_url = documentation_url
         , message = message
         , schemas = schemas
         , scimType = scimType
         , status = status
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "detail"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "documentation_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "message"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "schemas" (Json.Decode.list Json.Decode.string))
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "scimType"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "status" Json.Decode.int)


encodeScimError : ScimError -> Json.Encode.Value
encodeScimError rec =
    Json.Encode.object
        [ ( "detail"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.detail
          )
        , ( "documentation_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.documentation_url
          )
        , ( "message"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.message
          )
        , ( "schemas", Json.Encode.list Json.Encode.string rec.schemas )
        , ( "scimType"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.scimType
          )
        , ( "status", Json.Encode.int rec.status )
        ]


type alias RunnerLabel =
    { id : Int, name : String, type_ : String }


decodeRunnerLabel : Json.Decode.Decoder RunnerLabel
decodeRunnerLabel =
    Json.Decode.succeed
     (\id name type_ -> { id = id, name = name, type_ = type_ })
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "type" Json.Decode.string)


encodeRunnerLabel : RunnerLabel -> Json.Encode.Value
encodeRunnerLabel rec =
    Json.Encode.object
        [ ( "id", Json.Encode.int rec.id )
        , ( "name", Json.Encode.string rec.name )
        , ( "type", Json.Encode.string rec.type_ )
        ]


type alias RunnerGroupsOrg =
    { allows_public_repositories : Bool
    , default : Bool
    , id : Float
    , inherited : Bool
    , inherited_allows_public_repositories : Bool
    , name : String
    , restricted_to_workflows : Bool
    , runners_url : String
    , selected_repositories_url : String
    , selected_workflows : List String
    , visibility : String
    , workflow_restrictions_read_only : Bool
    }


decodeRunnerGroupsOrg : Json.Decode.Decoder RunnerGroupsOrg
decodeRunnerGroupsOrg =
    Json.Decode.succeed
     (\allows_public_repositories default id inherited inherited_allows_public_repositories name restricted_to_workflows runners_url selected_repositories_url selected_workflows visibility workflow_restrictions_read_only ->
         { allows_public_repositories = allows_public_repositories
         , default = default
         , id = id
         , inherited = inherited
         , inherited_allows_public_repositories =
             inherited_allows_public_repositories
         , name = name
         , restricted_to_workflows = restricted_to_workflows
         , runners_url = runners_url
         , selected_repositories_url = selected_repositories_url
         , selected_workflows = selected_workflows
         , visibility = visibility
         , workflow_restrictions_read_only = workflow_restrictions_read_only
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "allows_public_repositories" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "default" Json.Decode.bool)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.float)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "inherited" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "inherited_allows_public_repositories"
                Json.Decode.bool
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "restricted_to_workflows" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "runners_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "selected_repositories_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "selected_workflows"
                (Json.Decode.list Json.Decode.string)
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "visibility" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "workflow_restrictions_read_only"
                Json.Decode.bool
            )


encodeRunnerGroupsOrg : RunnerGroupsOrg -> Json.Encode.Value
encodeRunnerGroupsOrg rec =
    Json.Encode.object
        [ ( "allows_public_repositories"
          , Json.Encode.bool rec.allows_public_repositories
          )
        , ( "default", Json.Encode.bool rec.default )
        , ( "id", Json.Encode.float rec.id )
        , ( "inherited", Json.Encode.bool rec.inherited )
        , ( "inherited_allows_public_repositories"
          , Json.Encode.bool rec.inherited_allows_public_repositories
          )
        , ( "name", Json.Encode.string rec.name )
        , ( "restricted_to_workflows"
          , Json.Encode.bool rec.restricted_to_workflows
          )
        , ( "runners_url", Json.Encode.string rec.runners_url )
        , ( "selected_repositories_url"
          , Json.Encode.string rec.selected_repositories_url
          )
        , ( "selected_workflows"
          , Json.Encode.list Json.Encode.string rec.selected_workflows
          )
        , ( "visibility", Json.Encode.string rec.visibility )
        , ( "workflow_restrictions_read_only"
          , Json.Encode.bool rec.workflow_restrictions_read_only
          )
        ]


type alias RunnerGroupsEnterprise =
    { allows_public_repositories : Bool
    , default : Bool
    , id : Float
    , name : String
    , restricted_to_workflows : Bool
    , runners_url : String
    , selected_organizations_url : String
    , selected_workflows : List String
    , visibility : String
    , workflow_restrictions_read_only : Bool
    }


decodeRunnerGroupsEnterprise : Json.Decode.Decoder RunnerGroupsEnterprise
decodeRunnerGroupsEnterprise =
    Json.Decode.succeed
     (\allows_public_repositories default id name restricted_to_workflows runners_url selected_organizations_url selected_workflows visibility workflow_restrictions_read_only ->
         { allows_public_repositories = allows_public_repositories
         , default = default
         , id = id
         , name = name
         , restricted_to_workflows = restricted_to_workflows
         , runners_url = runners_url
         , selected_organizations_url = selected_organizations_url
         , selected_workflows = selected_workflows
         , visibility = visibility
         , workflow_restrictions_read_only = workflow_restrictions_read_only
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "allows_public_repositories" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "default" Json.Decode.bool)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.float)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "restricted_to_workflows" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "runners_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "selected_organizations_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "selected_workflows"
                (Json.Decode.list Json.Decode.string)
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "visibility" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "workflow_restrictions_read_only"
                Json.Decode.bool
            )


encodeRunnerGroupsEnterprise : RunnerGroupsEnterprise -> Json.Encode.Value
encodeRunnerGroupsEnterprise rec =
    Json.Encode.object
        [ ( "allows_public_repositories"
          , Json.Encode.bool rec.allows_public_repositories
          )
        , ( "default", Json.Encode.bool rec.default )
        , ( "id", Json.Encode.float rec.id )
        , ( "name", Json.Encode.string rec.name )
        , ( "restricted_to_workflows"
          , Json.Encode.bool rec.restricted_to_workflows
          )
        , ( "runners_url", Json.Encode.string rec.runners_url )
        , ( "selected_organizations_url"
          , Json.Encode.string rec.selected_organizations_url
          )
        , ( "selected_workflows"
          , Json.Encode.list Json.Encode.string rec.selected_workflows
          )
        , ( "visibility", Json.Encode.string rec.visibility )
        , ( "workflow_restrictions_read_only"
          , Json.Encode.bool rec.workflow_restrictions_read_only
          )
        ]


type alias RunnerApplication =
    { architecture : String
    , download_url : String
    , filename : String
    , os : String
    , sha256_checksum : String
    , temp_download_token : String
    }


decodeRunnerApplication : Json.Decode.Decoder RunnerApplication
decodeRunnerApplication =
    Json.Decode.succeed
     (\architecture download_url filename os sha256_checksum temp_download_token ->
         { architecture = architecture
         , download_url = download_url
         , filename = filename
         , os = os
         , sha256_checksum = sha256_checksum
         , temp_download_token = temp_download_token
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "architecture" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "download_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "filename" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "os" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "sha256_checksum" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "temp_download_token" Json.Decode.string)


encodeRunnerApplication : RunnerApplication -> Json.Encode.Value
encodeRunnerApplication rec =
    Json.Encode.object
        [ ( "architecture", Json.Encode.string rec.architecture )
        , ( "download_url", Json.Encode.string rec.download_url )
        , ( "filename", Json.Encode.string rec.filename )
        , ( "os", Json.Encode.string rec.os )
        , ( "sha256_checksum", Json.Encode.string rec.sha256_checksum )
        , ( "temp_download_token", Json.Encode.string rec.temp_download_token )
        ]


type alias Runner =
    { busy : Bool
    , id : Int
    , labels : List RunnerLabel
    , name : String
    , os : String
    , status : String
    }


decodeRunner : Json.Decode.Decoder Runner
decodeRunner =
    Json.Decode.succeed
     (\busy id labels name os status ->
         { busy = busy
         , id = id
         , labels = labels
         , name = name
         , os = os
         , status = status
         }
     )
        |> Json.Decode.Extra.andMap (Json.Decode.field "busy" Json.Decode.bool)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "labels" (Json.Decode.list decodeRunnerLabel))
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "os" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "status" Json.Decode.string)


encodeRunner : Runner -> Json.Encode.Value
encodeRunner rec =
    Json.Encode.object
        [ ( "busy", Json.Encode.bool rec.busy )
        , ( "id", Json.Encode.int rec.id )
        , ( "labels", Json.Encode.list encodeRunnerLabel rec.labels )
        , ( "name", Json.Encode.string rec.name )
        , ( "os", Json.Encode.string rec.os )
        , ( "status", Json.Encode.string rec.status )
        ]


type alias Root =
    { authorizations_url : String
    , code_search_url : String
    , commit_search_url : String
    , current_user_authorizations_html_url : String
    , current_user_repositories_url : String
    , current_user_url : String
    , emails_url : String
    , emojis_url : String
    , events_url : String
    , feeds_url : String
    , followers_url : String
    , following_url : String
    , gists_url : String
    , hub_url : String
    , issue_search_url : String
    , issues_url : String
    , keys_url : String
    , label_search_url : String
    , notifications_url : String
    , organization_repositories_url : String
    , organization_teams_url : String
    , organization_url : String
    , public_gists_url : String
    , rate_limit_url : String
    , repository_search_url : String
    , repository_url : String
    , starred_gists_url : String
    , starred_url : String
    , topic_search_url : String
    , user_organizations_url : String
    , user_repositories_url : String
    , user_search_url : String
    , user_url : String
    }


decodeRoot : Json.Decode.Decoder Root
decodeRoot =
    Json.Decode.succeed
     (\authorizations_url code_search_url commit_search_url current_user_authorizations_html_url current_user_repositories_url current_user_url emails_url emojis_url events_url feeds_url followers_url following_url gists_url hub_url issue_search_url issues_url keys_url label_search_url notifications_url organization_repositories_url organization_teams_url organization_url public_gists_url rate_limit_url repository_search_url repository_url starred_gists_url starred_url topic_search_url user_organizations_url user_repositories_url user_search_url user_url ->
         { authorizations_url = authorizations_url
         , code_search_url = code_search_url
         , commit_search_url = commit_search_url
         , current_user_authorizations_html_url =
             current_user_authorizations_html_url
         , current_user_repositories_url = current_user_repositories_url
         , current_user_url = current_user_url
         , emails_url = emails_url
         , emojis_url = emojis_url
         , events_url = events_url
         , feeds_url = feeds_url
         , followers_url = followers_url
         , following_url = following_url
         , gists_url = gists_url
         , hub_url = hub_url
         , issue_search_url = issue_search_url
         , issues_url = issues_url
         , keys_url = keys_url
         , label_search_url = label_search_url
         , notifications_url = notifications_url
         , organization_repositories_url = organization_repositories_url
         , organization_teams_url = organization_teams_url
         , organization_url = organization_url
         , public_gists_url = public_gists_url
         , rate_limit_url = rate_limit_url
         , repository_search_url = repository_search_url
         , repository_url = repository_url
         , starred_gists_url = starred_gists_url
         , starred_url = starred_url
         , topic_search_url = topic_search_url
         , user_organizations_url = user_organizations_url
         , user_repositories_url = user_repositories_url
         , user_search_url = user_search_url
         , user_url = user_url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "authorizations_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "code_search_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "commit_search_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "current_user_authorizations_html_url"
                Json.Decode.string
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "current_user_repositories_url"
                Json.Decode.string
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "current_user_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "emails_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "emojis_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "events_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "feeds_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "followers_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "following_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "gists_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "hub_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "issue_search_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "issues_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "keys_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "label_search_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "notifications_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "organization_repositories_url"
                Json.Decode.string
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "organization_teams_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "organization_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "public_gists_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "rate_limit_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "repository_search_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "repository_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "starred_gists_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "starred_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "topic_search_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "user_organizations_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "user_repositories_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "user_search_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "user_url" Json.Decode.string)


encodeRoot : Root -> Json.Encode.Value
encodeRoot rec =
    Json.Encode.object
        [ ( "authorizations_url", Json.Encode.string rec.authorizations_url )
        , ( "code_search_url", Json.Encode.string rec.code_search_url )
        , ( "commit_search_url", Json.Encode.string rec.commit_search_url )
        , ( "current_user_authorizations_html_url"
          , Json.Encode.string rec.current_user_authorizations_html_url
          )
        , ( "current_user_repositories_url"
          , Json.Encode.string rec.current_user_repositories_url
          )
        , ( "current_user_url", Json.Encode.string rec.current_user_url )
        , ( "emails_url", Json.Encode.string rec.emails_url )
        , ( "emojis_url", Json.Encode.string rec.emojis_url )
        , ( "events_url", Json.Encode.string rec.events_url )
        , ( "feeds_url", Json.Encode.string rec.feeds_url )
        , ( "followers_url", Json.Encode.string rec.followers_url )
        , ( "following_url", Json.Encode.string rec.following_url )
        , ( "gists_url", Json.Encode.string rec.gists_url )
        , ( "hub_url", Json.Encode.string rec.hub_url )
        , ( "issue_search_url", Json.Encode.string rec.issue_search_url )
        , ( "issues_url", Json.Encode.string rec.issues_url )
        , ( "keys_url", Json.Encode.string rec.keys_url )
        , ( "label_search_url", Json.Encode.string rec.label_search_url )
        , ( "notifications_url", Json.Encode.string rec.notifications_url )
        , ( "organization_repositories_url"
          , Json.Encode.string rec.organization_repositories_url
          )
        , ( "organization_teams_url"
          , Json.Encode.string rec.organization_teams_url
          )
        , ( "organization_url", Json.Encode.string rec.organization_url )
        , ( "public_gists_url", Json.Encode.string rec.public_gists_url )
        , ( "rate_limit_url", Json.Encode.string rec.rate_limit_url )
        , ( "repository_search_url"
          , Json.Encode.string rec.repository_search_url
          )
        , ( "repository_url", Json.Encode.string rec.repository_url )
        , ( "starred_gists_url", Json.Encode.string rec.starred_gists_url )
        , ( "starred_url", Json.Encode.string rec.starred_url )
        , ( "topic_search_url", Json.Encode.string rec.topic_search_url )
        , ( "user_organizations_url"
          , Json.Encode.string rec.user_organizations_url
          )
        , ( "user_repositories_url"
          , Json.Encode.string rec.user_repositories_url
          )
        , ( "user_search_url", Json.Encode.string rec.user_search_url )
        , ( "user_url", Json.Encode.string rec.user_url )
        ]


type alias ReviewRequestedIssueEvent =
    { actor : SimpleUser
    , commit_id : Nullable String
    , commit_url : Nullable String
    , created_at : String
    , event : String
    , id : Int
    , node_id : String
    , performed_via_github_app : Nullable Integration
    , requested_reviewer : SimpleUser
    , requested_team : Team
    , review_requester : SimpleUser
    , url : String
    }


decodeReviewRequestedIssueEvent : Json.Decode.Decoder ReviewRequestedIssueEvent
decodeReviewRequestedIssueEvent =
    Json.Decode.succeed
     (\actor commit_id commit_url created_at event id node_id performed_via_github_app requested_reviewer requested_team review_requester url ->
         { actor = actor
         , commit_id = commit_id
         , commit_url = commit_url
         , created_at = created_at
         , event = event
         , id = id
         , node_id = node_id
         , performed_via_github_app = performed_via_github_app
         , requested_reviewer = requested_reviewer
         , requested_team = requested_team
         , review_requester = review_requester
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap (Json.Decode.field "actor" decodeSimpleUser)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "commit_id"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "commit_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "event" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "performed_via_github_app"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeIntegration
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "requested_reviewer" decodeSimpleUser)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "requested_team" decodeTeam)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "review_requester" decodeSimpleUser)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeReviewRequestedIssueEvent : ReviewRequestedIssueEvent -> Json.Encode.Value
encodeReviewRequestedIssueEvent rec =
    Json.Encode.object
        [ ( "actor", encodeSimpleUser rec.actor )
        , ( "commit_id"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.commit_id
          )
        , ( "commit_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.commit_url
          )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "event", Json.Encode.string rec.event )
        , ( "id", Json.Encode.int rec.id )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "performed_via_github_app"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeIntegration value
            )
                rec.performed_via_github_app
          )
        , ( "requested_reviewer", encodeSimpleUser rec.requested_reviewer )
        , ( "requested_team", encodeTeam rec.requested_team )
        , ( "review_requester", encodeSimpleUser rec.review_requester )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias ReviewRequestRemovedIssueEvent =
    { actor : SimpleUser
    , commit_id : Nullable String
    , commit_url : Nullable String
    , created_at : String
    , event : String
    , id : Int
    , node_id : String
    , performed_via_github_app : Nullable Integration
    , requested_reviewer : SimpleUser
    , requested_team : Team
    , review_requester : SimpleUser
    , url : String
    }


decodeReviewRequestRemovedIssueEvent :
    Json.Decode.Decoder ReviewRequestRemovedIssueEvent
decodeReviewRequestRemovedIssueEvent =
    Json.Decode.succeed
     (\actor commit_id commit_url created_at event id node_id performed_via_github_app requested_reviewer requested_team review_requester url ->
         { actor = actor
         , commit_id = commit_id
         , commit_url = commit_url
         , created_at = created_at
         , event = event
         , id = id
         , node_id = node_id
         , performed_via_github_app = performed_via_github_app
         , requested_reviewer = requested_reviewer
         , requested_team = requested_team
         , review_requester = review_requester
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap (Json.Decode.field "actor" decodeSimpleUser)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "commit_id"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "commit_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "event" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "performed_via_github_app"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeIntegration
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "requested_reviewer" decodeSimpleUser)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "requested_team" decodeTeam)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "review_requester" decodeSimpleUser)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeReviewRequestRemovedIssueEvent :
    ReviewRequestRemovedIssueEvent -> Json.Encode.Value
encodeReviewRequestRemovedIssueEvent rec =
    Json.Encode.object
        [ ( "actor", encodeSimpleUser rec.actor )
        , ( "commit_id"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.commit_id
          )
        , ( "commit_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.commit_url
          )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "event", Json.Encode.string rec.event )
        , ( "id", Json.Encode.int rec.id )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "performed_via_github_app"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeIntegration value
            )
                rec.performed_via_github_app
          )
        , ( "requested_reviewer", encodeSimpleUser rec.requested_reviewer )
        , ( "requested_team", encodeTeam rec.requested_team )
        , ( "review_requester", encodeSimpleUser rec.review_requester )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias ReviewDismissedIssueEvent =
    { actor : SimpleUser
    , commit_id : Nullable String
    , commit_url : Nullable String
    , created_at : String
    , dismissed_review :
        { dismissal_commit_id : String
        , dismissal_message : Nullable String
        , review_id : Int
        , state : String
        }
    , event : String
    , id : Int
    , node_id : String
    , performed_via_github_app : Nullable Integration
    , url : String
    }


decodeReviewDismissedIssueEvent : Json.Decode.Decoder ReviewDismissedIssueEvent
decodeReviewDismissedIssueEvent =
    Json.Decode.succeed
     (\actor commit_id commit_url created_at dismissed_review event id node_id performed_via_github_app url ->
         { actor = actor
         , commit_id = commit_id
         , commit_url = commit_url
         , created_at = created_at
         , dismissed_review = dismissed_review
         , event = event
         , id = id
         , node_id = node_id
         , performed_via_github_app = performed_via_github_app
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap (Json.Decode.field "actor" decodeSimpleUser)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "commit_id"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "commit_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "dismissed_review"
                (Json.Decode.succeed
                  (\dismissal_commit_id dismissal_message review_id state ->
                      { dismissal_commit_id = dismissal_commit_id
                      , dismissal_message = dismissal_message
                      , review_id = review_id
                      , state = state
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "dismissal_commit_id"
                            Json.Decode.string
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "dismissal_message"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.string
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "review_id" Json.Decode.int)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "state" Json.Decode.string)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "event" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "performed_via_github_app"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeIntegration
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeReviewDismissedIssueEvent : ReviewDismissedIssueEvent -> Json.Encode.Value
encodeReviewDismissedIssueEvent rec =
    Json.Encode.object
        [ ( "actor", encodeSimpleUser rec.actor )
        , ( "commit_id"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.commit_id
          )
        , ( "commit_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.commit_url
          )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "dismissed_review"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "dismissal_commit_id"
                      , Json.Encode.string rec0.dismissal_commit_id
                      )
                    , ( "dismissal_message"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.string value
                        )
                            rec0.dismissal_message
                      )
                    , ( "review_id", Json.Encode.int rec0.review_id )
                    , ( "state", Json.Encode.string rec0.state )
                    ]
            )
                rec.dismissed_review
          )
        , ( "event", Json.Encode.string rec.event )
        , ( "id", Json.Encode.int rec.id )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "performed_via_github_app"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeIntegration value
            )
                rec.performed_via_github_app
          )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias ReviewComment =
    { _links : { html : Link, pull_request : Link, self : Link }
    , author_association : AuthorAssociation
    , body : String
    , body_html : String
    , body_text : String
    , commit_id : String
    , created_at : String
    , diff_hunk : String
    , html_url : String
    , id : Int
    , in_reply_to_id : Int
    , line : Int
    , node_id : String
    , original_commit_id : String
    , original_line : Int
    , original_position : Int
    , original_start_line : Nullable Int
    , path : String
    , position : Nullable Int
    , pull_request_review_id : Nullable Int
    , pull_request_url : String
    , reactions : ReactionRollup
    , side : String
    , start_line : Nullable Int
    , start_side : Nullable String
    , updated_at : String
    , url : String
    , user : Nullable SimpleUser
    }


decodeReviewComment : Json.Decode.Decoder ReviewComment
decodeReviewComment =
    Json.Decode.succeed
     (\_links author_association body body_html body_text commit_id created_at diff_hunk html_url id in_reply_to_id line node_id original_commit_id original_line original_position original_start_line path position pull_request_review_id pull_request_url reactions side start_line start_side updated_at url user ->
         { _links = _links
         , author_association = author_association
         , body = body
         , body_html = body_html
         , body_text = body_text
         , commit_id = commit_id
         , created_at = created_at
         , diff_hunk = diff_hunk
         , html_url = html_url
         , id = id
         , in_reply_to_id = in_reply_to_id
         , line = line
         , node_id = node_id
         , original_commit_id = original_commit_id
         , original_line = original_line
         , original_position = original_position
         , original_start_line = original_start_line
         , path = path
         , position = position
         , pull_request_review_id = pull_request_review_id
         , pull_request_url = pull_request_url
         , reactions = reactions
         , side = side
         , start_line = start_line
         , start_side = start_side
         , updated_at = updated_at
         , url = url
         , user = user
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "_links"
                (Json.Decode.succeed
                  (\html pull_request self ->
                      { html = html, pull_request = pull_request, self = self }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "html" decodeLink)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "pull_request" decodeLink)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "self" decodeLink)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "author_association" decodeAuthorAssociation)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "body" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "body_html" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "body_text" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "commit_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "diff_hunk" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "in_reply_to_id" Json.Decode.int)
        |> Json.Decode.Extra.andMap (Json.Decode.field "line" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "original_commit_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "original_line" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "original_position" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "original_start_line"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.int
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "path" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "position"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.int
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "pull_request_review_id"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.int
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "pull_request_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "reactions" decodeReactionRollup)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "side" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "start_line"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.int
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "start_side"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "user"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )


encodeReviewComment : ReviewComment -> Json.Encode.Value
encodeReviewComment rec =
    Json.Encode.object
        [ ( "_links"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "html", encodeLink rec0.html )
                    , ( "pull_request", encodeLink rec0.pull_request )
                    , ( "self", encodeLink rec0.self )
                    ]
            )
                rec._links
          )
        , ( "author_association"
          , encodeAuthorAssociation rec.author_association
          )
        , ( "body", Json.Encode.string rec.body )
        , ( "body_html", Json.Encode.string rec.body_html )
        , ( "body_text", Json.Encode.string rec.body_text )
        , ( "commit_id", Json.Encode.string rec.commit_id )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "diff_hunk", Json.Encode.string rec.diff_hunk )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "id", Json.Encode.int rec.id )
        , ( "in_reply_to_id", Json.Encode.int rec.in_reply_to_id )
        , ( "line", Json.Encode.int rec.line )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "original_commit_id", Json.Encode.string rec.original_commit_id )
        , ( "original_line", Json.Encode.int rec.original_line )
        , ( "original_position", Json.Encode.int rec.original_position )
        , ( "original_start_line"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.int value
            )
                rec.original_start_line
          )
        , ( "path", Json.Encode.string rec.path )
        , ( "position"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.int value
            )
                rec.position
          )
        , ( "pull_request_review_id"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.int value
            )
                rec.pull_request_review_id
          )
        , ( "pull_request_url", Json.Encode.string rec.pull_request_url )
        , ( "reactions", encodeReactionRollup rec.reactions )
        , ( "side", Json.Encode.string rec.side )
        , ( "start_line"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.int value
            )
                rec.start_line
          )
        , ( "start_side"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.start_side
          )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        , ( "url", Json.Encode.string rec.url )
        , ( "user"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.user
          )
        ]


type alias RepositorySubscription =
    { created_at : String
    , ignored : Bool
    , reason : Nullable String
    , repository_url : String
    , subscribed : Bool
    , url : String
    }


decodeRepositorySubscription : Json.Decode.Decoder RepositorySubscription
decodeRepositorySubscription =
    Json.Decode.succeed
     (\created_at ignored reason repository_url subscribed url ->
         { created_at = created_at
         , ignored = ignored
         , reason = reason
         , repository_url = repository_url
         , subscribed = subscribed
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "ignored" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "reason"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "repository_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "subscribed" Json.Decode.bool)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeRepositorySubscription : RepositorySubscription -> Json.Encode.Value
encodeRepositorySubscription rec =
    Json.Encode.object
        [ ( "created_at", Json.Encode.string rec.created_at )
        , ( "ignored", Json.Encode.bool rec.ignored )
        , ( "reason"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.reason
          )
        , ( "repository_url", Json.Encode.string rec.repository_url )
        , ( "subscribed", Json.Encode.bool rec.subscribed )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias RepositoryInvitation =
    { created_at : String
    , expired : Bool
    , html_url : String
    , id : Int
    , invitee : Nullable SimpleUser
    , inviter : Nullable SimpleUser
    , node_id : String
    , permissions : String
    , repository : MinimalRepository
    , url : String
    }


decodeRepositoryInvitation : Json.Decode.Decoder RepositoryInvitation
decodeRepositoryInvitation =
    Json.Decode.succeed
     (\created_at expired html_url id invitee inviter node_id permissions repository url ->
         { created_at = created_at
         , expired = expired
         , html_url = html_url
         , id = id
         , invitee = invitee
         , inviter = inviter
         , node_id = node_id
         , permissions = permissions
         , repository = repository
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "expired" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "invitee"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "inviter"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "permissions" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "repository" decodeMinimalRepository)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeRepositoryInvitation : RepositoryInvitation -> Json.Encode.Value
encodeRepositoryInvitation rec =
    Json.Encode.object
        [ ( "created_at", Json.Encode.string rec.created_at )
        , ( "expired", Json.Encode.bool rec.expired )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "id", Json.Encode.int rec.id )
        , ( "invitee"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.invitee
          )
        , ( "inviter"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.inviter
          )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "permissions", Json.Encode.string rec.permissions )
        , ( "repository", encodeMinimalRepository rec.repository )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias RepositoryCollaboratorPermission =
    { permission : String, role_name : String, user : Nullable Collaborator }


decodeRepositoryCollaboratorPermission :
    Json.Decode.Decoder RepositoryCollaboratorPermission
decodeRepositoryCollaboratorPermission =
    Json.Decode.succeed
     (\permission role_name user ->
         { permission = permission, role_name = role_name, user = user }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "permission" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "role_name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "user"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeCollaborator
                    , Json.Decode.null Null
                    ]
                )
            )


encodeRepositoryCollaboratorPermission :
    RepositoryCollaboratorPermission -> Json.Encode.Value
encodeRepositoryCollaboratorPermission rec =
    Json.Encode.object
        [ ( "permission", Json.Encode.string rec.permission )
        , ( "role_name", Json.Encode.string rec.role_name )
        , ( "user"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeCollaborator value
            )
                rec.user
          )
        ]


type alias Repository =
    { allow_auto_merge : Bool
    , allow_forking : Bool
    , allow_merge_commit : Bool
    , allow_rebase_merge : Bool
    , allow_squash_merge : Bool
    , allow_update_branch : Bool
    , anonymous_access_enabled : Bool
    , archive_url : String
    , archived : Bool
    , assignees_url : String
    , blobs_url : String
    , branches_url : String
    , clone_url : String
    , collaborators_url : String
    , comments_url : String
    , commits_url : String
    , compare_url : String
    , contents_url : String
    , contributors_url : String
    , created_at : Nullable String
    , default_branch : String
    , delete_branch_on_merge : Bool
    , deployments_url : String
    , description : Nullable String
    , disabled : Bool
    , downloads_url : String
    , events_url : String
    , fork : Bool
    , forks : Int
    , forks_count : Int
    , forks_url : String
    , full_name : String
    , git_commits_url : String
    , git_refs_url : String
    , git_tags_url : String
    , git_url : String
    , has_downloads : Bool
    , has_issues : Bool
    , has_pages : Bool
    , has_projects : Bool
    , has_wiki : Bool
    , homepage : Nullable String
    , hooks_url : String
    , html_url : String
    , id : Int
    , is_template : Bool
    , issue_comment_url : String
    , issue_events_url : String
    , issues_url : String
    , keys_url : String
    , labels_url : String
    , language : Nullable String
    , languages_url : String
    , license : Nullable LicenseSimple
    , master_branch : String
    , merge_commit_message : String
    , merge_commit_title : String
    , merges_url : String
    , milestones_url : String
    , mirror_url : Nullable String
    , name : String
    , network_count : Int
    , node_id : String
    , notifications_url : String
    , open_issues : Int
    , open_issues_count : Int
    , organization : Nullable SimpleUser
    , owner : SimpleUser
    , permissions :
        { admin : Bool
        , maintain : Bool
        , pull : Bool
        , push : Bool
        , triage : Bool
        }
    , private : Bool
    , pulls_url : String
    , pushed_at : Nullable String
    , releases_url : String
    , size : Int
    , squash_merge_commit_message : String
    , squash_merge_commit_title : String
    , ssh_url : String
    , stargazers_count : Int
    , stargazers_url : String
    , starred_at : String
    , statuses_url : String
    , subscribers_count : Int
    , subscribers_url : String
    , subscription_url : String
    , svn_url : String
    , tags_url : String
    , teams_url : String
    , temp_clone_token : String
    , template_repository :
        Nullable { allow_auto_merge : Bool
        , allow_merge_commit : Bool
        , allow_rebase_merge : Bool
        , allow_squash_merge : Bool
        , allow_update_branch : Bool
        , archive_url : String
        , archived : Bool
        , assignees_url : String
        , blobs_url : String
        , branches_url : String
        , clone_url : String
        , collaborators_url : String
        , comments_url : String
        , commits_url : String
        , compare_url : String
        , contents_url : String
        , contributors_url : String
        , created_at : String
        , default_branch : String
        , delete_branch_on_merge : Bool
        , deployments_url : String
        , description : String
        , disabled : Bool
        , downloads_url : String
        , events_url : String
        , fork : Bool
        , forks_count : Int
        , forks_url : String
        , full_name : String
        , git_commits_url : String
        , git_refs_url : String
        , git_tags_url : String
        , git_url : String
        , has_downloads : Bool
        , has_issues : Bool
        , has_pages : Bool
        , has_projects : Bool
        , has_wiki : Bool
        , homepage : String
        , hooks_url : String
        , html_url : String
        , id : Int
        , is_template : Bool
        , issue_comment_url : String
        , issue_events_url : String
        , issues_url : String
        , keys_url : String
        , labels_url : String
        , language : String
        , languages_url : String
        , merge_commit_message : String
        , merge_commit_title : String
        , merges_url : String
        , milestones_url : String
        , mirror_url : String
        , name : String
        , network_count : Int
        , node_id : String
        , notifications_url : String
        , open_issues_count : Int
        , owner :
            { avatar_url : String
            , events_url : String
            , followers_url : String
            , following_url : String
            , gists_url : String
            , gravatar_id : String
            , html_url : String
            , id : Int
            , login : String
            , node_id : String
            , organizations_url : String
            , received_events_url : String
            , repos_url : String
            , site_admin : Bool
            , starred_url : String
            , subscriptions_url : String
            , type_ : String
            , url : String
            }
        , permissions :
            { admin : Bool
            , maintain : Bool
            , pull : Bool
            , push : Bool
            , triage : Bool
            }
        , private : Bool
        , pulls_url : String
        , pushed_at : String
        , releases_url : String
        , size : Int
        , squash_merge_commit_message : String
        , squash_merge_commit_title : String
        , ssh_url : String
        , stargazers_count : Int
        , stargazers_url : String
        , statuses_url : String
        , subscribers_count : Int
        , subscribers_url : String
        , subscription_url : String
        , svn_url : String
        , tags_url : String
        , teams_url : String
        , temp_clone_token : String
        , topics : List String
        , trees_url : String
        , updated_at : String
        , url : String
        , use_squash_pr_title_as_default : Bool
        , visibility : String
        , watchers_count : Int
        }
    , topics : List String
    , trees_url : String
    , updated_at : Nullable String
    , url : String
    , use_squash_pr_title_as_default : Bool
    , visibility : String
    , watchers : Int
    , watchers_count : Int
    , web_commit_signoff_required : Bool
    }


decodeRepository : Json.Decode.Decoder Repository
decodeRepository =
    Json.Decode.succeed
     (\allow_auto_merge allow_forking allow_merge_commit allow_rebase_merge allow_squash_merge allow_update_branch anonymous_access_enabled archive_url archived assignees_url blobs_url branches_url clone_url collaborators_url comments_url commits_url compare_url contents_url contributors_url created_at default_branch delete_branch_on_merge deployments_url description disabled downloads_url events_url fork forks forks_count forks_url full_name git_commits_url git_refs_url git_tags_url git_url has_downloads has_issues has_pages has_projects has_wiki homepage hooks_url html_url id is_template issue_comment_url issue_events_url issues_url keys_url labels_url language languages_url license master_branch merge_commit_message merge_commit_title merges_url milestones_url mirror_url name network_count node_id notifications_url open_issues open_issues_count organization owner permissions private pulls_url pushed_at releases_url size squash_merge_commit_message squash_merge_commit_title ssh_url stargazers_count stargazers_url starred_at statuses_url subscribers_count subscribers_url subscription_url svn_url tags_url teams_url temp_clone_token template_repository topics trees_url updated_at url use_squash_pr_title_as_default visibility watchers watchers_count web_commit_signoff_required ->
         { allow_auto_merge = allow_auto_merge
         , allow_forking = allow_forking
         , allow_merge_commit = allow_merge_commit
         , allow_rebase_merge = allow_rebase_merge
         , allow_squash_merge = allow_squash_merge
         , allow_update_branch = allow_update_branch
         , anonymous_access_enabled = anonymous_access_enabled
         , archive_url = archive_url
         , archived = archived
         , assignees_url = assignees_url
         , blobs_url = blobs_url
         , branches_url = branches_url
         , clone_url = clone_url
         , collaborators_url = collaborators_url
         , comments_url = comments_url
         , commits_url = commits_url
         , compare_url = compare_url
         , contents_url = contents_url
         , contributors_url = contributors_url
         , created_at = created_at
         , default_branch = default_branch
         , delete_branch_on_merge = delete_branch_on_merge
         , deployments_url = deployments_url
         , description = description
         , disabled = disabled
         , downloads_url = downloads_url
         , events_url = events_url
         , fork = fork
         , forks = forks
         , forks_count = forks_count
         , forks_url = forks_url
         , full_name = full_name
         , git_commits_url = git_commits_url
         , git_refs_url = git_refs_url
         , git_tags_url = git_tags_url
         , git_url = git_url
         , has_downloads = has_downloads
         , has_issues = has_issues
         , has_pages = has_pages
         , has_projects = has_projects
         , has_wiki = has_wiki
         , homepage = homepage
         , hooks_url = hooks_url
         , html_url = html_url
         , id = id
         , is_template = is_template
         , issue_comment_url = issue_comment_url
         , issue_events_url = issue_events_url
         , issues_url = issues_url
         , keys_url = keys_url
         , labels_url = labels_url
         , language = language
         , languages_url = languages_url
         , license = license
         , master_branch = master_branch
         , merge_commit_message = merge_commit_message
         , merge_commit_title = merge_commit_title
         , merges_url = merges_url
         , milestones_url = milestones_url
         , mirror_url = mirror_url
         , name = name
         , network_count = network_count
         , node_id = node_id
         , notifications_url = notifications_url
         , open_issues = open_issues
         , open_issues_count = open_issues_count
         , organization = organization
         , owner = owner
         , permissions = permissions
         , private = private
         , pulls_url = pulls_url
         , pushed_at = pushed_at
         , releases_url = releases_url
         , size = size
         , squash_merge_commit_message = squash_merge_commit_message
         , squash_merge_commit_title = squash_merge_commit_title
         , ssh_url = ssh_url
         , stargazers_count = stargazers_count
         , stargazers_url = stargazers_url
         , starred_at = starred_at
         , statuses_url = statuses_url
         , subscribers_count = subscribers_count
         , subscribers_url = subscribers_url
         , subscription_url = subscription_url
         , svn_url = svn_url
         , tags_url = tags_url
         , teams_url = teams_url
         , temp_clone_token = temp_clone_token
         , template_repository = template_repository
         , topics = topics
         , trees_url = trees_url
         , updated_at = updated_at
         , url = url
         , use_squash_pr_title_as_default = use_squash_pr_title_as_default
         , visibility = visibility
         , watchers = watchers
         , watchers_count = watchers_count
         , web_commit_signoff_required = web_commit_signoff_required
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "allow_auto_merge" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "allow_forking" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "allow_merge_commit" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "allow_rebase_merge" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "allow_squash_merge" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "allow_update_branch" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "anonymous_access_enabled" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "archive_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "archived" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "assignees_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "blobs_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "branches_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "clone_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "collaborators_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "comments_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "commits_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "compare_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "contents_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "contributors_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "created_at"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "default_branch" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "delete_branch_on_merge" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "deployments_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "description"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "disabled" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "downloads_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "events_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "fork" Json.Decode.bool)
        |> Json.Decode.Extra.andMap (Json.Decode.field "forks" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "forks_count" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "forks_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "full_name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "git_commits_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "git_refs_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "git_tags_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "git_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "has_downloads" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "has_issues" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "has_pages" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "has_projects" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "has_wiki" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "homepage"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "hooks_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "is_template" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "issue_comment_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "issue_events_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "issues_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "keys_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "labels_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "language"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "languages_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "license"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeLicenseSimple
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "master_branch" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "merge_commit_message" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "merge_commit_title" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "merges_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "milestones_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "mirror_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "network_count" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "notifications_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "open_issues" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "open_issues_count" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "organization"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "owner" decodeSimpleUser)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "permissions"
                (Json.Decode.succeed
                  (\admin maintain pull push triage ->
                      { admin = admin
                      , maintain = maintain
                      , pull = pull
                      , push = push
                      , triage = triage
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "admin" Json.Decode.bool)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "maintain" Json.Decode.bool)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "pull" Json.Decode.bool)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "push" Json.Decode.bool)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "triage" Json.Decode.bool)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "private" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "pulls_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "pushed_at"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "releases_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "size" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "squash_merge_commit_message" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "squash_merge_commit_title" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "ssh_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "stargazers_count" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "stargazers_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "starred_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "statuses_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "subscribers_count" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "subscribers_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "subscription_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "svn_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "tags_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "teams_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "temp_clone_token" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "template_repository"
                (Json.Decode.oneOf
                    [ Json.Decode.map
                        Present
                        (Json.Decode.succeed
                          (\allow_auto_merge allow_merge_commit allow_rebase_merge allow_squash_merge allow_update_branch archive_url archived assignees_url blobs_url branches_url clone_url collaborators_url comments_url commits_url compare_url contents_url contributors_url created_at default_branch delete_branch_on_merge deployments_url description disabled downloads_url events_url fork forks_count forks_url full_name git_commits_url git_refs_url git_tags_url git_url has_downloads has_issues has_pages has_projects has_wiki homepage hooks_url html_url id is_template issue_comment_url issue_events_url issues_url keys_url labels_url language languages_url merge_commit_message merge_commit_title merges_url milestones_url mirror_url name network_count node_id notifications_url open_issues_count owner permissions private pulls_url pushed_at releases_url size squash_merge_commit_message squash_merge_commit_title ssh_url stargazers_count stargazers_url statuses_url subscribers_count subscribers_url subscription_url svn_url tags_url teams_url temp_clone_token topics trees_url updated_at url use_squash_pr_title_as_default visibility watchers_count ->
                              { allow_auto_merge = allow_auto_merge
                              , allow_merge_commit = allow_merge_commit
                              , allow_rebase_merge = allow_rebase_merge
                              , allow_squash_merge = allow_squash_merge
                              , allow_update_branch = allow_update_branch
                              , archive_url = archive_url
                              , archived = archived
                              , assignees_url = assignees_url
                              , blobs_url = blobs_url
                              , branches_url = branches_url
                              , clone_url = clone_url
                              , collaborators_url = collaborators_url
                              , comments_url = comments_url
                              , commits_url = commits_url
                              , compare_url = compare_url
                              , contents_url = contents_url
                              , contributors_url = contributors_url
                              , created_at = created_at
                              , default_branch = default_branch
                              , delete_branch_on_merge = delete_branch_on_merge
                              , deployments_url = deployments_url
                              , description = description
                              , disabled = disabled
                              , downloads_url = downloads_url
                              , events_url = events_url
                              , fork = fork
                              , forks_count = forks_count
                              , forks_url = forks_url
                              , full_name = full_name
                              , git_commits_url = git_commits_url
                              , git_refs_url = git_refs_url
                              , git_tags_url = git_tags_url
                              , git_url = git_url
                              , has_downloads = has_downloads
                              , has_issues = has_issues
                              , has_pages = has_pages
                              , has_projects = has_projects
                              , has_wiki = has_wiki
                              , homepage = homepage
                              , hooks_url = hooks_url
                              , html_url = html_url
                              , id = id
                              , is_template = is_template
                              , issue_comment_url = issue_comment_url
                              , issue_events_url = issue_events_url
                              , issues_url = issues_url
                              , keys_url = keys_url
                              , labels_url = labels_url
                              , language = language
                              , languages_url = languages_url
                              , merge_commit_message = merge_commit_message
                              , merge_commit_title = merge_commit_title
                              , merges_url = merges_url
                              , milestones_url = milestones_url
                              , mirror_url = mirror_url
                              , name = name
                              , network_count = network_count
                              , node_id = node_id
                              , notifications_url = notifications_url
                              , open_issues_count = open_issues_count
                              , owner = owner
                              , permissions = permissions
                              , private = private
                              , pulls_url = pulls_url
                              , pushed_at = pushed_at
                              , releases_url = releases_url
                              , size = size
                              , squash_merge_commit_message =
                                  squash_merge_commit_message
                              , squash_merge_commit_title =
                                  squash_merge_commit_title
                              , ssh_url = ssh_url
                              , stargazers_count = stargazers_count
                              , stargazers_url = stargazers_url
                              , statuses_url = statuses_url
                              , subscribers_count = subscribers_count
                              , subscribers_url = subscribers_url
                              , subscription_url = subscription_url
                              , svn_url = svn_url
                              , tags_url = tags_url
                              , teams_url = teams_url
                              , temp_clone_token = temp_clone_token
                              , topics = topics
                              , trees_url = trees_url
                              , updated_at = updated_at
                              , url = url
                              , use_squash_pr_title_as_default =
                                  use_squash_pr_title_as_default
                              , visibility = visibility
                              , watchers_count = watchers_count
                              }
                          )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "allow_auto_merge"
                                    Json.Decode.bool
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "allow_merge_commit"
                                    Json.Decode.bool
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "allow_rebase_merge"
                                    Json.Decode.bool
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "allow_squash_merge"
                                    Json.Decode.bool
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "allow_update_branch"
                                    Json.Decode.bool
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "archive_url"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "archived" Json.Decode.bool)
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "assignees_url"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "blobs_url"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "branches_url"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "clone_url"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "collaborators_url"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "comments_url"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "commits_url"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "compare_url"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "contents_url"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "contributors_url"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "created_at"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "default_branch"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "delete_branch_on_merge"
                                    Json.Decode.bool
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "deployments_url"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "description"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "disabled" Json.Decode.bool)
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "downloads_url"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "events_url"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "fork" Json.Decode.bool)
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "forks_count" Json.Decode.int
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "forks_url"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "full_name"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "git_commits_url"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "git_refs_url"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "git_tags_url"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "git_url" Json.Decode.string)
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "has_downloads"
                                    Json.Decode.bool
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "has_issues" Json.Decode.bool
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "has_pages" Json.Decode.bool)
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "has_projects"
                                    Json.Decode.bool
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "has_wiki" Json.Decode.bool)
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "homepage" Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "hooks_url"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "html_url" Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "id" Json.Decode.int)
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "is_template"
                                    Json.Decode.bool
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "issue_comment_url"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "issue_events_url"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "issues_url"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "keys_url" Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "labels_url"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "language" Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "languages_url"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "merge_commit_message"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "merge_commit_title"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "merges_url"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "milestones_url"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "mirror_url"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "name" Json.Decode.string)
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "network_count"
                                    Json.Decode.int
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "node_id" Json.Decode.string)
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "notifications_url"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "open_issues_count"
                                    Json.Decode.int
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "owner"
                                    (Json.Decode.succeed
                                      (\avatar_url events_url followers_url following_url gists_url gravatar_id html_url id login node_id organizations_url received_events_url repos_url site_admin starred_url subscriptions_url type_ url ->
                                          { avatar_url = avatar_url
                                          , events_url = events_url
                                          , followers_url = followers_url
                                          , following_url = following_url
                                          , gists_url = gists_url
                                          , gravatar_id = gravatar_id
                                          , html_url = html_url
                                          , id = id
                                          , login = login
                                          , node_id = node_id
                                          , organizations_url =
                                              organizations_url
                                          , received_events_url =
                                              received_events_url
                                          , repos_url = repos_url
                                          , site_admin = site_admin
                                          , starred_url = starred_url
                                          , subscriptions_url =
                                              subscriptions_url
                                          , type_ = type_
                                          , url = url
                                          }
                                      )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "avatar_url"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "events_url"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "followers_url"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "following_url"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "gists_url"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "gravatar_id"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "html_url"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "id"
                                                Json.Decode.int
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "login"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "node_id"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "organizations_url"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "received_events_url"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "repos_url"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "site_admin"
                                                Json.Decode.bool
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "starred_url"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "subscriptions_url"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "type"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "url"
                                                Json.Decode.string
                                            )
                                    )
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "permissions"
                                    (Json.Decode.succeed
                                      (\admin maintain pull push triage ->
                                          { admin = admin
                                          , maintain = maintain
                                          , pull = pull
                                          , push = push
                                          , triage = triage
                                          }
                                      )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "admin"
                                                Json.Decode.bool
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "maintain"
                                                Json.Decode.bool
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "pull"
                                                Json.Decode.bool
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "push"
                                                Json.Decode.bool
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "triage"
                                                Json.Decode.bool
                                            )
                                    )
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "private" Json.Decode.bool)
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "pulls_url"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "pushed_at"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "releases_url"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "size" Json.Decode.int)
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "squash_merge_commit_message"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "squash_merge_commit_title"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "ssh_url" Json.Decode.string)
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "stargazers_count"
                                    Json.Decode.int
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "stargazers_url"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "statuses_url"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "subscribers_count"
                                    Json.Decode.int
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "subscribers_url"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "subscription_url"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "svn_url" Json.Decode.string)
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "tags_url" Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "teams_url"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "temp_clone_token"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "topics"
                                    (Json.Decode.list Json.Decode.string)
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "trees_url"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "updated_at"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "url" Json.Decode.string)
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "use_squash_pr_title_as_default"
                                    Json.Decode.bool
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "visibility"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "watchers_count"
                                    Json.Decode.int
                                )
                        )
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "topics" (Json.Decode.list Json.Decode.string))
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "trees_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "updated_at"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "use_squash_pr_title_as_default" Json.Decode.bool
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "visibility" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "watchers" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "watchers_count" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "web_commit_signoff_required" Json.Decode.bool)


encodeRepository : Repository -> Json.Encode.Value
encodeRepository rec =
    Json.Encode.object
        [ ( "allow_auto_merge", Json.Encode.bool rec.allow_auto_merge )
        , ( "allow_forking", Json.Encode.bool rec.allow_forking )
        , ( "allow_merge_commit", Json.Encode.bool rec.allow_merge_commit )
        , ( "allow_rebase_merge", Json.Encode.bool rec.allow_rebase_merge )
        , ( "allow_squash_merge", Json.Encode.bool rec.allow_squash_merge )
        , ( "allow_update_branch", Json.Encode.bool rec.allow_update_branch )
        , ( "anonymous_access_enabled"
          , Json.Encode.bool rec.anonymous_access_enabled
          )
        , ( "archive_url", Json.Encode.string rec.archive_url )
        , ( "archived", Json.Encode.bool rec.archived )
        , ( "assignees_url", Json.Encode.string rec.assignees_url )
        , ( "blobs_url", Json.Encode.string rec.blobs_url )
        , ( "branches_url", Json.Encode.string rec.branches_url )
        , ( "clone_url", Json.Encode.string rec.clone_url )
        , ( "collaborators_url", Json.Encode.string rec.collaborators_url )
        , ( "comments_url", Json.Encode.string rec.comments_url )
        , ( "commits_url", Json.Encode.string rec.commits_url )
        , ( "compare_url", Json.Encode.string rec.compare_url )
        , ( "contents_url", Json.Encode.string rec.contents_url )
        , ( "contributors_url", Json.Encode.string rec.contributors_url )
        , ( "created_at"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.created_at
          )
        , ( "default_branch", Json.Encode.string rec.default_branch )
        , ( "delete_branch_on_merge"
          , Json.Encode.bool rec.delete_branch_on_merge
          )
        , ( "deployments_url", Json.Encode.string rec.deployments_url )
        , ( "description"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.description
          )
        , ( "disabled", Json.Encode.bool rec.disabled )
        , ( "downloads_url", Json.Encode.string rec.downloads_url )
        , ( "events_url", Json.Encode.string rec.events_url )
        , ( "fork", Json.Encode.bool rec.fork )
        , ( "forks", Json.Encode.int rec.forks )
        , ( "forks_count", Json.Encode.int rec.forks_count )
        , ( "forks_url", Json.Encode.string rec.forks_url )
        , ( "full_name", Json.Encode.string rec.full_name )
        , ( "git_commits_url", Json.Encode.string rec.git_commits_url )
        , ( "git_refs_url", Json.Encode.string rec.git_refs_url )
        , ( "git_tags_url", Json.Encode.string rec.git_tags_url )
        , ( "git_url", Json.Encode.string rec.git_url )
        , ( "has_downloads", Json.Encode.bool rec.has_downloads )
        , ( "has_issues", Json.Encode.bool rec.has_issues )
        , ( "has_pages", Json.Encode.bool rec.has_pages )
        , ( "has_projects", Json.Encode.bool rec.has_projects )
        , ( "has_wiki", Json.Encode.bool rec.has_wiki )
        , ( "homepage"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.homepage
          )
        , ( "hooks_url", Json.Encode.string rec.hooks_url )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "id", Json.Encode.int rec.id )
        , ( "is_template", Json.Encode.bool rec.is_template )
        , ( "issue_comment_url", Json.Encode.string rec.issue_comment_url )
        , ( "issue_events_url", Json.Encode.string rec.issue_events_url )
        , ( "issues_url", Json.Encode.string rec.issues_url )
        , ( "keys_url", Json.Encode.string rec.keys_url )
        , ( "labels_url", Json.Encode.string rec.labels_url )
        , ( "language"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.language
          )
        , ( "languages_url", Json.Encode.string rec.languages_url )
        , ( "license"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeLicenseSimple value
            )
                rec.license
          )
        , ( "master_branch", Json.Encode.string rec.master_branch )
        , ( "merge_commit_message"
          , Json.Encode.string rec.merge_commit_message
          )
        , ( "merge_commit_title", Json.Encode.string rec.merge_commit_title )
        , ( "merges_url", Json.Encode.string rec.merges_url )
        , ( "milestones_url", Json.Encode.string rec.milestones_url )
        , ( "mirror_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.mirror_url
          )
        , ( "name", Json.Encode.string rec.name )
        , ( "network_count", Json.Encode.int rec.network_count )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "notifications_url", Json.Encode.string rec.notifications_url )
        , ( "open_issues", Json.Encode.int rec.open_issues )
        , ( "open_issues_count", Json.Encode.int rec.open_issues_count )
        , ( "organization"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.organization
          )
        , ( "owner", encodeSimpleUser rec.owner )
        , ( "permissions"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "admin", Json.Encode.bool rec0.admin )
                    , ( "maintain", Json.Encode.bool rec0.maintain )
                    , ( "pull", Json.Encode.bool rec0.pull )
                    , ( "push", Json.Encode.bool rec0.push )
                    , ( "triage", Json.Encode.bool rec0.triage )
                    ]
            )
                rec.permissions
          )
        , ( "private", Json.Encode.bool rec.private )
        , ( "pulls_url", Json.Encode.string rec.pulls_url )
        , ( "pushed_at"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.pushed_at
          )
        , ( "releases_url", Json.Encode.string rec.releases_url )
        , ( "size", Json.Encode.int rec.size )
        , ( "squash_merge_commit_message"
          , Json.Encode.string rec.squash_merge_commit_message
          )
        , ( "squash_merge_commit_title"
          , Json.Encode.string rec.squash_merge_commit_title
          )
        , ( "ssh_url", Json.Encode.string rec.ssh_url )
        , ( "stargazers_count", Json.Encode.int rec.stargazers_count )
        , ( "stargazers_url", Json.Encode.string rec.stargazers_url )
        , ( "starred_at", Json.Encode.string rec.starred_at )
        , ( "statuses_url", Json.Encode.string rec.statuses_url )
        , ( "subscribers_count", Json.Encode.int rec.subscribers_count )
        , ( "subscribers_url", Json.Encode.string rec.subscribers_url )
        , ( "subscription_url", Json.Encode.string rec.subscription_url )
        , ( "svn_url", Json.Encode.string rec.svn_url )
        , ( "tags_url", Json.Encode.string rec.tags_url )
        , ( "teams_url", Json.Encode.string rec.teams_url )
        , ( "temp_clone_token", Json.Encode.string rec.temp_clone_token )
        , ( "template_repository"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        (\rec0 ->
                            Json.Encode.object
                                [ ( "allow_auto_merge"
                                  , Json.Encode.bool rec0.allow_auto_merge
                                  )
                                , ( "allow_merge_commit"
                                  , Json.Encode.bool rec0.allow_merge_commit
                                  )
                                , ( "allow_rebase_merge"
                                  , Json.Encode.bool rec0.allow_rebase_merge
                                  )
                                , ( "allow_squash_merge"
                                  , Json.Encode.bool rec0.allow_squash_merge
                                  )
                                , ( "allow_update_branch"
                                  , Json.Encode.bool rec0.allow_update_branch
                                  )
                                , ( "archive_url"
                                  , Json.Encode.string rec0.archive_url
                                  )
                                , ( "archived", Json.Encode.bool rec0.archived )
                                , ( "assignees_url"
                                  , Json.Encode.string rec0.assignees_url
                                  )
                                , ( "blobs_url"
                                  , Json.Encode.string rec0.blobs_url
                                  )
                                , ( "branches_url"
                                  , Json.Encode.string rec0.branches_url
                                  )
                                , ( "clone_url"
                                  , Json.Encode.string rec0.clone_url
                                  )
                                , ( "collaborators_url"
                                  , Json.Encode.string rec0.collaborators_url
                                  )
                                , ( "comments_url"
                                  , Json.Encode.string rec0.comments_url
                                  )
                                , ( "commits_url"
                                  , Json.Encode.string rec0.commits_url
                                  )
                                , ( "compare_url"
                                  , Json.Encode.string rec0.compare_url
                                  )
                                , ( "contents_url"
                                  , Json.Encode.string rec0.contents_url
                                  )
                                , ( "contributors_url"
                                  , Json.Encode.string rec0.contributors_url
                                  )
                                , ( "created_at"
                                  , Json.Encode.string rec0.created_at
                                  )
                                , ( "default_branch"
                                  , Json.Encode.string rec0.default_branch
                                  )
                                , ( "delete_branch_on_merge"
                                  , Json.Encode.bool rec0.delete_branch_on_merge
                                  )
                                , ( "deployments_url"
                                  , Json.Encode.string rec0.deployments_url
                                  )
                                , ( "description"
                                  , Json.Encode.string rec0.description
                                  )
                                , ( "disabled", Json.Encode.bool rec0.disabled )
                                , ( "downloads_url"
                                  , Json.Encode.string rec0.downloads_url
                                  )
                                , ( "events_url"
                                  , Json.Encode.string rec0.events_url
                                  )
                                , ( "fork", Json.Encode.bool rec0.fork )
                                , ( "forks_count"
                                  , Json.Encode.int rec0.forks_count
                                  )
                                , ( "forks_url"
                                  , Json.Encode.string rec0.forks_url
                                  )
                                , ( "full_name"
                                  , Json.Encode.string rec0.full_name
                                  )
                                , ( "git_commits_url"
                                  , Json.Encode.string rec0.git_commits_url
                                  )
                                , ( "git_refs_url"
                                  , Json.Encode.string rec0.git_refs_url
                                  )
                                , ( "git_tags_url"
                                  , Json.Encode.string rec0.git_tags_url
                                  )
                                , ( "git_url", Json.Encode.string rec0.git_url )
                                , ( "has_downloads"
                                  , Json.Encode.bool rec0.has_downloads
                                  )
                                , ( "has_issues"
                                  , Json.Encode.bool rec0.has_issues
                                  )
                                , ( "has_pages"
                                  , Json.Encode.bool rec0.has_pages
                                  )
                                , ( "has_projects"
                                  , Json.Encode.bool rec0.has_projects
                                  )
                                , ( "has_wiki", Json.Encode.bool rec0.has_wiki )
                                , ( "homepage"
                                  , Json.Encode.string rec0.homepage
                                  )
                                , ( "hooks_url"
                                  , Json.Encode.string rec0.hooks_url
                                  )
                                , ( "html_url"
                                  , Json.Encode.string rec0.html_url
                                  )
                                , ( "id", Json.Encode.int rec0.id )
                                , ( "is_template"
                                  , Json.Encode.bool rec0.is_template
                                  )
                                , ( "issue_comment_url"
                                  , Json.Encode.string rec0.issue_comment_url
                                  )
                                , ( "issue_events_url"
                                  , Json.Encode.string rec0.issue_events_url
                                  )
                                , ( "issues_url"
                                  , Json.Encode.string rec0.issues_url
                                  )
                                , ( "keys_url"
                                  , Json.Encode.string rec0.keys_url
                                  )
                                , ( "labels_url"
                                  , Json.Encode.string rec0.labels_url
                                  )
                                , ( "language"
                                  , Json.Encode.string rec0.language
                                  )
                                , ( "languages_url"
                                  , Json.Encode.string rec0.languages_url
                                  )
                                , ( "merge_commit_message"
                                  , Json.Encode.string rec0.merge_commit_message
                                  )
                                , ( "merge_commit_title"
                                  , Json.Encode.string rec0.merge_commit_title
                                  )
                                , ( "merges_url"
                                  , Json.Encode.string rec0.merges_url
                                  )
                                , ( "milestones_url"
                                  , Json.Encode.string rec0.milestones_url
                                  )
                                , ( "mirror_url"
                                  , Json.Encode.string rec0.mirror_url
                                  )
                                , ( "name", Json.Encode.string rec0.name )
                                , ( "network_count"
                                  , Json.Encode.int rec0.network_count
                                  )
                                , ( "node_id", Json.Encode.string rec0.node_id )
                                , ( "notifications_url"
                                  , Json.Encode.string rec0.notifications_url
                                  )
                                , ( "open_issues_count"
                                  , Json.Encode.int rec0.open_issues_count
                                  )
                                , ( "owner"
                                  , (\rec_0_61_1_1_0_0_1_0_0_89_1_0_0 ->
                                        Json.Encode.object
                                            [ ( "avatar_url"
                                              , Json.Encode.string
                                                    rec_0_61_1_1_0_0_1_0_0_89_1_0_0.avatar_url
                                              )
                                            , ( "events_url"
                                              , Json.Encode.string
                                                    rec_0_61_1_1_0_0_1_0_0_89_1_0_0.events_url
                                              )
                                            , ( "followers_url"
                                              , Json.Encode.string
                                                    rec_0_61_1_1_0_0_1_0_0_89_1_0_0.followers_url
                                              )
                                            , ( "following_url"
                                              , Json.Encode.string
                                                    rec_0_61_1_1_0_0_1_0_0_89_1_0_0.following_url
                                              )
                                            , ( "gists_url"
                                              , Json.Encode.string
                                                    rec_0_61_1_1_0_0_1_0_0_89_1_0_0.gists_url
                                              )
                                            , ( "gravatar_id"
                                              , Json.Encode.string
                                                    rec_0_61_1_1_0_0_1_0_0_89_1_0_0.gravatar_id
                                              )
                                            , ( "html_url"
                                              , Json.Encode.string
                                                    rec_0_61_1_1_0_0_1_0_0_89_1_0_0.html_url
                                              )
                                            , ( "id"
                                              , Json.Encode.int
                                                    rec_0_61_1_1_0_0_1_0_0_89_1_0_0.id
                                              )
                                            , ( "login"
                                              , Json.Encode.string
                                                    rec_0_61_1_1_0_0_1_0_0_89_1_0_0.login
                                              )
                                            , ( "node_id"
                                              , Json.Encode.string
                                                    rec_0_61_1_1_0_0_1_0_0_89_1_0_0.node_id
                                              )
                                            , ( "organizations_url"
                                              , Json.Encode.string
                                                    rec_0_61_1_1_0_0_1_0_0_89_1_0_0.organizations_url
                                              )
                                            , ( "received_events_url"
                                              , Json.Encode.string
                                                    rec_0_61_1_1_0_0_1_0_0_89_1_0_0.received_events_url
                                              )
                                            , ( "repos_url"
                                              , Json.Encode.string
                                                    rec_0_61_1_1_0_0_1_0_0_89_1_0_0.repos_url
                                              )
                                            , ( "site_admin"
                                              , Json.Encode.bool
                                                    rec_0_61_1_1_0_0_1_0_0_89_1_0_0.site_admin
                                              )
                                            , ( "starred_url"
                                              , Json.Encode.string
                                                    rec_0_61_1_1_0_0_1_0_0_89_1_0_0.starred_url
                                              )
                                            , ( "subscriptions_url"
                                              , Json.Encode.string
                                                    rec_0_61_1_1_0_0_1_0_0_89_1_0_0.subscriptions_url
                                              )
                                            , ( "type"
                                              , Json.Encode.string
                                                    rec_0_61_1_1_0_0_1_0_0_89_1_0_0.type_
                                              )
                                            , ( "url"
                                              , Json.Encode.string
                                                    rec_0_61_1_1_0_0_1_0_0_89_1_0_0.url
                                              )
                                            ]
                                    )
                                        rec0.owner
                                  )
                                , ( "permissions"
                                  , (\rec_0_62_1_1_0_0_1_0_0_89_1_0_0 ->
                                        Json.Encode.object
                                            [ ( "admin"
                                              , Json.Encode.bool
                                                    rec_0_62_1_1_0_0_1_0_0_89_1_0_0.admin
                                              )
                                            , ( "maintain"
                                              , Json.Encode.bool
                                                    rec_0_62_1_1_0_0_1_0_0_89_1_0_0.maintain
                                              )
                                            , ( "pull"
                                              , Json.Encode.bool
                                                    rec_0_62_1_1_0_0_1_0_0_89_1_0_0.pull
                                              )
                                            , ( "push"
                                              , Json.Encode.bool
                                                    rec_0_62_1_1_0_0_1_0_0_89_1_0_0.push
                                              )
                                            , ( "triage"
                                              , Json.Encode.bool
                                                    rec_0_62_1_1_0_0_1_0_0_89_1_0_0.triage
                                              )
                                            ]
                                    )
                                        rec0.permissions
                                  )
                                , ( "private", Json.Encode.bool rec0.private )
                                , ( "pulls_url"
                                  , Json.Encode.string rec0.pulls_url
                                  )
                                , ( "pushed_at"
                                  , Json.Encode.string rec0.pushed_at
                                  )
                                , ( "releases_url"
                                  , Json.Encode.string rec0.releases_url
                                  )
                                , ( "size", Json.Encode.int rec0.size )
                                , ( "squash_merge_commit_message"
                                  , Json.Encode.string
                                        rec0.squash_merge_commit_message
                                  )
                                , ( "squash_merge_commit_title"
                                  , Json.Encode.string
                                        rec0.squash_merge_commit_title
                                  )
                                , ( "ssh_url", Json.Encode.string rec0.ssh_url )
                                , ( "stargazers_count"
                                  , Json.Encode.int rec0.stargazers_count
                                  )
                                , ( "stargazers_url"
                                  , Json.Encode.string rec0.stargazers_url
                                  )
                                , ( "statuses_url"
                                  , Json.Encode.string rec0.statuses_url
                                  )
                                , ( "subscribers_count"
                                  , Json.Encode.int rec0.subscribers_count
                                  )
                                , ( "subscribers_url"
                                  , Json.Encode.string rec0.subscribers_url
                                  )
                                , ( "subscription_url"
                                  , Json.Encode.string rec0.subscription_url
                                  )
                                , ( "svn_url", Json.Encode.string rec0.svn_url )
                                , ( "tags_url"
                                  , Json.Encode.string rec0.tags_url
                                  )
                                , ( "teams_url"
                                  , Json.Encode.string rec0.teams_url
                                  )
                                , ( "temp_clone_token"
                                  , Json.Encode.string rec0.temp_clone_token
                                  )
                                , ( "topics"
                                  , Json.Encode.list Json.Encode.string
                                        rec0.topics
                                  )
                                , ( "trees_url"
                                  , Json.Encode.string rec0.trees_url
                                  )
                                , ( "updated_at"
                                  , Json.Encode.string rec0.updated_at
                                  )
                                , ( "url", Json.Encode.string rec0.url )
                                , ( "use_squash_pr_title_as_default"
                                  , Json.Encode.bool
                                        rec0.use_squash_pr_title_as_default
                                  )
                                , ( "visibility"
                                  , Json.Encode.string rec0.visibility
                                  )
                                , ( "watchers_count"
                                  , Json.Encode.int rec0.watchers_count
                                  )
                                ]
                        )
                            value
            )
                rec.template_repository
          )
        , ( "topics", Json.Encode.list Json.Encode.string rec.topics )
        , ( "trees_url", Json.Encode.string rec.trees_url )
        , ( "updated_at"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.updated_at
          )
        , ( "url", Json.Encode.string rec.url )
        , ( "use_squash_pr_title_as_default"
          , Json.Encode.bool rec.use_squash_pr_title_as_default
          )
        , ( "visibility", Json.Encode.string rec.visibility )
        , ( "watchers", Json.Encode.int rec.watchers )
        , ( "watchers_count", Json.Encode.int rec.watchers_count )
        , ( "web_commit_signoff_required"
          , Json.Encode.bool rec.web_commit_signoff_required
          )
        ]


type alias RepoSearchResultItem =
    { allow_auto_merge : Bool
    , allow_forking : Bool
    , allow_merge_commit : Bool
    , allow_rebase_merge : Bool
    , allow_squash_merge : Bool
    , archive_url : String
    , archived : Bool
    , assignees_url : String
    , blobs_url : String
    , branches_url : String
    , clone_url : String
    , collaborators_url : String
    , comments_url : String
    , commits_url : String
    , compare_url : String
    , contents_url : String
    , contributors_url : String
    , created_at : String
    , default_branch : String
    , delete_branch_on_merge : Bool
    , deployments_url : String
    , description : Nullable String
    , disabled : Bool
    , downloads_url : String
    , events_url : String
    , fork : Bool
    , forks : Int
    , forks_count : Int
    , forks_url : String
    , full_name : String
    , git_commits_url : String
    , git_refs_url : String
    , git_tags_url : String
    , git_url : String
    , has_downloads : Bool
    , has_issues : Bool
    , has_pages : Bool
    , has_projects : Bool
    , has_wiki : Bool
    , homepage : Nullable String
    , hooks_url : String
    , html_url : String
    , id : Int
    , is_template : Bool
    , issue_comment_url : String
    , issue_events_url : String
    , issues_url : String
    , keys_url : String
    , labels_url : String
    , language : Nullable String
    , languages_url : String
    , license : Nullable LicenseSimple
    , master_branch : String
    , merges_url : String
    , milestones_url : String
    , mirror_url : Nullable String
    , name : String
    , node_id : String
    , notifications_url : String
    , open_issues : Int
    , open_issues_count : Int
    , owner : Nullable SimpleUser
    , permissions :
        { admin : Bool
        , maintain : Bool
        , pull : Bool
        , push : Bool
        , triage : Bool
        }
    , private : Bool
    , pulls_url : String
    , pushed_at : String
    , releases_url : String
    , score : Float
    , size : Int
    , ssh_url : String
    , stargazers_count : Int
    , stargazers_url : String
    , statuses_url : String
    , subscribers_url : String
    , subscription_url : String
    , svn_url : String
    , tags_url : String
    , teams_url : String
    , temp_clone_token : String
    , text_matches : SearchResultTextMatches
    , topics : List String
    , trees_url : String
    , updated_at : String
    , url : String
    , visibility : String
    , watchers : Int
    , watchers_count : Int
    , web_commit_signoff_required : Bool
    }


decodeRepoSearchResultItem : Json.Decode.Decoder RepoSearchResultItem
decodeRepoSearchResultItem =
    Json.Decode.succeed
     (\allow_auto_merge allow_forking allow_merge_commit allow_rebase_merge allow_squash_merge archive_url archived assignees_url blobs_url branches_url clone_url collaborators_url comments_url commits_url compare_url contents_url contributors_url created_at default_branch delete_branch_on_merge deployments_url description disabled downloads_url events_url fork forks forks_count forks_url full_name git_commits_url git_refs_url git_tags_url git_url has_downloads has_issues has_pages has_projects has_wiki homepage hooks_url html_url id is_template issue_comment_url issue_events_url issues_url keys_url labels_url language languages_url license master_branch merges_url milestones_url mirror_url name node_id notifications_url open_issues open_issues_count owner permissions private pulls_url pushed_at releases_url score size ssh_url stargazers_count stargazers_url statuses_url subscribers_url subscription_url svn_url tags_url teams_url temp_clone_token text_matches topics trees_url updated_at url visibility watchers watchers_count web_commit_signoff_required ->
         { allow_auto_merge = allow_auto_merge
         , allow_forking = allow_forking
         , allow_merge_commit = allow_merge_commit
         , allow_rebase_merge = allow_rebase_merge
         , allow_squash_merge = allow_squash_merge
         , archive_url = archive_url
         , archived = archived
         , assignees_url = assignees_url
         , blobs_url = blobs_url
         , branches_url = branches_url
         , clone_url = clone_url
         , collaborators_url = collaborators_url
         , comments_url = comments_url
         , commits_url = commits_url
         , compare_url = compare_url
         , contents_url = contents_url
         , contributors_url = contributors_url
         , created_at = created_at
         , default_branch = default_branch
         , delete_branch_on_merge = delete_branch_on_merge
         , deployments_url = deployments_url
         , description = description
         , disabled = disabled
         , downloads_url = downloads_url
         , events_url = events_url
         , fork = fork
         , forks = forks
         , forks_count = forks_count
         , forks_url = forks_url
         , full_name = full_name
         , git_commits_url = git_commits_url
         , git_refs_url = git_refs_url
         , git_tags_url = git_tags_url
         , git_url = git_url
         , has_downloads = has_downloads
         , has_issues = has_issues
         , has_pages = has_pages
         , has_projects = has_projects
         , has_wiki = has_wiki
         , homepage = homepage
         , hooks_url = hooks_url
         , html_url = html_url
         , id = id
         , is_template = is_template
         , issue_comment_url = issue_comment_url
         , issue_events_url = issue_events_url
         , issues_url = issues_url
         , keys_url = keys_url
         , labels_url = labels_url
         , language = language
         , languages_url = languages_url
         , license = license
         , master_branch = master_branch
         , merges_url = merges_url
         , milestones_url = milestones_url
         , mirror_url = mirror_url
         , name = name
         , node_id = node_id
         , notifications_url = notifications_url
         , open_issues = open_issues
         , open_issues_count = open_issues_count
         , owner = owner
         , permissions = permissions
         , private = private
         , pulls_url = pulls_url
         , pushed_at = pushed_at
         , releases_url = releases_url
         , score = score
         , size = size
         , ssh_url = ssh_url
         , stargazers_count = stargazers_count
         , stargazers_url = stargazers_url
         , statuses_url = statuses_url
         , subscribers_url = subscribers_url
         , subscription_url = subscription_url
         , svn_url = svn_url
         , tags_url = tags_url
         , teams_url = teams_url
         , temp_clone_token = temp_clone_token
         , text_matches = text_matches
         , topics = topics
         , trees_url = trees_url
         , updated_at = updated_at
         , url = url
         , visibility = visibility
         , watchers = watchers
         , watchers_count = watchers_count
         , web_commit_signoff_required = web_commit_signoff_required
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "allow_auto_merge" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "allow_forking" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "allow_merge_commit" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "allow_rebase_merge" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "allow_squash_merge" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "archive_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "archived" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "assignees_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "blobs_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "branches_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "clone_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "collaborators_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "comments_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "commits_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "compare_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "contents_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "contributors_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "default_branch" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "delete_branch_on_merge" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "deployments_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "description"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "disabled" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "downloads_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "events_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "fork" Json.Decode.bool)
        |> Json.Decode.Extra.andMap (Json.Decode.field "forks" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "forks_count" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "forks_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "full_name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "git_commits_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "git_refs_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "git_tags_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "git_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "has_downloads" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "has_issues" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "has_pages" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "has_projects" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "has_wiki" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "homepage"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "hooks_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "is_template" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "issue_comment_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "issue_events_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "issues_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "keys_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "labels_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "language"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "languages_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "license"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeLicenseSimple
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "master_branch" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "merges_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "milestones_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "mirror_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "notifications_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "open_issues" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "open_issues_count" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "owner"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "permissions"
                (Json.Decode.succeed
                  (\admin maintain pull push triage ->
                      { admin = admin
                      , maintain = maintain
                      , pull = pull
                      , push = push
                      , triage = triage
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "admin" Json.Decode.bool)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "maintain" Json.Decode.bool)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "pull" Json.Decode.bool)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "push" Json.Decode.bool)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "triage" Json.Decode.bool)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "private" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "pulls_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "pushed_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "releases_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "score" Json.Decode.float)
        |> Json.Decode.Extra.andMap (Json.Decode.field "size" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "ssh_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "stargazers_count" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "stargazers_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "statuses_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "subscribers_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "subscription_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "svn_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "tags_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "teams_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "temp_clone_token" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "text_matches" decodeSearchResultTextMatches)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "topics" (Json.Decode.list Json.Decode.string))
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "trees_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "visibility" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "watchers" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "watchers_count" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "web_commit_signoff_required" Json.Decode.bool)


encodeRepoSearchResultItem : RepoSearchResultItem -> Json.Encode.Value
encodeRepoSearchResultItem rec =
    Json.Encode.object
        [ ( "allow_auto_merge", Json.Encode.bool rec.allow_auto_merge )
        , ( "allow_forking", Json.Encode.bool rec.allow_forking )
        , ( "allow_merge_commit", Json.Encode.bool rec.allow_merge_commit )
        , ( "allow_rebase_merge", Json.Encode.bool rec.allow_rebase_merge )
        , ( "allow_squash_merge", Json.Encode.bool rec.allow_squash_merge )
        , ( "archive_url", Json.Encode.string rec.archive_url )
        , ( "archived", Json.Encode.bool rec.archived )
        , ( "assignees_url", Json.Encode.string rec.assignees_url )
        , ( "blobs_url", Json.Encode.string rec.blobs_url )
        , ( "branches_url", Json.Encode.string rec.branches_url )
        , ( "clone_url", Json.Encode.string rec.clone_url )
        , ( "collaborators_url", Json.Encode.string rec.collaborators_url )
        , ( "comments_url", Json.Encode.string rec.comments_url )
        , ( "commits_url", Json.Encode.string rec.commits_url )
        , ( "compare_url", Json.Encode.string rec.compare_url )
        , ( "contents_url", Json.Encode.string rec.contents_url )
        , ( "contributors_url", Json.Encode.string rec.contributors_url )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "default_branch", Json.Encode.string rec.default_branch )
        , ( "delete_branch_on_merge"
          , Json.Encode.bool rec.delete_branch_on_merge
          )
        , ( "deployments_url", Json.Encode.string rec.deployments_url )
        , ( "description"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.description
          )
        , ( "disabled", Json.Encode.bool rec.disabled )
        , ( "downloads_url", Json.Encode.string rec.downloads_url )
        , ( "events_url", Json.Encode.string rec.events_url )
        , ( "fork", Json.Encode.bool rec.fork )
        , ( "forks", Json.Encode.int rec.forks )
        , ( "forks_count", Json.Encode.int rec.forks_count )
        , ( "forks_url", Json.Encode.string rec.forks_url )
        , ( "full_name", Json.Encode.string rec.full_name )
        , ( "git_commits_url", Json.Encode.string rec.git_commits_url )
        , ( "git_refs_url", Json.Encode.string rec.git_refs_url )
        , ( "git_tags_url", Json.Encode.string rec.git_tags_url )
        , ( "git_url", Json.Encode.string rec.git_url )
        , ( "has_downloads", Json.Encode.bool rec.has_downloads )
        , ( "has_issues", Json.Encode.bool rec.has_issues )
        , ( "has_pages", Json.Encode.bool rec.has_pages )
        , ( "has_projects", Json.Encode.bool rec.has_projects )
        , ( "has_wiki", Json.Encode.bool rec.has_wiki )
        , ( "homepage"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.homepage
          )
        , ( "hooks_url", Json.Encode.string rec.hooks_url )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "id", Json.Encode.int rec.id )
        , ( "is_template", Json.Encode.bool rec.is_template )
        , ( "issue_comment_url", Json.Encode.string rec.issue_comment_url )
        , ( "issue_events_url", Json.Encode.string rec.issue_events_url )
        , ( "issues_url", Json.Encode.string rec.issues_url )
        , ( "keys_url", Json.Encode.string rec.keys_url )
        , ( "labels_url", Json.Encode.string rec.labels_url )
        , ( "language"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.language
          )
        , ( "languages_url", Json.Encode.string rec.languages_url )
        , ( "license"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeLicenseSimple value
            )
                rec.license
          )
        , ( "master_branch", Json.Encode.string rec.master_branch )
        , ( "merges_url", Json.Encode.string rec.merges_url )
        , ( "milestones_url", Json.Encode.string rec.milestones_url )
        , ( "mirror_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.mirror_url
          )
        , ( "name", Json.Encode.string rec.name )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "notifications_url", Json.Encode.string rec.notifications_url )
        , ( "open_issues", Json.Encode.int rec.open_issues )
        , ( "open_issues_count", Json.Encode.int rec.open_issues_count )
        , ( "owner"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.owner
          )
        , ( "permissions"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "admin", Json.Encode.bool rec0.admin )
                    , ( "maintain", Json.Encode.bool rec0.maintain )
                    , ( "pull", Json.Encode.bool rec0.pull )
                    , ( "push", Json.Encode.bool rec0.push )
                    , ( "triage", Json.Encode.bool rec0.triage )
                    ]
            )
                rec.permissions
          )
        , ( "private", Json.Encode.bool rec.private )
        , ( "pulls_url", Json.Encode.string rec.pulls_url )
        , ( "pushed_at", Json.Encode.string rec.pushed_at )
        , ( "releases_url", Json.Encode.string rec.releases_url )
        , ( "score", Json.Encode.float rec.score )
        , ( "size", Json.Encode.int rec.size )
        , ( "ssh_url", Json.Encode.string rec.ssh_url )
        , ( "stargazers_count", Json.Encode.int rec.stargazers_count )
        , ( "stargazers_url", Json.Encode.string rec.stargazers_url )
        , ( "statuses_url", Json.Encode.string rec.statuses_url )
        , ( "subscribers_url", Json.Encode.string rec.subscribers_url )
        , ( "subscription_url", Json.Encode.string rec.subscription_url )
        , ( "svn_url", Json.Encode.string rec.svn_url )
        , ( "tags_url", Json.Encode.string rec.tags_url )
        , ( "teams_url", Json.Encode.string rec.teams_url )
        , ( "temp_clone_token", Json.Encode.string rec.temp_clone_token )
        , ( "text_matches", encodeSearchResultTextMatches rec.text_matches )
        , ( "topics", Json.Encode.list Json.Encode.string rec.topics )
        , ( "trees_url", Json.Encode.string rec.trees_url )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        , ( "url", Json.Encode.string rec.url )
        , ( "visibility", Json.Encode.string rec.visibility )
        , ( "watchers", Json.Encode.int rec.watchers )
        , ( "watchers_count", Json.Encode.int rec.watchers_count )
        , ( "web_commit_signoff_required"
          , Json.Encode.bool rec.web_commit_signoff_required
          )
        ]


type alias RepoCodespacesSecret =
    { created_at : String, name : String, updated_at : String }


decodeRepoCodespacesSecret : Json.Decode.Decoder RepoCodespacesSecret
decodeRepoCodespacesSecret =
    Json.Decode.succeed
     (\created_at name updated_at ->
         { created_at = created_at, name = name, updated_at = updated_at }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)


encodeRepoCodespacesSecret : RepoCodespacesSecret -> Json.Encode.Value
encodeRepoCodespacesSecret rec =
    Json.Encode.object
        [ ( "created_at", Json.Encode.string rec.created_at )
        , ( "name", Json.Encode.string rec.name )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        ]


type alias RenamedIssueEvent =
    { actor : SimpleUser
    , commit_id : Nullable String
    , commit_url : Nullable String
    , created_at : String
    , event : String
    , id : Int
    , node_id : String
    , performed_via_github_app : Nullable Integration
    , rename : { from : String, to : String }
    , url : String
    }


decodeRenamedIssueEvent : Json.Decode.Decoder RenamedIssueEvent
decodeRenamedIssueEvent =
    Json.Decode.succeed
     (\actor commit_id commit_url created_at event id node_id performed_via_github_app rename url ->
         { actor = actor
         , commit_id = commit_id
         , commit_url = commit_url
         , created_at = created_at
         , event = event
         , id = id
         , node_id = node_id
         , performed_via_github_app = performed_via_github_app
         , rename = rename
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap (Json.Decode.field "actor" decodeSimpleUser)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "commit_id"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "commit_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "event" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "performed_via_github_app"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeIntegration
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "rename"
                (Json.Decode.succeed (\from to -> { from = from, to = to })
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "from" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "to" Json.Decode.string)
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeRenamedIssueEvent : RenamedIssueEvent -> Json.Encode.Value
encodeRenamedIssueEvent rec =
    Json.Encode.object
        [ ( "actor", encodeSimpleUser rec.actor )
        , ( "commit_id"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.commit_id
          )
        , ( "commit_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.commit_url
          )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "event", Json.Encode.string rec.event )
        , ( "id", Json.Encode.int rec.id )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "performed_via_github_app"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeIntegration value
            )
                rec.performed_via_github_app
          )
        , ( "rename"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "from", Json.Encode.string rec0.from )
                    , ( "to", Json.Encode.string rec0.to )
                    ]
            )
                rec.rename
          )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias RemovedFromProjectIssueEvent =
    { actor : SimpleUser
    , commit_id : Nullable String
    , commit_url : Nullable String
    , created_at : String
    , event : String
    , id : Int
    , node_id : String
    , performed_via_github_app : Nullable Integration
    , project_card :
        { column_name : String
        , id : Int
        , previous_column_name : String
        , project_id : Int
        , project_url : String
        , url : String
        }
    , url : String
    }


decodeRemovedFromProjectIssueEvent :
    Json.Decode.Decoder RemovedFromProjectIssueEvent
decodeRemovedFromProjectIssueEvent =
    Json.Decode.succeed
     (\actor commit_id commit_url created_at event id node_id performed_via_github_app project_card url ->
         { actor = actor
         , commit_id = commit_id
         , commit_url = commit_url
         , created_at = created_at
         , event = event
         , id = id
         , node_id = node_id
         , performed_via_github_app = performed_via_github_app
         , project_card = project_card
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap (Json.Decode.field "actor" decodeSimpleUser)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "commit_id"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "commit_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "event" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "performed_via_github_app"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeIntegration
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "project_card"
                (Json.Decode.succeed
                  (\column_name id previous_column_name project_id project_url url ->
                      { column_name = column_name
                      , id = id
                      , previous_column_name = previous_column_name
                      , project_id = project_id
                      , project_url = project_url
                      , url = url
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "column_name" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "id" Json.Decode.int)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "previous_column_name"
                            Json.Decode.string
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "project_id" Json.Decode.int)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "project_url" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "url" Json.Decode.string)
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeRemovedFromProjectIssueEvent :
    RemovedFromProjectIssueEvent -> Json.Encode.Value
encodeRemovedFromProjectIssueEvent rec =
    Json.Encode.object
        [ ( "actor", encodeSimpleUser rec.actor )
        , ( "commit_id"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.commit_id
          )
        , ( "commit_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.commit_url
          )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "event", Json.Encode.string rec.event )
        , ( "id", Json.Encode.int rec.id )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "performed_via_github_app"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeIntegration value
            )
                rec.performed_via_github_app
          )
        , ( "project_card"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "column_name", Json.Encode.string rec0.column_name )
                    , ( "id", Json.Encode.int rec0.id )
                    , ( "previous_column_name"
                      , Json.Encode.string rec0.previous_column_name
                      )
                    , ( "project_id", Json.Encode.int rec0.project_id )
                    , ( "project_url", Json.Encode.string rec0.project_url )
                    , ( "url", Json.Encode.string rec0.url )
                    ]
            )
                rec.project_card
          )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias ReleaseNotesContent =
    { body : String, name : String }


decodeReleaseNotesContent : Json.Decode.Decoder ReleaseNotesContent
decodeReleaseNotesContent =
    Json.Decode.succeed (\body name -> { body = body, name = name })
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "body" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)


encodeReleaseNotesContent : ReleaseNotesContent -> Json.Encode.Value
encodeReleaseNotesContent rec =
    Json.Encode.object
        [ ( "body", Json.Encode.string rec.body )
        , ( "name", Json.Encode.string rec.name )
        ]


type alias ReleaseAsset =
    { browser_download_url : String
    , content_type : String
    , created_at : String
    , download_count : Int
    , id : Int
    , label : Nullable String
    , name : String
    , node_id : String
    , size : Int
    , state : String
    , updated_at : String
    , uploader : Nullable SimpleUser
    , url : String
    }


decodeReleaseAsset : Json.Decode.Decoder ReleaseAsset
decodeReleaseAsset =
    Json.Decode.succeed
     (\browser_download_url content_type created_at download_count id label name node_id size state updated_at uploader url ->
         { browser_download_url = browser_download_url
         , content_type = content_type
         , created_at = created_at
         , download_count = download_count
         , id = id
         , label = label
         , name = name
         , node_id = node_id
         , size = size
         , state = state
         , updated_at = updated_at
         , uploader = uploader
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "browser_download_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "content_type" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "download_count" Json.Decode.int)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "label"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "size" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "state" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "uploader"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeReleaseAsset : ReleaseAsset -> Json.Encode.Value
encodeReleaseAsset rec =
    Json.Encode.object
        [ ( "browser_download_url"
          , Json.Encode.string rec.browser_download_url
          )
        , ( "content_type", Json.Encode.string rec.content_type )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "download_count", Json.Encode.int rec.download_count )
        , ( "id", Json.Encode.int rec.id )
        , ( "label"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.label
          )
        , ( "name", Json.Encode.string rec.name )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "size", Json.Encode.int rec.size )
        , ( "state", Json.Encode.string rec.state )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        , ( "uploader"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.uploader
          )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias Release =
    { assets : List ReleaseAsset
    , assets_url : String
    , author : SimpleUser
    , body : Nullable String
    , body_html : String
    , body_text : String
    , created_at : String
    , discussion_url : String
    , draft : Bool
    , html_url : String
    , id : Int
    , mentions_count : Int
    , name : Nullable String
    , node_id : String
    , prerelease : Bool
    , published_at : Nullable String
    , reactions : ReactionRollup
    , tag_name : String
    , tarball_url : Nullable String
    , target_commitish : String
    , upload_url : String
    , url : String
    , zipball_url : Nullable String
    }


decodeRelease : Json.Decode.Decoder Release
decodeRelease =
    Json.Decode.succeed
     (\assets assets_url author body body_html body_text created_at discussion_url draft html_url id mentions_count name node_id prerelease published_at reactions tag_name tarball_url target_commitish upload_url url zipball_url ->
         { assets = assets
         , assets_url = assets_url
         , author = author
         , body = body
         , body_html = body_html
         , body_text = body_text
         , created_at = created_at
         , discussion_url = discussion_url
         , draft = draft
         , html_url = html_url
         , id = id
         , mentions_count = mentions_count
         , name = name
         , node_id = node_id
         , prerelease = prerelease
         , published_at = published_at
         , reactions = reactions
         , tag_name = tag_name
         , tarball_url = tarball_url
         , target_commitish = target_commitish
         , upload_url = upload_url
         , url = url
         , zipball_url = zipball_url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "assets" (Json.Decode.list decodeReleaseAsset))
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "assets_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "author" decodeSimpleUser)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "body"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "body_html" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "body_text" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "discussion_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "draft" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "mentions_count" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "name"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "prerelease" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "published_at"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "reactions" decodeReactionRollup)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "tag_name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "tarball_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "target_commitish" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "upload_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "zipball_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )


encodeRelease : Release -> Json.Encode.Value
encodeRelease rec =
    Json.Encode.object
        [ ( "assets", Json.Encode.list encodeReleaseAsset rec.assets )
        , ( "assets_url", Json.Encode.string rec.assets_url )
        , ( "author", encodeSimpleUser rec.author )
        , ( "body"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.body
          )
        , ( "body_html", Json.Encode.string rec.body_html )
        , ( "body_text", Json.Encode.string rec.body_text )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "discussion_url", Json.Encode.string rec.discussion_url )
        , ( "draft", Json.Encode.bool rec.draft )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "id", Json.Encode.int rec.id )
        , ( "mentions_count", Json.Encode.int rec.mentions_count )
        , ( "name"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.name
          )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "prerelease", Json.Encode.bool rec.prerelease )
        , ( "published_at"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.published_at
          )
        , ( "reactions", encodeReactionRollup rec.reactions )
        , ( "tag_name", Json.Encode.string rec.tag_name )
        , ( "tarball_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.tarball_url
          )
        , ( "target_commitish", Json.Encode.string rec.target_commitish )
        , ( "upload_url", Json.Encode.string rec.upload_url )
        , ( "url", Json.Encode.string rec.url )
        , ( "zipball_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.zipball_url
          )
        ]


type alias ReferrerTraffic =
    { count : Int, referrer : String, uniques : Int }


decodeReferrerTraffic : Json.Decode.Decoder ReferrerTraffic
decodeReferrerTraffic =
    Json.Decode.succeed
     (\count referrer uniques ->
         { count = count, referrer = referrer, uniques = uniques }
     )
        |> Json.Decode.Extra.andMap (Json.Decode.field "count" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "referrer" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "uniques" Json.Decode.int)


encodeReferrerTraffic : ReferrerTraffic -> Json.Encode.Value
encodeReferrerTraffic rec =
    Json.Encode.object
        [ ( "count", Json.Encode.int rec.count )
        , ( "referrer", Json.Encode.string rec.referrer )
        , ( "uniques", Json.Encode.int rec.uniques )
        ]


type alias ReferencedWorkflow =
    { path : String, ref : String, sha : String }


decodeReferencedWorkflow : Json.Decode.Decoder ReferencedWorkflow
decodeReferencedWorkflow =
    Json.Decode.succeed (\path ref sha -> { path = path, ref = ref, sha = sha })
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "path" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "ref" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "sha" Json.Decode.string)


encodeReferencedWorkflow : ReferencedWorkflow -> Json.Encode.Value
encodeReferencedWorkflow rec =
    Json.Encode.object
        [ ( "path", Json.Encode.string rec.path )
        , ( "ref", Json.Encode.string rec.ref )
        , ( "sha", Json.Encode.string rec.sha )
        ]


type alias ReactionRollup =
    { plus1 : Int
    , minus1 : Int
    , confused : Int
    , eyes : Int
    , heart : Int
    , hooray : Int
    , laugh : Int
    , rocket : Int
    , total_count : Int
    , url : String
    }


decodeReactionRollup : Json.Decode.Decoder ReactionRollup
decodeReactionRollup =
    Json.Decode.succeed
     (\plus1 minus1 confused eyes heart hooray laugh rocket total_count url ->
         { plus1 = plus1
         , minus1 = minus1
         , confused = confused
         , eyes = eyes
         , heart = heart
         , hooray = hooray
         , laugh = laugh
         , rocket = rocket
         , total_count = total_count
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap (Json.Decode.field "+1" Json.Decode.int)
        |> Json.Decode.Extra.andMap (Json.Decode.field "-1" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "confused" Json.Decode.int)
        |> Json.Decode.Extra.andMap (Json.Decode.field "eyes" Json.Decode.int)
        |> Json.Decode.Extra.andMap (Json.Decode.field "heart" Json.Decode.int)
        |> Json.Decode.Extra.andMap (Json.Decode.field "hooray" Json.Decode.int)
        |> Json.Decode.Extra.andMap (Json.Decode.field "laugh" Json.Decode.int)
        |> Json.Decode.Extra.andMap (Json.Decode.field "rocket" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "total_count" Json.Decode.int)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeReactionRollup : ReactionRollup -> Json.Encode.Value
encodeReactionRollup rec =
    Json.Encode.object
        [ ( "+1", Json.Encode.int rec.plus1 )
        , ( "-1", Json.Encode.int rec.minus1 )
        , ( "confused", Json.Encode.int rec.confused )
        , ( "eyes", Json.Encode.int rec.eyes )
        , ( "heart", Json.Encode.int rec.heart )
        , ( "hooray", Json.Encode.int rec.hooray )
        , ( "laugh", Json.Encode.int rec.laugh )
        , ( "rocket", Json.Encode.int rec.rocket )
        , ( "total_count", Json.Encode.int rec.total_count )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias Reaction =
    { content : String
    , created_at : String
    , id : Int
    , node_id : String
    , user : Nullable SimpleUser
    }


decodeReaction : Json.Decode.Decoder Reaction
decodeReaction =
    Json.Decode.succeed
     (\content created_at id node_id user ->
         { content = content
         , created_at = created_at
         , id = id
         , node_id = node_id
         , user = user
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "content" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "user"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )


encodeReaction : Reaction -> Json.Encode.Value
encodeReaction rec =
    Json.Encode.object
        [ ( "content", Json.Encode.string rec.content )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "id", Json.Encode.int rec.id )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "user"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.user
          )
        ]


type alias RateLimitOverview =
    { rate : RateLimit
    , resources :
        { actions_runner_registration : RateLimit
        , code_scanning_upload : RateLimit
        , core : RateLimit
        , dependency_snapshots : RateLimit
        , graphql : RateLimit
        , integration_manifest : RateLimit
        , scim : RateLimit
        , search : RateLimit
        , source_import : RateLimit
        }
    }


decodeRateLimitOverview : Json.Decode.Decoder RateLimitOverview
decodeRateLimitOverview =
    Json.Decode.succeed
     (\rate resources -> { rate = rate, resources = resources })
        |> Json.Decode.Extra.andMap (Json.Decode.field "rate" decodeRateLimit)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "resources"
                (Json.Decode.succeed
                  (\actions_runner_registration code_scanning_upload core dependency_snapshots graphql integration_manifest scim search source_import ->
                      { actions_runner_registration =
                          actions_runner_registration
                      , code_scanning_upload = code_scanning_upload
                      , core = core
                      , dependency_snapshots = dependency_snapshots
                      , graphql = graphql
                      , integration_manifest = integration_manifest
                      , scim = scim
                      , search = search
                      , source_import = source_import
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "actions_runner_registration"
                            decodeRateLimit
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "code_scanning_upload"
                            decodeRateLimit
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "core" decodeRateLimit)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "dependency_snapshots"
                            decodeRateLimit
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "graphql" decodeRateLimit)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "integration_manifest"
                            decodeRateLimit
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "scim" decodeRateLimit)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "search" decodeRateLimit)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "source_import" decodeRateLimit)
                )
            )


encodeRateLimitOverview : RateLimitOverview -> Json.Encode.Value
encodeRateLimitOverview rec =
    Json.Encode.object
        [ ( "rate", encodeRateLimit rec.rate )
        , ( "resources"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "actions_runner_registration"
                      , encodeRateLimit rec0.actions_runner_registration
                      )
                    , ( "code_scanning_upload"
                      , encodeRateLimit rec0.code_scanning_upload
                      )
                    , ( "core", encodeRateLimit rec0.core )
                    , ( "dependency_snapshots"
                      , encodeRateLimit rec0.dependency_snapshots
                      )
                    , ( "graphql", encodeRateLimit rec0.graphql )
                    , ( "integration_manifest"
                      , encodeRateLimit rec0.integration_manifest
                      )
                    , ( "scim", encodeRateLimit rec0.scim )
                    , ( "search", encodeRateLimit rec0.search )
                    , ( "source_import", encodeRateLimit rec0.source_import )
                    ]
            )
                rec.resources
          )
        ]


type alias RateLimit =
    { limit : Int, remaining : Int, reset : Int, used : Int }


decodeRateLimit : Json.Decode.Decoder RateLimit
decodeRateLimit =
    Json.Decode.succeed
     (\limit remaining reset used ->
         { limit = limit, remaining = remaining, reset = reset, used = used }
     )
        |> Json.Decode.Extra.andMap (Json.Decode.field "limit" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "remaining" Json.Decode.int)
        |> Json.Decode.Extra.andMap (Json.Decode.field "reset" Json.Decode.int)
        |> Json.Decode.Extra.andMap (Json.Decode.field "used" Json.Decode.int)


encodeRateLimit : RateLimit -> Json.Encode.Value
encodeRateLimit rec =
    Json.Encode.object
        [ ( "limit", Json.Encode.int rec.limit )
        , ( "remaining", Json.Encode.int rec.remaining )
        , ( "reset", Json.Encode.int rec.reset )
        , ( "used", Json.Encode.int rec.used )
        ]


type alias PullRequestSimple =
    { _links :
        { comments : Link
        , commits : Link
        , html : Link
        , issue : Link
        , review_comment : Link
        , review_comments : Link
        , self : Link
        , statuses : Link
        }
    , active_lock_reason : Nullable String
    , assignee : Nullable SimpleUser
    , assignees : Nullable (List SimpleUser)
    , author_association : AuthorAssociation
    , auto_merge : AutoMerge
    , base :
        { label : String
        , ref : String
        , repo : Repository
        , sha : String
        , user : Nullable SimpleUser
        }
    , body : Nullable String
    , closed_at : Nullable String
    , comments_url : String
    , commits_url : String
    , created_at : String
    , diff_url : String
    , draft : Bool
    , head :
        { label : String
        , ref : String
        , repo : Repository
        , sha : String
        , user : Nullable SimpleUser
        }
    , html_url : String
    , id : Int
    , issue_url : String
    , labels :
        List { color : String
        , default : Bool
        , description : String
        , id : Int
        , name : String
        , node_id : String
        , url : String
        }
    , locked : Bool
    , merge_commit_sha : Nullable String
    , merged_at : Nullable String
    , milestone : Nullable Milestone
    , node_id : String
    , number : Int
    , patch_url : String
    , requested_reviewers : Nullable (List SimpleUser)
    , requested_teams : Nullable (List Team)
    , review_comment_url : String
    , review_comments_url : String
    , state : String
    , statuses_url : String
    , title : String
    , updated_at : String
    , url : String
    , user : Nullable SimpleUser
    }


decodePullRequestSimple : Json.Decode.Decoder PullRequestSimple
decodePullRequestSimple =
    Json.Decode.succeed
     (\_links active_lock_reason assignee assignees author_association auto_merge base body closed_at comments_url commits_url created_at diff_url draft head html_url id issue_url labels locked merge_commit_sha merged_at milestone node_id number patch_url requested_reviewers requested_teams review_comment_url review_comments_url state statuses_url title updated_at url user ->
         { _links = _links
         , active_lock_reason = active_lock_reason
         , assignee = assignee
         , assignees = assignees
         , author_association = author_association
         , auto_merge = auto_merge
         , base = base
         , body = body
         , closed_at = closed_at
         , comments_url = comments_url
         , commits_url = commits_url
         , created_at = created_at
         , diff_url = diff_url
         , draft = draft
         , head = head
         , html_url = html_url
         , id = id
         , issue_url = issue_url
         , labels = labels
         , locked = locked
         , merge_commit_sha = merge_commit_sha
         , merged_at = merged_at
         , milestone = milestone
         , node_id = node_id
         , number = number
         , patch_url = patch_url
         , requested_reviewers = requested_reviewers
         , requested_teams = requested_teams
         , review_comment_url = review_comment_url
         , review_comments_url = review_comments_url
         , state = state
         , statuses_url = statuses_url
         , title = title
         , updated_at = updated_at
         , url = url
         , user = user
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "_links"
                (Json.Decode.succeed
                  (\comments commits html issue review_comment review_comments self statuses ->
                      { comments = comments
                      , commits = commits
                      , html = html
                      , issue = issue
                      , review_comment = review_comment
                      , review_comments = review_comments
                      , self = self
                      , statuses = statuses
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "comments" decodeLink)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "commits" decodeLink)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "html" decodeLink)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "issue" decodeLink)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "review_comment" decodeLink)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "review_comments" decodeLink)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "self" decodeLink)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "statuses" decodeLink)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "active_lock_reason"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "assignee"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "assignees"
                (Json.Decode.oneOf
                    [ Json.Decode.map
                        Present
                        (Json.Decode.list decodeSimpleUser)
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "author_association" decodeAuthorAssociation)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "auto_merge" decodeAutoMerge)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "base"
                (Json.Decode.succeed
                  (\label ref repo sha user ->
                      { label = label
                      , ref = ref
                      , repo = repo
                      , sha = sha
                      , user = user
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "label" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "ref" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "repo" decodeRepository)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "sha" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "user"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present decodeSimpleUser
                                , Json.Decode.null Null
                                ]
                            )
                        )
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "body"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "closed_at"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "comments_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "commits_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "diff_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "draft" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "head"
                (Json.Decode.succeed
                  (\label ref repo sha user ->
                      { label = label
                      , ref = ref
                      , repo = repo
                      , sha = sha
                      , user = user
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "label" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "ref" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "repo" decodeRepository)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "sha" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "user"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present decodeSimpleUser
                                , Json.Decode.null Null
                                ]
                            )
                        )
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "issue_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "labels"
                (Json.Decode.list
                    (Json.Decode.succeed
                      (\color default description id name node_id url ->
                          { color = color
                          , default = default
                          , description = description
                          , id = id
                          , name = name
                          , node_id = node_id
                          , url = url
                          }
                      )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "color" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "default" Json.Decode.bool)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "description" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "id" Json.Decode.int)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "name" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "node_id" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "url" Json.Decode.string)
                    )
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "locked" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "merge_commit_sha"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "merged_at"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "milestone"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeMilestone
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "number" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "patch_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "requested_reviewers"
                (Json.Decode.oneOf
                    [ Json.Decode.map
                        Present
                        (Json.Decode.list decodeSimpleUser)
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "requested_teams"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present (Json.Decode.list decodeTeam)
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "review_comment_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "review_comments_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "state" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "statuses_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "title" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "user"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )


encodePullRequestSimple : PullRequestSimple -> Json.Encode.Value
encodePullRequestSimple rec =
    Json.Encode.object
        [ ( "_links"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "comments", encodeLink rec0.comments )
                    , ( "commits", encodeLink rec0.commits )
                    , ( "html", encodeLink rec0.html )
                    , ( "issue", encodeLink rec0.issue )
                    , ( "review_comment", encodeLink rec0.review_comment )
                    , ( "review_comments", encodeLink rec0.review_comments )
                    , ( "self", encodeLink rec0.self )
                    , ( "statuses", encodeLink rec0.statuses )
                    ]
            )
                rec._links
          )
        , ( "active_lock_reason"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.active_lock_reason
          )
        , ( "assignee"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.assignee
          )
        , ( "assignees"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.list encodeSimpleUser value
            )
                rec.assignees
          )
        , ( "author_association"
          , encodeAuthorAssociation rec.author_association
          )
        , ( "auto_merge", encodeAutoMerge rec.auto_merge )
        , ( "base"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "label", Json.Encode.string rec0.label )
                    , ( "ref", Json.Encode.string rec0.ref )
                    , ( "repo", encodeRepository rec0.repo )
                    , ( "sha", Json.Encode.string rec0.sha )
                    , ( "user"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    encodeSimpleUser value
                        )
                            rec0.user
                      )
                    ]
            )
                rec.base
          )
        , ( "body"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.body
          )
        , ( "closed_at"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.closed_at
          )
        , ( "comments_url", Json.Encode.string rec.comments_url )
        , ( "commits_url", Json.Encode.string rec.commits_url )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "diff_url", Json.Encode.string rec.diff_url )
        , ( "draft", Json.Encode.bool rec.draft )
        , ( "head"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "label", Json.Encode.string rec0.label )
                    , ( "ref", Json.Encode.string rec0.ref )
                    , ( "repo", encodeRepository rec0.repo )
                    , ( "sha", Json.Encode.string rec0.sha )
                    , ( "user"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    encodeSimpleUser value
                        )
                            rec0.user
                      )
                    ]
            )
                rec.head
          )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "id", Json.Encode.int rec.id )
        , ( "issue_url", Json.Encode.string rec.issue_url )
        , ( "labels"
          , Json.Encode.list
                (\rec0 ->
                    Json.Encode.object
                        [ ( "color", Json.Encode.string rec0.color )
                        , ( "default", Json.Encode.bool rec0.default )
                        , ( "description", Json.Encode.string rec0.description )
                        , ( "id", Json.Encode.int rec0.id )
                        , ( "name", Json.Encode.string rec0.name )
                        , ( "node_id", Json.Encode.string rec0.node_id )
                        , ( "url", Json.Encode.string rec0.url )
                        ]
                )
                rec.labels
          )
        , ( "locked", Json.Encode.bool rec.locked )
        , ( "merge_commit_sha"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.merge_commit_sha
          )
        , ( "merged_at"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.merged_at
          )
        , ( "milestone"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeMilestone value
            )
                rec.milestone
          )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "number", Json.Encode.int rec.number )
        , ( "patch_url", Json.Encode.string rec.patch_url )
        , ( "requested_reviewers"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.list encodeSimpleUser value
            )
                rec.requested_reviewers
          )
        , ( "requested_teams"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.list encodeTeam value
            )
                rec.requested_teams
          )
        , ( "review_comment_url", Json.Encode.string rec.review_comment_url )
        , ( "review_comments_url", Json.Encode.string rec.review_comments_url )
        , ( "state", Json.Encode.string rec.state )
        , ( "statuses_url", Json.Encode.string rec.statuses_url )
        , ( "title", Json.Encode.string rec.title )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        , ( "url", Json.Encode.string rec.url )
        , ( "user"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.user
          )
        ]


type alias PullRequestReviewRequest =
    { teams : List Team, users : List SimpleUser }


decodePullRequestReviewRequest : Json.Decode.Decoder PullRequestReviewRequest
decodePullRequestReviewRequest =
    Json.Decode.succeed (\teams users -> { teams = teams, users = users })
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "teams" (Json.Decode.list decodeTeam))
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "users" (Json.Decode.list decodeSimpleUser))


encodePullRequestReviewRequest : PullRequestReviewRequest -> Json.Encode.Value
encodePullRequestReviewRequest rec =
    Json.Encode.object
        [ ( "teams", Json.Encode.list encodeTeam rec.teams )
        , ( "users", Json.Encode.list encodeSimpleUser rec.users )
        ]


type alias PullRequestReviewComment =
    { _links :
        { html : { href : String }
        , pull_request : { href : String }
        , self : { href : String }
        }
    , author_association : AuthorAssociation
    , body : String
    , body_html : String
    , body_text : String
    , commit_id : String
    , created_at : String
    , diff_hunk : String
    , html_url : String
    , id : Int
    , in_reply_to_id : Int
    , line : Int
    , node_id : String
    , original_commit_id : String
    , original_line : Int
    , original_position : Int
    , original_start_line : Nullable Int
    , path : String
    , position : Int
    , pull_request_review_id : Nullable Int
    , pull_request_url : String
    , reactions : ReactionRollup
    , side : String
    , start_line : Nullable Int
    , start_side : Nullable String
    , updated_at : String
    , url : String
    , user : SimpleUser
    }


decodePullRequestReviewComment : Json.Decode.Decoder PullRequestReviewComment
decodePullRequestReviewComment =
    Json.Decode.succeed
     (\_links author_association body body_html body_text commit_id created_at diff_hunk html_url id in_reply_to_id line node_id original_commit_id original_line original_position original_start_line path position pull_request_review_id pull_request_url reactions side start_line start_side updated_at url user ->
         { _links = _links
         , author_association = author_association
         , body = body
         , body_html = body_html
         , body_text = body_text
         , commit_id = commit_id
         , created_at = created_at
         , diff_hunk = diff_hunk
         , html_url = html_url
         , id = id
         , in_reply_to_id = in_reply_to_id
         , line = line
         , node_id = node_id
         , original_commit_id = original_commit_id
         , original_line = original_line
         , original_position = original_position
         , original_start_line = original_start_line
         , path = path
         , position = position
         , pull_request_review_id = pull_request_review_id
         , pull_request_url = pull_request_url
         , reactions = reactions
         , side = side
         , start_line = start_line
         , start_side = start_side
         , updated_at = updated_at
         , url = url
         , user = user
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "_links"
                (Json.Decode.succeed
                  (\html pull_request self ->
                      { html = html, pull_request = pull_request, self = self }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "html"
                            (Json.Decode.succeed (\href -> { href = href })
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field "href" Json.Decode.string
                                    )
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "pull_request"
                            (Json.Decode.succeed (\href -> { href = href })
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field "href" Json.Decode.string
                                    )
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "self"
                            (Json.Decode.succeed (\href -> { href = href })
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field "href" Json.Decode.string
                                    )
                            )
                        )
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "author_association" decodeAuthorAssociation)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "body" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "body_html" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "body_text" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "commit_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "diff_hunk" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "in_reply_to_id" Json.Decode.int)
        |> Json.Decode.Extra.andMap (Json.Decode.field "line" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "original_commit_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "original_line" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "original_position" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "original_start_line"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.int
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "path" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "position" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "pull_request_review_id"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.int
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "pull_request_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "reactions" decodeReactionRollup)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "side" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "start_line"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.int
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "start_side"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "user" decodeSimpleUser)


encodePullRequestReviewComment : PullRequestReviewComment -> Json.Encode.Value
encodePullRequestReviewComment rec =
    Json.Encode.object
        [ ( "_links"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "html"
                      , (\rec_0_1_1_1_0_1_1_0_0 ->
                            Json.Encode.object
                                [ ( "href"
                                  , Json.Encode.string
                                        rec_0_1_1_1_0_1_1_0_0.href
                                  )
                                ]
                        )
                            rec0.html
                      )
                    , ( "pull_request"
                      , (\rec_0_2_1_1_0_1_1_0_0 ->
                            Json.Encode.object
                                [ ( "href"
                                  , Json.Encode.string
                                        rec_0_2_1_1_0_1_1_0_0.href
                                  )
                                ]
                        )
                            rec0.pull_request
                      )
                    , ( "self"
                      , (\rec_0_3_1_1_0_1_1_0_0 ->
                            Json.Encode.object
                                [ ( "href"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_1_1_0_0.href
                                  )
                                ]
                        )
                            rec0.self
                      )
                    ]
            )
                rec._links
          )
        , ( "author_association"
          , encodeAuthorAssociation rec.author_association
          )
        , ( "body", Json.Encode.string rec.body )
        , ( "body_html", Json.Encode.string rec.body_html )
        , ( "body_text", Json.Encode.string rec.body_text )
        , ( "commit_id", Json.Encode.string rec.commit_id )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "diff_hunk", Json.Encode.string rec.diff_hunk )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "id", Json.Encode.int rec.id )
        , ( "in_reply_to_id", Json.Encode.int rec.in_reply_to_id )
        , ( "line", Json.Encode.int rec.line )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "original_commit_id", Json.Encode.string rec.original_commit_id )
        , ( "original_line", Json.Encode.int rec.original_line )
        , ( "original_position", Json.Encode.int rec.original_position )
        , ( "original_start_line"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.int value
            )
                rec.original_start_line
          )
        , ( "path", Json.Encode.string rec.path )
        , ( "position", Json.Encode.int rec.position )
        , ( "pull_request_review_id"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.int value
            )
                rec.pull_request_review_id
          )
        , ( "pull_request_url", Json.Encode.string rec.pull_request_url )
        , ( "reactions", encodeReactionRollup rec.reactions )
        , ( "side", Json.Encode.string rec.side )
        , ( "start_line"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.int value
            )
                rec.start_line
          )
        , ( "start_side"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.start_side
          )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        , ( "url", Json.Encode.string rec.url )
        , ( "user", encodeSimpleUser rec.user )
        ]


type alias PullRequestReview =
    { _links : { html : { href : String }, pull_request : { href : String } }
    , author_association : AuthorAssociation
    , body : String
    , body_html : String
    , body_text : String
    , commit_id : String
    , html_url : String
    , id : Int
    , node_id : String
    , pull_request_url : String
    , state : String
    , submitted_at : String
    , user : Nullable SimpleUser
    }


decodePullRequestReview : Json.Decode.Decoder PullRequestReview
decodePullRequestReview =
    Json.Decode.succeed
     (\_links author_association body body_html body_text commit_id html_url id node_id pull_request_url state submitted_at user ->
         { _links = _links
         , author_association = author_association
         , body = body
         , body_html = body_html
         , body_text = body_text
         , commit_id = commit_id
         , html_url = html_url
         , id = id
         , node_id = node_id
         , pull_request_url = pull_request_url
         , state = state
         , submitted_at = submitted_at
         , user = user
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "_links"
                (Json.Decode.succeed
                  (\html pull_request ->
                      { html = html, pull_request = pull_request }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "html"
                            (Json.Decode.succeed (\href -> { href = href })
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field "href" Json.Decode.string
                                    )
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "pull_request"
                            (Json.Decode.succeed (\href -> { href = href })
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field "href" Json.Decode.string
                                    )
                            )
                        )
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "author_association" decodeAuthorAssociation)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "body" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "body_html" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "body_text" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "commit_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "pull_request_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "state" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "submitted_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "user"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )


encodePullRequestReview : PullRequestReview -> Json.Encode.Value
encodePullRequestReview rec =
    Json.Encode.object
        [ ( "_links"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "html"
                      , (\rec_0_1_1_1_0_1_1_0_0 ->
                            Json.Encode.object
                                [ ( "href"
                                  , Json.Encode.string
                                        rec_0_1_1_1_0_1_1_0_0.href
                                  )
                                ]
                        )
                            rec0.html
                      )
                    , ( "pull_request"
                      , (\rec_0_2_1_1_0_1_1_0_0 ->
                            Json.Encode.object
                                [ ( "href"
                                  , Json.Encode.string
                                        rec_0_2_1_1_0_1_1_0_0.href
                                  )
                                ]
                        )
                            rec0.pull_request
                      )
                    ]
            )
                rec._links
          )
        , ( "author_association"
          , encodeAuthorAssociation rec.author_association
          )
        , ( "body", Json.Encode.string rec.body )
        , ( "body_html", Json.Encode.string rec.body_html )
        , ( "body_text", Json.Encode.string rec.body_text )
        , ( "commit_id", Json.Encode.string rec.commit_id )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "id", Json.Encode.int rec.id )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "pull_request_url", Json.Encode.string rec.pull_request_url )
        , ( "state", Json.Encode.string rec.state )
        , ( "submitted_at", Json.Encode.string rec.submitted_at )
        , ( "user"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.user
          )
        ]


type alias PullRequestMinimal =
    { base :
        { ref : String
        , repo : { id : Int, name : String, url : String }
        , sha : String
        }
    , head :
        { ref : String
        , repo : { id : Int, name : String, url : String }
        , sha : String
        }
    , id : Int
    , number : Int
    , url : String
    }


decodePullRequestMinimal : Json.Decode.Decoder PullRequestMinimal
decodePullRequestMinimal =
    Json.Decode.succeed
     (\base head id number url ->
         { base = base, head = head, id = id, number = number, url = url }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "base"
                (Json.Decode.succeed
                  (\ref repo sha -> { ref = ref, repo = repo, sha = sha })
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "ref" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "repo"
                            (Json.Decode.succeed
                              (\id name url ->
                                  { id = id, name = name, url = url }
                              )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field "id" Json.Decode.int)
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field "name" Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field "url" Json.Decode.string)
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "sha" Json.Decode.string)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "head"
                (Json.Decode.succeed
                  (\ref repo sha -> { ref = ref, repo = repo, sha = sha })
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "ref" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "repo"
                            (Json.Decode.succeed
                              (\id name url ->
                                  { id = id, name = name, url = url }
                              )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field "id" Json.Decode.int)
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field "name" Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field "url" Json.Decode.string)
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "sha" Json.Decode.string)
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap (Json.Decode.field "number" Json.Decode.int)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodePullRequestMinimal : PullRequestMinimal -> Json.Encode.Value
encodePullRequestMinimal rec =
    Json.Encode.object
        [ ( "base"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "ref", Json.Encode.string rec0.ref )
                    , ( "repo"
                      , (\rec_0_2_1_1_0_1_1_0_0 ->
                            Json.Encode.object
                                [ ( "id"
                                  , Json.Encode.int rec_0_2_1_1_0_1_1_0_0.id
                                  )
                                , ( "name"
                                  , Json.Encode.string
                                        rec_0_2_1_1_0_1_1_0_0.name
                                  )
                                , ( "url"
                                  , Json.Encode.string rec_0_2_1_1_0_1_1_0_0.url
                                  )
                                ]
                        )
                            rec0.repo
                      )
                    , ( "sha", Json.Encode.string rec0.sha )
                    ]
            )
                rec.base
          )
        , ( "head"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "ref", Json.Encode.string rec0.ref )
                    , ( "repo"
                      , (\rec_0_2_1_1_0_2_1_0_0 ->
                            Json.Encode.object
                                [ ( "id"
                                  , Json.Encode.int rec_0_2_1_1_0_2_1_0_0.id
                                  )
                                , ( "name"
                                  , Json.Encode.string
                                        rec_0_2_1_1_0_2_1_0_0.name
                                  )
                                , ( "url"
                                  , Json.Encode.string rec_0_2_1_1_0_2_1_0_0.url
                                  )
                                ]
                        )
                            rec0.repo
                      )
                    , ( "sha", Json.Encode.string rec0.sha )
                    ]
            )
                rec.head
          )
        , ( "id", Json.Encode.int rec.id )
        , ( "number", Json.Encode.int rec.number )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias PullRequestMergeResult =
    { merged : Bool, message : String, sha : String }


decodePullRequestMergeResult : Json.Decode.Decoder PullRequestMergeResult
decodePullRequestMergeResult =
    Json.Decode.succeed
     (\merged message sha -> { merged = merged, message = message, sha = sha })
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "merged" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "message" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "sha" Json.Decode.string)


encodePullRequestMergeResult : PullRequestMergeResult -> Json.Encode.Value
encodePullRequestMergeResult rec =
    Json.Encode.object
        [ ( "merged", Json.Encode.bool rec.merged )
        , ( "message", Json.Encode.string rec.message )
        , ( "sha", Json.Encode.string rec.sha )
        ]


type alias PullRequest =
    { _links :
        { comments : Link
        , commits : Link
        , html : Link
        , issue : Link
        , review_comment : Link
        , review_comments : Link
        , self : Link
        , statuses : Link
        }
    , active_lock_reason : Nullable String
    , additions : Int
    , assignee : Nullable SimpleUser
    , assignees : Nullable (List SimpleUser)
    , author_association : AuthorAssociation
    , auto_merge : AutoMerge
    , base :
        { label : String
        , ref : String
        , repo :
            { allow_forking : Bool
            , allow_merge_commit : Bool
            , allow_rebase_merge : Bool
            , allow_squash_merge : Bool
            , archive_url : String
            , archived : Bool
            , assignees_url : String
            , blobs_url : String
            , branches_url : String
            , clone_url : String
            , collaborators_url : String
            , comments_url : String
            , commits_url : String
            , compare_url : String
            , contents_url : String
            , contributors_url : String
            , created_at : String
            , default_branch : String
            , deployments_url : String
            , description : Nullable String
            , disabled : Bool
            , downloads_url : String
            , events_url : String
            , fork : Bool
            , forks : Int
            , forks_count : Int
            , forks_url : String
            , full_name : String
            , git_commits_url : String
            , git_refs_url : String
            , git_tags_url : String
            , git_url : String
            , has_downloads : Bool
            , has_issues : Bool
            , has_pages : Bool
            , has_projects : Bool
            , has_wiki : Bool
            , homepage : Nullable String
            , hooks_url : String
            , html_url : String
            , id : Int
            , is_template : Bool
            , issue_comment_url : String
            , issue_events_url : String
            , issues_url : String
            , keys_url : String
            , labels_url : String
            , language : Nullable String
            , languages_url : String
            , license : Nullable LicenseSimple
            , master_branch : String
            , merges_url : String
            , milestones_url : String
            , mirror_url : Nullable String
            , name : String
            , node_id : String
            , notifications_url : String
            , open_issues : Int
            , open_issues_count : Int
            , owner :
                { avatar_url : String
                , events_url : String
                , followers_url : String
                , following_url : String
                , gists_url : String
                , gravatar_id : Nullable String
                , html_url : String
                , id : Int
                , login : String
                , node_id : String
                , organizations_url : String
                , received_events_url : String
                , repos_url : String
                , site_admin : Bool
                , starred_url : String
                , subscriptions_url : String
                , type_ : String
                , url : String
                }
            , permissions :
                { admin : Bool
                , maintain : Bool
                , pull : Bool
                , push : Bool
                , triage : Bool
                }
            , private : Bool
            , pulls_url : String
            , pushed_at : String
            , releases_url : String
            , size : Int
            , ssh_url : String
            , stargazers_count : Int
            , stargazers_url : String
            , statuses_url : String
            , subscribers_url : String
            , subscription_url : String
            , svn_url : String
            , tags_url : String
            , teams_url : String
            , temp_clone_token : String
            , topics : List String
            , trees_url : String
            , updated_at : String
            , url : String
            , visibility : String
            , watchers : Int
            , watchers_count : Int
            , web_commit_signoff_required : Bool
            }
        , sha : String
        , user :
            { avatar_url : String
            , events_url : String
            , followers_url : String
            , following_url : String
            , gists_url : String
            , gravatar_id : Nullable String
            , html_url : String
            , id : Int
            , login : String
            , node_id : String
            , organizations_url : String
            , received_events_url : String
            , repos_url : String
            , site_admin : Bool
            , starred_url : String
            , subscriptions_url : String
            , type_ : String
            , url : String
            }
        }
    , body : Nullable String
    , changed_files : Int
    , closed_at : Nullable String
    , comments : Int
    , comments_url : String
    , commits : Int
    , commits_url : String
    , created_at : String
    , deletions : Int
    , diff_url : String
    , draft : Bool
    , head :
        { label : String
        , ref : String
        , repo :
            Nullable { allow_forking : Bool
            , allow_merge_commit : Bool
            , allow_rebase_merge : Bool
            , allow_squash_merge : Bool
            , archive_url : String
            , archived : Bool
            , assignees_url : String
            , blobs_url : String
            , branches_url : String
            , clone_url : String
            , collaborators_url : String
            , comments_url : String
            , commits_url : String
            , compare_url : String
            , contents_url : String
            , contributors_url : String
            , created_at : String
            , default_branch : String
            , deployments_url : String
            , description : Nullable String
            , disabled : Bool
            , downloads_url : String
            , events_url : String
            , fork : Bool
            , forks : Int
            , forks_count : Int
            , forks_url : String
            , full_name : String
            , git_commits_url : String
            , git_refs_url : String
            , git_tags_url : String
            , git_url : String
            , has_downloads : Bool
            , has_issues : Bool
            , has_pages : Bool
            , has_projects : Bool
            , has_wiki : Bool
            , homepage : Nullable String
            , hooks_url : String
            , html_url : String
            , id : Int
            , is_template : Bool
            , issue_comment_url : String
            , issue_events_url : String
            , issues_url : String
            , keys_url : String
            , labels_url : String
            , language : Nullable String
            , languages_url : String
            , license :
                Nullable { key : String
                , name : String
                , node_id : String
                , spdx_id : Nullable String
                , url : Nullable String
                }
            , master_branch : String
            , merges_url : String
            , milestones_url : String
            , mirror_url : Nullable String
            , name : String
            , node_id : String
            , notifications_url : String
            , open_issues : Int
            , open_issues_count : Int
            , owner :
                { avatar_url : String
                , events_url : String
                , followers_url : String
                , following_url : String
                , gists_url : String
                , gravatar_id : Nullable String
                , html_url : String
                , id : Int
                , login : String
                , node_id : String
                , organizations_url : String
                , received_events_url : String
                , repos_url : String
                , site_admin : Bool
                , starred_url : String
                , subscriptions_url : String
                , type_ : String
                , url : String
                }
            , permissions :
                { admin : Bool
                , maintain : Bool
                , pull : Bool
                , push : Bool
                , triage : Bool
                }
            , private : Bool
            , pulls_url : String
            , pushed_at : String
            , releases_url : String
            , size : Int
            , ssh_url : String
            , stargazers_count : Int
            , stargazers_url : String
            , statuses_url : String
            , subscribers_url : String
            , subscription_url : String
            , svn_url : String
            , tags_url : String
            , teams_url : String
            , temp_clone_token : String
            , topics : List String
            , trees_url : String
            , updated_at : String
            , url : String
            , visibility : String
            , watchers : Int
            , watchers_count : Int
            , web_commit_signoff_required : Bool
            }
        , sha : String
        , user :
            { avatar_url : String
            , events_url : String
            , followers_url : String
            , following_url : String
            , gists_url : String
            , gravatar_id : Nullable String
            , html_url : String
            , id : Int
            , login : String
            , node_id : String
            , organizations_url : String
            , received_events_url : String
            , repos_url : String
            , site_admin : Bool
            , starred_url : String
            , subscriptions_url : String
            , type_ : String
            , url : String
            }
        }
    , html_url : String
    , id : Int
    , issue_url : String
    , labels :
        List { color : String
        , default : Bool
        , description : Nullable String
        , id : Int
        , name : String
        , node_id : String
        , url : String
        }
    , locked : Bool
    , maintainer_can_modify : Bool
    , merge_commit_sha : Nullable String
    , mergeable : Nullable Bool
    , mergeable_state : String
    , merged : Bool
    , merged_at : Nullable String
    , merged_by : Nullable SimpleUser
    , milestone : Nullable Milestone
    , node_id : String
    , number : Int
    , patch_url : String
    , rebaseable : Nullable Bool
    , requested_reviewers : Nullable (List SimpleUser)
    , requested_teams : Nullable (List TeamSimple)
    , review_comment_url : String
    , review_comments : Int
    , review_comments_url : String
    , state : String
    , statuses_url : String
    , title : String
    , updated_at : String
    , url : String
    , user : Nullable SimpleUser
    }


decodePullRequest : Json.Decode.Decoder PullRequest
decodePullRequest =
    Json.Decode.succeed
     (\_links active_lock_reason additions assignee assignees author_association auto_merge base body changed_files closed_at comments comments_url commits commits_url created_at deletions diff_url draft head html_url id issue_url labels locked maintainer_can_modify merge_commit_sha mergeable mergeable_state merged merged_at merged_by milestone node_id number patch_url rebaseable requested_reviewers requested_teams review_comment_url review_comments review_comments_url state statuses_url title updated_at url user ->
         { _links = _links
         , active_lock_reason = active_lock_reason
         , additions = additions
         , assignee = assignee
         , assignees = assignees
         , author_association = author_association
         , auto_merge = auto_merge
         , base = base
         , body = body
         , changed_files = changed_files
         , closed_at = closed_at
         , comments = comments
         , comments_url = comments_url
         , commits = commits
         , commits_url = commits_url
         , created_at = created_at
         , deletions = deletions
         , diff_url = diff_url
         , draft = draft
         , head = head
         , html_url = html_url
         , id = id
         , issue_url = issue_url
         , labels = labels
         , locked = locked
         , maintainer_can_modify = maintainer_can_modify
         , merge_commit_sha = merge_commit_sha
         , mergeable = mergeable
         , mergeable_state = mergeable_state
         , merged = merged
         , merged_at = merged_at
         , merged_by = merged_by
         , milestone = milestone
         , node_id = node_id
         , number = number
         , patch_url = patch_url
         , rebaseable = rebaseable
         , requested_reviewers = requested_reviewers
         , requested_teams = requested_teams
         , review_comment_url = review_comment_url
         , review_comments = review_comments
         , review_comments_url = review_comments_url
         , state = state
         , statuses_url = statuses_url
         , title = title
         , updated_at = updated_at
         , url = url
         , user = user
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "_links"
                (Json.Decode.succeed
                  (\comments commits html issue review_comment review_comments self statuses ->
                      { comments = comments
                      , commits = commits
                      , html = html
                      , issue = issue
                      , review_comment = review_comment
                      , review_comments = review_comments
                      , self = self
                      , statuses = statuses
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "comments" decodeLink)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "commits" decodeLink)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "html" decodeLink)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "issue" decodeLink)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "review_comment" decodeLink)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "review_comments" decodeLink)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "self" decodeLink)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "statuses" decodeLink)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "active_lock_reason"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "additions" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "assignee"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "assignees"
                (Json.Decode.oneOf
                    [ Json.Decode.map
                        Present
                        (Json.Decode.list decodeSimpleUser)
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "author_association" decodeAuthorAssociation)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "auto_merge" decodeAutoMerge)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "base"
                (Json.Decode.succeed
                  (\label ref repo sha user ->
                      { label = label
                      , ref = ref
                      , repo = repo
                      , sha = sha
                      , user = user
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "label" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "ref" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "repo"
                            (Json.Decode.succeed
                              (\allow_forking allow_merge_commit allow_rebase_merge allow_squash_merge archive_url archived assignees_url blobs_url branches_url clone_url collaborators_url comments_url commits_url compare_url contents_url contributors_url created_at default_branch deployments_url description disabled downloads_url events_url fork forks forks_count forks_url full_name git_commits_url git_refs_url git_tags_url git_url has_downloads has_issues has_pages has_projects has_wiki homepage hooks_url html_url id is_template issue_comment_url issue_events_url issues_url keys_url labels_url language languages_url license master_branch merges_url milestones_url mirror_url name node_id notifications_url open_issues open_issues_count owner permissions private pulls_url pushed_at releases_url size ssh_url stargazers_count stargazers_url statuses_url subscribers_url subscription_url svn_url tags_url teams_url temp_clone_token topics trees_url updated_at url visibility watchers watchers_count web_commit_signoff_required ->
                                  { allow_forking = allow_forking
                                  , allow_merge_commit = allow_merge_commit
                                  , allow_rebase_merge = allow_rebase_merge
                                  , allow_squash_merge = allow_squash_merge
                                  , archive_url = archive_url
                                  , archived = archived
                                  , assignees_url = assignees_url
                                  , blobs_url = blobs_url
                                  , branches_url = branches_url
                                  , clone_url = clone_url
                                  , collaborators_url = collaborators_url
                                  , comments_url = comments_url
                                  , commits_url = commits_url
                                  , compare_url = compare_url
                                  , contents_url = contents_url
                                  , contributors_url = contributors_url
                                  , created_at = created_at
                                  , default_branch = default_branch
                                  , deployments_url = deployments_url
                                  , description = description
                                  , disabled = disabled
                                  , downloads_url = downloads_url
                                  , events_url = events_url
                                  , fork = fork
                                  , forks = forks
                                  , forks_count = forks_count
                                  , forks_url = forks_url
                                  , full_name = full_name
                                  , git_commits_url = git_commits_url
                                  , git_refs_url = git_refs_url
                                  , git_tags_url = git_tags_url
                                  , git_url = git_url
                                  , has_downloads = has_downloads
                                  , has_issues = has_issues
                                  , has_pages = has_pages
                                  , has_projects = has_projects
                                  , has_wiki = has_wiki
                                  , homepage = homepage
                                  , hooks_url = hooks_url
                                  , html_url = html_url
                                  , id = id
                                  , is_template = is_template
                                  , issue_comment_url = issue_comment_url
                                  , issue_events_url = issue_events_url
                                  , issues_url = issues_url
                                  , keys_url = keys_url
                                  , labels_url = labels_url
                                  , language = language
                                  , languages_url = languages_url
                                  , license = license
                                  , master_branch = master_branch
                                  , merges_url = merges_url
                                  , milestones_url = milestones_url
                                  , mirror_url = mirror_url
                                  , name = name
                                  , node_id = node_id
                                  , notifications_url = notifications_url
                                  , open_issues = open_issues
                                  , open_issues_count = open_issues_count
                                  , owner = owner
                                  , permissions = permissions
                                  , private = private
                                  , pulls_url = pulls_url
                                  , pushed_at = pushed_at
                                  , releases_url = releases_url
                                  , size = size
                                  , ssh_url = ssh_url
                                  , stargazers_count = stargazers_count
                                  , stargazers_url = stargazers_url
                                  , statuses_url = statuses_url
                                  , subscribers_url = subscribers_url
                                  , subscription_url = subscription_url
                                  , svn_url = svn_url
                                  , tags_url = tags_url
                                  , teams_url = teams_url
                                  , temp_clone_token = temp_clone_token
                                  , topics = topics
                                  , trees_url = trees_url
                                  , updated_at = updated_at
                                  , url = url
                                  , visibility = visibility
                                  , watchers = watchers
                                  , watchers_count = watchers_count
                                  , web_commit_signoff_required =
                                      web_commit_signoff_required
                                  }
                              )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "allow_forking"
                                        Json.Decode.bool
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "allow_merge_commit"
                                        Json.Decode.bool
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "allow_rebase_merge"
                                        Json.Decode.bool
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "allow_squash_merge"
                                        Json.Decode.bool
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "archive_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "archived"
                                        Json.Decode.bool
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "assignees_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "blobs_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "branches_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "clone_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "collaborators_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "comments_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "commits_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "compare_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "contents_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "contributors_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "created_at"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "default_branch"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "deployments_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "description"
                                        (Json.Decode.oneOf
                                            [ Json.Decode.map
                                                Present
                                                Json.Decode.string
                                            , Json.Decode.null Null
                                            ]
                                        )
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "disabled"
                                        Json.Decode.bool
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "downloads_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "events_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field "fork" Json.Decode.bool)
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field "forks" Json.Decode.int)
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "forks_count"
                                        Json.Decode.int
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "forks_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "full_name"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "git_commits_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "git_refs_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "git_tags_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "git_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "has_downloads"
                                        Json.Decode.bool
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "has_issues"
                                        Json.Decode.bool
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "has_pages"
                                        Json.Decode.bool
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "has_projects"
                                        Json.Decode.bool
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "has_wiki"
                                        Json.Decode.bool
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "homepage"
                                        (Json.Decode.oneOf
                                            [ Json.Decode.map
                                                Present
                                                Json.Decode.string
                                            , Json.Decode.null Null
                                            ]
                                        )
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "hooks_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "html_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field "id" Json.Decode.int)
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "is_template"
                                        Json.Decode.bool
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "issue_comment_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "issue_events_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "issues_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "keys_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "labels_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "language"
                                        (Json.Decode.oneOf
                                            [ Json.Decode.map
                                                Present
                                                Json.Decode.string
                                            , Json.Decode.null Null
                                            ]
                                        )
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "languages_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "license"
                                        (Json.Decode.oneOf
                                            [ Json.Decode.map
                                                Present
                                                decodeLicenseSimple
                                            , Json.Decode.null Null
                                            ]
                                        )
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "master_branch"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "merges_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "milestones_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "mirror_url"
                                        (Json.Decode.oneOf
                                            [ Json.Decode.map
                                                Present
                                                Json.Decode.string
                                            , Json.Decode.null Null
                                            ]
                                        )
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field "name" Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "node_id"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "notifications_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "open_issues"
                                        Json.Decode.int
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "open_issues_count"
                                        Json.Decode.int
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "owner"
                                        (Json.Decode.succeed
                                          (\avatar_url events_url followers_url following_url gists_url gravatar_id html_url id login node_id organizations_url received_events_url repos_url site_admin starred_url subscriptions_url type_ url ->
                                              { avatar_url = avatar_url
                                              , events_url = events_url
                                              , followers_url = followers_url
                                              , following_url = following_url
                                              , gists_url = gists_url
                                              , gravatar_id = gravatar_id
                                              , html_url = html_url
                                              , id = id
                                              , login = login
                                              , node_id = node_id
                                              , organizations_url =
                                                  organizations_url
                                              , received_events_url =
                                                  received_events_url
                                              , repos_url = repos_url
                                              , site_admin = site_admin
                                              , starred_url = starred_url
                                              , subscriptions_url =
                                                  subscriptions_url
                                              , type_ = type_
                                              , url = url
                                              }
                                          )
                                            |> Json.Decode.Extra.andMap
                                                (Json.Decode.field
                                                    "avatar_url"
                                                    Json.Decode.string
                                                )
                                            |> Json.Decode.Extra.andMap
                                                (Json.Decode.field
                                                    "events_url"
                                                    Json.Decode.string
                                                )
                                            |> Json.Decode.Extra.andMap
                                                (Json.Decode.field
                                                    "followers_url"
                                                    Json.Decode.string
                                                )
                                            |> Json.Decode.Extra.andMap
                                                (Json.Decode.field
                                                    "following_url"
                                                    Json.Decode.string
                                                )
                                            |> Json.Decode.Extra.andMap
                                                (Json.Decode.field
                                                    "gists_url"
                                                    Json.Decode.string
                                                )
                                            |> Json.Decode.Extra.andMap
                                                (Json.Decode.field
                                                    "gravatar_id"
                                                    (Json.Decode.oneOf
                                                        [ Json.Decode.map
                                                            Present
                                                            Json.Decode.string
                                                        , Json.Decode.null Null
                                                        ]
                                                    )
                                                )
                                            |> Json.Decode.Extra.andMap
                                                (Json.Decode.field
                                                    "html_url"
                                                    Json.Decode.string
                                                )
                                            |> Json.Decode.Extra.andMap
                                                (Json.Decode.field
                                                    "id"
                                                    Json.Decode.int
                                                )
                                            |> Json.Decode.Extra.andMap
                                                (Json.Decode.field
                                                    "login"
                                                    Json.Decode.string
                                                )
                                            |> Json.Decode.Extra.andMap
                                                (Json.Decode.field
                                                    "node_id"
                                                    Json.Decode.string
                                                )
                                            |> Json.Decode.Extra.andMap
                                                (Json.Decode.field
                                                    "organizations_url"
                                                    Json.Decode.string
                                                )
                                            |> Json.Decode.Extra.andMap
                                                (Json.Decode.field
                                                    "received_events_url"
                                                    Json.Decode.string
                                                )
                                            |> Json.Decode.Extra.andMap
                                                (Json.Decode.field
                                                    "repos_url"
                                                    Json.Decode.string
                                                )
                                            |> Json.Decode.Extra.andMap
                                                (Json.Decode.field
                                                    "site_admin"
                                                    Json.Decode.bool
                                                )
                                            |> Json.Decode.Extra.andMap
                                                (Json.Decode.field
                                                    "starred_url"
                                                    Json.Decode.string
                                                )
                                            |> Json.Decode.Extra.andMap
                                                (Json.Decode.field
                                                    "subscriptions_url"
                                                    Json.Decode.string
                                                )
                                            |> Json.Decode.Extra.andMap
                                                (Json.Decode.field
                                                    "type"
                                                    Json.Decode.string
                                                )
                                            |> Json.Decode.Extra.andMap
                                                (Json.Decode.field
                                                    "url"
                                                    Json.Decode.string
                                                )
                                        )
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "permissions"
                                        (Json.Decode.succeed
                                          (\admin maintain pull push triage ->
                                              { admin = admin
                                              , maintain = maintain
                                              , pull = pull
                                              , push = push
                                              , triage = triage
                                              }
                                          )
                                            |> Json.Decode.Extra.andMap
                                                (Json.Decode.field
                                                    "admin"
                                                    Json.Decode.bool
                                                )
                                            |> Json.Decode.Extra.andMap
                                                (Json.Decode.field
                                                    "maintain"
                                                    Json.Decode.bool
                                                )
                                            |> Json.Decode.Extra.andMap
                                                (Json.Decode.field
                                                    "pull"
                                                    Json.Decode.bool
                                                )
                                            |> Json.Decode.Extra.andMap
                                                (Json.Decode.field
                                                    "push"
                                                    Json.Decode.bool
                                                )
                                            |> Json.Decode.Extra.andMap
                                                (Json.Decode.field
                                                    "triage"
                                                    Json.Decode.bool
                                                )
                                        )
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "private"
                                        Json.Decode.bool
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "pulls_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "pushed_at"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "releases_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field "size" Json.Decode.int)
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "ssh_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "stargazers_count"
                                        Json.Decode.int
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "stargazers_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "statuses_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "subscribers_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "subscription_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "svn_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "tags_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "teams_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "temp_clone_token"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "topics"
                                        (Json.Decode.list Json.Decode.string)
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "trees_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "updated_at"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field "url" Json.Decode.string)
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "visibility"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "watchers"
                                        Json.Decode.int
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "watchers_count"
                                        Json.Decode.int
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "web_commit_signoff_required"
                                        Json.Decode.bool
                                    )
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "sha" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "user"
                            (Json.Decode.succeed
                              (\avatar_url events_url followers_url following_url gists_url gravatar_id html_url id login node_id organizations_url received_events_url repos_url site_admin starred_url subscriptions_url type_ url ->
                                  { avatar_url = avatar_url
                                  , events_url = events_url
                                  , followers_url = followers_url
                                  , following_url = following_url
                                  , gists_url = gists_url
                                  , gravatar_id = gravatar_id
                                  , html_url = html_url
                                  , id = id
                                  , login = login
                                  , node_id = node_id
                                  , organizations_url = organizations_url
                                  , received_events_url = received_events_url
                                  , repos_url = repos_url
                                  , site_admin = site_admin
                                  , starred_url = starred_url
                                  , subscriptions_url = subscriptions_url
                                  , type_ = type_
                                  , url = url
                                  }
                              )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "avatar_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "events_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "followers_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "following_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "gists_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "gravatar_id"
                                        (Json.Decode.oneOf
                                            [ Json.Decode.map
                                                Present
                                                Json.Decode.string
                                            , Json.Decode.null Null
                                            ]
                                        )
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "html_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field "id" Json.Decode.int)
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "login"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "node_id"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "organizations_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "received_events_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "repos_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "site_admin"
                                        Json.Decode.bool
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "starred_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "subscriptions_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field "type" Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field "url" Json.Decode.string)
                            )
                        )
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "body"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "changed_files" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "closed_at"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "comments" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "comments_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "commits" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "commits_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "deletions" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "diff_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "draft" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "head"
                (Json.Decode.succeed
                  (\label ref repo sha user ->
                      { label = label
                      , ref = ref
                      , repo = repo
                      , sha = sha
                      , user = user
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "label" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "ref" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "repo"
                            (Json.Decode.oneOf
                                [ Json.Decode.map
                                    Present
                                    (Json.Decode.succeed
                                      (\allow_forking allow_merge_commit allow_rebase_merge allow_squash_merge archive_url archived assignees_url blobs_url branches_url clone_url collaborators_url comments_url commits_url compare_url contents_url contributors_url created_at default_branch deployments_url description disabled downloads_url events_url fork forks forks_count forks_url full_name git_commits_url git_refs_url git_tags_url git_url has_downloads has_issues has_pages has_projects has_wiki homepage hooks_url html_url id is_template issue_comment_url issue_events_url issues_url keys_url labels_url language languages_url license master_branch merges_url milestones_url mirror_url name node_id notifications_url open_issues open_issues_count owner permissions private pulls_url pushed_at releases_url size ssh_url stargazers_count stargazers_url statuses_url subscribers_url subscription_url svn_url tags_url teams_url temp_clone_token topics trees_url updated_at url visibility watchers watchers_count web_commit_signoff_required ->
                                          { allow_forking = allow_forking
                                          , allow_merge_commit =
                                              allow_merge_commit
                                          , allow_rebase_merge =
                                              allow_rebase_merge
                                          , allow_squash_merge =
                                              allow_squash_merge
                                          , archive_url = archive_url
                                          , archived = archived
                                          , assignees_url = assignees_url
                                          , blobs_url = blobs_url
                                          , branches_url = branches_url
                                          , clone_url = clone_url
                                          , collaborators_url =
                                              collaborators_url
                                          , comments_url = comments_url
                                          , commits_url = commits_url
                                          , compare_url = compare_url
                                          , contents_url = contents_url
                                          , contributors_url = contributors_url
                                          , created_at = created_at
                                          , default_branch = default_branch
                                          , deployments_url = deployments_url
                                          , description = description
                                          , disabled = disabled
                                          , downloads_url = downloads_url
                                          , events_url = events_url
                                          , fork = fork
                                          , forks = forks
                                          , forks_count = forks_count
                                          , forks_url = forks_url
                                          , full_name = full_name
                                          , git_commits_url = git_commits_url
                                          , git_refs_url = git_refs_url
                                          , git_tags_url = git_tags_url
                                          , git_url = git_url
                                          , has_downloads = has_downloads
                                          , has_issues = has_issues
                                          , has_pages = has_pages
                                          , has_projects = has_projects
                                          , has_wiki = has_wiki
                                          , homepage = homepage
                                          , hooks_url = hooks_url
                                          , html_url = html_url
                                          , id = id
                                          , is_template = is_template
                                          , issue_comment_url =
                                              issue_comment_url
                                          , issue_events_url = issue_events_url
                                          , issues_url = issues_url
                                          , keys_url = keys_url
                                          , labels_url = labels_url
                                          , language = language
                                          , languages_url = languages_url
                                          , license = license
                                          , master_branch = master_branch
                                          , merges_url = merges_url
                                          , milestones_url = milestones_url
                                          , mirror_url = mirror_url
                                          , name = name
                                          , node_id = node_id
                                          , notifications_url =
                                              notifications_url
                                          , open_issues = open_issues
                                          , open_issues_count =
                                              open_issues_count
                                          , owner = owner
                                          , permissions = permissions
                                          , private = private
                                          , pulls_url = pulls_url
                                          , pushed_at = pushed_at
                                          , releases_url = releases_url
                                          , size = size
                                          , ssh_url = ssh_url
                                          , stargazers_count = stargazers_count
                                          , stargazers_url = stargazers_url
                                          , statuses_url = statuses_url
                                          , subscribers_url = subscribers_url
                                          , subscription_url = subscription_url
                                          , svn_url = svn_url
                                          , tags_url = tags_url
                                          , teams_url = teams_url
                                          , temp_clone_token = temp_clone_token
                                          , topics = topics
                                          , trees_url = trees_url
                                          , updated_at = updated_at
                                          , url = url
                                          , visibility = visibility
                                          , watchers = watchers
                                          , watchers_count = watchers_count
                                          , web_commit_signoff_required =
                                              web_commit_signoff_required
                                          }
                                      )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "allow_forking"
                                                Json.Decode.bool
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "allow_merge_commit"
                                                Json.Decode.bool
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "allow_rebase_merge"
                                                Json.Decode.bool
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "allow_squash_merge"
                                                Json.Decode.bool
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "archive_url"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "archived"
                                                Json.Decode.bool
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "assignees_url"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "blobs_url"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "branches_url"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "clone_url"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "collaborators_url"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "comments_url"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "commits_url"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "compare_url"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "contents_url"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "contributors_url"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "created_at"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "default_branch"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "deployments_url"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "description"
                                                (Json.Decode.oneOf
                                                    [ Json.Decode.map
                                                        Present
                                                        Json.Decode.string
                                                    , Json.Decode.null Null
                                                    ]
                                                )
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "disabled"
                                                Json.Decode.bool
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "downloads_url"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "events_url"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "fork"
                                                Json.Decode.bool
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "forks"
                                                Json.Decode.int
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "forks_count"
                                                Json.Decode.int
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "forks_url"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "full_name"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "git_commits_url"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "git_refs_url"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "git_tags_url"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "git_url"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "has_downloads"
                                                Json.Decode.bool
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "has_issues"
                                                Json.Decode.bool
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "has_pages"
                                                Json.Decode.bool
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "has_projects"
                                                Json.Decode.bool
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "has_wiki"
                                                Json.Decode.bool
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "homepage"
                                                (Json.Decode.oneOf
                                                    [ Json.Decode.map
                                                        Present
                                                        Json.Decode.string
                                                    , Json.Decode.null Null
                                                    ]
                                                )
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "hooks_url"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "html_url"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "id"
                                                Json.Decode.int
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "is_template"
                                                Json.Decode.bool
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "issue_comment_url"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "issue_events_url"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "issues_url"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "keys_url"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "labels_url"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "language"
                                                (Json.Decode.oneOf
                                                    [ Json.Decode.map
                                                        Present
                                                        Json.Decode.string
                                                    , Json.Decode.null Null
                                                    ]
                                                )
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "languages_url"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "license"
                                                (Json.Decode.oneOf
                                                    [ Json.Decode.map
                                                        Present
                                                        (Json.Decode.succeed
                                                          (\key name node_id spdx_id url ->
                                                              { key = key
                                                              , name = name
                                                              , node_id =
                                                                  node_id
                                                              , spdx_id =
                                                                  spdx_id
                                                              , url = url
                                                              }
                                                          )
                                                            |> Json.Decode.Extra.andMap
                                                                (Json.Decode.field
                                                                    "key"
                                                                    Json.Decode.string
                                                                )
                                                            |> Json.Decode.Extra.andMap
                                                                (Json.Decode.field
                                                                    "name"
                                                                    Json.Decode.string
                                                                )
                                                            |> Json.Decode.Extra.andMap
                                                                (Json.Decode.field
                                                                    "node_id"
                                                                    Json.Decode.string
                                                                )
                                                            |> Json.Decode.Extra.andMap
                                                                (Json.Decode.field
                                                                    "spdx_id"
                                                                    (Json.Decode.oneOf
                                                                        [ Json.Decode.map
                                                                            Present
                                                                            Json.Decode.string
                                                                        , Json.Decode.null
                                                                            Null
                                                                        ]
                                                                    )
                                                                )
                                                            |> Json.Decode.Extra.andMap
                                                                (Json.Decode.field
                                                                    "url"
                                                                    (Json.Decode.oneOf
                                                                        [ Json.Decode.map
                                                                            Present
                                                                            Json.Decode.string
                                                                        , Json.Decode.null
                                                                            Null
                                                                        ]
                                                                    )
                                                                )
                                                        )
                                                    , Json.Decode.null Null
                                                    ]
                                                )
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "master_branch"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "merges_url"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "milestones_url"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "mirror_url"
                                                (Json.Decode.oneOf
                                                    [ Json.Decode.map
                                                        Present
                                                        Json.Decode.string
                                                    , Json.Decode.null Null
                                                    ]
                                                )
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "name"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "node_id"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "notifications_url"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "open_issues"
                                                Json.Decode.int
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "open_issues_count"
                                                Json.Decode.int
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "owner"
                                                (Json.Decode.succeed
                                                  (\avatar_url events_url followers_url following_url gists_url gravatar_id html_url id login node_id organizations_url received_events_url repos_url site_admin starred_url subscriptions_url type_ url ->
                                                      { avatar_url = avatar_url
                                                      , events_url = events_url
                                                      , followers_url =
                                                          followers_url
                                                      , following_url =
                                                          following_url
                                                      , gists_url = gists_url
                                                      , gravatar_id =
                                                          gravatar_id
                                                      , html_url = html_url
                                                      , id = id
                                                      , login = login
                                                      , node_id = node_id
                                                      , organizations_url =
                                                          organizations_url
                                                      , received_events_url =
                                                          received_events_url
                                                      , repos_url = repos_url
                                                      , site_admin = site_admin
                                                      , starred_url =
                                                          starred_url
                                                      , subscriptions_url =
                                                          subscriptions_url
                                                      , type_ = type_
                                                      , url = url
                                                      }
                                                  )
                                                    |> Json.Decode.Extra.andMap
                                                        (Json.Decode.field
                                                            "avatar_url"
                                                            Json.Decode.string
                                                        )
                                                    |> Json.Decode.Extra.andMap
                                                        (Json.Decode.field
                                                            "events_url"
                                                            Json.Decode.string
                                                        )
                                                    |> Json.Decode.Extra.andMap
                                                        (Json.Decode.field
                                                            "followers_url"
                                                            Json.Decode.string
                                                        )
                                                    |> Json.Decode.Extra.andMap
                                                        (Json.Decode.field
                                                            "following_url"
                                                            Json.Decode.string
                                                        )
                                                    |> Json.Decode.Extra.andMap
                                                        (Json.Decode.field
                                                            "gists_url"
                                                            Json.Decode.string
                                                        )
                                                    |> Json.Decode.Extra.andMap
                                                        (Json.Decode.field
                                                            "gravatar_id"
                                                            (Json.Decode.oneOf
                                                                [ Json.Decode.map
                                                                    Present
                                                                    Json.Decode.string
                                                                , Json.Decode.null
                                                                    Null
                                                                ]
                                                            )
                                                        )
                                                    |> Json.Decode.Extra.andMap
                                                        (Json.Decode.field
                                                            "html_url"
                                                            Json.Decode.string
                                                        )
                                                    |> Json.Decode.Extra.andMap
                                                        (Json.Decode.field
                                                            "id"
                                                            Json.Decode.int
                                                        )
                                                    |> Json.Decode.Extra.andMap
                                                        (Json.Decode.field
                                                            "login"
                                                            Json.Decode.string
                                                        )
                                                    |> Json.Decode.Extra.andMap
                                                        (Json.Decode.field
                                                            "node_id"
                                                            Json.Decode.string
                                                        )
                                                    |> Json.Decode.Extra.andMap
                                                        (Json.Decode.field
                                                            "organizations_url"
                                                            Json.Decode.string
                                                        )
                                                    |> Json.Decode.Extra.andMap
                                                        (Json.Decode.field
                                                            "received_events_url"
                                                            Json.Decode.string
                                                        )
                                                    |> Json.Decode.Extra.andMap
                                                        (Json.Decode.field
                                                            "repos_url"
                                                            Json.Decode.string
                                                        )
                                                    |> Json.Decode.Extra.andMap
                                                        (Json.Decode.field
                                                            "site_admin"
                                                            Json.Decode.bool
                                                        )
                                                    |> Json.Decode.Extra.andMap
                                                        (Json.Decode.field
                                                            "starred_url"
                                                            Json.Decode.string
                                                        )
                                                    |> Json.Decode.Extra.andMap
                                                        (Json.Decode.field
                                                            "subscriptions_url"
                                                            Json.Decode.string
                                                        )
                                                    |> Json.Decode.Extra.andMap
                                                        (Json.Decode.field
                                                            "type"
                                                            Json.Decode.string
                                                        )
                                                    |> Json.Decode.Extra.andMap
                                                        (Json.Decode.field
                                                            "url"
                                                            Json.Decode.string
                                                        )
                                                )
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "permissions"
                                                (Json.Decode.succeed
                                                  (\admin maintain pull push triage ->
                                                      { admin = admin
                                                      , maintain = maintain
                                                      , pull = pull
                                                      , push = push
                                                      , triage = triage
                                                      }
                                                  )
                                                    |> Json.Decode.Extra.andMap
                                                        (Json.Decode.field
                                                            "admin"
                                                            Json.Decode.bool
                                                        )
                                                    |> Json.Decode.Extra.andMap
                                                        (Json.Decode.field
                                                            "maintain"
                                                            Json.Decode.bool
                                                        )
                                                    |> Json.Decode.Extra.andMap
                                                        (Json.Decode.field
                                                            "pull"
                                                            Json.Decode.bool
                                                        )
                                                    |> Json.Decode.Extra.andMap
                                                        (Json.Decode.field
                                                            "push"
                                                            Json.Decode.bool
                                                        )
                                                    |> Json.Decode.Extra.andMap
                                                        (Json.Decode.field
                                                            "triage"
                                                            Json.Decode.bool
                                                        )
                                                )
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "private"
                                                Json.Decode.bool
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "pulls_url"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "pushed_at"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "releases_url"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "size"
                                                Json.Decode.int
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "ssh_url"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "stargazers_count"
                                                Json.Decode.int
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "stargazers_url"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "statuses_url"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "subscribers_url"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "subscription_url"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "svn_url"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "tags_url"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "teams_url"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "temp_clone_token"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "topics"
                                                (Json.Decode.list
                                                    Json.Decode.string
                                                )
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "trees_url"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "updated_at"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "url"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "visibility"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "watchers"
                                                Json.Decode.int
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "watchers_count"
                                                Json.Decode.int
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "web_commit_signoff_required"
                                                Json.Decode.bool
                                            )
                                    )
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "sha" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "user"
                            (Json.Decode.succeed
                              (\avatar_url events_url followers_url following_url gists_url gravatar_id html_url id login node_id organizations_url received_events_url repos_url site_admin starred_url subscriptions_url type_ url ->
                                  { avatar_url = avatar_url
                                  , events_url = events_url
                                  , followers_url = followers_url
                                  , following_url = following_url
                                  , gists_url = gists_url
                                  , gravatar_id = gravatar_id
                                  , html_url = html_url
                                  , id = id
                                  , login = login
                                  , node_id = node_id
                                  , organizations_url = organizations_url
                                  , received_events_url = received_events_url
                                  , repos_url = repos_url
                                  , site_admin = site_admin
                                  , starred_url = starred_url
                                  , subscriptions_url = subscriptions_url
                                  , type_ = type_
                                  , url = url
                                  }
                              )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "avatar_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "events_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "followers_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "following_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "gists_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "gravatar_id"
                                        (Json.Decode.oneOf
                                            [ Json.Decode.map
                                                Present
                                                Json.Decode.string
                                            , Json.Decode.null Null
                                            ]
                                        )
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "html_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field "id" Json.Decode.int)
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "login"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "node_id"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "organizations_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "received_events_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "repos_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "site_admin"
                                        Json.Decode.bool
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "starred_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "subscriptions_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field "type" Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field "url" Json.Decode.string)
                            )
                        )
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "issue_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "labels"
                (Json.Decode.list
                    (Json.Decode.succeed
                      (\color default description id name node_id url ->
                          { color = color
                          , default = default
                          , description = description
                          , id = id
                          , name = name
                          , node_id = node_id
                          , url = url
                          }
                      )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "color" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "default" Json.Decode.bool)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field
                                "description"
                                (Json.Decode.oneOf
                                    [ Json.Decode.map Present Json.Decode.string
                                    , Json.Decode.null Null
                                    ]
                                )
                            )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "id" Json.Decode.int)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "name" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "node_id" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "url" Json.Decode.string)
                    )
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "locked" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "maintainer_can_modify" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "merge_commit_sha"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "mergeable"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.bool
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "mergeable_state" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "merged" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "merged_at"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "merged_by"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "milestone"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeMilestone
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "number" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "patch_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "rebaseable"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.bool
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "requested_reviewers"
                (Json.Decode.oneOf
                    [ Json.Decode.map
                        Present
                        (Json.Decode.list decodeSimpleUser)
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "requested_teams"
                (Json.Decode.oneOf
                    [ Json.Decode.map
                        Present
                        (Json.Decode.list decodeTeamSimple)
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "review_comment_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "review_comments" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "review_comments_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "state" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "statuses_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "title" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "user"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )


encodePullRequest : PullRequest -> Json.Encode.Value
encodePullRequest rec =
    Json.Encode.object
        [ ( "_links"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "comments", encodeLink rec0.comments )
                    , ( "commits", encodeLink rec0.commits )
                    , ( "html", encodeLink rec0.html )
                    , ( "issue", encodeLink rec0.issue )
                    , ( "review_comment", encodeLink rec0.review_comment )
                    , ( "review_comments", encodeLink rec0.review_comments )
                    , ( "self", encodeLink rec0.self )
                    , ( "statuses", encodeLink rec0.statuses )
                    ]
            )
                rec._links
          )
        , ( "active_lock_reason"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.active_lock_reason
          )
        , ( "additions", Json.Encode.int rec.additions )
        , ( "assignee"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.assignee
          )
        , ( "assignees"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.list encodeSimpleUser value
            )
                rec.assignees
          )
        , ( "author_association"
          , encodeAuthorAssociation rec.author_association
          )
        , ( "auto_merge", encodeAutoMerge rec.auto_merge )
        , ( "base"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "label", Json.Encode.string rec0.label )
                    , ( "ref", Json.Encode.string rec0.ref )
                    , ( "repo"
                      , (\rec_0_3_1_1_0_8_1_0_0 ->
                            Json.Encode.object
                                [ ( "allow_forking"
                                  , Json.Encode.bool
                                        rec_0_3_1_1_0_8_1_0_0.allow_forking
                                  )
                                , ( "allow_merge_commit"
                                  , Json.Encode.bool
                                        rec_0_3_1_1_0_8_1_0_0.allow_merge_commit
                                  )
                                , ( "allow_rebase_merge"
                                  , Json.Encode.bool
                                        rec_0_3_1_1_0_8_1_0_0.allow_rebase_merge
                                  )
                                , ( "allow_squash_merge"
                                  , Json.Encode.bool
                                        rec_0_3_1_1_0_8_1_0_0.allow_squash_merge
                                  )
                                , ( "archive_url"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_8_1_0_0.archive_url
                                  )
                                , ( "archived"
                                  , Json.Encode.bool
                                        rec_0_3_1_1_0_8_1_0_0.archived
                                  )
                                , ( "assignees_url"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_8_1_0_0.assignees_url
                                  )
                                , ( "blobs_url"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_8_1_0_0.blobs_url
                                  )
                                , ( "branches_url"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_8_1_0_0.branches_url
                                  )
                                , ( "clone_url"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_8_1_0_0.clone_url
                                  )
                                , ( "collaborators_url"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_8_1_0_0.collaborators_url
                                  )
                                , ( "comments_url"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_8_1_0_0.comments_url
                                  )
                                , ( "commits_url"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_8_1_0_0.commits_url
                                  )
                                , ( "compare_url"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_8_1_0_0.compare_url
                                  )
                                , ( "contents_url"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_8_1_0_0.contents_url
                                  )
                                , ( "contributors_url"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_8_1_0_0.contributors_url
                                  )
                                , ( "created_at"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_8_1_0_0.created_at
                                  )
                                , ( "default_branch"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_8_1_0_0.default_branch
                                  )
                                , ( "deployments_url"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_8_1_0_0.deployments_url
                                  )
                                , ( "description"
                                  , (\nullableValue ->
                                        case nullableValue of
                                            Null ->
                                                Json.Encode.null

                                            Present value ->
                                                Json.Encode.string value
                                    )
                                        rec_0_3_1_1_0_8_1_0_0.description
                                  )
                                , ( "disabled"
                                  , Json.Encode.bool
                                        rec_0_3_1_1_0_8_1_0_0.disabled
                                  )
                                , ( "downloads_url"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_8_1_0_0.downloads_url
                                  )
                                , ( "events_url"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_8_1_0_0.events_url
                                  )
                                , ( "fork"
                                  , Json.Encode.bool rec_0_3_1_1_0_8_1_0_0.fork
                                  )
                                , ( "forks"
                                  , Json.Encode.int rec_0_3_1_1_0_8_1_0_0.forks
                                  )
                                , ( "forks_count"
                                  , Json.Encode.int
                                        rec_0_3_1_1_0_8_1_0_0.forks_count
                                  )
                                , ( "forks_url"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_8_1_0_0.forks_url
                                  )
                                , ( "full_name"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_8_1_0_0.full_name
                                  )
                                , ( "git_commits_url"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_8_1_0_0.git_commits_url
                                  )
                                , ( "git_refs_url"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_8_1_0_0.git_refs_url
                                  )
                                , ( "git_tags_url"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_8_1_0_0.git_tags_url
                                  )
                                , ( "git_url"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_8_1_0_0.git_url
                                  )
                                , ( "has_downloads"
                                  , Json.Encode.bool
                                        rec_0_3_1_1_0_8_1_0_0.has_downloads
                                  )
                                , ( "has_issues"
                                  , Json.Encode.bool
                                        rec_0_3_1_1_0_8_1_0_0.has_issues
                                  )
                                , ( "has_pages"
                                  , Json.Encode.bool
                                        rec_0_3_1_1_0_8_1_0_0.has_pages
                                  )
                                , ( "has_projects"
                                  , Json.Encode.bool
                                        rec_0_3_1_1_0_8_1_0_0.has_projects
                                  )
                                , ( "has_wiki"
                                  , Json.Encode.bool
                                        rec_0_3_1_1_0_8_1_0_0.has_wiki
                                  )
                                , ( "homepage"
                                  , (\nullableValue ->
                                        case nullableValue of
                                            Null ->
                                                Json.Encode.null

                                            Present value ->
                                                Json.Encode.string value
                                    )
                                        rec_0_3_1_1_0_8_1_0_0.homepage
                                  )
                                , ( "hooks_url"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_8_1_0_0.hooks_url
                                  )
                                , ( "html_url"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_8_1_0_0.html_url
                                  )
                                , ( "id"
                                  , Json.Encode.int rec_0_3_1_1_0_8_1_0_0.id
                                  )
                                , ( "is_template"
                                  , Json.Encode.bool
                                        rec_0_3_1_1_0_8_1_0_0.is_template
                                  )
                                , ( "issue_comment_url"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_8_1_0_0.issue_comment_url
                                  )
                                , ( "issue_events_url"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_8_1_0_0.issue_events_url
                                  )
                                , ( "issues_url"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_8_1_0_0.issues_url
                                  )
                                , ( "keys_url"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_8_1_0_0.keys_url
                                  )
                                , ( "labels_url"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_8_1_0_0.labels_url
                                  )
                                , ( "language"
                                  , (\nullableValue ->
                                        case nullableValue of
                                            Null ->
                                                Json.Encode.null

                                            Present value ->
                                                Json.Encode.string value
                                    )
                                        rec_0_3_1_1_0_8_1_0_0.language
                                  )
                                , ( "languages_url"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_8_1_0_0.languages_url
                                  )
                                , ( "license"
                                  , (\nullableValue ->
                                        case nullableValue of
                                            Null ->
                                                Json.Encode.null

                                            Present value ->
                                                encodeLicenseSimple value
                                    )
                                        rec_0_3_1_1_0_8_1_0_0.license
                                  )
                                , ( "master_branch"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_8_1_0_0.master_branch
                                  )
                                , ( "merges_url"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_8_1_0_0.merges_url
                                  )
                                , ( "milestones_url"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_8_1_0_0.milestones_url
                                  )
                                , ( "mirror_url"
                                  , (\nullableValue ->
                                        case nullableValue of
                                            Null ->
                                                Json.Encode.null

                                            Present value ->
                                                Json.Encode.string value
                                    )
                                        rec_0_3_1_1_0_8_1_0_0.mirror_url
                                  )
                                , ( "name"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_8_1_0_0.name
                                  )
                                , ( "node_id"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_8_1_0_0.node_id
                                  )
                                , ( "notifications_url"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_8_1_0_0.notifications_url
                                  )
                                , ( "open_issues"
                                  , Json.Encode.int
                                        rec_0_3_1_1_0_8_1_0_0.open_issues
                                  )
                                , ( "open_issues_count"
                                  , Json.Encode.int
                                        rec_0_3_1_1_0_8_1_0_0.open_issues_count
                                  )
                                , ( "owner"
                                  , (\rec_0_60_1_1_0_3_1_1_0_8_1_0_0 ->
                                        Json.Encode.object
                                            [ ( "avatar_url"
                                              , Json.Encode.string
                                                    rec_0_60_1_1_0_3_1_1_0_8_1_0_0.avatar_url
                                              )
                                            , ( "events_url"
                                              , Json.Encode.string
                                                    rec_0_60_1_1_0_3_1_1_0_8_1_0_0.events_url
                                              )
                                            , ( "followers_url"
                                              , Json.Encode.string
                                                    rec_0_60_1_1_0_3_1_1_0_8_1_0_0.followers_url
                                              )
                                            , ( "following_url"
                                              , Json.Encode.string
                                                    rec_0_60_1_1_0_3_1_1_0_8_1_0_0.following_url
                                              )
                                            , ( "gists_url"
                                              , Json.Encode.string
                                                    rec_0_60_1_1_0_3_1_1_0_8_1_0_0.gists_url
                                              )
                                            , ( "gravatar_id"
                                              , (\nullableValue ->
                                                    case nullableValue of
                                                        Null ->
                                                            Json.Encode.null

                                                        Present value ->
                                                            Json.Encode.string
                                                                value
                                                )
                                                    rec_0_60_1_1_0_3_1_1_0_8_1_0_0.gravatar_id
                                              )
                                            , ( "html_url"
                                              , Json.Encode.string
                                                    rec_0_60_1_1_0_3_1_1_0_8_1_0_0.html_url
                                              )
                                            , ( "id"
                                              , Json.Encode.int
                                                    rec_0_60_1_1_0_3_1_1_0_8_1_0_0.id
                                              )
                                            , ( "login"
                                              , Json.Encode.string
                                                    rec_0_60_1_1_0_3_1_1_0_8_1_0_0.login
                                              )
                                            , ( "node_id"
                                              , Json.Encode.string
                                                    rec_0_60_1_1_0_3_1_1_0_8_1_0_0.node_id
                                              )
                                            , ( "organizations_url"
                                              , Json.Encode.string
                                                    rec_0_60_1_1_0_3_1_1_0_8_1_0_0.organizations_url
                                              )
                                            , ( "received_events_url"
                                              , Json.Encode.string
                                                    rec_0_60_1_1_0_3_1_1_0_8_1_0_0.received_events_url
                                              )
                                            , ( "repos_url"
                                              , Json.Encode.string
                                                    rec_0_60_1_1_0_3_1_1_0_8_1_0_0.repos_url
                                              )
                                            , ( "site_admin"
                                              , Json.Encode.bool
                                                    rec_0_60_1_1_0_3_1_1_0_8_1_0_0.site_admin
                                              )
                                            , ( "starred_url"
                                              , Json.Encode.string
                                                    rec_0_60_1_1_0_3_1_1_0_8_1_0_0.starred_url
                                              )
                                            , ( "subscriptions_url"
                                              , Json.Encode.string
                                                    rec_0_60_1_1_0_3_1_1_0_8_1_0_0.subscriptions_url
                                              )
                                            , ( "type"
                                              , Json.Encode.string
                                                    rec_0_60_1_1_0_3_1_1_0_8_1_0_0.type_
                                              )
                                            , ( "url"
                                              , Json.Encode.string
                                                    rec_0_60_1_1_0_3_1_1_0_8_1_0_0.url
                                              )
                                            ]
                                    )
                                        rec_0_3_1_1_0_8_1_0_0.owner
                                  )
                                , ( "permissions"
                                  , (\rec_0_61_1_1_0_3_1_1_0_8_1_0_0 ->
                                        Json.Encode.object
                                            [ ( "admin"
                                              , Json.Encode.bool
                                                    rec_0_61_1_1_0_3_1_1_0_8_1_0_0.admin
                                              )
                                            , ( "maintain"
                                              , Json.Encode.bool
                                                    rec_0_61_1_1_0_3_1_1_0_8_1_0_0.maintain
                                              )
                                            , ( "pull"
                                              , Json.Encode.bool
                                                    rec_0_61_1_1_0_3_1_1_0_8_1_0_0.pull
                                              )
                                            , ( "push"
                                              , Json.Encode.bool
                                                    rec_0_61_1_1_0_3_1_1_0_8_1_0_0.push
                                              )
                                            , ( "triage"
                                              , Json.Encode.bool
                                                    rec_0_61_1_1_0_3_1_1_0_8_1_0_0.triage
                                              )
                                            ]
                                    )
                                        rec_0_3_1_1_0_8_1_0_0.permissions
                                  )
                                , ( "private"
                                  , Json.Encode.bool
                                        rec_0_3_1_1_0_8_1_0_0.private
                                  )
                                , ( "pulls_url"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_8_1_0_0.pulls_url
                                  )
                                , ( "pushed_at"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_8_1_0_0.pushed_at
                                  )
                                , ( "releases_url"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_8_1_0_0.releases_url
                                  )
                                , ( "size"
                                  , Json.Encode.int rec_0_3_1_1_0_8_1_0_0.size
                                  )
                                , ( "ssh_url"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_8_1_0_0.ssh_url
                                  )
                                , ( "stargazers_count"
                                  , Json.Encode.int
                                        rec_0_3_1_1_0_8_1_0_0.stargazers_count
                                  )
                                , ( "stargazers_url"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_8_1_0_0.stargazers_url
                                  )
                                , ( "statuses_url"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_8_1_0_0.statuses_url
                                  )
                                , ( "subscribers_url"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_8_1_0_0.subscribers_url
                                  )
                                , ( "subscription_url"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_8_1_0_0.subscription_url
                                  )
                                , ( "svn_url"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_8_1_0_0.svn_url
                                  )
                                , ( "tags_url"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_8_1_0_0.tags_url
                                  )
                                , ( "teams_url"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_8_1_0_0.teams_url
                                  )
                                , ( "temp_clone_token"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_8_1_0_0.temp_clone_token
                                  )
                                , ( "topics"
                                  , Json.Encode.list Json.Encode.string
                                        rec_0_3_1_1_0_8_1_0_0.topics
                                  )
                                , ( "trees_url"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_8_1_0_0.trees_url
                                  )
                                , ( "updated_at"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_8_1_0_0.updated_at
                                  )
                                , ( "url"
                                  , Json.Encode.string rec_0_3_1_1_0_8_1_0_0.url
                                  )
                                , ( "visibility"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_8_1_0_0.visibility
                                  )
                                , ( "watchers"
                                  , Json.Encode.int
                                        rec_0_3_1_1_0_8_1_0_0.watchers
                                  )
                                , ( "watchers_count"
                                  , Json.Encode.int
                                        rec_0_3_1_1_0_8_1_0_0.watchers_count
                                  )
                                , ( "web_commit_signoff_required"
                                  , Json.Encode.bool
                                        rec_0_3_1_1_0_8_1_0_0.web_commit_signoff_required
                                  )
                                ]
                        )
                            rec0.repo
                      )
                    , ( "sha", Json.Encode.string rec0.sha )
                    , ( "user"
                      , (\rec_0_5_1_1_0_8_1_0_0 ->
                            Json.Encode.object
                                [ ( "avatar_url"
                                  , Json.Encode.string
                                        rec_0_5_1_1_0_8_1_0_0.avatar_url
                                  )
                                , ( "events_url"
                                  , Json.Encode.string
                                        rec_0_5_1_1_0_8_1_0_0.events_url
                                  )
                                , ( "followers_url"
                                  , Json.Encode.string
                                        rec_0_5_1_1_0_8_1_0_0.followers_url
                                  )
                                , ( "following_url"
                                  , Json.Encode.string
                                        rec_0_5_1_1_0_8_1_0_0.following_url
                                  )
                                , ( "gists_url"
                                  , Json.Encode.string
                                        rec_0_5_1_1_0_8_1_0_0.gists_url
                                  )
                                , ( "gravatar_id"
                                  , (\nullableValue ->
                                        case nullableValue of
                                            Null ->
                                                Json.Encode.null

                                            Present value ->
                                                Json.Encode.string value
                                    )
                                        rec_0_5_1_1_0_8_1_0_0.gravatar_id
                                  )
                                , ( "html_url"
                                  , Json.Encode.string
                                        rec_0_5_1_1_0_8_1_0_0.html_url
                                  )
                                , ( "id"
                                  , Json.Encode.int rec_0_5_1_1_0_8_1_0_0.id
                                  )
                                , ( "login"
                                  , Json.Encode.string
                                        rec_0_5_1_1_0_8_1_0_0.login
                                  )
                                , ( "node_id"
                                  , Json.Encode.string
                                        rec_0_5_1_1_0_8_1_0_0.node_id
                                  )
                                , ( "organizations_url"
                                  , Json.Encode.string
                                        rec_0_5_1_1_0_8_1_0_0.organizations_url
                                  )
                                , ( "received_events_url"
                                  , Json.Encode.string
                                        rec_0_5_1_1_0_8_1_0_0.received_events_url
                                  )
                                , ( "repos_url"
                                  , Json.Encode.string
                                        rec_0_5_1_1_0_8_1_0_0.repos_url
                                  )
                                , ( "site_admin"
                                  , Json.Encode.bool
                                        rec_0_5_1_1_0_8_1_0_0.site_admin
                                  )
                                , ( "starred_url"
                                  , Json.Encode.string
                                        rec_0_5_1_1_0_8_1_0_0.starred_url
                                  )
                                , ( "subscriptions_url"
                                  , Json.Encode.string
                                        rec_0_5_1_1_0_8_1_0_0.subscriptions_url
                                  )
                                , ( "type"
                                  , Json.Encode.string
                                        rec_0_5_1_1_0_8_1_0_0.type_
                                  )
                                , ( "url"
                                  , Json.Encode.string rec_0_5_1_1_0_8_1_0_0.url
                                  )
                                ]
                        )
                            rec0.user
                      )
                    ]
            )
                rec.base
          )
        , ( "body"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.body
          )
        , ( "changed_files", Json.Encode.int rec.changed_files )
        , ( "closed_at"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.closed_at
          )
        , ( "comments", Json.Encode.int rec.comments )
        , ( "comments_url", Json.Encode.string rec.comments_url )
        , ( "commits", Json.Encode.int rec.commits )
        , ( "commits_url", Json.Encode.string rec.commits_url )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "deletions", Json.Encode.int rec.deletions )
        , ( "diff_url", Json.Encode.string rec.diff_url )
        , ( "draft", Json.Encode.bool rec.draft )
        , ( "head"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "label", Json.Encode.string rec0.label )
                    , ( "ref", Json.Encode.string rec0.ref )
                    , ( "repo"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    (\rec_0_0_1_0_0_3_1_1_0_20_1_0_0 ->
                                        Json.Encode.object
                                            [ ( "allow_forking"
                                              , Json.Encode.bool
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.allow_forking
                                              )
                                            , ( "allow_merge_commit"
                                              , Json.Encode.bool
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.allow_merge_commit
                                              )
                                            , ( "allow_rebase_merge"
                                              , Json.Encode.bool
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.allow_rebase_merge
                                              )
                                            , ( "allow_squash_merge"
                                              , Json.Encode.bool
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.allow_squash_merge
                                              )
                                            , ( "archive_url"
                                              , Json.Encode.string
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.archive_url
                                              )
                                            , ( "archived"
                                              , Json.Encode.bool
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.archived
                                              )
                                            , ( "assignees_url"
                                              , Json.Encode.string
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.assignees_url
                                              )
                                            , ( "blobs_url"
                                              , Json.Encode.string
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.blobs_url
                                              )
                                            , ( "branches_url"
                                              , Json.Encode.string
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.branches_url
                                              )
                                            , ( "clone_url"
                                              , Json.Encode.string
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.clone_url
                                              )
                                            , ( "collaborators_url"
                                              , Json.Encode.string
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.collaborators_url
                                              )
                                            , ( "comments_url"
                                              , Json.Encode.string
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.comments_url
                                              )
                                            , ( "commits_url"
                                              , Json.Encode.string
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.commits_url
                                              )
                                            , ( "compare_url"
                                              , Json.Encode.string
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.compare_url
                                              )
                                            , ( "contents_url"
                                              , Json.Encode.string
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.contents_url
                                              )
                                            , ( "contributors_url"
                                              , Json.Encode.string
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.contributors_url
                                              )
                                            , ( "created_at"
                                              , Json.Encode.string
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.created_at
                                              )
                                            , ( "default_branch"
                                              , Json.Encode.string
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.default_branch
                                              )
                                            , ( "deployments_url"
                                              , Json.Encode.string
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.deployments_url
                                              )
                                            , ( "description"
                                              , (\nullableValue0 ->
                                                    case nullableValue0 of
                                                        Null ->
                                                            Json.Encode.null

                                                        Present value0 ->
                                                            Json.Encode.string
                                                                value0
                                                )
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.description
                                              )
                                            , ( "disabled"
                                              , Json.Encode.bool
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.disabled
                                              )
                                            , ( "downloads_url"
                                              , Json.Encode.string
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.downloads_url
                                              )
                                            , ( "events_url"
                                              , Json.Encode.string
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.events_url
                                              )
                                            , ( "fork"
                                              , Json.Encode.bool
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.fork
                                              )
                                            , ( "forks"
                                              , Json.Encode.int
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.forks
                                              )
                                            , ( "forks_count"
                                              , Json.Encode.int
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.forks_count
                                              )
                                            , ( "forks_url"
                                              , Json.Encode.string
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.forks_url
                                              )
                                            , ( "full_name"
                                              , Json.Encode.string
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.full_name
                                              )
                                            , ( "git_commits_url"
                                              , Json.Encode.string
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.git_commits_url
                                              )
                                            , ( "git_refs_url"
                                              , Json.Encode.string
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.git_refs_url
                                              )
                                            , ( "git_tags_url"
                                              , Json.Encode.string
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.git_tags_url
                                              )
                                            , ( "git_url"
                                              , Json.Encode.string
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.git_url
                                              )
                                            , ( "has_downloads"
                                              , Json.Encode.bool
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.has_downloads
                                              )
                                            , ( "has_issues"
                                              , Json.Encode.bool
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.has_issues
                                              )
                                            , ( "has_pages"
                                              , Json.Encode.bool
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.has_pages
                                              )
                                            , ( "has_projects"
                                              , Json.Encode.bool
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.has_projects
                                              )
                                            , ( "has_wiki"
                                              , Json.Encode.bool
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.has_wiki
                                              )
                                            , ( "homepage"
                                              , (\nullableValue0 ->
                                                    case nullableValue0 of
                                                        Null ->
                                                            Json.Encode.null

                                                        Present value0 ->
                                                            Json.Encode.string
                                                                value0
                                                )
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.homepage
                                              )
                                            , ( "hooks_url"
                                              , Json.Encode.string
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.hooks_url
                                              )
                                            , ( "html_url"
                                              , Json.Encode.string
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.html_url
                                              )
                                            , ( "id"
                                              , Json.Encode.int
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.id
                                              )
                                            , ( "is_template"
                                              , Json.Encode.bool
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.is_template
                                              )
                                            , ( "issue_comment_url"
                                              , Json.Encode.string
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.issue_comment_url
                                              )
                                            , ( "issue_events_url"
                                              , Json.Encode.string
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.issue_events_url
                                              )
                                            , ( "issues_url"
                                              , Json.Encode.string
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.issues_url
                                              )
                                            , ( "keys_url"
                                              , Json.Encode.string
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.keys_url
                                              )
                                            , ( "labels_url"
                                              , Json.Encode.string
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.labels_url
                                              )
                                            , ( "language"
                                              , (\nullableValue0 ->
                                                    case nullableValue0 of
                                                        Null ->
                                                            Json.Encode.null

                                                        Present value0 ->
                                                            Json.Encode.string
                                                                value0
                                                )
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.language
                                              )
                                            , ( "languages_url"
                                              , Json.Encode.string
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.languages_url
                                              )
                                            , ( "license"
                                              , (\nullableValue0 ->
                                                    case nullableValue0 of
                                                        Null ->
                                                            Json.Encode.null

                                                        Present value0 ->
                                                            (\rec_0_1_1_1_0_50_1_1_0_0_1_0_0_3_1_1_0_20_1_0_0 ->
                                                                Json.Encode.object
                                                                    [ ( "key"
                                                                      , Json.Encode.string
                                                                            rec_0_1_1_1_0_50_1_1_0_0_1_0_0_3_1_1_0_20_1_0_0.key
                                                                      )
                                                                    , ( "name"
                                                                      , Json.Encode.string
                                                                            rec_0_1_1_1_0_50_1_1_0_0_1_0_0_3_1_1_0_20_1_0_0.name
                                                                      )
                                                                    , ( "node_id"
                                                                      , Json.Encode.string
                                                                            rec_0_1_1_1_0_50_1_1_0_0_1_0_0_3_1_1_0_20_1_0_0.node_id
                                                                      )
                                                                    , ( "spdx_id"
                                                                      , (\nullableValue_0_4_1_1_0_1_1_1_0_50_1_1_0_0_1_0_0_3_1_1_0_20_1_0_0 ->
                                                                            case
                                                                                nullableValue_0_4_1_1_0_1_1_1_0_50_1_1_0_0_1_0_0_3_1_1_0_20_1_0_0
                                                                            of
                                                                                Null ->
                                                                                    Json.Encode.null

                                                                                Present value_1_1_0_4_1_1_0_1_1_1_0_50_1_1_0_0_1_0_0_3_1_1_0_20_1_0_0 ->
                                                                                    Json.Encode.string
                                                                                        value_1_1_0_4_1_1_0_1_1_1_0_50_1_1_0_0_1_0_0_3_1_1_0_20_1_0_0
                                                                        )
                                                                            rec_0_1_1_1_0_50_1_1_0_0_1_0_0_3_1_1_0_20_1_0_0.spdx_id
                                                                      )
                                                                    , ( "url"
                                                                      , (\nullableValue_0_5_1_1_0_1_1_1_0_50_1_1_0_0_1_0_0_3_1_1_0_20_1_0_0 ->
                                                                            case
                                                                                nullableValue_0_5_1_1_0_1_1_1_0_50_1_1_0_0_1_0_0_3_1_1_0_20_1_0_0
                                                                            of
                                                                                Null ->
                                                                                    Json.Encode.null

                                                                                Present value_1_1_0_5_1_1_0_1_1_1_0_50_1_1_0_0_1_0_0_3_1_1_0_20_1_0_0 ->
                                                                                    Json.Encode.string
                                                                                        value_1_1_0_5_1_1_0_1_1_1_0_50_1_1_0_0_1_0_0_3_1_1_0_20_1_0_0
                                                                        )
                                                                            rec_0_1_1_1_0_50_1_1_0_0_1_0_0_3_1_1_0_20_1_0_0.url
                                                                      )
                                                                    ]
                                                            )
                                                                value0
                                                )
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.license
                                              )
                                            , ( "master_branch"
                                              , Json.Encode.string
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.master_branch
                                              )
                                            , ( "merges_url"
                                              , Json.Encode.string
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.merges_url
                                              )
                                            , ( "milestones_url"
                                              , Json.Encode.string
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.milestones_url
                                              )
                                            , ( "mirror_url"
                                              , (\nullableValue0 ->
                                                    case nullableValue0 of
                                                        Null ->
                                                            Json.Encode.null

                                                        Present value0 ->
                                                            Json.Encode.string
                                                                value0
                                                )
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.mirror_url
                                              )
                                            , ( "name"
                                              , Json.Encode.string
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.name
                                              )
                                            , ( "node_id"
                                              , Json.Encode.string
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.node_id
                                              )
                                            , ( "notifications_url"
                                              , Json.Encode.string
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.notifications_url
                                              )
                                            , ( "open_issues"
                                              , Json.Encode.int
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.open_issues
                                              )
                                            , ( "open_issues_count"
                                              , Json.Encode.int
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.open_issues_count
                                              )
                                            , ( "owner"
                                              , (\rec_0_60_1_1_0_0_1_0_0_3_1_1_0_20_1_0_0 ->
                                                    Json.Encode.object
                                                        [ ( "avatar_url"
                                                          , Json.Encode.string
                                                                rec_0_60_1_1_0_0_1_0_0_3_1_1_0_20_1_0_0.avatar_url
                                                          )
                                                        , ( "events_url"
                                                          , Json.Encode.string
                                                                rec_0_60_1_1_0_0_1_0_0_3_1_1_0_20_1_0_0.events_url
                                                          )
                                                        , ( "followers_url"
                                                          , Json.Encode.string
                                                                rec_0_60_1_1_0_0_1_0_0_3_1_1_0_20_1_0_0.followers_url
                                                          )
                                                        , ( "following_url"
                                                          , Json.Encode.string
                                                                rec_0_60_1_1_0_0_1_0_0_3_1_1_0_20_1_0_0.following_url
                                                          )
                                                        , ( "gists_url"
                                                          , Json.Encode.string
                                                                rec_0_60_1_1_0_0_1_0_0_3_1_1_0_20_1_0_0.gists_url
                                                          )
                                                        , ( "gravatar_id"
                                                          , (\nullableValue0 ->
                                                                case
                                                                    nullableValue0
                                                                of
                                                                    Null ->
                                                                        Json.Encode.null

                                                                    Present value0 ->
                                                                        Json.Encode.string
                                                                            value0
                                                            )
                                                                rec_0_60_1_1_0_0_1_0_0_3_1_1_0_20_1_0_0.gravatar_id
                                                          )
                                                        , ( "html_url"
                                                          , Json.Encode.string
                                                                rec_0_60_1_1_0_0_1_0_0_3_1_1_0_20_1_0_0.html_url
                                                          )
                                                        , ( "id"
                                                          , Json.Encode.int
                                                                rec_0_60_1_1_0_0_1_0_0_3_1_1_0_20_1_0_0.id
                                                          )
                                                        , ( "login"
                                                          , Json.Encode.string
                                                                rec_0_60_1_1_0_0_1_0_0_3_1_1_0_20_1_0_0.login
                                                          )
                                                        , ( "node_id"
                                                          , Json.Encode.string
                                                                rec_0_60_1_1_0_0_1_0_0_3_1_1_0_20_1_0_0.node_id
                                                          )
                                                        , ( "organizations_url"
                                                          , Json.Encode.string
                                                                rec_0_60_1_1_0_0_1_0_0_3_1_1_0_20_1_0_0.organizations_url
                                                          )
                                                        , ( "received_events_url"
                                                          , Json.Encode.string
                                                                rec_0_60_1_1_0_0_1_0_0_3_1_1_0_20_1_0_0.received_events_url
                                                          )
                                                        , ( "repos_url"
                                                          , Json.Encode.string
                                                                rec_0_60_1_1_0_0_1_0_0_3_1_1_0_20_1_0_0.repos_url
                                                          )
                                                        , ( "site_admin"
                                                          , Json.Encode.bool
                                                                rec_0_60_1_1_0_0_1_0_0_3_1_1_0_20_1_0_0.site_admin
                                                          )
                                                        , ( "starred_url"
                                                          , Json.Encode.string
                                                                rec_0_60_1_1_0_0_1_0_0_3_1_1_0_20_1_0_0.starred_url
                                                          )
                                                        , ( "subscriptions_url"
                                                          , Json.Encode.string
                                                                rec_0_60_1_1_0_0_1_0_0_3_1_1_0_20_1_0_0.subscriptions_url
                                                          )
                                                        , ( "type"
                                                          , Json.Encode.string
                                                                rec_0_60_1_1_0_0_1_0_0_3_1_1_0_20_1_0_0.type_
                                                          )
                                                        , ( "url"
                                                          , Json.Encode.string
                                                                rec_0_60_1_1_0_0_1_0_0_3_1_1_0_20_1_0_0.url
                                                          )
                                                        ]
                                                )
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.owner
                                              )
                                            , ( "permissions"
                                              , (\rec_0_61_1_1_0_0_1_0_0_3_1_1_0_20_1_0_0 ->
                                                    Json.Encode.object
                                                        [ ( "admin"
                                                          , Json.Encode.bool
                                                                rec_0_61_1_1_0_0_1_0_0_3_1_1_0_20_1_0_0.admin
                                                          )
                                                        , ( "maintain"
                                                          , Json.Encode.bool
                                                                rec_0_61_1_1_0_0_1_0_0_3_1_1_0_20_1_0_0.maintain
                                                          )
                                                        , ( "pull"
                                                          , Json.Encode.bool
                                                                rec_0_61_1_1_0_0_1_0_0_3_1_1_0_20_1_0_0.pull
                                                          )
                                                        , ( "push"
                                                          , Json.Encode.bool
                                                                rec_0_61_1_1_0_0_1_0_0_3_1_1_0_20_1_0_0.push
                                                          )
                                                        , ( "triage"
                                                          , Json.Encode.bool
                                                                rec_0_61_1_1_0_0_1_0_0_3_1_1_0_20_1_0_0.triage
                                                          )
                                                        ]
                                                )
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.permissions
                                              )
                                            , ( "private"
                                              , Json.Encode.bool
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.private
                                              )
                                            , ( "pulls_url"
                                              , Json.Encode.string
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.pulls_url
                                              )
                                            , ( "pushed_at"
                                              , Json.Encode.string
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.pushed_at
                                              )
                                            , ( "releases_url"
                                              , Json.Encode.string
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.releases_url
                                              )
                                            , ( "size"
                                              , Json.Encode.int
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.size
                                              )
                                            , ( "ssh_url"
                                              , Json.Encode.string
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.ssh_url
                                              )
                                            , ( "stargazers_count"
                                              , Json.Encode.int
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.stargazers_count
                                              )
                                            , ( "stargazers_url"
                                              , Json.Encode.string
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.stargazers_url
                                              )
                                            , ( "statuses_url"
                                              , Json.Encode.string
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.statuses_url
                                              )
                                            , ( "subscribers_url"
                                              , Json.Encode.string
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.subscribers_url
                                              )
                                            , ( "subscription_url"
                                              , Json.Encode.string
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.subscription_url
                                              )
                                            , ( "svn_url"
                                              , Json.Encode.string
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.svn_url
                                              )
                                            , ( "tags_url"
                                              , Json.Encode.string
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.tags_url
                                              )
                                            , ( "teams_url"
                                              , Json.Encode.string
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.teams_url
                                              )
                                            , ( "temp_clone_token"
                                              , Json.Encode.string
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.temp_clone_token
                                              )
                                            , ( "topics"
                                              , Json.Encode.list
                                                    Json.Encode.string
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.topics
                                              )
                                            , ( "trees_url"
                                              , Json.Encode.string
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.trees_url
                                              )
                                            , ( "updated_at"
                                              , Json.Encode.string
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.updated_at
                                              )
                                            , ( "url"
                                              , Json.Encode.string
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.url
                                              )
                                            , ( "visibility"
                                              , Json.Encode.string
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.visibility
                                              )
                                            , ( "watchers"
                                              , Json.Encode.int
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.watchers
                                              )
                                            , ( "watchers_count"
                                              , Json.Encode.int
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.watchers_count
                                              )
                                            , ( "web_commit_signoff_required"
                                              , Json.Encode.bool
                                                    rec_0_0_1_0_0_3_1_1_0_20_1_0_0.web_commit_signoff_required
                                              )
                                            ]
                                    )
                                        value
                        )
                            rec0.repo
                      )
                    , ( "sha", Json.Encode.string rec0.sha )
                    , ( "user"
                      , (\rec_0_5_1_1_0_20_1_0_0 ->
                            Json.Encode.object
                                [ ( "avatar_url"
                                  , Json.Encode.string
                                        rec_0_5_1_1_0_20_1_0_0.avatar_url
                                  )
                                , ( "events_url"
                                  , Json.Encode.string
                                        rec_0_5_1_1_0_20_1_0_0.events_url
                                  )
                                , ( "followers_url"
                                  , Json.Encode.string
                                        rec_0_5_1_1_0_20_1_0_0.followers_url
                                  )
                                , ( "following_url"
                                  , Json.Encode.string
                                        rec_0_5_1_1_0_20_1_0_0.following_url
                                  )
                                , ( "gists_url"
                                  , Json.Encode.string
                                        rec_0_5_1_1_0_20_1_0_0.gists_url
                                  )
                                , ( "gravatar_id"
                                  , (\nullableValue ->
                                        case nullableValue of
                                            Null ->
                                                Json.Encode.null

                                            Present value ->
                                                Json.Encode.string value
                                    )
                                        rec_0_5_1_1_0_20_1_0_0.gravatar_id
                                  )
                                , ( "html_url"
                                  , Json.Encode.string
                                        rec_0_5_1_1_0_20_1_0_0.html_url
                                  )
                                , ( "id"
                                  , Json.Encode.int rec_0_5_1_1_0_20_1_0_0.id
                                  )
                                , ( "login"
                                  , Json.Encode.string
                                        rec_0_5_1_1_0_20_1_0_0.login
                                  )
                                , ( "node_id"
                                  , Json.Encode.string
                                        rec_0_5_1_1_0_20_1_0_0.node_id
                                  )
                                , ( "organizations_url"
                                  , Json.Encode.string
                                        rec_0_5_1_1_0_20_1_0_0.organizations_url
                                  )
                                , ( "received_events_url"
                                  , Json.Encode.string
                                        rec_0_5_1_1_0_20_1_0_0.received_events_url
                                  )
                                , ( "repos_url"
                                  , Json.Encode.string
                                        rec_0_5_1_1_0_20_1_0_0.repos_url
                                  )
                                , ( "site_admin"
                                  , Json.Encode.bool
                                        rec_0_5_1_1_0_20_1_0_0.site_admin
                                  )
                                , ( "starred_url"
                                  , Json.Encode.string
                                        rec_0_5_1_1_0_20_1_0_0.starred_url
                                  )
                                , ( "subscriptions_url"
                                  , Json.Encode.string
                                        rec_0_5_1_1_0_20_1_0_0.subscriptions_url
                                  )
                                , ( "type"
                                  , Json.Encode.string
                                        rec_0_5_1_1_0_20_1_0_0.type_
                                  )
                                , ( "url"
                                  , Json.Encode.string
                                        rec_0_5_1_1_0_20_1_0_0.url
                                  )
                                ]
                        )
                            rec0.user
                      )
                    ]
            )
                rec.head
          )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "id", Json.Encode.int rec.id )
        , ( "issue_url", Json.Encode.string rec.issue_url )
        , ( "labels"
          , Json.Encode.list
                (\rec0 ->
                    Json.Encode.object
                        [ ( "color", Json.Encode.string rec0.color )
                        , ( "default", Json.Encode.bool rec0.default )
                        , ( "description"
                          , (\nullableValue ->
                                case nullableValue of
                                    Null ->
                                        Json.Encode.null

                                    Present value ->
                                        Json.Encode.string value
                            )
                                rec0.description
                          )
                        , ( "id", Json.Encode.int rec0.id )
                        , ( "name", Json.Encode.string rec0.name )
                        , ( "node_id", Json.Encode.string rec0.node_id )
                        , ( "url", Json.Encode.string rec0.url )
                        ]
                )
                rec.labels
          )
        , ( "locked", Json.Encode.bool rec.locked )
        , ( "maintainer_can_modify"
          , Json.Encode.bool rec.maintainer_can_modify
          )
        , ( "merge_commit_sha"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.merge_commit_sha
          )
        , ( "mergeable"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.bool value
            )
                rec.mergeable
          )
        , ( "mergeable_state", Json.Encode.string rec.mergeable_state )
        , ( "merged", Json.Encode.bool rec.merged )
        , ( "merged_at"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.merged_at
          )
        , ( "merged_by"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.merged_by
          )
        , ( "milestone"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeMilestone value
            )
                rec.milestone
          )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "number", Json.Encode.int rec.number )
        , ( "patch_url", Json.Encode.string rec.patch_url )
        , ( "rebaseable"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.bool value
            )
                rec.rebaseable
          )
        , ( "requested_reviewers"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.list encodeSimpleUser value
            )
                rec.requested_reviewers
          )
        , ( "requested_teams"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.list encodeTeamSimple value
            )
                rec.requested_teams
          )
        , ( "review_comment_url", Json.Encode.string rec.review_comment_url )
        , ( "review_comments", Json.Encode.int rec.review_comments )
        , ( "review_comments_url", Json.Encode.string rec.review_comments_url )
        , ( "state", Json.Encode.string rec.state )
        , ( "statuses_url", Json.Encode.string rec.statuses_url )
        , ( "title", Json.Encode.string rec.title )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        , ( "url", Json.Encode.string rec.url )
        , ( "user"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.user
          )
        ]


type alias PublicUser =
    { avatar_url : String
    , bio : Nullable String
    , blog : Nullable String
    , collaborators : Int
    , company : Nullable String
    , created_at : String
    , disk_usage : Int
    , email : Nullable String
    , events_url : String
    , followers : Int
    , followers_url : String
    , following : Int
    , following_url : String
    , gists_url : String
    , gravatar_id : Nullable String
    , hireable : Nullable Bool
    , html_url : String
    , id : Int
    , location : Nullable String
    , login : String
    , name : Nullable String
    , node_id : String
    , organizations_url : String
    , owned_private_repos : Int
    , plan :
        { collaborators : Int, name : String, private_repos : Int, space : Int }
    , private_gists : Int
    , public_gists : Int
    , public_repos : Int
    , received_events_url : String
    , repos_url : String
    , site_admin : Bool
    , starred_url : String
    , subscriptions_url : String
    , suspended_at : Nullable String
    , total_private_repos : Int
    , twitter_username : Nullable String
    , type_ : String
    , updated_at : String
    , url : String
    }


decodePublicUser : Json.Decode.Decoder PublicUser
decodePublicUser =
    Json.Decode.succeed
     (\avatar_url bio blog collaborators company created_at disk_usage email events_url followers followers_url following following_url gists_url gravatar_id hireable html_url id location login name node_id organizations_url owned_private_repos plan private_gists public_gists public_repos received_events_url repos_url site_admin starred_url subscriptions_url suspended_at total_private_repos twitter_username type_ updated_at url ->
         { avatar_url = avatar_url
         , bio = bio
         , blog = blog
         , collaborators = collaborators
         , company = company
         , created_at = created_at
         , disk_usage = disk_usage
         , email = email
         , events_url = events_url
         , followers = followers
         , followers_url = followers_url
         , following = following
         , following_url = following_url
         , gists_url = gists_url
         , gravatar_id = gravatar_id
         , hireable = hireable
         , html_url = html_url
         , id = id
         , location = location
         , login = login
         , name = name
         , node_id = node_id
         , organizations_url = organizations_url
         , owned_private_repos = owned_private_repos
         , plan = plan
         , private_gists = private_gists
         , public_gists = public_gists
         , public_repos = public_repos
         , received_events_url = received_events_url
         , repos_url = repos_url
         , site_admin = site_admin
         , starred_url = starred_url
         , subscriptions_url = subscriptions_url
         , suspended_at = suspended_at
         , total_private_repos = total_private_repos
         , twitter_username = twitter_username
         , type_ = type_
         , updated_at = updated_at
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "avatar_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "bio"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "blog"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "collaborators" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "company"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "disk_usage" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "email"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "events_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "followers" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "followers_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "following" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "following_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "gists_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "gravatar_id"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "hireable"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.bool
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "location"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "login" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "name"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "organizations_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "owned_private_repos" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "plan"
                (Json.Decode.succeed
                  (\collaborators name private_repos space ->
                      { collaborators = collaborators
                      , name = name
                      , private_repos = private_repos
                      , space = space
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "collaborators" Json.Decode.int)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "name" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "private_repos" Json.Decode.int)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "space" Json.Decode.int)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "private_gists" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "public_gists" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "public_repos" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "received_events_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "repos_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "site_admin" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "starred_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "subscriptions_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "suspended_at"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "total_private_repos" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "twitter_username"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "type" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodePublicUser : PublicUser -> Json.Encode.Value
encodePublicUser rec =
    Json.Encode.object
        [ ( "avatar_url", Json.Encode.string rec.avatar_url )
        , ( "bio"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.bio
          )
        , ( "blog"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.blog
          )
        , ( "collaborators", Json.Encode.int rec.collaborators )
        , ( "company"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.company
          )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "disk_usage", Json.Encode.int rec.disk_usage )
        , ( "email"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.email
          )
        , ( "events_url", Json.Encode.string rec.events_url )
        , ( "followers", Json.Encode.int rec.followers )
        , ( "followers_url", Json.Encode.string rec.followers_url )
        , ( "following", Json.Encode.int rec.following )
        , ( "following_url", Json.Encode.string rec.following_url )
        , ( "gists_url", Json.Encode.string rec.gists_url )
        , ( "gravatar_id"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.gravatar_id
          )
        , ( "hireable"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.bool value
            )
                rec.hireable
          )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "id", Json.Encode.int rec.id )
        , ( "location"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.location
          )
        , ( "login", Json.Encode.string rec.login )
        , ( "name"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.name
          )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "organizations_url", Json.Encode.string rec.organizations_url )
        , ( "owned_private_repos", Json.Encode.int rec.owned_private_repos )
        , ( "plan"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "collaborators", Json.Encode.int rec0.collaborators )
                    , ( "name", Json.Encode.string rec0.name )
                    , ( "private_repos", Json.Encode.int rec0.private_repos )
                    , ( "space", Json.Encode.int rec0.space )
                    ]
            )
                rec.plan
          )
        , ( "private_gists", Json.Encode.int rec.private_gists )
        , ( "public_gists", Json.Encode.int rec.public_gists )
        , ( "public_repos", Json.Encode.int rec.public_repos )
        , ( "received_events_url", Json.Encode.string rec.received_events_url )
        , ( "repos_url", Json.Encode.string rec.repos_url )
        , ( "site_admin", Json.Encode.bool rec.site_admin )
        , ( "starred_url", Json.Encode.string rec.starred_url )
        , ( "subscriptions_url", Json.Encode.string rec.subscriptions_url )
        , ( "suspended_at"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.suspended_at
          )
        , ( "total_private_repos", Json.Encode.int rec.total_private_repos )
        , ( "twitter_username"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.twitter_username
          )
        , ( "type", Json.Encode.string rec.type_ )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias ProtectedBranchRequiredStatusCheck =
    { checks : List { app_id : Nullable Int, context : String }
    , contexts : List String
    , contexts_url : String
    , enforcement_level : String
    , strict : Bool
    , url : String
    }


decodeProtectedBranchRequiredStatusCheck :
    Json.Decode.Decoder ProtectedBranchRequiredStatusCheck
decodeProtectedBranchRequiredStatusCheck =
    Json.Decode.succeed
     (\checks contexts contexts_url enforcement_level strict url ->
         { checks = checks
         , contexts = contexts
         , contexts_url = contexts_url
         , enforcement_level = enforcement_level
         , strict = strict
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "checks"
                (Json.Decode.list
                    (Json.Decode.succeed
                      (\app_id context -> { app_id = app_id, context = context }
                      )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field
                                "app_id"
                                (Json.Decode.oneOf
                                    [ Json.Decode.map Present Json.Decode.int
                                    , Json.Decode.null Null
                                    ]
                                )
                            )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "context" Json.Decode.string)
                    )
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "contexts" (Json.Decode.list Json.Decode.string))
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "contexts_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "enforcement_level" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "strict" Json.Decode.bool)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeProtectedBranchRequiredStatusCheck :
    ProtectedBranchRequiredStatusCheck -> Json.Encode.Value
encodeProtectedBranchRequiredStatusCheck rec =
    Json.Encode.object
        [ ( "checks"
          , Json.Encode.list
                (\rec0 ->
                    Json.Encode.object
                        [ ( "app_id"
                          , (\nullableValue ->
                                case nullableValue of
                                    Null ->
                                        Json.Encode.null

                                    Present value ->
                                        Json.Encode.int value
                            )
                                rec0.app_id
                          )
                        , ( "context", Json.Encode.string rec0.context )
                        ]
                )
                rec.checks
          )
        , ( "contexts", Json.Encode.list Json.Encode.string rec.contexts )
        , ( "contexts_url", Json.Encode.string rec.contexts_url )
        , ( "enforcement_level", Json.Encode.string rec.enforcement_level )
        , ( "strict", Json.Encode.bool rec.strict )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias ProtectedBranchPullRequestReview =
    { bypass_pull_request_allowances :
        { apps : List Integration, teams : List Team, users : List SimpleUser }
    , dismiss_stale_reviews : Bool
    , dismissal_restrictions :
        { apps : List Integration
        , teams : List Team
        , teams_url : String
        , url : String
        , users : List SimpleUser
        , users_url : String
        }
    , require_code_owner_reviews : Bool
    , required_approving_review_count : Int
    , url : String
    }


decodeProtectedBranchPullRequestReview :
    Json.Decode.Decoder ProtectedBranchPullRequestReview
decodeProtectedBranchPullRequestReview =
    Json.Decode.succeed
     (\bypass_pull_request_allowances dismiss_stale_reviews dismissal_restrictions require_code_owner_reviews required_approving_review_count url ->
         { bypass_pull_request_allowances = bypass_pull_request_allowances
         , dismiss_stale_reviews = dismiss_stale_reviews
         , dismissal_restrictions = dismissal_restrictions
         , require_code_owner_reviews = require_code_owner_reviews
         , required_approving_review_count = required_approving_review_count
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "bypass_pull_request_allowances"
                (Json.Decode.succeed
                  (\apps teams users ->
                      { apps = apps, teams = teams, users = users }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "apps"
                            (Json.Decode.list decodeIntegration)
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "teams" (Json.Decode.list decodeTeam)
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "users"
                            (Json.Decode.list decodeSimpleUser)
                        )
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "dismiss_stale_reviews" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "dismissal_restrictions"
                (Json.Decode.succeed
                  (\apps teams teams_url url users users_url ->
                      { apps = apps
                      , teams = teams
                      , teams_url = teams_url
                      , url = url
                      , users = users
                      , users_url = users_url
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "apps"
                            (Json.Decode.list decodeIntegration)
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "teams" (Json.Decode.list decodeTeam)
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "teams_url" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "url" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "users"
                            (Json.Decode.list decodeSimpleUser)
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "users_url" Json.Decode.string)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "require_code_owner_reviews" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "required_approving_review_count" Json.Decode.int
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeProtectedBranchPullRequestReview :
    ProtectedBranchPullRequestReview -> Json.Encode.Value
encodeProtectedBranchPullRequestReview rec =
    Json.Encode.object
        [ ( "bypass_pull_request_allowances"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "apps", Json.Encode.list encodeIntegration rec0.apps )
                    , ( "teams", Json.Encode.list encodeTeam rec0.teams )
                    , ( "users", Json.Encode.list encodeSimpleUser rec0.users )
                    ]
            )
                rec.bypass_pull_request_allowances
          )
        , ( "dismiss_stale_reviews"
          , Json.Encode.bool rec.dismiss_stale_reviews
          )
        , ( "dismissal_restrictions"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "apps", Json.Encode.list encodeIntegration rec0.apps )
                    , ( "teams", Json.Encode.list encodeTeam rec0.teams )
                    , ( "teams_url", Json.Encode.string rec0.teams_url )
                    , ( "url", Json.Encode.string rec0.url )
                    , ( "users", Json.Encode.list encodeSimpleUser rec0.users )
                    , ( "users_url", Json.Encode.string rec0.users_url )
                    ]
            )
                rec.dismissal_restrictions
          )
        , ( "require_code_owner_reviews"
          , Json.Encode.bool rec.require_code_owner_reviews
          )
        , ( "required_approving_review_count"
          , Json.Encode.int rec.required_approving_review_count
          )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias ProtectedBranchAdminEnforced =
    { enabled : Bool, url : String }


decodeProtectedBranchAdminEnforced :
    Json.Decode.Decoder ProtectedBranchAdminEnforced
decodeProtectedBranchAdminEnforced =
    Json.Decode.succeed (\enabled url -> { enabled = enabled, url = url })
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "enabled" Json.Decode.bool)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeProtectedBranchAdminEnforced :
    ProtectedBranchAdminEnforced -> Json.Encode.Value
encodeProtectedBranchAdminEnforced rec =
    Json.Encode.object
        [ ( "enabled", Json.Encode.bool rec.enabled )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias ProtectedBranch =
    { allow_deletions : { enabled : Bool }
    , allow_force_pushes : { enabled : Bool }
    , block_creations : { enabled : Bool }
    , enforce_admins : { enabled : Bool, url : String }
    , required_conversation_resolution : { enabled : Bool }
    , required_linear_history : { enabled : Bool }
    , required_pull_request_reviews :
        { bypass_pull_request_allowances :
            { apps : List Integration
            , teams : List Team
            , users : List SimpleUser
            }
        , dismiss_stale_reviews : Bool
        , dismissal_restrictions :
            { apps : List Integration
            , teams : List Team
            , teams_url : String
            , url : String
            , users : List SimpleUser
            , users_url : String
            }
        , require_code_owner_reviews : Bool
        , required_approving_review_count : Int
        , url : String
        }
    , required_signatures : { enabled : Bool, url : String }
    , required_status_checks : StatusCheckPolicy
    , restrictions : BranchRestrictionPolicy
    , url : String
    }


decodeProtectedBranch : Json.Decode.Decoder ProtectedBranch
decodeProtectedBranch =
    Json.Decode.succeed
     (\allow_deletions allow_force_pushes block_creations enforce_admins required_conversation_resolution required_linear_history required_pull_request_reviews required_signatures required_status_checks restrictions url ->
         { allow_deletions = allow_deletions
         , allow_force_pushes = allow_force_pushes
         , block_creations = block_creations
         , enforce_admins = enforce_admins
         , required_conversation_resolution = required_conversation_resolution
         , required_linear_history = required_linear_history
         , required_pull_request_reviews = required_pull_request_reviews
         , required_signatures = required_signatures
         , required_status_checks = required_status_checks
         , restrictions = restrictions
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "allow_deletions"
                (Json.Decode.succeed (\enabled -> { enabled = enabled })
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "enabled" Json.Decode.bool)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "allow_force_pushes"
                (Json.Decode.succeed (\enabled -> { enabled = enabled })
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "enabled" Json.Decode.bool)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "block_creations"
                (Json.Decode.succeed (\enabled -> { enabled = enabled })
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "enabled" Json.Decode.bool)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "enforce_admins"
                (Json.Decode.succeed
                  (\enabled url -> { enabled = enabled, url = url })
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "enabled" Json.Decode.bool)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "url" Json.Decode.string)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "required_conversation_resolution"
                (Json.Decode.succeed (\enabled -> { enabled = enabled })
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "enabled" Json.Decode.bool)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "required_linear_history"
                (Json.Decode.succeed (\enabled -> { enabled = enabled })
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "enabled" Json.Decode.bool)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "required_pull_request_reviews"
                (Json.Decode.succeed
                  (\bypass_pull_request_allowances dismiss_stale_reviews dismissal_restrictions require_code_owner_reviews required_approving_review_count url ->
                      { bypass_pull_request_allowances =
                          bypass_pull_request_allowances
                      , dismiss_stale_reviews = dismiss_stale_reviews
                      , dismissal_restrictions = dismissal_restrictions
                      , require_code_owner_reviews = require_code_owner_reviews
                      , required_approving_review_count =
                          required_approving_review_count
                      , url = url
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "bypass_pull_request_allowances"
                            (Json.Decode.succeed
                              (\apps teams users ->
                                  { apps = apps, teams = teams, users = users }
                              )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "apps"
                                        (Json.Decode.list decodeIntegration)
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "teams"
                                        (Json.Decode.list decodeTeam)
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "users"
                                        (Json.Decode.list decodeSimpleUser)
                                    )
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "dismiss_stale_reviews"
                            Json.Decode.bool
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "dismissal_restrictions"
                            (Json.Decode.succeed
                              (\apps teams teams_url url users users_url ->
                                  { apps = apps
                                  , teams = teams
                                  , teams_url = teams_url
                                  , url = url
                                  , users = users
                                  , users_url = users_url
                                  }
                              )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "apps"
                                        (Json.Decode.list decodeIntegration)
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "teams"
                                        (Json.Decode.list decodeTeam)
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "teams_url"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field "url" Json.Decode.string)
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "users"
                                        (Json.Decode.list decodeSimpleUser)
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "users_url"
                                        Json.Decode.string
                                    )
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "require_code_owner_reviews"
                            Json.Decode.bool
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "required_approving_review_count"
                            Json.Decode.int
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "url" Json.Decode.string)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "required_signatures"
                (Json.Decode.succeed
                  (\enabled url -> { enabled = enabled, url = url })
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "enabled" Json.Decode.bool)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "url" Json.Decode.string)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "required_status_checks" decodeStatusCheckPolicy)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "restrictions" decodeBranchRestrictionPolicy)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeProtectedBranch : ProtectedBranch -> Json.Encode.Value
encodeProtectedBranch rec =
    Json.Encode.object
        [ ( "allow_deletions"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "enabled", Json.Encode.bool rec0.enabled ) ]
            )
                rec.allow_deletions
          )
        , ( "allow_force_pushes"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "enabled", Json.Encode.bool rec0.enabled ) ]
            )
                rec.allow_force_pushes
          )
        , ( "block_creations"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "enabled", Json.Encode.bool rec0.enabled ) ]
            )
                rec.block_creations
          )
        , ( "enforce_admins"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "enabled", Json.Encode.bool rec0.enabled )
                    , ( "url", Json.Encode.string rec0.url )
                    ]
            )
                rec.enforce_admins
          )
        , ( "required_conversation_resolution"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "enabled", Json.Encode.bool rec0.enabled ) ]
            )
                rec.required_conversation_resolution
          )
        , ( "required_linear_history"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "enabled", Json.Encode.bool rec0.enabled ) ]
            )
                rec.required_linear_history
          )
        , ( "required_pull_request_reviews"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "bypass_pull_request_allowances"
                      , (\rec_0_1_1_1_0_7_1_0_0 ->
                            Json.Encode.object
                                [ ( "apps"
                                  , Json.Encode.list encodeIntegration
                                        rec_0_1_1_1_0_7_1_0_0.apps
                                  )
                                , ( "teams"
                                  , Json.Encode.list encodeTeam
                                        rec_0_1_1_1_0_7_1_0_0.teams
                                  )
                                , ( "users"
                                  , Json.Encode.list encodeSimpleUser
                                        rec_0_1_1_1_0_7_1_0_0.users
                                  )
                                ]
                        )
                            rec0.bypass_pull_request_allowances
                      )
                    , ( "dismiss_stale_reviews"
                      , Json.Encode.bool rec0.dismiss_stale_reviews
                      )
                    , ( "dismissal_restrictions"
                      , (\rec_0_3_1_1_0_7_1_0_0 ->
                            Json.Encode.object
                                [ ( "apps"
                                  , Json.Encode.list encodeIntegration
                                        rec_0_3_1_1_0_7_1_0_0.apps
                                  )
                                , ( "teams"
                                  , Json.Encode.list encodeTeam
                                        rec_0_3_1_1_0_7_1_0_0.teams
                                  )
                                , ( "teams_url"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_7_1_0_0.teams_url
                                  )
                                , ( "url"
                                  , Json.Encode.string rec_0_3_1_1_0_7_1_0_0.url
                                  )
                                , ( "users"
                                  , Json.Encode.list encodeSimpleUser
                                        rec_0_3_1_1_0_7_1_0_0.users
                                  )
                                , ( "users_url"
                                  , Json.Encode.string
                                        rec_0_3_1_1_0_7_1_0_0.users_url
                                  )
                                ]
                        )
                            rec0.dismissal_restrictions
                      )
                    , ( "require_code_owner_reviews"
                      , Json.Encode.bool rec0.require_code_owner_reviews
                      )
                    , ( "required_approving_review_count"
                      , Json.Encode.int rec0.required_approving_review_count
                      )
                    , ( "url", Json.Encode.string rec0.url )
                    ]
            )
                rec.required_pull_request_reviews
          )
        , ( "required_signatures"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "enabled", Json.Encode.bool rec0.enabled )
                    , ( "url", Json.Encode.string rec0.url )
                    ]
            )
                rec.required_signatures
          )
        , ( "required_status_checks"
          , encodeStatusCheckPolicy rec.required_status_checks
          )
        , ( "restrictions", encodeBranchRestrictionPolicy rec.restrictions )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias ProjectColumn =
    { cards_url : String
    , created_at : String
    , id : Int
    , name : String
    , node_id : String
    , project_url : String
    , updated_at : String
    , url : String
    }


decodeProjectColumn : Json.Decode.Decoder ProjectColumn
decodeProjectColumn =
    Json.Decode.succeed
     (\cards_url created_at id name node_id project_url updated_at url ->
         { cards_url = cards_url
         , created_at = created_at
         , id = id
         , name = name
         , node_id = node_id
         , project_url = project_url
         , updated_at = updated_at
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "cards_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "project_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeProjectColumn : ProjectColumn -> Json.Encode.Value
encodeProjectColumn rec =
    Json.Encode.object
        [ ( "cards_url", Json.Encode.string rec.cards_url )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "id", Json.Encode.int rec.id )
        , ( "name", Json.Encode.string rec.name )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "project_url", Json.Encode.string rec.project_url )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias ProjectCollaboratorPermission =
    { permission : String, user : Nullable SimpleUser }


decodeProjectCollaboratorPermission :
    Json.Decode.Decoder ProjectCollaboratorPermission
decodeProjectCollaboratorPermission =
    Json.Decode.succeed
     (\permission user -> { permission = permission, user = user })
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "permission" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "user"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )


encodeProjectCollaboratorPermission :
    ProjectCollaboratorPermission -> Json.Encode.Value
encodeProjectCollaboratorPermission rec =
    Json.Encode.object
        [ ( "permission", Json.Encode.string rec.permission )
        , ( "user"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.user
          )
        ]


type alias ProjectCard =
    { archived : Bool
    , column_name : String
    , column_url : String
    , content_url : String
    , created_at : String
    , creator : Nullable SimpleUser
    , id : Int
    , node_id : String
    , note : Nullable String
    , project_id : String
    , project_url : String
    , updated_at : String
    , url : String
    }


decodeProjectCard : Json.Decode.Decoder ProjectCard
decodeProjectCard =
    Json.Decode.succeed
     (\archived column_name column_url content_url created_at creator id node_id note project_id project_url updated_at url ->
         { archived = archived
         , column_name = column_name
         , column_url = column_url
         , content_url = content_url
         , created_at = created_at
         , creator = creator
         , id = id
         , node_id = node_id
         , note = note
         , project_id = project_id
         , project_url = project_url
         , updated_at = updated_at
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "archived" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "column_name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "column_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "content_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "creator"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "note"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "project_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "project_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeProjectCard : ProjectCard -> Json.Encode.Value
encodeProjectCard rec =
    Json.Encode.object
        [ ( "archived", Json.Encode.bool rec.archived )
        , ( "column_name", Json.Encode.string rec.column_name )
        , ( "column_url", Json.Encode.string rec.column_url )
        , ( "content_url", Json.Encode.string rec.content_url )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "creator"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.creator
          )
        , ( "id", Json.Encode.int rec.id )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "note"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.note
          )
        , ( "project_id", Json.Encode.string rec.project_id )
        , ( "project_url", Json.Encode.string rec.project_url )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias Project =
    { body : Nullable String
    , columns_url : String
    , created_at : String
    , creator : Nullable SimpleUser
    , html_url : String
    , id : Int
    , name : String
    , node_id : String
    , number : Int
    , organization_permission : String
    , owner_url : String
    , private : Bool
    , state : String
    , updated_at : String
    , url : String
    }


decodeProject : Json.Decode.Decoder Project
decodeProject =
    Json.Decode.succeed
     (\body columns_url created_at creator html_url id name node_id number organization_permission owner_url private state updated_at url ->
         { body = body
         , columns_url = columns_url
         , created_at = created_at
         , creator = creator
         , html_url = html_url
         , id = id
         , name = name
         , node_id = node_id
         , number = number
         , organization_permission = organization_permission
         , owner_url = owner_url
         , private = private
         , state = state
         , updated_at = updated_at
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "body"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "columns_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "creator"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "number" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "organization_permission" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "owner_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "private" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "state" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeProject : Project -> Json.Encode.Value
encodeProject rec =
    Json.Encode.object
        [ ( "body"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.body
          )
        , ( "columns_url", Json.Encode.string rec.columns_url )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "creator"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.creator
          )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "id", Json.Encode.int rec.id )
        , ( "name", Json.Encode.string rec.name )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "number", Json.Encode.int rec.number )
        , ( "organization_permission"
          , Json.Encode.string rec.organization_permission
          )
        , ( "owner_url", Json.Encode.string rec.owner_url )
        , ( "private", Json.Encode.bool rec.private )
        , ( "state", Json.Encode.string rec.state )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias PrivateUser =
    { avatar_url : String
    , bio : Nullable String
    , blog : Nullable String
    , business_plus : Bool
    , collaborators : Int
    , company : Nullable String
    , created_at : String
    , disk_usage : Int
    , email : Nullable String
    , events_url : String
    , followers : Int
    , followers_url : String
    , following : Int
    , following_url : String
    , gists_url : String
    , gravatar_id : Nullable String
    , hireable : Nullable Bool
    , html_url : String
    , id : Int
    , ldap_dn : String
    , location : Nullable String
    , login : String
    , name : Nullable String
    , node_id : String
    , organizations_url : String
    , owned_private_repos : Int
    , plan :
        { collaborators : Int, name : String, private_repos : Int, space : Int }
    , private_gists : Int
    , public_gists : Int
    , public_repos : Int
    , received_events_url : String
    , repos_url : String
    , site_admin : Bool
    , starred_url : String
    , subscriptions_url : String
    , suspended_at : Nullable String
    , total_private_repos : Int
    , twitter_username : Nullable String
    , two_factor_authentication : Bool
    , type_ : String
    , updated_at : String
    , url : String
    }


decodePrivateUser : Json.Decode.Decoder PrivateUser
decodePrivateUser =
    Json.Decode.succeed
     (\avatar_url bio blog business_plus collaborators company created_at disk_usage email events_url followers followers_url following following_url gists_url gravatar_id hireable html_url id ldap_dn location login name node_id organizations_url owned_private_repos plan private_gists public_gists public_repos received_events_url repos_url site_admin starred_url subscriptions_url suspended_at total_private_repos twitter_username two_factor_authentication type_ updated_at url ->
         { avatar_url = avatar_url
         , bio = bio
         , blog = blog
         , business_plus = business_plus
         , collaborators = collaborators
         , company = company
         , created_at = created_at
         , disk_usage = disk_usage
         , email = email
         , events_url = events_url
         , followers = followers
         , followers_url = followers_url
         , following = following
         , following_url = following_url
         , gists_url = gists_url
         , gravatar_id = gravatar_id
         , hireable = hireable
         , html_url = html_url
         , id = id
         , ldap_dn = ldap_dn
         , location = location
         , login = login
         , name = name
         , node_id = node_id
         , organizations_url = organizations_url
         , owned_private_repos = owned_private_repos
         , plan = plan
         , private_gists = private_gists
         , public_gists = public_gists
         , public_repos = public_repos
         , received_events_url = received_events_url
         , repos_url = repos_url
         , site_admin = site_admin
         , starred_url = starred_url
         , subscriptions_url = subscriptions_url
         , suspended_at = suspended_at
         , total_private_repos = total_private_repos
         , twitter_username = twitter_username
         , two_factor_authentication = two_factor_authentication
         , type_ = type_
         , updated_at = updated_at
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "avatar_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "bio"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "blog"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "business_plus" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "collaborators" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "company"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "disk_usage" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "email"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "events_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "followers" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "followers_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "following" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "following_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "gists_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "gravatar_id"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "hireable"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.bool
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "ldap_dn" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "location"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "login" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "name"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "organizations_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "owned_private_repos" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "plan"
                (Json.Decode.succeed
                  (\collaborators name private_repos space ->
                      { collaborators = collaborators
                      , name = name
                      , private_repos = private_repos
                      , space = space
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "collaborators" Json.Decode.int)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "name" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "private_repos" Json.Decode.int)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "space" Json.Decode.int)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "private_gists" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "public_gists" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "public_repos" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "received_events_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "repos_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "site_admin" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "starred_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "subscriptions_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "suspended_at"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "total_private_repos" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "twitter_username"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "two_factor_authentication" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "type" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodePrivateUser : PrivateUser -> Json.Encode.Value
encodePrivateUser rec =
    Json.Encode.object
        [ ( "avatar_url", Json.Encode.string rec.avatar_url )
        , ( "bio"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.bio
          )
        , ( "blog"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.blog
          )
        , ( "business_plus", Json.Encode.bool rec.business_plus )
        , ( "collaborators", Json.Encode.int rec.collaborators )
        , ( "company"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.company
          )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "disk_usage", Json.Encode.int rec.disk_usage )
        , ( "email"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.email
          )
        , ( "events_url", Json.Encode.string rec.events_url )
        , ( "followers", Json.Encode.int rec.followers )
        , ( "followers_url", Json.Encode.string rec.followers_url )
        , ( "following", Json.Encode.int rec.following )
        , ( "following_url", Json.Encode.string rec.following_url )
        , ( "gists_url", Json.Encode.string rec.gists_url )
        , ( "gravatar_id"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.gravatar_id
          )
        , ( "hireable"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.bool value
            )
                rec.hireable
          )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "id", Json.Encode.int rec.id )
        , ( "ldap_dn", Json.Encode.string rec.ldap_dn )
        , ( "location"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.location
          )
        , ( "login", Json.Encode.string rec.login )
        , ( "name"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.name
          )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "organizations_url", Json.Encode.string rec.organizations_url )
        , ( "owned_private_repos", Json.Encode.int rec.owned_private_repos )
        , ( "plan"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "collaborators", Json.Encode.int rec0.collaborators )
                    , ( "name", Json.Encode.string rec0.name )
                    , ( "private_repos", Json.Encode.int rec0.private_repos )
                    , ( "space", Json.Encode.int rec0.space )
                    ]
            )
                rec.plan
          )
        , ( "private_gists", Json.Encode.int rec.private_gists )
        , ( "public_gists", Json.Encode.int rec.public_gists )
        , ( "public_repos", Json.Encode.int rec.public_repos )
        , ( "received_events_url", Json.Encode.string rec.received_events_url )
        , ( "repos_url", Json.Encode.string rec.repos_url )
        , ( "site_admin", Json.Encode.bool rec.site_admin )
        , ( "starred_url", Json.Encode.string rec.starred_url )
        , ( "subscriptions_url", Json.Encode.string rec.subscriptions_url )
        , ( "suspended_at"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.suspended_at
          )
        , ( "total_private_repos", Json.Encode.int rec.total_private_repos )
        , ( "twitter_username"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.twitter_username
          )
        , ( "two_factor_authentication"
          , Json.Encode.bool rec.two_factor_authentication
          )
        , ( "type", Json.Encode.string rec.type_ )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias PorterLargeFile =
    { oid : String, path : String, ref_name : String, size : Int }


decodePorterLargeFile : Json.Decode.Decoder PorterLargeFile
decodePorterLargeFile =
    Json.Decode.succeed
     (\oid path ref_name size ->
         { oid = oid, path = path, ref_name = ref_name, size = size }
     )
        |> Json.Decode.Extra.andMap (Json.Decode.field "oid" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "path" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "ref_name" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "size" Json.Decode.int)


encodePorterLargeFile : PorterLargeFile -> Json.Encode.Value
encodePorterLargeFile rec =
    Json.Encode.object
        [ ( "oid", Json.Encode.string rec.oid )
        , ( "path", Json.Encode.string rec.path )
        , ( "ref_name", Json.Encode.string rec.ref_name )
        , ( "size", Json.Encode.int rec.size )
        ]


type alias PorterAuthor =
    { email : String
    , id : Int
    , import_url : String
    , name : String
    , remote_id : String
    , remote_name : String
    , url : String
    }


decodePorterAuthor : Json.Decode.Decoder PorterAuthor
decodePorterAuthor =
    Json.Decode.succeed
     (\email id import_url name remote_id remote_name url ->
         { email = email
         , id = id
         , import_url = import_url
         , name = name
         , remote_id = remote_id
         , remote_name = remote_name
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "email" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "import_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "remote_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "remote_name" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodePorterAuthor : PorterAuthor -> Json.Encode.Value
encodePorterAuthor rec =
    Json.Encode.object
        [ ( "email", Json.Encode.string rec.email )
        , ( "id", Json.Encode.int rec.id )
        , ( "import_url", Json.Encode.string rec.import_url )
        , ( "name", Json.Encode.string rec.name )
        , ( "remote_id", Json.Encode.string rec.remote_id )
        , ( "remote_name", Json.Encode.string rec.remote_name )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias PendingDeployment =
    { current_user_can_approve : Bool
    , environment :
        { html_url : String
        , id : Int
        , name : String
        , node_id : String
        , url : String
        }
    , reviewers :
        List { reviewer : EnumTwo SimpleUser Team
        , type_ : DeploymentReviewerType
        }
    , wait_timer : Int
    , wait_timer_started_at : Nullable String
    }


decodePendingDeployment : Json.Decode.Decoder PendingDeployment
decodePendingDeployment =
    Json.Decode.succeed
     (\current_user_can_approve environment reviewers wait_timer wait_timer_started_at ->
         { current_user_can_approve = current_user_can_approve
         , environment = environment
         , reviewers = reviewers
         , wait_timer = wait_timer
         , wait_timer_started_at = wait_timer_started_at
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "current_user_can_approve" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "environment"
                (Json.Decode.succeed
                  (\html_url id name node_id url ->
                      { html_url = html_url
                      , id = id
                      , name = name
                      , node_id = node_id
                      , url = url
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "html_url" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "id" Json.Decode.int)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "name" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "node_id" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "url" Json.Decode.string)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "reviewers"
                (Json.Decode.list
                    (Json.Decode.succeed
                      (\reviewer type_ -> { reviewer = reviewer, type_ = type_ }
                      )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field
                                "reviewer"
                                (Debug.todo "Enum decoder not implemented yet")
                            )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field
                                "type"
                                decodeDeploymentReviewerType
                            )
                    )
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "wait_timer" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "wait_timer_started_at"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )


encodePendingDeployment : PendingDeployment -> Json.Encode.Value
encodePendingDeployment rec =
    Json.Encode.object
        [ ( "current_user_can_approve"
          , Json.Encode.bool rec.current_user_can_approve
          )
        , ( "environment"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "html_url", Json.Encode.string rec0.html_url )
                    , ( "id", Json.Encode.int rec0.id )
                    , ( "name", Json.Encode.string rec0.name )
                    , ( "node_id", Json.Encode.string rec0.node_id )
                    , ( "url", Json.Encode.string rec0.url )
                    ]
            )
                rec.environment
          )
        , ( "reviewers"
          , Json.Encode.list
                (\rec0 ->
                    Json.Encode.object
                        [ ( "reviewer"
                          , Debug.todo "encoder for enum not implemented"
                                rec0.reviewer
                          )
                        , ( "type", encodeDeploymentReviewerType rec0.type_ )
                        ]
                )
                rec.reviewers
          )
        , ( "wait_timer", Json.Encode.int rec.wait_timer )
        , ( "wait_timer_started_at"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.wait_timer_started_at
          )
        ]


type alias ParticipationStats =
    { all : List Int, owner : List Int }


decodeParticipationStats : Json.Decode.Decoder ParticipationStats
decodeParticipationStats =
    Json.Decode.succeed (\all owner -> { all = all, owner = owner })
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "all" (Json.Decode.list Json.Decode.int))
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "owner" (Json.Decode.list Json.Decode.int))


encodeParticipationStats : ParticipationStats -> Json.Encode.Value
encodeParticipationStats rec =
    Json.Encode.object
        [ ( "all", Json.Encode.list Json.Encode.int rec.all )
        , ( "owner", Json.Encode.list Json.Encode.int rec.owner )
        ]


type alias PagesSourceHash =
    { branch : String, path : String }


decodePagesSourceHash : Json.Decode.Decoder PagesSourceHash
decodePagesSourceHash =
    Json.Decode.succeed (\branch path -> { branch = branch, path = path })
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "branch" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "path" Json.Decode.string)


encodePagesSourceHash : PagesSourceHash -> Json.Encode.Value
encodePagesSourceHash rec =
    Json.Encode.object
        [ ( "branch", Json.Encode.string rec.branch )
        , ( "path", Json.Encode.string rec.path )
        ]


type alias PagesHttpsCertificate =
    { description : String
    , domains : List String
    , expires_at : String
    , state : String
    }


decodePagesHttpsCertificate : Json.Decode.Decoder PagesHttpsCertificate
decodePagesHttpsCertificate =
    Json.Decode.succeed
     (\description domains expires_at state ->
         { description = description
         , domains = domains
         , expires_at = expires_at
         , state = state
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "description" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "domains" (Json.Decode.list Json.Decode.string))
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "expires_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "state" Json.Decode.string)


encodePagesHttpsCertificate : PagesHttpsCertificate -> Json.Encode.Value
encodePagesHttpsCertificate rec =
    Json.Encode.object
        [ ( "description", Json.Encode.string rec.description )
        , ( "domains", Json.Encode.list Json.Encode.string rec.domains )
        , ( "expires_at", Json.Encode.string rec.expires_at )
        , ( "state", Json.Encode.string rec.state )
        ]


type alias PagesHealthCheck =
    { alt_domain :
        Nullable { caa_error : Nullable String
        , dns_resolves : Bool
        , enforces_https : Bool
        , has_cname_record : Nullable Bool
        , has_mx_records_present : Nullable Bool
        , host : String
        , https_error : Nullable String
        , is_a_record : Nullable Bool
        , is_apex_domain : Bool
        , is_cloudflare_ip : Nullable Bool
        , is_cname_to_fastly : Nullable Bool
        , is_cname_to_github_user_domain : Nullable Bool
        , is_cname_to_pages_dot_github_dot_com : Nullable Bool
        , is_fastly_ip : Nullable Bool
        , is_https_eligible : Nullable Bool
        , is_non_github_pages_ip_present : Nullable Bool
        , is_old_ip_address : Nullable Bool
        , is_pages_domain : Bool
        , is_pointed_to_github_pages_ip : Nullable Bool
        , is_proxied : Nullable Bool
        , is_served_by_pages : Nullable Bool
        , is_valid : Bool
        , is_valid_domain : Bool
        , nameservers : String
        , reason : Nullable String
        , responds_to_https : Bool
        , should_be_a_record : Nullable Bool
        , uri : String
        }
    , domain :
        { caa_error : Nullable String
        , dns_resolves : Bool
        , enforces_https : Bool
        , has_cname_record : Nullable Bool
        , has_mx_records_present : Nullable Bool
        , host : String
        , https_error : Nullable String
        , is_a_record : Nullable Bool
        , is_apex_domain : Bool
        , is_cloudflare_ip : Nullable Bool
        , is_cname_to_fastly : Nullable Bool
        , is_cname_to_github_user_domain : Nullable Bool
        , is_cname_to_pages_dot_github_dot_com : Nullable Bool
        , is_fastly_ip : Nullable Bool
        , is_https_eligible : Nullable Bool
        , is_non_github_pages_ip_present : Nullable Bool
        , is_old_ip_address : Nullable Bool
        , is_pages_domain : Bool
        , is_pointed_to_github_pages_ip : Nullable Bool
        , is_proxied : Nullable Bool
        , is_served_by_pages : Nullable Bool
        , is_valid : Bool
        , is_valid_domain : Bool
        , nameservers : String
        , reason : Nullable String
        , responds_to_https : Bool
        , should_be_a_record : Nullable Bool
        , uri : String
        }
    }


decodePagesHealthCheck : Json.Decode.Decoder PagesHealthCheck
decodePagesHealthCheck =
    Json.Decode.succeed
     (\alt_domain domain -> { alt_domain = alt_domain, domain = domain })
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "alt_domain"
                (Json.Decode.oneOf
                    [ Json.Decode.map
                        Present
                        (Json.Decode.succeed
                          (\caa_error dns_resolves enforces_https has_cname_record has_mx_records_present host https_error is_a_record is_apex_domain is_cloudflare_ip is_cname_to_fastly is_cname_to_github_user_domain is_cname_to_pages_dot_github_dot_com is_fastly_ip is_https_eligible is_non_github_pages_ip_present is_old_ip_address is_pages_domain is_pointed_to_github_pages_ip is_proxied is_served_by_pages is_valid is_valid_domain nameservers reason responds_to_https should_be_a_record uri ->
                              { caa_error = caa_error
                              , dns_resolves = dns_resolves
                              , enforces_https = enforces_https
                              , has_cname_record = has_cname_record
                              , has_mx_records_present = has_mx_records_present
                              , host = host
                              , https_error = https_error
                              , is_a_record = is_a_record
                              , is_apex_domain = is_apex_domain
                              , is_cloudflare_ip = is_cloudflare_ip
                              , is_cname_to_fastly = is_cname_to_fastly
                              , is_cname_to_github_user_domain =
                                  is_cname_to_github_user_domain
                              , is_cname_to_pages_dot_github_dot_com =
                                  is_cname_to_pages_dot_github_dot_com
                              , is_fastly_ip = is_fastly_ip
                              , is_https_eligible = is_https_eligible
                              , is_non_github_pages_ip_present =
                                  is_non_github_pages_ip_present
                              , is_old_ip_address = is_old_ip_address
                              , is_pages_domain = is_pages_domain
                              , is_pointed_to_github_pages_ip =
                                  is_pointed_to_github_pages_ip
                              , is_proxied = is_proxied
                              , is_served_by_pages = is_served_by_pages
                              , is_valid = is_valid
                              , is_valid_domain = is_valid_domain
                              , nameservers = nameservers
                              , reason = reason
                              , responds_to_https = responds_to_https
                              , should_be_a_record = should_be_a_record
                              , uri = uri
                              }
                          )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "caa_error"
                                    (Json.Decode.oneOf
                                        [ Json.Decode.map
                                            Present
                                            Json.Decode.string
                                        , Json.Decode.null Null
                                        ]
                                    )
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "dns_resolves"
                                    Json.Decode.bool
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "enforces_https"
                                    Json.Decode.bool
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "has_cname_record"
                                    (Json.Decode.oneOf
                                        [ Json.Decode.map
                                            Present
                                            Json.Decode.bool
                                        , Json.Decode.null Null
                                        ]
                                    )
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "has_mx_records_present"
                                    (Json.Decode.oneOf
                                        [ Json.Decode.map
                                            Present
                                            Json.Decode.bool
                                        , Json.Decode.null Null
                                        ]
                                    )
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "host" Json.Decode.string)
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "https_error"
                                    (Json.Decode.oneOf
                                        [ Json.Decode.map
                                            Present
                                            Json.Decode.string
                                        , Json.Decode.null Null
                                        ]
                                    )
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "is_a_record"
                                    (Json.Decode.oneOf
                                        [ Json.Decode.map
                                            Present
                                            Json.Decode.bool
                                        , Json.Decode.null Null
                                        ]
                                    )
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "is_apex_domain"
                                    Json.Decode.bool
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "is_cloudflare_ip"
                                    (Json.Decode.oneOf
                                        [ Json.Decode.map
                                            Present
                                            Json.Decode.bool
                                        , Json.Decode.null Null
                                        ]
                                    )
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "is_cname_to_fastly"
                                    (Json.Decode.oneOf
                                        [ Json.Decode.map
                                            Present
                                            Json.Decode.bool
                                        , Json.Decode.null Null
                                        ]
                                    )
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "is_cname_to_github_user_domain"
                                    (Json.Decode.oneOf
                                        [ Json.Decode.map
                                            Present
                                            Json.Decode.bool
                                        , Json.Decode.null Null
                                        ]
                                    )
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "is_cname_to_pages_dot_github_dot_com"
                                    (Json.Decode.oneOf
                                        [ Json.Decode.map
                                            Present
                                            Json.Decode.bool
                                        , Json.Decode.null Null
                                        ]
                                    )
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "is_fastly_ip"
                                    (Json.Decode.oneOf
                                        [ Json.Decode.map
                                            Present
                                            Json.Decode.bool
                                        , Json.Decode.null Null
                                        ]
                                    )
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "is_https_eligible"
                                    (Json.Decode.oneOf
                                        [ Json.Decode.map
                                            Present
                                            Json.Decode.bool
                                        , Json.Decode.null Null
                                        ]
                                    )
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "is_non_github_pages_ip_present"
                                    (Json.Decode.oneOf
                                        [ Json.Decode.map
                                            Present
                                            Json.Decode.bool
                                        , Json.Decode.null Null
                                        ]
                                    )
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "is_old_ip_address"
                                    (Json.Decode.oneOf
                                        [ Json.Decode.map
                                            Present
                                            Json.Decode.bool
                                        , Json.Decode.null Null
                                        ]
                                    )
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "is_pages_domain"
                                    Json.Decode.bool
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "is_pointed_to_github_pages_ip"
                                    (Json.Decode.oneOf
                                        [ Json.Decode.map
                                            Present
                                            Json.Decode.bool
                                        , Json.Decode.null Null
                                        ]
                                    )
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "is_proxied"
                                    (Json.Decode.oneOf
                                        [ Json.Decode.map
                                            Present
                                            Json.Decode.bool
                                        , Json.Decode.null Null
                                        ]
                                    )
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "is_served_by_pages"
                                    (Json.Decode.oneOf
                                        [ Json.Decode.map
                                            Present
                                            Json.Decode.bool
                                        , Json.Decode.null Null
                                        ]
                                    )
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "is_valid" Json.Decode.bool)
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "is_valid_domain"
                                    Json.Decode.bool
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "nameservers"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "reason"
                                    (Json.Decode.oneOf
                                        [ Json.Decode.map
                                            Present
                                            Json.Decode.string
                                        , Json.Decode.null Null
                                        ]
                                    )
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "responds_to_https"
                                    Json.Decode.bool
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "should_be_a_record"
                                    (Json.Decode.oneOf
                                        [ Json.Decode.map
                                            Present
                                            Json.Decode.bool
                                        , Json.Decode.null Null
                                        ]
                                    )
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "uri" Json.Decode.string)
                        )
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "domain"
                (Json.Decode.succeed
                  (\caa_error dns_resolves enforces_https has_cname_record has_mx_records_present host https_error is_a_record is_apex_domain is_cloudflare_ip is_cname_to_fastly is_cname_to_github_user_domain is_cname_to_pages_dot_github_dot_com is_fastly_ip is_https_eligible is_non_github_pages_ip_present is_old_ip_address is_pages_domain is_pointed_to_github_pages_ip is_proxied is_served_by_pages is_valid is_valid_domain nameservers reason responds_to_https should_be_a_record uri ->
                      { caa_error = caa_error
                      , dns_resolves = dns_resolves
                      , enforces_https = enforces_https
                      , has_cname_record = has_cname_record
                      , has_mx_records_present = has_mx_records_present
                      , host = host
                      , https_error = https_error
                      , is_a_record = is_a_record
                      , is_apex_domain = is_apex_domain
                      , is_cloudflare_ip = is_cloudflare_ip
                      , is_cname_to_fastly = is_cname_to_fastly
                      , is_cname_to_github_user_domain =
                          is_cname_to_github_user_domain
                      , is_cname_to_pages_dot_github_dot_com =
                          is_cname_to_pages_dot_github_dot_com
                      , is_fastly_ip = is_fastly_ip
                      , is_https_eligible = is_https_eligible
                      , is_non_github_pages_ip_present =
                          is_non_github_pages_ip_present
                      , is_old_ip_address = is_old_ip_address
                      , is_pages_domain = is_pages_domain
                      , is_pointed_to_github_pages_ip =
                          is_pointed_to_github_pages_ip
                      , is_proxied = is_proxied
                      , is_served_by_pages = is_served_by_pages
                      , is_valid = is_valid
                      , is_valid_domain = is_valid_domain
                      , nameservers = nameservers
                      , reason = reason
                      , responds_to_https = responds_to_https
                      , should_be_a_record = should_be_a_record
                      , uri = uri
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "caa_error"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.string
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "dns_resolves" Json.Decode.bool)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "enforces_https" Json.Decode.bool)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "has_cname_record"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.bool
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "has_mx_records_present"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.bool
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "host" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "https_error"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.string
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "is_a_record"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.bool
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "is_apex_domain" Json.Decode.bool)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "is_cloudflare_ip"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.bool
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "is_cname_to_fastly"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.bool
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "is_cname_to_github_user_domain"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.bool
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "is_cname_to_pages_dot_github_dot_com"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.bool
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "is_fastly_ip"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.bool
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "is_https_eligible"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.bool
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "is_non_github_pages_ip_present"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.bool
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "is_old_ip_address"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.bool
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "is_pages_domain" Json.Decode.bool)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "is_pointed_to_github_pages_ip"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.bool
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "is_proxied"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.bool
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "is_served_by_pages"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.bool
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "is_valid" Json.Decode.bool)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "is_valid_domain" Json.Decode.bool)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "nameservers" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "reason"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.string
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "responds_to_https" Json.Decode.bool)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "should_be_a_record"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.bool
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "uri" Json.Decode.string)
                )
            )


encodePagesHealthCheck : PagesHealthCheck -> Json.Encode.Value
encodePagesHealthCheck rec =
    Json.Encode.object
        [ ( "alt_domain"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        (\rec0 ->
                            Json.Encode.object
                                [ ( "caa_error"
                                  , (\nullableValue0 ->
                                        case nullableValue0 of
                                            Null ->
                                                Json.Encode.null

                                            Present value0 ->
                                                Json.Encode.string value0
                                    )
                                        rec0.caa_error
                                  )
                                , ( "dns_resolves"
                                  , Json.Encode.bool rec0.dns_resolves
                                  )
                                , ( "enforces_https"
                                  , Json.Encode.bool rec0.enforces_https
                                  )
                                , ( "has_cname_record"
                                  , (\nullableValue0 ->
                                        case nullableValue0 of
                                            Null ->
                                                Json.Encode.null

                                            Present value0 ->
                                                Json.Encode.bool value0
                                    )
                                        rec0.has_cname_record
                                  )
                                , ( "has_mx_records_present"
                                  , (\nullableValue0 ->
                                        case nullableValue0 of
                                            Null ->
                                                Json.Encode.null

                                            Present value0 ->
                                                Json.Encode.bool value0
                                    )
                                        rec0.has_mx_records_present
                                  )
                                , ( "host", Json.Encode.string rec0.host )
                                , ( "https_error"
                                  , (\nullableValue0 ->
                                        case nullableValue0 of
                                            Null ->
                                                Json.Encode.null

                                            Present value0 ->
                                                Json.Encode.string value0
                                    )
                                        rec0.https_error
                                  )
                                , ( "is_a_record"
                                  , (\nullableValue0 ->
                                        case nullableValue0 of
                                            Null ->
                                                Json.Encode.null

                                            Present value0 ->
                                                Json.Encode.bool value0
                                    )
                                        rec0.is_a_record
                                  )
                                , ( "is_apex_domain"
                                  , Json.Encode.bool rec0.is_apex_domain
                                  )
                                , ( "is_cloudflare_ip"
                                  , (\nullableValue0 ->
                                        case nullableValue0 of
                                            Null ->
                                                Json.Encode.null

                                            Present value0 ->
                                                Json.Encode.bool value0
                                    )
                                        rec0.is_cloudflare_ip
                                  )
                                , ( "is_cname_to_fastly"
                                  , (\nullableValue0 ->
                                        case nullableValue0 of
                                            Null ->
                                                Json.Encode.null

                                            Present value0 ->
                                                Json.Encode.bool value0
                                    )
                                        rec0.is_cname_to_fastly
                                  )
                                , ( "is_cname_to_github_user_domain"
                                  , (\nullableValue0 ->
                                        case nullableValue0 of
                                            Null ->
                                                Json.Encode.null

                                            Present value0 ->
                                                Json.Encode.bool value0
                                    )
                                        rec0.is_cname_to_github_user_domain
                                  )
                                , ( "is_cname_to_pages_dot_github_dot_com"
                                  , (\nullableValue0 ->
                                        case nullableValue0 of
                                            Null ->
                                                Json.Encode.null

                                            Present value0 ->
                                                Json.Encode.bool value0
                                    )
                                        rec0.is_cname_to_pages_dot_github_dot_com
                                  )
                                , ( "is_fastly_ip"
                                  , (\nullableValue0 ->
                                        case nullableValue0 of
                                            Null ->
                                                Json.Encode.null

                                            Present value0 ->
                                                Json.Encode.bool value0
                                    )
                                        rec0.is_fastly_ip
                                  )
                                , ( "is_https_eligible"
                                  , (\nullableValue0 ->
                                        case nullableValue0 of
                                            Null ->
                                                Json.Encode.null

                                            Present value0 ->
                                                Json.Encode.bool value0
                                    )
                                        rec0.is_https_eligible
                                  )
                                , ( "is_non_github_pages_ip_present"
                                  , (\nullableValue0 ->
                                        case nullableValue0 of
                                            Null ->
                                                Json.Encode.null

                                            Present value0 ->
                                                Json.Encode.bool value0
                                    )
                                        rec0.is_non_github_pages_ip_present
                                  )
                                , ( "is_old_ip_address"
                                  , (\nullableValue0 ->
                                        case nullableValue0 of
                                            Null ->
                                                Json.Encode.null

                                            Present value0 ->
                                                Json.Encode.bool value0
                                    )
                                        rec0.is_old_ip_address
                                  )
                                , ( "is_pages_domain"
                                  , Json.Encode.bool rec0.is_pages_domain
                                  )
                                , ( "is_pointed_to_github_pages_ip"
                                  , (\nullableValue0 ->
                                        case nullableValue0 of
                                            Null ->
                                                Json.Encode.null

                                            Present value0 ->
                                                Json.Encode.bool value0
                                    )
                                        rec0.is_pointed_to_github_pages_ip
                                  )
                                , ( "is_proxied"
                                  , (\nullableValue0 ->
                                        case nullableValue0 of
                                            Null ->
                                                Json.Encode.null

                                            Present value0 ->
                                                Json.Encode.bool value0
                                    )
                                        rec0.is_proxied
                                  )
                                , ( "is_served_by_pages"
                                  , (\nullableValue0 ->
                                        case nullableValue0 of
                                            Null ->
                                                Json.Encode.null

                                            Present value0 ->
                                                Json.Encode.bool value0
                                    )
                                        rec0.is_served_by_pages
                                  )
                                , ( "is_valid", Json.Encode.bool rec0.is_valid )
                                , ( "is_valid_domain"
                                  , Json.Encode.bool rec0.is_valid_domain
                                  )
                                , ( "nameservers"
                                  , Json.Encode.string rec0.nameservers
                                  )
                                , ( "reason"
                                  , (\nullableValue0 ->
                                        case nullableValue0 of
                                            Null ->
                                                Json.Encode.null

                                            Present value0 ->
                                                Json.Encode.string value0
                                    )
                                        rec0.reason
                                  )
                                , ( "responds_to_https"
                                  , Json.Encode.bool rec0.responds_to_https
                                  )
                                , ( "should_be_a_record"
                                  , (\nullableValue0 ->
                                        case nullableValue0 of
                                            Null ->
                                                Json.Encode.null

                                            Present value0 ->
                                                Json.Encode.bool value0
                                    )
                                        rec0.should_be_a_record
                                  )
                                , ( "uri", Json.Encode.string rec0.uri )
                                ]
                        )
                            value
            )
                rec.alt_domain
          )
        , ( "domain"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "caa_error"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.string value
                        )
                            rec0.caa_error
                      )
                    , ( "dns_resolves", Json.Encode.bool rec0.dns_resolves )
                    , ( "enforces_https", Json.Encode.bool rec0.enforces_https )
                    , ( "has_cname_record"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.bool value
                        )
                            rec0.has_cname_record
                      )
                    , ( "has_mx_records_present"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.bool value
                        )
                            rec0.has_mx_records_present
                      )
                    , ( "host", Json.Encode.string rec0.host )
                    , ( "https_error"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.string value
                        )
                            rec0.https_error
                      )
                    , ( "is_a_record"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.bool value
                        )
                            rec0.is_a_record
                      )
                    , ( "is_apex_domain", Json.Encode.bool rec0.is_apex_domain )
                    , ( "is_cloudflare_ip"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.bool value
                        )
                            rec0.is_cloudflare_ip
                      )
                    , ( "is_cname_to_fastly"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.bool value
                        )
                            rec0.is_cname_to_fastly
                      )
                    , ( "is_cname_to_github_user_domain"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.bool value
                        )
                            rec0.is_cname_to_github_user_domain
                      )
                    , ( "is_cname_to_pages_dot_github_dot_com"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.bool value
                        )
                            rec0.is_cname_to_pages_dot_github_dot_com
                      )
                    , ( "is_fastly_ip"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.bool value
                        )
                            rec0.is_fastly_ip
                      )
                    , ( "is_https_eligible"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.bool value
                        )
                            rec0.is_https_eligible
                      )
                    , ( "is_non_github_pages_ip_present"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.bool value
                        )
                            rec0.is_non_github_pages_ip_present
                      )
                    , ( "is_old_ip_address"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.bool value
                        )
                            rec0.is_old_ip_address
                      )
                    , ( "is_pages_domain"
                      , Json.Encode.bool rec0.is_pages_domain
                      )
                    , ( "is_pointed_to_github_pages_ip"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.bool value
                        )
                            rec0.is_pointed_to_github_pages_ip
                      )
                    , ( "is_proxied"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.bool value
                        )
                            rec0.is_proxied
                      )
                    , ( "is_served_by_pages"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.bool value
                        )
                            rec0.is_served_by_pages
                      )
                    , ( "is_valid", Json.Encode.bool rec0.is_valid )
                    , ( "is_valid_domain"
                      , Json.Encode.bool rec0.is_valid_domain
                      )
                    , ( "nameservers", Json.Encode.string rec0.nameservers )
                    , ( "reason"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.string value
                        )
                            rec0.reason
                      )
                    , ( "responds_to_https"
                      , Json.Encode.bool rec0.responds_to_https
                      )
                    , ( "should_be_a_record"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.bool value
                        )
                            rec0.should_be_a_record
                      )
                    , ( "uri", Json.Encode.string rec0.uri )
                    ]
            )
                rec.domain
          )
        ]


type alias PageDeployment =
    { page_url : String, preview_url : String, status_url : String }


decodePageDeployment : Json.Decode.Decoder PageDeployment
decodePageDeployment =
    Json.Decode.succeed
     (\page_url preview_url status_url ->
         { page_url = page_url
         , preview_url = preview_url
         , status_url = status_url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "page_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "preview_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "status_url" Json.Decode.string)


encodePageDeployment : PageDeployment -> Json.Encode.Value
encodePageDeployment rec =
    Json.Encode.object
        [ ( "page_url", Json.Encode.string rec.page_url )
        , ( "preview_url", Json.Encode.string rec.preview_url )
        , ( "status_url", Json.Encode.string rec.status_url )
        ]


type alias PageBuildStatus =
    { status : String, url : String }


decodePageBuildStatus : Json.Decode.Decoder PageBuildStatus
decodePageBuildStatus =
    Json.Decode.succeed (\status url -> { status = status, url = url })
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "status" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodePageBuildStatus : PageBuildStatus -> Json.Encode.Value
encodePageBuildStatus rec =
    Json.Encode.object
        [ ( "status", Json.Encode.string rec.status )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias PageBuild =
    { commit : String
    , created_at : String
    , duration : Int
    , error : { message : Nullable String }
    , pusher : Nullable SimpleUser
    , status : String
    , updated_at : String
    , url : String
    }


decodePageBuild : Json.Decode.Decoder PageBuild
decodePageBuild =
    Json.Decode.succeed
     (\commit created_at duration error pusher status updated_at url ->
         { commit = commit
         , created_at = created_at
         , duration = duration
         , error = error
         , pusher = pusher
         , status = status
         , updated_at = updated_at
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "commit" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "duration" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "error"
                (Json.Decode.succeed (\message -> { message = message })
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "message"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.string
                                , Json.Decode.null Null
                                ]
                            )
                        )
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "pusher"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "status" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodePageBuild : PageBuild -> Json.Encode.Value
encodePageBuild rec =
    Json.Encode.object
        [ ( "commit", Json.Encode.string rec.commit )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "duration", Json.Encode.int rec.duration )
        , ( "error"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "message"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.string value
                        )
                            rec0.message
                      )
                    ]
            )
                rec.error
          )
        , ( "pusher"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.pusher
          )
        , ( "status", Json.Encode.string rec.status )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias Page =
    { build_type : Nullable String
    , cname : Nullable String
    , custom_404 : Bool
    , html_url : String
    , https_certificate : PagesHttpsCertificate
    , https_enforced : Bool
    , pending_domain_unverified_at : Nullable String
    , protected_domain_state : Nullable String
    , public : Bool
    , source : PagesSourceHash
    , status : Nullable String
    , url : String
    }


decodePage : Json.Decode.Decoder Page
decodePage =
    Json.Decode.succeed
     (\build_type cname custom_404 html_url https_certificate https_enforced pending_domain_unverified_at protected_domain_state public source status url ->
         { build_type = build_type
         , cname = cname
         , custom_404 = custom_404
         , html_url = html_url
         , https_certificate = https_certificate
         , https_enforced = https_enforced
         , pending_domain_unverified_at = pending_domain_unverified_at
         , protected_domain_state = protected_domain_state
         , public = public
         , source = source
         , status = status
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "build_type"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "cname"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "custom_404" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "https_certificate" decodePagesHttpsCertificate)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "https_enforced" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "pending_domain_unverified_at"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "protected_domain_state"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "public" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "source" decodePagesSourceHash)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "status"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodePage : Page -> Json.Encode.Value
encodePage rec =
    Json.Encode.object
        [ ( "build_type"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.build_type
          )
        , ( "cname"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.cname
          )
        , ( "custom_404", Json.Encode.bool rec.custom_404 )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "https_certificate"
          , encodePagesHttpsCertificate rec.https_certificate
          )
        , ( "https_enforced", Json.Encode.bool rec.https_enforced )
        , ( "pending_domain_unverified_at"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.pending_domain_unverified_at
          )
        , ( "protected_domain_state"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.protected_domain_state
          )
        , ( "public", Json.Encode.bool rec.public )
        , ( "source", encodePagesSourceHash rec.source )
        , ( "status"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.status
          )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias PackagesBillingUsage =
    { included_gigabytes_bandwidth : Int
    , total_gigabytes_bandwidth_used : Int
    , total_paid_gigabytes_bandwidth_used : Int
    }


decodePackagesBillingUsage : Json.Decode.Decoder PackagesBillingUsage
decodePackagesBillingUsage =
    Json.Decode.succeed
     (\included_gigabytes_bandwidth total_gigabytes_bandwidth_used total_paid_gigabytes_bandwidth_used ->
         { included_gigabytes_bandwidth = included_gigabytes_bandwidth
         , total_gigabytes_bandwidth_used = total_gigabytes_bandwidth_used
         , total_paid_gigabytes_bandwidth_used =
             total_paid_gigabytes_bandwidth_used
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "included_gigabytes_bandwidth" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "total_gigabytes_bandwidth_used" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "total_paid_gigabytes_bandwidth_used"
                Json.Decode.int
            )


encodePackagesBillingUsage : PackagesBillingUsage -> Json.Encode.Value
encodePackagesBillingUsage rec =
    Json.Encode.object
        [ ( "included_gigabytes_bandwidth"
          , Json.Encode.int rec.included_gigabytes_bandwidth
          )
        , ( "total_gigabytes_bandwidth_used"
          , Json.Encode.int rec.total_gigabytes_bandwidth_used
          )
        , ( "total_paid_gigabytes_bandwidth_used"
          , Json.Encode.int rec.total_paid_gigabytes_bandwidth_used
          )
        ]


type alias PackageVersion =
    { created_at : String
    , deleted_at : String
    , description : String
    , html_url : String
    , id : Int
    , license : String
    , metadata :
        { container : { tags : List String }
        , docker : { tag : List String }
        , package_type : String
        }
    , name : String
    , package_html_url : String
    , updated_at : String
    , url : String
    }


decodePackageVersion : Json.Decode.Decoder PackageVersion
decodePackageVersion =
    Json.Decode.succeed
     (\created_at deleted_at description html_url id license metadata name package_html_url updated_at url ->
         { created_at = created_at
         , deleted_at = deleted_at
         , description = description
         , html_url = html_url
         , id = id
         , license = license
         , metadata = metadata
         , name = name
         , package_html_url = package_html_url
         , updated_at = updated_at
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "deleted_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "description" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "license" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "metadata"
                (Json.Decode.succeed
                  (\container docker package_type ->
                      { container = container
                      , docker = docker
                      , package_type = package_type
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "container"
                            (Json.Decode.succeed (\tags -> { tags = tags })
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "tags"
                                        (Json.Decode.list Json.Decode.string)
                                    )
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "docker"
                            (Json.Decode.succeed (\tag -> { tag = tag })
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "tag"
                                        (Json.Decode.list Json.Decode.string)
                                    )
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "package_type" Json.Decode.string)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "package_html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodePackageVersion : PackageVersion -> Json.Encode.Value
encodePackageVersion rec =
    Json.Encode.object
        [ ( "created_at", Json.Encode.string rec.created_at )
        , ( "deleted_at", Json.Encode.string rec.deleted_at )
        , ( "description", Json.Encode.string rec.description )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "id", Json.Encode.int rec.id )
        , ( "license", Json.Encode.string rec.license )
        , ( "metadata"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "container"
                      , (\rec_0_1_1_1_0_7_1_0_0 ->
                            Json.Encode.object
                                [ ( "tags"
                                  , Json.Encode.list Json.Encode.string
                                        rec_0_1_1_1_0_7_1_0_0.tags
                                  )
                                ]
                        )
                            rec0.container
                      )
                    , ( "docker"
                      , (\rec_0_2_1_1_0_7_1_0_0 ->
                            Json.Encode.object
                                [ ( "tag"
                                  , Json.Encode.list Json.Encode.string
                                        rec_0_2_1_1_0_7_1_0_0.tag
                                  )
                                ]
                        )
                            rec0.docker
                      )
                    , ( "package_type", Json.Encode.string rec0.package_type )
                    ]
            )
                rec.metadata
          )
        , ( "name", Json.Encode.string rec.name )
        , ( "package_html_url", Json.Encode.string rec.package_html_url )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias Package =
    { created_at : String
    , html_url : String
    , id : Int
    , name : String
    , owner : Nullable SimpleUser
    , package_type : String
    , repository : Nullable MinimalRepository
    , updated_at : String
    , url : String
    , version_count : Int
    , visibility : String
    }


decodePackage : Json.Decode.Decoder Package
decodePackage =
    Json.Decode.succeed
     (\created_at html_url id name owner package_type repository updated_at url version_count visibility ->
         { created_at = created_at
         , html_url = html_url
         , id = id
         , name = name
         , owner = owner
         , package_type = package_type
         , repository = repository
         , updated_at = updated_at
         , url = url
         , version_count = version_count
         , visibility = visibility
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "owner"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "package_type" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "repository"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeMinimalRepository
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "version_count" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "visibility" Json.Decode.string)


encodePackage : Package -> Json.Encode.Value
encodePackage rec =
    Json.Encode.object
        [ ( "created_at", Json.Encode.string rec.created_at )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "id", Json.Encode.int rec.id )
        , ( "name", Json.Encode.string rec.name )
        , ( "owner"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.owner
          )
        , ( "package_type", Json.Encode.string rec.package_type )
        , ( "repository"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeMinimalRepository value
            )
                rec.repository
          )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        , ( "url", Json.Encode.string rec.url )
        , ( "version_count", Json.Encode.int rec.version_count )
        , ( "visibility", Json.Encode.string rec.visibility )
        ]


type alias OrganizationSimple =
    { avatar_url : String
    , description : Nullable String
    , events_url : String
    , hooks_url : String
    , id : Int
    , issues_url : String
    , login : String
    , members_url : String
    , node_id : String
    , public_members_url : String
    , repos_url : String
    , url : String
    }


decodeOrganizationSimple : Json.Decode.Decoder OrganizationSimple
decodeOrganizationSimple =
    Json.Decode.succeed
     (\avatar_url description events_url hooks_url id issues_url login members_url node_id public_members_url repos_url url ->
         { avatar_url = avatar_url
         , description = description
         , events_url = events_url
         , hooks_url = hooks_url
         , id = id
         , issues_url = issues_url
         , login = login
         , members_url = members_url
         , node_id = node_id
         , public_members_url = public_members_url
         , repos_url = repos_url
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "avatar_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "description"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "events_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "hooks_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "issues_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "login" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "members_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "public_members_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "repos_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeOrganizationSimple : OrganizationSimple -> Json.Encode.Value
encodeOrganizationSimple rec =
    Json.Encode.object
        [ ( "avatar_url", Json.Encode.string rec.avatar_url )
        , ( "description"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.description
          )
        , ( "events_url", Json.Encode.string rec.events_url )
        , ( "hooks_url", Json.Encode.string rec.hooks_url )
        , ( "id", Json.Encode.int rec.id )
        , ( "issues_url", Json.Encode.string rec.issues_url )
        , ( "login", Json.Encode.string rec.login )
        , ( "members_url", Json.Encode.string rec.members_url )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "public_members_url", Json.Encode.string rec.public_members_url )
        , ( "repos_url", Json.Encode.string rec.repos_url )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias OrganizationSecretScanningAlert =
    { created_at : AlertCreatedAt
    , html_url : AlertHtmlUrl
    , locations_url : String
    , number : AlertNumber
    , push_protection_bypassed : Nullable Bool
    , push_protection_bypassed_at : Nullable String
    , push_protection_bypassed_by : Nullable SimpleUser
    , repository : SimpleRepository
    , resolution : SecretScanningAlertResolution
    , resolution_comment : Nullable String
    , resolved_at : Nullable String
    , resolved_by : Nullable SimpleUser
    , secret : String
    , secret_type : String
    , secret_type_display_name : String
    , state : SecretScanningAlertState
    , updated_at : Nullable AlertUpdatedAt
    , url : AlertUrl
    }


decodeOrganizationSecretScanningAlert :
    Json.Decode.Decoder OrganizationSecretScanningAlert
decodeOrganizationSecretScanningAlert =
    Json.Decode.succeed
     (\created_at html_url locations_url number push_protection_bypassed push_protection_bypassed_at push_protection_bypassed_by repository resolution resolution_comment resolved_at resolved_by secret secret_type secret_type_display_name state updated_at url ->
         { created_at = created_at
         , html_url = html_url
         , locations_url = locations_url
         , number = number
         , push_protection_bypassed = push_protection_bypassed
         , push_protection_bypassed_at = push_protection_bypassed_at
         , push_protection_bypassed_by = push_protection_bypassed_by
         , repository = repository
         , resolution = resolution
         , resolution_comment = resolution_comment
         , resolved_at = resolved_at
         , resolved_by = resolved_by
         , secret = secret
         , secret_type = secret_type
         , secret_type_display_name = secret_type_display_name
         , state = state
         , updated_at = updated_at
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" decodeAlertCreatedAt)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" decodeAlertHtmlUrl)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "locations_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "number" decodeAlertNumber)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "push_protection_bypassed"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.bool
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "push_protection_bypassed_at"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "push_protection_bypassed_by"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "repository" decodeSimpleRepository)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "resolution" decodeSecretScanningAlertResolution)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "resolution_comment"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "resolved_at"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "resolved_by"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "secret" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "secret_type" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "secret_type_display_name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "state" decodeSecretScanningAlertState)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "updated_at"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeAlertUpdatedAt
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" decodeAlertUrl)


encodeOrganizationSecretScanningAlert :
    OrganizationSecretScanningAlert -> Json.Encode.Value
encodeOrganizationSecretScanningAlert rec =
    Json.Encode.object
        [ ( "created_at", encodeAlertCreatedAt rec.created_at )
        , ( "html_url", encodeAlertHtmlUrl rec.html_url )
        , ( "locations_url", Json.Encode.string rec.locations_url )
        , ( "number", encodeAlertNumber rec.number )
        , ( "push_protection_bypassed"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.bool value
            )
                rec.push_protection_bypassed
          )
        , ( "push_protection_bypassed_at"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.push_protection_bypassed_at
          )
        , ( "push_protection_bypassed_by"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.push_protection_bypassed_by
          )
        , ( "repository", encodeSimpleRepository rec.repository )
        , ( "resolution", encodeSecretScanningAlertResolution rec.resolution )
        , ( "resolution_comment"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.resolution_comment
          )
        , ( "resolved_at"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.resolved_at
          )
        , ( "resolved_by"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.resolved_by
          )
        , ( "secret", Json.Encode.string rec.secret )
        , ( "secret_type", Json.Encode.string rec.secret_type )
        , ( "secret_type_display_name"
          , Json.Encode.string rec.secret_type_display_name
          )
        , ( "state", encodeSecretScanningAlertState rec.state )
        , ( "updated_at"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeAlertUpdatedAt value
            )
                rec.updated_at
          )
        , ( "url", encodeAlertUrl rec.url )
        ]


type alias OrganizationInvitation =
    { created_at : String
    , email : Nullable String
    , failed_at : Nullable String
    , failed_reason : Nullable String
    , id : Int
    , invitation_teams_url : String
    , inviter : SimpleUser
    , login : Nullable String
    , node_id : String
    , role : String
    , team_count : Int
    }


decodeOrganizationInvitation : Json.Decode.Decoder OrganizationInvitation
decodeOrganizationInvitation =
    Json.Decode.succeed
     (\created_at email failed_at failed_reason id invitation_teams_url inviter login node_id role team_count ->
         { created_at = created_at
         , email = email
         , failed_at = failed_at
         , failed_reason = failed_reason
         , id = id
         , invitation_teams_url = invitation_teams_url
         , inviter = inviter
         , login = login
         , node_id = node_id
         , role = role
         , team_count = team_count
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "email"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "failed_at"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "failed_reason"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "invitation_teams_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "inviter" decodeSimpleUser)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "login"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "role" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "team_count" Json.Decode.int)


encodeOrganizationInvitation : OrganizationInvitation -> Json.Encode.Value
encodeOrganizationInvitation rec =
    Json.Encode.object
        [ ( "created_at", Json.Encode.string rec.created_at )
        , ( "email"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.email
          )
        , ( "failed_at"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.failed_at
          )
        , ( "failed_reason"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.failed_reason
          )
        , ( "id", Json.Encode.int rec.id )
        , ( "invitation_teams_url"
          , Json.Encode.string rec.invitation_teams_url
          )
        , ( "inviter", encodeSimpleUser rec.inviter )
        , ( "login"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.login
          )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "role", Json.Encode.string rec.role )
        , ( "team_count", Json.Encode.int rec.team_count )
        ]


type alias OrganizationFull =
    { advanced_security_enabled_for_new_repositories : Bool
    , avatar_url : String
    , billing_email : Nullable String
    , blog : String
    , collaborators : Nullable Int
    , company : String
    , created_at : String
    , default_repository_permission : Nullable String
    , dependabot_alerts_enabled_for_new_repositories : Bool
    , dependabot_security_updates_enabled_for_new_repositories : Bool
    , dependency_graph_enabled_for_new_repositories : Bool
    , description : Nullable String
    , disk_usage : Nullable Int
    , email : String
    , events_url : String
    , followers : Int
    , following : Int
    , has_organization_projects : Bool
    , has_repository_projects : Bool
    , hooks_url : String
    , html_url : String
    , id : Int
    , is_verified : Bool
    , issues_url : String
    , location : String
    , login : String
    , members_allowed_repository_creation_type : String
    , members_can_create_internal_repositories : Bool
    , members_can_create_pages : Bool
    , members_can_create_private_pages : Bool
    , members_can_create_private_repositories : Bool
    , members_can_create_public_pages : Bool
    , members_can_create_public_repositories : Bool
    , members_can_create_repositories : Nullable Bool
    , members_can_fork_private_repositories : Nullable Bool
    , members_url : String
    , name : String
    , node_id : String
    , owned_private_repos : Int
    , plan :
        { filled_seats : Int
        , name : String
        , private_repos : Int
        , seats : Int
        , space : Int
        }
    , private_gists : Nullable Int
    , public_gists : Int
    , public_members_url : String
    , public_repos : Int
    , repos_url : String
    , secret_scanning_enabled_for_new_repositories : Bool
    , secret_scanning_push_protection_enabled_for_new_repositories : Bool
    , total_private_repos : Int
    , twitter_username : Nullable String
    , two_factor_requirement_enabled : Nullable Bool
    , type_ : String
    , updated_at : String
    , url : String
    , web_commit_signoff_required : Bool
    }


decodeOrganizationFull : Json.Decode.Decoder OrganizationFull
decodeOrganizationFull =
    Json.Decode.succeed
     (\advanced_security_enabled_for_new_repositories avatar_url billing_email blog collaborators company created_at default_repository_permission dependabot_alerts_enabled_for_new_repositories dependabot_security_updates_enabled_for_new_repositories dependency_graph_enabled_for_new_repositories description disk_usage email events_url followers following has_organization_projects has_repository_projects hooks_url html_url id is_verified issues_url location login members_allowed_repository_creation_type members_can_create_internal_repositories members_can_create_pages members_can_create_private_pages members_can_create_private_repositories members_can_create_public_pages members_can_create_public_repositories members_can_create_repositories members_can_fork_private_repositories members_url name node_id owned_private_repos plan private_gists public_gists public_members_url public_repos repos_url secret_scanning_enabled_for_new_repositories secret_scanning_push_protection_enabled_for_new_repositories total_private_repos twitter_username two_factor_requirement_enabled type_ updated_at url web_commit_signoff_required ->
         { advanced_security_enabled_for_new_repositories =
             advanced_security_enabled_for_new_repositories
         , avatar_url = avatar_url
         , billing_email = billing_email
         , blog = blog
         , collaborators = collaborators
         , company = company
         , created_at = created_at
         , default_repository_permission = default_repository_permission
         , dependabot_alerts_enabled_for_new_repositories =
             dependabot_alerts_enabled_for_new_repositories
         , dependabot_security_updates_enabled_for_new_repositories =
             dependabot_security_updates_enabled_for_new_repositories
         , dependency_graph_enabled_for_new_repositories =
             dependency_graph_enabled_for_new_repositories
         , description = description
         , disk_usage = disk_usage
         , email = email
         , events_url = events_url
         , followers = followers
         , following = following
         , has_organization_projects = has_organization_projects
         , has_repository_projects = has_repository_projects
         , hooks_url = hooks_url
         , html_url = html_url
         , id = id
         , is_verified = is_verified
         , issues_url = issues_url
         , location = location
         , login = login
         , members_allowed_repository_creation_type =
             members_allowed_repository_creation_type
         , members_can_create_internal_repositories =
             members_can_create_internal_repositories
         , members_can_create_pages = members_can_create_pages
         , members_can_create_private_pages = members_can_create_private_pages
         , members_can_create_private_repositories =
             members_can_create_private_repositories
         , members_can_create_public_pages = members_can_create_public_pages
         , members_can_create_public_repositories =
             members_can_create_public_repositories
         , members_can_create_repositories = members_can_create_repositories
         , members_can_fork_private_repositories =
             members_can_fork_private_repositories
         , members_url = members_url
         , name = name
         , node_id = node_id
         , owned_private_repos = owned_private_repos
         , plan = plan
         , private_gists = private_gists
         , public_gists = public_gists
         , public_members_url = public_members_url
         , public_repos = public_repos
         , repos_url = repos_url
         , secret_scanning_enabled_for_new_repositories =
             secret_scanning_enabled_for_new_repositories
         , secret_scanning_push_protection_enabled_for_new_repositories =
             secret_scanning_push_protection_enabled_for_new_repositories
         , total_private_repos = total_private_repos
         , twitter_username = twitter_username
         , two_factor_requirement_enabled = two_factor_requirement_enabled
         , type_ = type_
         , updated_at = updated_at
         , url = url
         , web_commit_signoff_required = web_commit_signoff_required
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "advanced_security_enabled_for_new_repositories"
                Json.Decode.bool
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "avatar_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "billing_email"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "blog" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "collaborators"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.int
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "company" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "default_repository_permission"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "dependabot_alerts_enabled_for_new_repositories"
                Json.Decode.bool
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "dependabot_security_updates_enabled_for_new_repositories"
                Json.Decode.bool
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "dependency_graph_enabled_for_new_repositories"
                Json.Decode.bool
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "description"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "disk_usage"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.int
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "email" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "events_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "followers" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "following" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "has_organization_projects" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "has_repository_projects" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "hooks_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "is_verified" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "issues_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "location" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "login" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "members_allowed_repository_creation_type"
                Json.Decode.string
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "members_can_create_internal_repositories"
                Json.Decode.bool
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "members_can_create_pages" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "members_can_create_private_pages"
                Json.Decode.bool
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "members_can_create_private_repositories"
                Json.Decode.bool
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "members_can_create_public_pages"
                Json.Decode.bool
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "members_can_create_public_repositories"
                Json.Decode.bool
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "members_can_create_repositories"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.bool
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "members_can_fork_private_repositories"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.bool
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "members_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "owned_private_repos" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "plan"
                (Json.Decode.succeed
                  (\filled_seats name private_repos seats space ->
                      { filled_seats = filled_seats
                      , name = name
                      , private_repos = private_repos
                      , seats = seats
                      , space = space
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "filled_seats" Json.Decode.int)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "name" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "private_repos" Json.Decode.int)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "seats" Json.Decode.int)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "space" Json.Decode.int)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "private_gists"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.int
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "public_gists" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "public_members_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "public_repos" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "repos_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "secret_scanning_enabled_for_new_repositories"
                Json.Decode.bool
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "secret_scanning_push_protection_enabled_for_new_repositories"
                Json.Decode.bool
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "total_private_repos" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "twitter_username"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "two_factor_requirement_enabled"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.bool
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "type" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "web_commit_signoff_required" Json.Decode.bool)


encodeOrganizationFull : OrganizationFull -> Json.Encode.Value
encodeOrganizationFull rec =
    Json.Encode.object
        [ ( "advanced_security_enabled_for_new_repositories"
          , Json.Encode.bool rec.advanced_security_enabled_for_new_repositories
          )
        , ( "avatar_url", Json.Encode.string rec.avatar_url )
        , ( "billing_email"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.billing_email
          )
        , ( "blog", Json.Encode.string rec.blog )
        , ( "collaborators"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.int value
            )
                rec.collaborators
          )
        , ( "company", Json.Encode.string rec.company )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "default_repository_permission"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.default_repository_permission
          )
        , ( "dependabot_alerts_enabled_for_new_repositories"
          , Json.Encode.bool rec.dependabot_alerts_enabled_for_new_repositories
          )
        , ( "dependabot_security_updates_enabled_for_new_repositories"
          , Json.Encode.bool
                rec.dependabot_security_updates_enabled_for_new_repositories
          )
        , ( "dependency_graph_enabled_for_new_repositories"
          , Json.Encode.bool rec.dependency_graph_enabled_for_new_repositories
          )
        , ( "description"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.description
          )
        , ( "disk_usage"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.int value
            )
                rec.disk_usage
          )
        , ( "email", Json.Encode.string rec.email )
        , ( "events_url", Json.Encode.string rec.events_url )
        , ( "followers", Json.Encode.int rec.followers )
        , ( "following", Json.Encode.int rec.following )
        , ( "has_organization_projects"
          , Json.Encode.bool rec.has_organization_projects
          )
        , ( "has_repository_projects"
          , Json.Encode.bool rec.has_repository_projects
          )
        , ( "hooks_url", Json.Encode.string rec.hooks_url )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "id", Json.Encode.int rec.id )
        , ( "is_verified", Json.Encode.bool rec.is_verified )
        , ( "issues_url", Json.Encode.string rec.issues_url )
        , ( "location", Json.Encode.string rec.location )
        , ( "login", Json.Encode.string rec.login )
        , ( "members_allowed_repository_creation_type"
          , Json.Encode.string rec.members_allowed_repository_creation_type
          )
        , ( "members_can_create_internal_repositories"
          , Json.Encode.bool rec.members_can_create_internal_repositories
          )
        , ( "members_can_create_pages"
          , Json.Encode.bool rec.members_can_create_pages
          )
        , ( "members_can_create_private_pages"
          , Json.Encode.bool rec.members_can_create_private_pages
          )
        , ( "members_can_create_private_repositories"
          , Json.Encode.bool rec.members_can_create_private_repositories
          )
        , ( "members_can_create_public_pages"
          , Json.Encode.bool rec.members_can_create_public_pages
          )
        , ( "members_can_create_public_repositories"
          , Json.Encode.bool rec.members_can_create_public_repositories
          )
        , ( "members_can_create_repositories"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.bool value
            )
                rec.members_can_create_repositories
          )
        , ( "members_can_fork_private_repositories"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.bool value
            )
                rec.members_can_fork_private_repositories
          )
        , ( "members_url", Json.Encode.string rec.members_url )
        , ( "name", Json.Encode.string rec.name )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "owned_private_repos", Json.Encode.int rec.owned_private_repos )
        , ( "plan"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "filled_seats", Json.Encode.int rec0.filled_seats )
                    , ( "name", Json.Encode.string rec0.name )
                    , ( "private_repos", Json.Encode.int rec0.private_repos )
                    , ( "seats", Json.Encode.int rec0.seats )
                    , ( "space", Json.Encode.int rec0.space )
                    ]
            )
                rec.plan
          )
        , ( "private_gists"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.int value
            )
                rec.private_gists
          )
        , ( "public_gists", Json.Encode.int rec.public_gists )
        , ( "public_members_url", Json.Encode.string rec.public_members_url )
        , ( "public_repos", Json.Encode.int rec.public_repos )
        , ( "repos_url", Json.Encode.string rec.repos_url )
        , ( "secret_scanning_enabled_for_new_repositories"
          , Json.Encode.bool rec.secret_scanning_enabled_for_new_repositories
          )
        , ( "secret_scanning_push_protection_enabled_for_new_repositories"
          , Json.Encode.bool
                rec.secret_scanning_push_protection_enabled_for_new_repositories
          )
        , ( "total_private_repos", Json.Encode.int rec.total_private_repos )
        , ( "twitter_username"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.twitter_username
          )
        , ( "two_factor_requirement_enabled"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.bool value
            )
                rec.two_factor_requirement_enabled
          )
        , ( "type", Json.Encode.string rec.type_ )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        , ( "url", Json.Encode.string rec.url )
        , ( "web_commit_signoff_required"
          , Json.Encode.bool rec.web_commit_signoff_required
          )
        ]


type alias OrganizationFineGrainedPermission =
    { description : String, name : String }


decodeOrganizationFineGrainedPermission :
    Json.Decode.Decoder OrganizationFineGrainedPermission
decodeOrganizationFineGrainedPermission =
    Json.Decode.succeed
     (\description name -> { description = description, name = name })
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "description" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)


encodeOrganizationFineGrainedPermission :
    OrganizationFineGrainedPermission -> Json.Encode.Value
encodeOrganizationFineGrainedPermission rec =
    Json.Encode.object
        [ ( "description", Json.Encode.string rec.description )
        , ( "name", Json.Encode.string rec.name )
        ]


type alias OrganizationDependabotSecret =
    { created_at : String
    , name : String
    , selected_repositories_url : String
    , updated_at : String
    , visibility : String
    }


decodeOrganizationDependabotSecret :
    Json.Decode.Decoder OrganizationDependabotSecret
decodeOrganizationDependabotSecret =
    Json.Decode.succeed
     (\created_at name selected_repositories_url updated_at visibility ->
         { created_at = created_at
         , name = name
         , selected_repositories_url = selected_repositories_url
         , updated_at = updated_at
         , visibility = visibility
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "selected_repositories_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "visibility" Json.Decode.string)


encodeOrganizationDependabotSecret :
    OrganizationDependabotSecret -> Json.Encode.Value
encodeOrganizationDependabotSecret rec =
    Json.Encode.object
        [ ( "created_at", Json.Encode.string rec.created_at )
        , ( "name", Json.Encode.string rec.name )
        , ( "selected_repositories_url"
          , Json.Encode.string rec.selected_repositories_url
          )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        , ( "visibility", Json.Encode.string rec.visibility )
        ]


type alias OrganizationCustomRepositoryRole =
    { base_role : String
    , created_at : String
    , description : Nullable String
    , id : Int
    , name : String
    , organization : SimpleUser
    , permissions : List String
    , updated_at : String
    }


decodeOrganizationCustomRepositoryRole :
    Json.Decode.Decoder OrganizationCustomRepositoryRole
decodeOrganizationCustomRepositoryRole =
    Json.Decode.succeed
     (\base_role created_at description id name organization permissions updated_at ->
         { base_role = base_role
         , created_at = created_at
         , description = description
         , id = id
         , name = name
         , organization = organization
         , permissions = permissions
         , updated_at = updated_at
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "base_role" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "description"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "organization" decodeSimpleUser)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "permissions"
                (Json.Decode.list Json.Decode.string)
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)


encodeOrganizationCustomRepositoryRole :
    OrganizationCustomRepositoryRole -> Json.Encode.Value
encodeOrganizationCustomRepositoryRole rec =
    Json.Encode.object
        [ ( "base_role", Json.Encode.string rec.base_role )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "description"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.description
          )
        , ( "id", Json.Encode.int rec.id )
        , ( "name", Json.Encode.string rec.name )
        , ( "organization", encodeSimpleUser rec.organization )
        , ( "permissions", Json.Encode.list Json.Encode.string rec.permissions )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        ]


type alias OrganizationActionsSecret =
    { created_at : String
    , name : String
    , selected_repositories_url : String
    , updated_at : String
    , visibility : String
    }


decodeOrganizationActionsSecret : Json.Decode.Decoder OrganizationActionsSecret
decodeOrganizationActionsSecret =
    Json.Decode.succeed
     (\created_at name selected_repositories_url updated_at visibility ->
         { created_at = created_at
         , name = name
         , selected_repositories_url = selected_repositories_url
         , updated_at = updated_at
         , visibility = visibility
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "selected_repositories_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "visibility" Json.Decode.string)


encodeOrganizationActionsSecret : OrganizationActionsSecret -> Json.Encode.Value
encodeOrganizationActionsSecret rec =
    Json.Encode.object
        [ ( "created_at", Json.Encode.string rec.created_at )
        , ( "name", Json.Encode.string rec.name )
        , ( "selected_repositories_url"
          , Json.Encode.string rec.selected_repositories_url
          )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        , ( "visibility", Json.Encode.string rec.visibility )
        ]


type alias OrgMembership =
    { organization : OrganizationSimple
    , organization_url : String
    , permissions : { can_create_repository : Bool }
    , role : String
    , state : String
    , url : String
    , user : Nullable SimpleUser
    }


decodeOrgMembership : Json.Decode.Decoder OrgMembership
decodeOrgMembership =
    Json.Decode.succeed
     (\organization organization_url permissions role state url user ->
         { organization = organization
         , organization_url = organization_url
         , permissions = permissions
         , role = role
         , state = state
         , url = url
         , user = user
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "organization" decodeOrganizationSimple)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "organization_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "permissions"
                (Json.Decode.succeed
                    (\can_create_repository ->
                        { can_create_repository = can_create_repository }
                    )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "can_create_repository"
                            Json.Decode.bool
                        )
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "role" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "state" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "user"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )


encodeOrgMembership : OrgMembership -> Json.Encode.Value
encodeOrgMembership rec =
    Json.Encode.object
        [ ( "organization", encodeOrganizationSimple rec.organization )
        , ( "organization_url", Json.Encode.string rec.organization_url )
        , ( "permissions"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "can_create_repository"
                      , Json.Encode.bool rec0.can_create_repository
                      )
                    ]
            )
                rec.permissions
          )
        , ( "role", Json.Encode.string rec.role )
        , ( "state", Json.Encode.string rec.state )
        , ( "url", Json.Encode.string rec.url )
        , ( "user"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.user
          )
        ]


type alias OrgHook =
    { active : Bool
    , config :
        { content_type : String
        , insecure_ssl : String
        , secret : String
        , url : String
        }
    , created_at : String
    , deliveries_url : String
    , events : List String
    , id : Int
    , name : String
    , ping_url : String
    , type_ : String
    , updated_at : String
    , url : String
    }


decodeOrgHook : Json.Decode.Decoder OrgHook
decodeOrgHook =
    Json.Decode.succeed
     (\active config created_at deliveries_url events id name ping_url type_ updated_at url ->
         { active = active
         , config = config
         , created_at = created_at
         , deliveries_url = deliveries_url
         , events = events
         , id = id
         , name = name
         , ping_url = ping_url
         , type_ = type_
         , updated_at = updated_at
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "active" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "config"
                (Json.Decode.succeed
                  (\content_type insecure_ssl secret url ->
                      { content_type = content_type
                      , insecure_ssl = insecure_ssl
                      , secret = secret
                      , url = url
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "content_type" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "insecure_ssl" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "secret" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "url" Json.Decode.string)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "deliveries_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "events" (Json.Decode.list Json.Decode.string))
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "ping_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "type" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeOrgHook : OrgHook -> Json.Encode.Value
encodeOrgHook rec =
    Json.Encode.object
        [ ( "active", Json.Encode.bool rec.active )
        , ( "config"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "content_type", Json.Encode.string rec0.content_type )
                    , ( "insecure_ssl", Json.Encode.string rec0.insecure_ssl )
                    , ( "secret", Json.Encode.string rec0.secret )
                    , ( "url", Json.Encode.string rec0.url )
                    ]
            )
                rec.config
          )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "deliveries_url", Json.Encode.string rec.deliveries_url )
        , ( "events", Json.Encode.list Json.Encode.string rec.events )
        , ( "id", Json.Encode.int rec.id )
        , ( "name", Json.Encode.string rec.name )
        , ( "ping_url", Json.Encode.string rec.ping_url )
        , ( "type", Json.Encode.string rec.type_ )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias MovedColumnInProjectIssueEvent =
    { actor : SimpleUser
    , commit_id : Nullable String
    , commit_url : Nullable String
    , created_at : String
    , event : String
    , id : Int
    , node_id : String
    , performed_via_github_app : Nullable Integration
    , project_card :
        { column_name : String
        , id : Int
        , previous_column_name : String
        , project_id : Int
        , project_url : String
        , url : String
        }
    , url : String
    }


decodeMovedColumnInProjectIssueEvent :
    Json.Decode.Decoder MovedColumnInProjectIssueEvent
decodeMovedColumnInProjectIssueEvent =
    Json.Decode.succeed
     (\actor commit_id commit_url created_at event id node_id performed_via_github_app project_card url ->
         { actor = actor
         , commit_id = commit_id
         , commit_url = commit_url
         , created_at = created_at
         , event = event
         , id = id
         , node_id = node_id
         , performed_via_github_app = performed_via_github_app
         , project_card = project_card
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap (Json.Decode.field "actor" decodeSimpleUser)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "commit_id"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "commit_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "event" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "performed_via_github_app"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeIntegration
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "project_card"
                (Json.Decode.succeed
                  (\column_name id previous_column_name project_id project_url url ->
                      { column_name = column_name
                      , id = id
                      , previous_column_name = previous_column_name
                      , project_id = project_id
                      , project_url = project_url
                      , url = url
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "column_name" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "id" Json.Decode.int)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "previous_column_name"
                            Json.Decode.string
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "project_id" Json.Decode.int)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "project_url" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "url" Json.Decode.string)
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeMovedColumnInProjectIssueEvent :
    MovedColumnInProjectIssueEvent -> Json.Encode.Value
encodeMovedColumnInProjectIssueEvent rec =
    Json.Encode.object
        [ ( "actor", encodeSimpleUser rec.actor )
        , ( "commit_id"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.commit_id
          )
        , ( "commit_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.commit_url
          )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "event", Json.Encode.string rec.event )
        , ( "id", Json.Encode.int rec.id )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "performed_via_github_app"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeIntegration value
            )
                rec.performed_via_github_app
          )
        , ( "project_card"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "column_name", Json.Encode.string rec0.column_name )
                    , ( "id", Json.Encode.int rec0.id )
                    , ( "previous_column_name"
                      , Json.Encode.string rec0.previous_column_name
                      )
                    , ( "project_id", Json.Encode.int rec0.project_id )
                    , ( "project_url", Json.Encode.string rec0.project_url )
                    , ( "url", Json.Encode.string rec0.url )
                    ]
            )
                rec.project_card
          )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias MinimalRepository =
    { allow_forking : Bool
    , archive_url : String
    , archived : Bool
    , assignees_url : String
    , blobs_url : String
    , branches_url : String
    , clone_url : String
    , code_of_conduct : CodeOfConduct
    , collaborators_url : String
    , comments_url : String
    , commits_url : String
    , compare_url : String
    , contents_url : String
    , contributors_url : String
    , created_at : Nullable String
    , default_branch : String
    , delete_branch_on_merge : Bool
    , deployments_url : String
    , description : Nullable String
    , disabled : Bool
    , downloads_url : String
    , events_url : String
    , fork : Bool
    , forks : Int
    , forks_count : Int
    , forks_url : String
    , full_name : String
    , git_commits_url : String
    , git_refs_url : String
    , git_tags_url : String
    , git_url : String
    , has_downloads : Bool
    , has_issues : Bool
    , has_pages : Bool
    , has_projects : Bool
    , has_wiki : Bool
    , homepage : Nullable String
    , hooks_url : String
    , html_url : String
    , id : Int
    , is_template : Bool
    , issue_comment_url : String
    , issue_events_url : String
    , issues_url : String
    , keys_url : String
    , labels_url : String
    , language : Nullable String
    , languages_url : String
    , license :
        Nullable { key : String
        , name : String
        , node_id : String
        , spdx_id : String
        , url : String
        }
    , merges_url : String
    , milestones_url : String
    , mirror_url : Nullable String
    , name : String
    , network_count : Int
    , node_id : String
    , notifications_url : String
    , open_issues : Int
    , open_issues_count : Int
    , owner : SimpleUser
    , permissions :
        { admin : Bool
        , maintain : Bool
        , pull : Bool
        , push : Bool
        , triage : Bool
        }
    , private : Bool
    , pulls_url : String
    , pushed_at : Nullable String
    , releases_url : String
    , role_name : String
    , size : Int
    , ssh_url : String
    , stargazers_count : Int
    , stargazers_url : String
    , statuses_url : String
    , subscribers_count : Int
    , subscribers_url : String
    , subscription_url : String
    , svn_url : String
    , tags_url : String
    , teams_url : String
    , temp_clone_token : String
    , topics : List String
    , trees_url : String
    , updated_at : Nullable String
    , url : String
    , visibility : String
    , watchers : Int
    , watchers_count : Int
    , web_commit_signoff_required : Bool
    }


decodeMinimalRepository : Json.Decode.Decoder MinimalRepository
decodeMinimalRepository =
    Json.Decode.succeed
     (\allow_forking archive_url archived assignees_url blobs_url branches_url clone_url code_of_conduct collaborators_url comments_url commits_url compare_url contents_url contributors_url created_at default_branch delete_branch_on_merge deployments_url description disabled downloads_url events_url fork forks forks_count forks_url full_name git_commits_url git_refs_url git_tags_url git_url has_downloads has_issues has_pages has_projects has_wiki homepage hooks_url html_url id is_template issue_comment_url issue_events_url issues_url keys_url labels_url language languages_url license merges_url milestones_url mirror_url name network_count node_id notifications_url open_issues open_issues_count owner permissions private pulls_url pushed_at releases_url role_name size ssh_url stargazers_count stargazers_url statuses_url subscribers_count subscribers_url subscription_url svn_url tags_url teams_url temp_clone_token topics trees_url updated_at url visibility watchers watchers_count web_commit_signoff_required ->
         { allow_forking = allow_forking
         , archive_url = archive_url
         , archived = archived
         , assignees_url = assignees_url
         , blobs_url = blobs_url
         , branches_url = branches_url
         , clone_url = clone_url
         , code_of_conduct = code_of_conduct
         , collaborators_url = collaborators_url
         , comments_url = comments_url
         , commits_url = commits_url
         , compare_url = compare_url
         , contents_url = contents_url
         , contributors_url = contributors_url
         , created_at = created_at
         , default_branch = default_branch
         , delete_branch_on_merge = delete_branch_on_merge
         , deployments_url = deployments_url
         , description = description
         , disabled = disabled
         , downloads_url = downloads_url
         , events_url = events_url
         , fork = fork
         , forks = forks
         , forks_count = forks_count
         , forks_url = forks_url
         , full_name = full_name
         , git_commits_url = git_commits_url
         , git_refs_url = git_refs_url
         , git_tags_url = git_tags_url
         , git_url = git_url
         , has_downloads = has_downloads
         , has_issues = has_issues
         , has_pages = has_pages
         , has_projects = has_projects
         , has_wiki = has_wiki
         , homepage = homepage
         , hooks_url = hooks_url
         , html_url = html_url
         , id = id
         , is_template = is_template
         , issue_comment_url = issue_comment_url
         , issue_events_url = issue_events_url
         , issues_url = issues_url
         , keys_url = keys_url
         , labels_url = labels_url
         , language = language
         , languages_url = languages_url
         , license = license
         , merges_url = merges_url
         , milestones_url = milestones_url
         , mirror_url = mirror_url
         , name = name
         , network_count = network_count
         , node_id = node_id
         , notifications_url = notifications_url
         , open_issues = open_issues
         , open_issues_count = open_issues_count
         , owner = owner
         , permissions = permissions
         , private = private
         , pulls_url = pulls_url
         , pushed_at = pushed_at
         , releases_url = releases_url
         , role_name = role_name
         , size = size
         , ssh_url = ssh_url
         , stargazers_count = stargazers_count
         , stargazers_url = stargazers_url
         , statuses_url = statuses_url
         , subscribers_count = subscribers_count
         , subscribers_url = subscribers_url
         , subscription_url = subscription_url
         , svn_url = svn_url
         , tags_url = tags_url
         , teams_url = teams_url
         , temp_clone_token = temp_clone_token
         , topics = topics
         , trees_url = trees_url
         , updated_at = updated_at
         , url = url
         , visibility = visibility
         , watchers = watchers
         , watchers_count = watchers_count
         , web_commit_signoff_required = web_commit_signoff_required
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "allow_forking" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "archive_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "archived" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "assignees_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "blobs_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "branches_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "clone_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "code_of_conduct" decodeCodeOfConduct)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "collaborators_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "comments_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "commits_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "compare_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "contents_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "contributors_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "created_at"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "default_branch" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "delete_branch_on_merge" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "deployments_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "description"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "disabled" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "downloads_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "events_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "fork" Json.Decode.bool)
        |> Json.Decode.Extra.andMap (Json.Decode.field "forks" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "forks_count" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "forks_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "full_name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "git_commits_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "git_refs_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "git_tags_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "git_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "has_downloads" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "has_issues" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "has_pages" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "has_projects" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "has_wiki" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "homepage"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "hooks_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "is_template" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "issue_comment_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "issue_events_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "issues_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "keys_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "labels_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "language"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "languages_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "license"
                (Json.Decode.oneOf
                    [ Json.Decode.map
                        Present
                        (Json.Decode.succeed
                          (\key name node_id spdx_id url ->
                              { key = key
                              , name = name
                              , node_id = node_id
                              , spdx_id = spdx_id
                              , url = url
                              }
                          )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "key" Json.Decode.string)
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "name" Json.Decode.string)
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "node_id" Json.Decode.string)
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "spdx_id" Json.Decode.string)
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "url" Json.Decode.string)
                        )
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "merges_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "milestones_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "mirror_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "network_count" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "notifications_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "open_issues" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "open_issues_count" Json.Decode.int)
        |> Json.Decode.Extra.andMap (Json.Decode.field "owner" decodeSimpleUser)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "permissions"
                (Json.Decode.succeed
                  (\admin maintain pull push triage ->
                      { admin = admin
                      , maintain = maintain
                      , pull = pull
                      , push = push
                      , triage = triage
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "admin" Json.Decode.bool)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "maintain" Json.Decode.bool)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "pull" Json.Decode.bool)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "push" Json.Decode.bool)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "triage" Json.Decode.bool)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "private" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "pulls_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "pushed_at"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "releases_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "role_name" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "size" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "ssh_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "stargazers_count" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "stargazers_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "statuses_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "subscribers_count" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "subscribers_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "subscription_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "svn_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "tags_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "teams_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "temp_clone_token" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "topics" (Json.Decode.list Json.Decode.string))
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "trees_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "updated_at"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "visibility" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "watchers" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "watchers_count" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "web_commit_signoff_required" Json.Decode.bool)


encodeMinimalRepository : MinimalRepository -> Json.Encode.Value
encodeMinimalRepository rec =
    Json.Encode.object
        [ ( "allow_forking", Json.Encode.bool rec.allow_forking )
        , ( "archive_url", Json.Encode.string rec.archive_url )
        , ( "archived", Json.Encode.bool rec.archived )
        , ( "assignees_url", Json.Encode.string rec.assignees_url )
        , ( "blobs_url", Json.Encode.string rec.blobs_url )
        , ( "branches_url", Json.Encode.string rec.branches_url )
        , ( "clone_url", Json.Encode.string rec.clone_url )
        , ( "code_of_conduct", encodeCodeOfConduct rec.code_of_conduct )
        , ( "collaborators_url", Json.Encode.string rec.collaborators_url )
        , ( "comments_url", Json.Encode.string rec.comments_url )
        , ( "commits_url", Json.Encode.string rec.commits_url )
        , ( "compare_url", Json.Encode.string rec.compare_url )
        , ( "contents_url", Json.Encode.string rec.contents_url )
        , ( "contributors_url", Json.Encode.string rec.contributors_url )
        , ( "created_at"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.created_at
          )
        , ( "default_branch", Json.Encode.string rec.default_branch )
        , ( "delete_branch_on_merge"
          , Json.Encode.bool rec.delete_branch_on_merge
          )
        , ( "deployments_url", Json.Encode.string rec.deployments_url )
        , ( "description"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.description
          )
        , ( "disabled", Json.Encode.bool rec.disabled )
        , ( "downloads_url", Json.Encode.string rec.downloads_url )
        , ( "events_url", Json.Encode.string rec.events_url )
        , ( "fork", Json.Encode.bool rec.fork )
        , ( "forks", Json.Encode.int rec.forks )
        , ( "forks_count", Json.Encode.int rec.forks_count )
        , ( "forks_url", Json.Encode.string rec.forks_url )
        , ( "full_name", Json.Encode.string rec.full_name )
        , ( "git_commits_url", Json.Encode.string rec.git_commits_url )
        , ( "git_refs_url", Json.Encode.string rec.git_refs_url )
        , ( "git_tags_url", Json.Encode.string rec.git_tags_url )
        , ( "git_url", Json.Encode.string rec.git_url )
        , ( "has_downloads", Json.Encode.bool rec.has_downloads )
        , ( "has_issues", Json.Encode.bool rec.has_issues )
        , ( "has_pages", Json.Encode.bool rec.has_pages )
        , ( "has_projects", Json.Encode.bool rec.has_projects )
        , ( "has_wiki", Json.Encode.bool rec.has_wiki )
        , ( "homepage"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.homepage
          )
        , ( "hooks_url", Json.Encode.string rec.hooks_url )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "id", Json.Encode.int rec.id )
        , ( "is_template", Json.Encode.bool rec.is_template )
        , ( "issue_comment_url", Json.Encode.string rec.issue_comment_url )
        , ( "issue_events_url", Json.Encode.string rec.issue_events_url )
        , ( "issues_url", Json.Encode.string rec.issues_url )
        , ( "keys_url", Json.Encode.string rec.keys_url )
        , ( "labels_url", Json.Encode.string rec.labels_url )
        , ( "language"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.language
          )
        , ( "languages_url", Json.Encode.string rec.languages_url )
        , ( "license"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        (\rec0 ->
                            Json.Encode.object
                                [ ( "key", Json.Encode.string rec0.key )
                                , ( "name", Json.Encode.string rec0.name )
                                , ( "node_id", Json.Encode.string rec0.node_id )
                                , ( "spdx_id", Json.Encode.string rec0.spdx_id )
                                , ( "url", Json.Encode.string rec0.url )
                                ]
                        )
                            value
            )
                rec.license
          )
        , ( "merges_url", Json.Encode.string rec.merges_url )
        , ( "milestones_url", Json.Encode.string rec.milestones_url )
        , ( "mirror_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.mirror_url
          )
        , ( "name", Json.Encode.string rec.name )
        , ( "network_count", Json.Encode.int rec.network_count )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "notifications_url", Json.Encode.string rec.notifications_url )
        , ( "open_issues", Json.Encode.int rec.open_issues )
        , ( "open_issues_count", Json.Encode.int rec.open_issues_count )
        , ( "owner", encodeSimpleUser rec.owner )
        , ( "permissions"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "admin", Json.Encode.bool rec0.admin )
                    , ( "maintain", Json.Encode.bool rec0.maintain )
                    , ( "pull", Json.Encode.bool rec0.pull )
                    , ( "push", Json.Encode.bool rec0.push )
                    , ( "triage", Json.Encode.bool rec0.triage )
                    ]
            )
                rec.permissions
          )
        , ( "private", Json.Encode.bool rec.private )
        , ( "pulls_url", Json.Encode.string rec.pulls_url )
        , ( "pushed_at"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.pushed_at
          )
        , ( "releases_url", Json.Encode.string rec.releases_url )
        , ( "role_name", Json.Encode.string rec.role_name )
        , ( "size", Json.Encode.int rec.size )
        , ( "ssh_url", Json.Encode.string rec.ssh_url )
        , ( "stargazers_count", Json.Encode.int rec.stargazers_count )
        , ( "stargazers_url", Json.Encode.string rec.stargazers_url )
        , ( "statuses_url", Json.Encode.string rec.statuses_url )
        , ( "subscribers_count", Json.Encode.int rec.subscribers_count )
        , ( "subscribers_url", Json.Encode.string rec.subscribers_url )
        , ( "subscription_url", Json.Encode.string rec.subscription_url )
        , ( "svn_url", Json.Encode.string rec.svn_url )
        , ( "tags_url", Json.Encode.string rec.tags_url )
        , ( "teams_url", Json.Encode.string rec.teams_url )
        , ( "temp_clone_token", Json.Encode.string rec.temp_clone_token )
        , ( "topics", Json.Encode.list Json.Encode.string rec.topics )
        , ( "trees_url", Json.Encode.string rec.trees_url )
        , ( "updated_at"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.updated_at
          )
        , ( "url", Json.Encode.string rec.url )
        , ( "visibility", Json.Encode.string rec.visibility )
        , ( "watchers", Json.Encode.int rec.watchers )
        , ( "watchers_count", Json.Encode.int rec.watchers_count )
        , ( "web_commit_signoff_required"
          , Json.Encode.bool rec.web_commit_signoff_required
          )
        ]


type alias MilestonedIssueEvent =
    { actor : SimpleUser
    , commit_id : Nullable String
    , commit_url : Nullable String
    , created_at : String
    , event : String
    , id : Int
    , milestone : { title : String }
    , node_id : String
    , performed_via_github_app : Nullable Integration
    , url : String
    }


decodeMilestonedIssueEvent : Json.Decode.Decoder MilestonedIssueEvent
decodeMilestonedIssueEvent =
    Json.Decode.succeed
     (\actor commit_id commit_url created_at event id milestone node_id performed_via_github_app url ->
         { actor = actor
         , commit_id = commit_id
         , commit_url = commit_url
         , created_at = created_at
         , event = event
         , id = id
         , milestone = milestone
         , node_id = node_id
         , performed_via_github_app = performed_via_github_app
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap (Json.Decode.field "actor" decodeSimpleUser)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "commit_id"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "commit_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "event" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "milestone"
                (Json.Decode.succeed (\title -> { title = title })
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "title" Json.Decode.string)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "performed_via_github_app"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeIntegration
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeMilestonedIssueEvent : MilestonedIssueEvent -> Json.Encode.Value
encodeMilestonedIssueEvent rec =
    Json.Encode.object
        [ ( "actor", encodeSimpleUser rec.actor )
        , ( "commit_id"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.commit_id
          )
        , ( "commit_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.commit_url
          )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "event", Json.Encode.string rec.event )
        , ( "id", Json.Encode.int rec.id )
        , ( "milestone"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "title", Json.Encode.string rec0.title ) ]
            )
                rec.milestone
          )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "performed_via_github_app"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeIntegration value
            )
                rec.performed_via_github_app
          )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias Milestone =
    { closed_at : Nullable String
    , closed_issues : Int
    , created_at : String
    , creator : Nullable SimpleUser
    , description : Nullable String
    , due_on : Nullable String
    , html_url : String
    , id : Int
    , labels_url : String
    , node_id : String
    , number : Int
    , open_issues : Int
    , state : String
    , title : String
    , updated_at : String
    , url : String
    }


decodeMilestone : Json.Decode.Decoder Milestone
decodeMilestone =
    Json.Decode.succeed
     (\closed_at closed_issues created_at creator description due_on html_url id labels_url node_id number open_issues state title updated_at url ->
         { closed_at = closed_at
         , closed_issues = closed_issues
         , created_at = created_at
         , creator = creator
         , description = description
         , due_on = due_on
         , html_url = html_url
         , id = id
         , labels_url = labels_url
         , node_id = node_id
         , number = number
         , open_issues = open_issues
         , state = state
         , title = title
         , updated_at = updated_at
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "closed_at"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "closed_issues" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "creator"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "description"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "due_on"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "labels_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "number" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "open_issues" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "state" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "title" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeMilestone : Milestone -> Json.Encode.Value
encodeMilestone rec =
    Json.Encode.object
        [ ( "closed_at"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.closed_at
          )
        , ( "closed_issues", Json.Encode.int rec.closed_issues )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "creator"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.creator
          )
        , ( "description"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.description
          )
        , ( "due_on"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.due_on
          )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "id", Json.Encode.int rec.id )
        , ( "labels_url", Json.Encode.string rec.labels_url )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "number", Json.Encode.int rec.number )
        , ( "open_issues", Json.Encode.int rec.open_issues )
        , ( "state", Json.Encode.string rec.state )
        , ( "title", Json.Encode.string rec.title )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias Migration =
    { archive_url : String
    , created_at : String
    , exclude : List Json.Encode.Value
    , exclude_attachments : Bool
    , exclude_git_data : Bool
    , exclude_metadata : Bool
    , exclude_owner_projects : Bool
    , exclude_releases : Bool
    , guid : String
    , id : Int
    , lock_repositories : Bool
    , node_id : String
    , org_metadata_only : Bool
    , owner : Nullable SimpleUser
    , repositories : List Repository
    , state : String
    , updated_at : String
    , url : String
    }


decodeMigration : Json.Decode.Decoder Migration
decodeMigration =
    Json.Decode.succeed
     (\archive_url created_at exclude exclude_attachments exclude_git_data exclude_metadata exclude_owner_projects exclude_releases guid id lock_repositories node_id org_metadata_only owner repositories state updated_at url ->
         { archive_url = archive_url
         , created_at = created_at
         , exclude = exclude
         , exclude_attachments = exclude_attachments
         , exclude_git_data = exclude_git_data
         , exclude_metadata = exclude_metadata
         , exclude_owner_projects = exclude_owner_projects
         , exclude_releases = exclude_releases
         , guid = guid
         , id = id
         , lock_repositories = lock_repositories
         , node_id = node_id
         , org_metadata_only = org_metadata_only
         , owner = owner
         , repositories = repositories
         , state = state
         , updated_at = updated_at
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "archive_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "exclude" (Json.Decode.list Json.Decode.value))
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "exclude_attachments" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "exclude_git_data" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "exclude_metadata" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "exclude_owner_projects" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "exclude_releases" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "guid" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "lock_repositories" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "org_metadata_only" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "owner"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "repositories"
                (Json.Decode.list decodeRepository)
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "state" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeMigration : Migration -> Json.Encode.Value
encodeMigration rec =
    Json.Encode.object
        [ ( "archive_url", Json.Encode.string rec.archive_url )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "exclude", Json.Encode.list Basics.identity rec.exclude )
        , ( "exclude_attachments", Json.Encode.bool rec.exclude_attachments )
        , ( "exclude_git_data", Json.Encode.bool rec.exclude_git_data )
        , ( "exclude_metadata", Json.Encode.bool rec.exclude_metadata )
        , ( "exclude_owner_projects"
          , Json.Encode.bool rec.exclude_owner_projects
          )
        , ( "exclude_releases", Json.Encode.bool rec.exclude_releases )
        , ( "guid", Json.Encode.string rec.guid )
        , ( "id", Json.Encode.int rec.id )
        , ( "lock_repositories", Json.Encode.bool rec.lock_repositories )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "org_metadata_only", Json.Encode.bool rec.org_metadata_only )
        , ( "owner"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.owner
          )
        , ( "repositories", Json.Encode.list encodeRepository rec.repositories )
        , ( "state", Json.Encode.string rec.state )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias Metadata =
    {}


decodeMetadata : Json.Decode.Decoder Metadata
decodeMetadata =
    Json.Decode.succeed {}


encodeMetadata : Metadata -> Json.Encode.Value
encodeMetadata rec =
    Json.Encode.object []


type alias MergedUpstream =
    { base_branch : String, merge_type : String, message : String }


decodeMergedUpstream : Json.Decode.Decoder MergedUpstream
decodeMergedUpstream =
    Json.Decode.succeed
     (\base_branch merge_type message ->
         { base_branch = base_branch
         , merge_type = merge_type
         , message = message
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "base_branch" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "merge_type" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "message" Json.Decode.string)


encodeMergedUpstream : MergedUpstream -> Json.Encode.Value
encodeMergedUpstream rec =
    Json.Encode.object
        [ ( "base_branch", Json.Encode.string rec.base_branch )
        , ( "merge_type", Json.Encode.string rec.merge_type )
        , ( "message", Json.Encode.string rec.message )
        ]


type alias MarketplacePurchase =
    { email : Nullable String
    , id : Int
    , login : String
    , marketplace_pending_change :
        Nullable { effective_date : String
        , id : Int
        , is_installed : Bool
        , plan : MarketplaceListingPlan
        , unit_count : Nullable Int
        }
    , marketplace_purchase :
        { billing_cycle : String
        , free_trial_ends_on : Nullable String
        , is_installed : Bool
        , next_billing_date : Nullable String
        , on_free_trial : Bool
        , plan : MarketplaceListingPlan
        , unit_count : Nullable Int
        , updated_at : String
        }
    , organization_billing_email : String
    , type_ : String
    , url : String
    }


decodeMarketplacePurchase : Json.Decode.Decoder MarketplacePurchase
decodeMarketplacePurchase =
    Json.Decode.succeed
     (\email id login marketplace_pending_change marketplace_purchase organization_billing_email type_ url ->
         { email = email
         , id = id
         , login = login
         , marketplace_pending_change = marketplace_pending_change
         , marketplace_purchase = marketplace_purchase
         , organization_billing_email = organization_billing_email
         , type_ = type_
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "email"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "login" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "marketplace_pending_change"
                (Json.Decode.oneOf
                    [ Json.Decode.map
                        Present
                        (Json.Decode.succeed
                          (\effective_date id is_installed plan unit_count ->
                              { effective_date = effective_date
                              , id = id
                              , is_installed = is_installed
                              , plan = plan
                              , unit_count = unit_count
                              }
                          )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "effective_date"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "id" Json.Decode.int)
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "is_installed"
                                    Json.Decode.bool
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "plan"
                                    decodeMarketplaceListingPlan
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "unit_count"
                                    (Json.Decode.oneOf
                                        [ Json.Decode.map
                                            Present
                                            Json.Decode.int
                                        , Json.Decode.null Null
                                        ]
                                    )
                                )
                        )
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "marketplace_purchase"
                (Json.Decode.succeed
                  (\billing_cycle free_trial_ends_on is_installed next_billing_date on_free_trial plan unit_count updated_at ->
                      { billing_cycle = billing_cycle
                      , free_trial_ends_on = free_trial_ends_on
                      , is_installed = is_installed
                      , next_billing_date = next_billing_date
                      , on_free_trial = on_free_trial
                      , plan = plan
                      , unit_count = unit_count
                      , updated_at = updated_at
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "billing_cycle" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "free_trial_ends_on"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.string
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "is_installed" Json.Decode.bool)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "next_billing_date"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.string
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "on_free_trial" Json.Decode.bool)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "plan" decodeMarketplaceListingPlan)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "unit_count"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.int
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "updated_at" Json.Decode.string)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "organization_billing_email" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "type" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeMarketplacePurchase : MarketplacePurchase -> Json.Encode.Value
encodeMarketplacePurchase rec =
    Json.Encode.object
        [ ( "email"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.email
          )
        , ( "id", Json.Encode.int rec.id )
        , ( "login", Json.Encode.string rec.login )
        , ( "marketplace_pending_change"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        (\rec0 ->
                            Json.Encode.object
                                [ ( "effective_date"
                                  , Json.Encode.string rec0.effective_date
                                  )
                                , ( "id", Json.Encode.int rec0.id )
                                , ( "is_installed"
                                  , Json.Encode.bool rec0.is_installed
                                  )
                                , ( "plan"
                                  , encodeMarketplaceListingPlan rec0.plan
                                  )
                                , ( "unit_count"
                                  , (\nullableValue0 ->
                                        case nullableValue0 of
                                            Null ->
                                                Json.Encode.null

                                            Present value0 ->
                                                Json.Encode.int value0
                                    )
                                        rec0.unit_count
                                  )
                                ]
                        )
                            value
            )
                rec.marketplace_pending_change
          )
        , ( "marketplace_purchase"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "billing_cycle", Json.Encode.string rec0.billing_cycle )
                    , ( "free_trial_ends_on"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.string value
                        )
                            rec0.free_trial_ends_on
                      )
                    , ( "is_installed", Json.Encode.bool rec0.is_installed )
                    , ( "next_billing_date"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.string value
                        )
                            rec0.next_billing_date
                      )
                    , ( "on_free_trial", Json.Encode.bool rec0.on_free_trial )
                    , ( "plan", encodeMarketplaceListingPlan rec0.plan )
                    , ( "unit_count"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.int value
                        )
                            rec0.unit_count
                      )
                    , ( "updated_at", Json.Encode.string rec0.updated_at )
                    ]
            )
                rec.marketplace_purchase
          )
        , ( "organization_billing_email"
          , Json.Encode.string rec.organization_billing_email
          )
        , ( "type", Json.Encode.string rec.type_ )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias MarketplaceListingPlan =
    { accounts_url : String
    , bullets : List String
    , description : String
    , has_free_trial : Bool
    , id : Int
    , monthly_price_in_cents : Int
    , name : String
    , number : Int
    , price_model : String
    , state : String
    , unit_name : Nullable String
    , url : String
    , yearly_price_in_cents : Int
    }


decodeMarketplaceListingPlan : Json.Decode.Decoder MarketplaceListingPlan
decodeMarketplaceListingPlan =
    Json.Decode.succeed
     (\accounts_url bullets description has_free_trial id monthly_price_in_cents name number price_model state unit_name url yearly_price_in_cents ->
         { accounts_url = accounts_url
         , bullets = bullets
         , description = description
         , has_free_trial = has_free_trial
         , id = id
         , monthly_price_in_cents = monthly_price_in_cents
         , name = name
         , number = number
         , price_model = price_model
         , state = state
         , unit_name = unit_name
         , url = url
         , yearly_price_in_cents = yearly_price_in_cents
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "accounts_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "bullets" (Json.Decode.list Json.Decode.string))
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "description" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "has_free_trial" Json.Decode.bool)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "monthly_price_in_cents" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "number" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "price_model" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "state" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "unit_name"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "yearly_price_in_cents" Json.Decode.int)


encodeMarketplaceListingPlan : MarketplaceListingPlan -> Json.Encode.Value
encodeMarketplaceListingPlan rec =
    Json.Encode.object
        [ ( "accounts_url", Json.Encode.string rec.accounts_url )
        , ( "bullets", Json.Encode.list Json.Encode.string rec.bullets )
        , ( "description", Json.Encode.string rec.description )
        , ( "has_free_trial", Json.Encode.bool rec.has_free_trial )
        , ( "id", Json.Encode.int rec.id )
        , ( "monthly_price_in_cents"
          , Json.Encode.int rec.monthly_price_in_cents
          )
        , ( "name", Json.Encode.string rec.name )
        , ( "number", Json.Encode.int rec.number )
        , ( "price_model", Json.Encode.string rec.price_model )
        , ( "state", Json.Encode.string rec.state )
        , ( "unit_name"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.unit_name
          )
        , ( "url", Json.Encode.string rec.url )
        , ( "yearly_price_in_cents", Json.Encode.int rec.yearly_price_in_cents )
        ]


type alias MarketplaceAccount =
    { email : Nullable String
    , id : Int
    , login : String
    , node_id : String
    , organization_billing_email : Nullable String
    , type_ : String
    , url : String
    }


decodeMarketplaceAccount : Json.Decode.Decoder MarketplaceAccount
decodeMarketplaceAccount =
    Json.Decode.succeed
     (\email id login node_id organization_billing_email type_ url ->
         { email = email
         , id = id
         , login = login
         , node_id = node_id
         , organization_billing_email = organization_billing_email
         , type_ = type_
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "email"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "login" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "organization_billing_email"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "type" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeMarketplaceAccount : MarketplaceAccount -> Json.Encode.Value
encodeMarketplaceAccount rec =
    Json.Encode.object
        [ ( "email"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.email
          )
        , ( "id", Json.Encode.int rec.id )
        , ( "login", Json.Encode.string rec.login )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "organization_billing_email"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.organization_billing_email
          )
        , ( "type", Json.Encode.string rec.type_ )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias Manifest =
    { file : { source_location : String }
    , metadata : Metadata
    , name : String
    , resolved : {}
    }


decodeManifest : Json.Decode.Decoder Manifest
decodeManifest =
    Json.Decode.succeed
     (\file metadata name resolved ->
         { file = file, metadata = metadata, name = name, resolved = resolved }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "file"
                (Json.Decode.succeed
                    (\source_location -> { source_location = source_location })
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "source_location" Json.Decode.string)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "metadata" decodeMetadata)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "resolved" (Json.Decode.succeed {}))


encodeManifest : Manifest -> Json.Encode.Value
encodeManifest rec =
    Json.Encode.object
        [ ( "file"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "source_location"
                      , Json.Encode.string rec0.source_location
                      )
                    ]
            )
                rec.file
          )
        , ( "metadata", encodeMetadata rec.metadata )
        , ( "name", Json.Encode.string rec.name )
        , ( "resolved", (\rec0 -> Json.Encode.object []) rec.resolved )
        ]


type alias LockedIssueEvent =
    { actor : SimpleUser
    , commit_id : Nullable String
    , commit_url : Nullable String
    , created_at : String
    , event : String
    , id : Int
    , lock_reason : Nullable String
    , node_id : String
    , performed_via_github_app : Nullable Integration
    , url : String
    }


decodeLockedIssueEvent : Json.Decode.Decoder LockedIssueEvent
decodeLockedIssueEvent =
    Json.Decode.succeed
     (\actor commit_id commit_url created_at event id lock_reason node_id performed_via_github_app url ->
         { actor = actor
         , commit_id = commit_id
         , commit_url = commit_url
         , created_at = created_at
         , event = event
         , id = id
         , lock_reason = lock_reason
         , node_id = node_id
         , performed_via_github_app = performed_via_github_app
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap (Json.Decode.field "actor" decodeSimpleUser)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "commit_id"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "commit_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "event" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "lock_reason"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "performed_via_github_app"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeIntegration
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeLockedIssueEvent : LockedIssueEvent -> Json.Encode.Value
encodeLockedIssueEvent rec =
    Json.Encode.object
        [ ( "actor", encodeSimpleUser rec.actor )
        , ( "commit_id"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.commit_id
          )
        , ( "commit_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.commit_url
          )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "event", Json.Encode.string rec.event )
        , ( "id", Json.Encode.int rec.id )
        , ( "lock_reason"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.lock_reason
          )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "performed_via_github_app"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeIntegration value
            )
                rec.performed_via_github_app
          )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias LinkWithType =
    { href : String, type_ : String }


decodeLinkWithType : Json.Decode.Decoder LinkWithType
decodeLinkWithType =
    Json.Decode.succeed (\href type_ -> { href = href, type_ = type_ })
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "href" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "type" Json.Decode.string)


encodeLinkWithType : LinkWithType -> Json.Encode.Value
encodeLinkWithType rec =
    Json.Encode.object
        [ ( "href", Json.Encode.string rec.href )
        , ( "type", Json.Encode.string rec.type_ )
        ]


type alias Link =
    { href : String }


decodeLink : Json.Decode.Decoder Link
decodeLink =
    Json.Decode.succeed (\href -> { href = href })
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "href" Json.Decode.string)


encodeLink : Link -> Json.Encode.Value
encodeLink rec =
    Json.Encode.object [ ( "href", Json.Encode.string rec.href ) ]


type alias LicenseSimple =
    { html_url : String
    , key : String
    , name : String
    , node_id : String
    , spdx_id : Nullable String
    , url : Nullable String
    }


decodeLicenseSimple : Json.Decode.Decoder LicenseSimple
decodeLicenseSimple =
    Json.Decode.succeed
     (\html_url key name node_id spdx_id url ->
         { html_url = html_url
         , key = key
         , name = name
         , node_id = node_id
         , spdx_id = spdx_id
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "key" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "spdx_id"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )


encodeLicenseSimple : LicenseSimple -> Json.Encode.Value
encodeLicenseSimple rec =
    Json.Encode.object
        [ ( "html_url", Json.Encode.string rec.html_url )
        , ( "key", Json.Encode.string rec.key )
        , ( "name", Json.Encode.string rec.name )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "spdx_id"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.spdx_id
          )
        , ( "url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.url
          )
        ]


type alias LicenseContent =
    { _links : { git : Nullable String, html : Nullable String, self : String }
    , content : String
    , download_url : Nullable String
    , encoding : String
    , git_url : Nullable String
    , html_url : Nullable String
    , license : Nullable LicenseSimple
    , name : String
    , path : String
    , sha : String
    , size : Int
    , type_ : String
    , url : String
    }


decodeLicenseContent : Json.Decode.Decoder LicenseContent
decodeLicenseContent =
    Json.Decode.succeed
     (\_links content download_url encoding git_url html_url license name path sha size type_ url ->
         { _links = _links
         , content = content
         , download_url = download_url
         , encoding = encoding
         , git_url = git_url
         , html_url = html_url
         , license = license
         , name = name
         , path = path
         , sha = sha
         , size = size
         , type_ = type_
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "_links"
                (Json.Decode.succeed
                  (\git html self -> { git = git, html = html, self = self })
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "git"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.string
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "html"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.string
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "self" Json.Decode.string)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "content" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "download_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "encoding" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "git_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "html_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "license"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeLicenseSimple
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "path" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "sha" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "size" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "type" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeLicenseContent : LicenseContent -> Json.Encode.Value
encodeLicenseContent rec =
    Json.Encode.object
        [ ( "_links"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "git"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.string value
                        )
                            rec0.git
                      )
                    , ( "html"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.string value
                        )
                            rec0.html
                      )
                    , ( "self", Json.Encode.string rec0.self )
                    ]
            )
                rec._links
          )
        , ( "content", Json.Encode.string rec.content )
        , ( "download_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.download_url
          )
        , ( "encoding", Json.Encode.string rec.encoding )
        , ( "git_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.git_url
          )
        , ( "html_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.html_url
          )
        , ( "license"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeLicenseSimple value
            )
                rec.license
          )
        , ( "name", Json.Encode.string rec.name )
        , ( "path", Json.Encode.string rec.path )
        , ( "sha", Json.Encode.string rec.sha )
        , ( "size", Json.Encode.int rec.size )
        , ( "type", Json.Encode.string rec.type_ )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias License =
    { body : String
    , conditions : List String
    , description : String
    , featured : Bool
    , html_url : String
    , implementation : String
    , key : String
    , limitations : List String
    , name : String
    , node_id : String
    , permissions : List String
    , spdx_id : Nullable String
    , url : Nullable String
    }


decodeLicense : Json.Decode.Decoder License
decodeLicense =
    Json.Decode.succeed
     (\body conditions description featured html_url implementation key limitations name node_id permissions spdx_id url ->
         { body = body
         , conditions = conditions
         , description = description
         , featured = featured
         , html_url = html_url
         , implementation = implementation
         , key = key
         , limitations = limitations
         , name = name
         , node_id = node_id
         , permissions = permissions
         , spdx_id = spdx_id
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "body" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "conditions"
                (Json.Decode.list Json.Decode.string)
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "description" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "featured" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "implementation" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "key" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "limitations"
                (Json.Decode.list Json.Decode.string)
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "permissions"
                (Json.Decode.list Json.Decode.string)
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "spdx_id"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )


encodeLicense : License -> Json.Encode.Value
encodeLicense rec =
    Json.Encode.object
        [ ( "body", Json.Encode.string rec.body )
        , ( "conditions", Json.Encode.list Json.Encode.string rec.conditions )
        , ( "description", Json.Encode.string rec.description )
        , ( "featured", Json.Encode.bool rec.featured )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "implementation", Json.Encode.string rec.implementation )
        , ( "key", Json.Encode.string rec.key )
        , ( "limitations", Json.Encode.list Json.Encode.string rec.limitations )
        , ( "name", Json.Encode.string rec.name )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "permissions", Json.Encode.list Json.Encode.string rec.permissions )
        , ( "spdx_id"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.spdx_id
          )
        , ( "url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.url
          )
        ]


type alias Language =
    {}


decodeLanguage : Json.Decode.Decoder Language
decodeLanguage =
    Json.Decode.succeed {}


encodeLanguage : Language -> Json.Encode.Value
encodeLanguage rec =
    Json.Encode.object []


type alias LabeledIssueEvent =
    { actor : SimpleUser
    , commit_id : Nullable String
    , commit_url : Nullable String
    , created_at : String
    , event : String
    , id : Int
    , label : { color : String, name : String }
    , node_id : String
    , performed_via_github_app : Nullable Integration
    , url : String
    }


decodeLabeledIssueEvent : Json.Decode.Decoder LabeledIssueEvent
decodeLabeledIssueEvent =
    Json.Decode.succeed
     (\actor commit_id commit_url created_at event id label node_id performed_via_github_app url ->
         { actor = actor
         , commit_id = commit_id
         , commit_url = commit_url
         , created_at = created_at
         , event = event
         , id = id
         , label = label
         , node_id = node_id
         , performed_via_github_app = performed_via_github_app
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap (Json.Decode.field "actor" decodeSimpleUser)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "commit_id"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "commit_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "event" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "label"
                (Json.Decode.succeed
                  (\color name -> { color = color, name = name })
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "color" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "name" Json.Decode.string)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "performed_via_github_app"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeIntegration
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeLabeledIssueEvent : LabeledIssueEvent -> Json.Encode.Value
encodeLabeledIssueEvent rec =
    Json.Encode.object
        [ ( "actor", encodeSimpleUser rec.actor )
        , ( "commit_id"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.commit_id
          )
        , ( "commit_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.commit_url
          )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "event", Json.Encode.string rec.event )
        , ( "id", Json.Encode.int rec.id )
        , ( "label"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "color", Json.Encode.string rec0.color )
                    , ( "name", Json.Encode.string rec0.name )
                    ]
            )
                rec.label
          )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "performed_via_github_app"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeIntegration value
            )
                rec.performed_via_github_app
          )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias LabelSearchResultItem =
    { color : String
    , default : Bool
    , description : Nullable String
    , id : Int
    , name : String
    , node_id : String
    , score : Float
    , text_matches : SearchResultTextMatches
    , url : String
    }


decodeLabelSearchResultItem : Json.Decode.Decoder LabelSearchResultItem
decodeLabelSearchResultItem =
    Json.Decode.succeed
     (\color default description id name node_id score text_matches url ->
         { color = color
         , default = default
         , description = description
         , id = id
         , name = name
         , node_id = node_id
         , score = score
         , text_matches = text_matches
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "color" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "default" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "description"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "score" Json.Decode.float)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "text_matches" decodeSearchResultTextMatches)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeLabelSearchResultItem : LabelSearchResultItem -> Json.Encode.Value
encodeLabelSearchResultItem rec =
    Json.Encode.object
        [ ( "color", Json.Encode.string rec.color )
        , ( "default", Json.Encode.bool rec.default )
        , ( "description"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.description
          )
        , ( "id", Json.Encode.int rec.id )
        , ( "name", Json.Encode.string rec.name )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "score", Json.Encode.float rec.score )
        , ( "text_matches", encodeSearchResultTextMatches rec.text_matches )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias Label =
    { color : String
    , default : Bool
    , description : Nullable String
    , id : Int
    , name : String
    , node_id : String
    , url : String
    }


decodeLabel : Json.Decode.Decoder Label
decodeLabel =
    Json.Decode.succeed
     (\color default description id name node_id url ->
         { color = color
         , default = default
         , description = description
         , id = id
         , name = name
         , node_id = node_id
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "color" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "default" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "description"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeLabel : Label -> Json.Encode.Value
encodeLabel rec =
    Json.Encode.object
        [ ( "color", Json.Encode.string rec.color )
        , ( "default", Json.Encode.bool rec.default )
        , ( "description"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.description
          )
        , ( "id", Json.Encode.int rec.id )
        , ( "name", Json.Encode.string rec.name )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias KeySimple =
    { id : Int, key : String }


decodeKeySimple : Json.Decode.Decoder KeySimple
decodeKeySimple =
    Json.Decode.succeed (\id key -> { id = id, key = key })
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap (Json.Decode.field "key" Json.Decode.string)


encodeKeySimple : KeySimple -> Json.Encode.Value
encodeKeySimple rec =
    Json.Encode.object
        [ ( "id", Json.Encode.int rec.id )
        , ( "key", Json.Encode.string rec.key )
        ]


type alias Key =
    { created_at : String
    , id : Int
    , key : String
    , read_only : Bool
    , title : String
    , url : String
    , verified : Bool
    }


decodeKey : Json.Decode.Decoder Key
decodeKey =
    Json.Decode.succeed
     (\created_at id key read_only title url verified ->
         { created_at = created_at
         , id = id
         , key = key
         , read_only = read_only
         , title = title
         , url = url
         , verified = verified
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap (Json.Decode.field "key" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "read_only" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "title" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "verified" Json.Decode.bool)


encodeKey : Key -> Json.Encode.Value
encodeKey rec =
    Json.Encode.object
        [ ( "created_at", Json.Encode.string rec.created_at )
        , ( "id", Json.Encode.int rec.id )
        , ( "key", Json.Encode.string rec.key )
        , ( "read_only", Json.Encode.bool rec.read_only )
        , ( "title", Json.Encode.string rec.title )
        , ( "url", Json.Encode.string rec.url )
        , ( "verified", Json.Encode.bool rec.verified )
        ]


type alias Job =
    { check_run_url : String
    , completed_at : Nullable String
    , conclusion : Nullable String
    , head_sha : String
    , html_url : Nullable String
    , id : Int
    , labels : List String
    , name : String
    , node_id : String
    , run_attempt : Int
    , run_id : Int
    , run_url : String
    , runner_group_id : Nullable Int
    , runner_group_name : Nullable String
    , runner_id : Nullable Int
    , runner_name : Nullable String
    , started_at : String
    , status : String
    , steps :
        List { completed_at : Nullable String
        , conclusion : Nullable String
        , name : String
        , number : Int
        , started_at : Nullable String
        , status : String
        }
    , url : String
    }


decodeJob : Json.Decode.Decoder Job
decodeJob =
    Json.Decode.succeed
     (\check_run_url completed_at conclusion head_sha html_url id labels name node_id run_attempt run_id run_url runner_group_id runner_group_name runner_id runner_name started_at status steps url ->
         { check_run_url = check_run_url
         , completed_at = completed_at
         , conclusion = conclusion
         , head_sha = head_sha
         , html_url = html_url
         , id = id
         , labels = labels
         , name = name
         , node_id = node_id
         , run_attempt = run_attempt
         , run_id = run_id
         , run_url = run_url
         , runner_group_id = runner_group_id
         , runner_group_name = runner_group_name
         , runner_id = runner_id
         , runner_name = runner_name
         , started_at = started_at
         , status = status
         , steps = steps
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "check_run_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "completed_at"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "conclusion"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "head_sha" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "html_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "labels" (Json.Decode.list Json.Decode.string))
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "run_attempt" Json.Decode.int)
        |> Json.Decode.Extra.andMap (Json.Decode.field "run_id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "run_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "runner_group_id"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.int
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "runner_group_name"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "runner_id"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.int
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "runner_name"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "started_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "status" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "steps"
                (Json.Decode.list
                    (Json.Decode.succeed
                      (\completed_at conclusion name number started_at status ->
                          { completed_at = completed_at
                          , conclusion = conclusion
                          , name = name
                          , number = number
                          , started_at = started_at
                          , status = status
                          }
                      )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field
                                "completed_at"
                                (Json.Decode.oneOf
                                    [ Json.Decode.map Present Json.Decode.string
                                    , Json.Decode.null Null
                                    ]
                                )
                            )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field
                                "conclusion"
                                (Json.Decode.oneOf
                                    [ Json.Decode.map Present Json.Decode.string
                                    , Json.Decode.null Null
                                    ]
                                )
                            )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "name" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "number" Json.Decode.int)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field
                                "started_at"
                                (Json.Decode.oneOf
                                    [ Json.Decode.map Present Json.Decode.string
                                    , Json.Decode.null Null
                                    ]
                                )
                            )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "status" Json.Decode.string)
                    )
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeJob : Job -> Json.Encode.Value
encodeJob rec =
    Json.Encode.object
        [ ( "check_run_url", Json.Encode.string rec.check_run_url )
        , ( "completed_at"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.completed_at
          )
        , ( "conclusion"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.conclusion
          )
        , ( "head_sha", Json.Encode.string rec.head_sha )
        , ( "html_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.html_url
          )
        , ( "id", Json.Encode.int rec.id )
        , ( "labels", Json.Encode.list Json.Encode.string rec.labels )
        , ( "name", Json.Encode.string rec.name )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "run_attempt", Json.Encode.int rec.run_attempt )
        , ( "run_id", Json.Encode.int rec.run_id )
        , ( "run_url", Json.Encode.string rec.run_url )
        , ( "runner_group_id"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.int value
            )
                rec.runner_group_id
          )
        , ( "runner_group_name"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.runner_group_name
          )
        , ( "runner_id"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.int value
            )
                rec.runner_id
          )
        , ( "runner_name"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.runner_name
          )
        , ( "started_at", Json.Encode.string rec.started_at )
        , ( "status", Json.Encode.string rec.status )
        , ( "steps"
          , Json.Encode.list
                (\rec0 ->
                    Json.Encode.object
                        [ ( "completed_at"
                          , (\nullableValue ->
                                case nullableValue of
                                    Null ->
                                        Json.Encode.null

                                    Present value ->
                                        Json.Encode.string value
                            )
                                rec0.completed_at
                          )
                        , ( "conclusion"
                          , (\nullableValue ->
                                case nullableValue of
                                    Null ->
                                        Json.Encode.null

                                    Present value ->
                                        Json.Encode.string value
                            )
                                rec0.conclusion
                          )
                        , ( "name", Json.Encode.string rec0.name )
                        , ( "number", Json.Encode.int rec0.number )
                        , ( "started_at"
                          , (\nullableValue ->
                                case nullableValue of
                                    Null ->
                                        Json.Encode.null

                                    Present value ->
                                        Json.Encode.string value
                            )
                                rec0.started_at
                          )
                        , ( "status", Json.Encode.string rec0.status )
                        ]
                )
                rec.steps
          )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias IssueSearchResultItem =
    { active_lock_reason : Nullable String
    , assignee : Nullable SimpleUser
    , assignees : Nullable (List SimpleUser)
    , author_association : AuthorAssociation
    , body : String
    , body_html : String
    , body_text : String
    , closed_at : Nullable String
    , comments : Int
    , comments_url : String
    , created_at : String
    , draft : Bool
    , events_url : String
    , html_url : String
    , id : Int
    , labels :
        List { color : String
        , default : Bool
        , description : Nullable String
        , id : Int
        , name : String
        , node_id : String
        , url : String
        }
    , labels_url : String
    , locked : Bool
    , milestone : Nullable Milestone
    , node_id : String
    , number : Int
    , performed_via_github_app : Nullable Integration
    , pull_request :
        { diff_url : Nullable String
        , html_url : Nullable String
        , merged_at : Nullable String
        , patch_url : Nullable String
        , url : Nullable String
        }
    , reactions : ReactionRollup
    , repository : Repository
    , repository_url : String
    , score : Float
    , state : String
    , state_reason : Nullable String
    , text_matches : SearchResultTextMatches
    , timeline_url : String
    , title : String
    , updated_at : String
    , url : String
    , user : Nullable SimpleUser
    }


decodeIssueSearchResultItem : Json.Decode.Decoder IssueSearchResultItem
decodeIssueSearchResultItem =
    Json.Decode.succeed
     (\active_lock_reason assignee assignees author_association body body_html body_text closed_at comments comments_url created_at draft events_url html_url id labels labels_url locked milestone node_id number performed_via_github_app pull_request reactions repository repository_url score state state_reason text_matches timeline_url title updated_at url user ->
         { active_lock_reason = active_lock_reason
         , assignee = assignee
         , assignees = assignees
         , author_association = author_association
         , body = body
         , body_html = body_html
         , body_text = body_text
         , closed_at = closed_at
         , comments = comments
         , comments_url = comments_url
         , created_at = created_at
         , draft = draft
         , events_url = events_url
         , html_url = html_url
         , id = id
         , labels = labels
         , labels_url = labels_url
         , locked = locked
         , milestone = milestone
         , node_id = node_id
         , number = number
         , performed_via_github_app = performed_via_github_app
         , pull_request = pull_request
         , reactions = reactions
         , repository = repository
         , repository_url = repository_url
         , score = score
         , state = state
         , state_reason = state_reason
         , text_matches = text_matches
         , timeline_url = timeline_url
         , title = title
         , updated_at = updated_at
         , url = url
         , user = user
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "active_lock_reason"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "assignee"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "assignees"
                (Json.Decode.oneOf
                    [ Json.Decode.map
                        Present
                        (Json.Decode.list decodeSimpleUser)
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "author_association" decodeAuthorAssociation)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "body" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "body_html" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "body_text" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "closed_at"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "comments" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "comments_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "draft" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "events_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "labels"
                (Json.Decode.list
                    (Json.Decode.succeed
                      (\color default description id name node_id url ->
                          { color = color
                          , default = default
                          , description = description
                          , id = id
                          , name = name
                          , node_id = node_id
                          , url = url
                          }
                      )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "color" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "default" Json.Decode.bool)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field
                                "description"
                                (Json.Decode.oneOf
                                    [ Json.Decode.map Present Json.Decode.string
                                    , Json.Decode.null Null
                                    ]
                                )
                            )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "id" Json.Decode.int)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "name" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "node_id" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "url" Json.Decode.string)
                    )
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "labels_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "locked" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "milestone"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeMilestone
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "number" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "performed_via_github_app"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeIntegration
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "pull_request"
                (Json.Decode.succeed
                  (\diff_url html_url merged_at patch_url url ->
                      { diff_url = diff_url
                      , html_url = html_url
                      , merged_at = merged_at
                      , patch_url = patch_url
                      , url = url
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "diff_url"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.string
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "html_url"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.string
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "merged_at"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.string
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "patch_url"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.string
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "url"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.string
                                , Json.Decode.null Null
                                ]
                            )
                        )
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "reactions" decodeReactionRollup)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "repository" decodeRepository)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "repository_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "score" Json.Decode.float)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "state" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "state_reason"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "text_matches" decodeSearchResultTextMatches)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "timeline_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "title" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "user"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )


encodeIssueSearchResultItem : IssueSearchResultItem -> Json.Encode.Value
encodeIssueSearchResultItem rec =
    Json.Encode.object
        [ ( "active_lock_reason"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.active_lock_reason
          )
        , ( "assignee"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.assignee
          )
        , ( "assignees"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.list encodeSimpleUser value
            )
                rec.assignees
          )
        , ( "author_association"
          , encodeAuthorAssociation rec.author_association
          )
        , ( "body", Json.Encode.string rec.body )
        , ( "body_html", Json.Encode.string rec.body_html )
        , ( "body_text", Json.Encode.string rec.body_text )
        , ( "closed_at"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.closed_at
          )
        , ( "comments", Json.Encode.int rec.comments )
        , ( "comments_url", Json.Encode.string rec.comments_url )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "draft", Json.Encode.bool rec.draft )
        , ( "events_url", Json.Encode.string rec.events_url )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "id", Json.Encode.int rec.id )
        , ( "labels"
          , Json.Encode.list
                (\rec0 ->
                    Json.Encode.object
                        [ ( "color", Json.Encode.string rec0.color )
                        , ( "default", Json.Encode.bool rec0.default )
                        , ( "description"
                          , (\nullableValue ->
                                case nullableValue of
                                    Null ->
                                        Json.Encode.null

                                    Present value ->
                                        Json.Encode.string value
                            )
                                rec0.description
                          )
                        , ( "id", Json.Encode.int rec0.id )
                        , ( "name", Json.Encode.string rec0.name )
                        , ( "node_id", Json.Encode.string rec0.node_id )
                        , ( "url", Json.Encode.string rec0.url )
                        ]
                )
                rec.labels
          )
        , ( "labels_url", Json.Encode.string rec.labels_url )
        , ( "locked", Json.Encode.bool rec.locked )
        , ( "milestone"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeMilestone value
            )
                rec.milestone
          )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "number", Json.Encode.int rec.number )
        , ( "performed_via_github_app"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeIntegration value
            )
                rec.performed_via_github_app
          )
        , ( "pull_request"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "diff_url"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.string value
                        )
                            rec0.diff_url
                      )
                    , ( "html_url"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.string value
                        )
                            rec0.html_url
                      )
                    , ( "merged_at"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.string value
                        )
                            rec0.merged_at
                      )
                    , ( "patch_url"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.string value
                        )
                            rec0.patch_url
                      )
                    , ( "url"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.string value
                        )
                            rec0.url
                      )
                    ]
            )
                rec.pull_request
          )
        , ( "reactions", encodeReactionRollup rec.reactions )
        , ( "repository", encodeRepository rec.repository )
        , ( "repository_url", Json.Encode.string rec.repository_url )
        , ( "score", Json.Encode.float rec.score )
        , ( "state", Json.Encode.string rec.state )
        , ( "state_reason"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.state_reason
          )
        , ( "text_matches", encodeSearchResultTextMatches rec.text_matches )
        , ( "timeline_url", Json.Encode.string rec.timeline_url )
        , ( "title", Json.Encode.string rec.title )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        , ( "url", Json.Encode.string rec.url )
        , ( "user"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.user
          )
        ]


type alias IssueEventRename =
    { from : String, to : String }


decodeIssueEventRename : Json.Decode.Decoder IssueEventRename
decodeIssueEventRename =
    Json.Decode.succeed (\from to -> { from = from, to = to })
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "from" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "to" Json.Decode.string)


encodeIssueEventRename : IssueEventRename -> Json.Encode.Value
encodeIssueEventRename rec =
    Json.Encode.object
        [ ( "from", Json.Encode.string rec.from )
        , ( "to", Json.Encode.string rec.to )
        ]


type alias IssueEventProjectCard =
    { column_name : String
    , id : Int
    , previous_column_name : String
    , project_id : Int
    , project_url : String
    , url : String
    }


decodeIssueEventProjectCard : Json.Decode.Decoder IssueEventProjectCard
decodeIssueEventProjectCard =
    Json.Decode.succeed
     (\column_name id previous_column_name project_id project_url url ->
         { column_name = column_name
         , id = id
         , previous_column_name = previous_column_name
         , project_id = project_id
         , project_url = project_url
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "column_name" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "previous_column_name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "project_id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "project_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeIssueEventProjectCard : IssueEventProjectCard -> Json.Encode.Value
encodeIssueEventProjectCard rec =
    Json.Encode.object
        [ ( "column_name", Json.Encode.string rec.column_name )
        , ( "id", Json.Encode.int rec.id )
        , ( "previous_column_name"
          , Json.Encode.string rec.previous_column_name
          )
        , ( "project_id", Json.Encode.int rec.project_id )
        , ( "project_url", Json.Encode.string rec.project_url )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias IssueEventMilestone =
    { title : String }


decodeIssueEventMilestone : Json.Decode.Decoder IssueEventMilestone
decodeIssueEventMilestone =
    Json.Decode.succeed (\title -> { title = title })
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "title" Json.Decode.string)


encodeIssueEventMilestone : IssueEventMilestone -> Json.Encode.Value
encodeIssueEventMilestone rec =
    Json.Encode.object [ ( "title", Json.Encode.string rec.title ) ]


type alias IssueEventLabel =
    { color : Nullable String, name : Nullable String }


decodeIssueEventLabel : Json.Decode.Decoder IssueEventLabel
decodeIssueEventLabel =
    Json.Decode.succeed (\color name -> { color = color, name = name })
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "color"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "name"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )


encodeIssueEventLabel : IssueEventLabel -> Json.Encode.Value
encodeIssueEventLabel rec =
    Json.Encode.object
        [ ( "color"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.color
          )
        , ( "name"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.name
          )
        ]


type alias IssueEventForIssue =
    EnumFifteen LabeledIssueEvent UnlabeledIssueEvent AssignedIssueEvent UnassignedIssueEvent MilestonedIssueEvent DemilestonedIssueEvent RenamedIssueEvent ReviewRequestedIssueEvent ReviewRequestRemovedIssueEvent ReviewDismissedIssueEvent LockedIssueEvent AddedToProjectIssueEvent MovedColumnInProjectIssueEvent RemovedFromProjectIssueEvent ConvertedNoteToIssueIssueEvent


decodeIssueEventForIssue : Json.Decode.Decoder IssueEventForIssue
decodeIssueEventForIssue =
    Debug.todo "Enum decoder not implemented yet"


encodeIssueEventForIssue : IssueEventForIssue -> Json.Encode.Value
encodeIssueEventForIssue =
    Debug.todo "encoder for enum not implemented"


type alias IssueEventDismissedReview =
    { dismissal_commit_id : Nullable String
    , dismissal_message : Nullable String
    , review_id : Int
    , state : String
    }


decodeIssueEventDismissedReview : Json.Decode.Decoder IssueEventDismissedReview
decodeIssueEventDismissedReview =
    Json.Decode.succeed
     (\dismissal_commit_id dismissal_message review_id state ->
         { dismissal_commit_id = dismissal_commit_id
         , dismissal_message = dismissal_message
         , review_id = review_id
         , state = state
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "dismissal_commit_id"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "dismissal_message"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "review_id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "state" Json.Decode.string)


encodeIssueEventDismissedReview : IssueEventDismissedReview -> Json.Encode.Value
encodeIssueEventDismissedReview rec =
    Json.Encode.object
        [ ( "dismissal_commit_id"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.dismissal_commit_id
          )
        , ( "dismissal_message"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.dismissal_message
          )
        , ( "review_id", Json.Encode.int rec.review_id )
        , ( "state", Json.Encode.string rec.state )
        ]


type alias IssueEvent =
    { actor : Nullable SimpleUser
    , assignee : Nullable SimpleUser
    , assigner : Nullable SimpleUser
    , author_association : AuthorAssociation
    , commit_id : Nullable String
    , commit_url : Nullable String
    , created_at : String
    , dismissed_review : IssueEventDismissedReview
    , event : String
    , id : Int
    , issue : Nullable Issue
    , label : IssueEventLabel
    , lock_reason : Nullable String
    , milestone : IssueEventMilestone
    , node_id : String
    , performed_via_github_app : Nullable Integration
    , project_card : IssueEventProjectCard
    , rename : IssueEventRename
    , requested_reviewer : Nullable SimpleUser
    , requested_team : Team
    , review_requester : Nullable SimpleUser
    , url : String
    }


decodeIssueEvent : Json.Decode.Decoder IssueEvent
decodeIssueEvent =
    Json.Decode.succeed
     (\actor assignee assigner author_association commit_id commit_url created_at dismissed_review event id issue label lock_reason milestone node_id performed_via_github_app project_card rename requested_reviewer requested_team review_requester url ->
         { actor = actor
         , assignee = assignee
         , assigner = assigner
         , author_association = author_association
         , commit_id = commit_id
         , commit_url = commit_url
         , created_at = created_at
         , dismissed_review = dismissed_review
         , event = event
         , id = id
         , issue = issue
         , label = label
         , lock_reason = lock_reason
         , milestone = milestone
         , node_id = node_id
         , performed_via_github_app = performed_via_github_app
         , project_card = project_card
         , rename = rename
         , requested_reviewer = requested_reviewer
         , requested_team = requested_team
         , review_requester = review_requester
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "actor"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "assignee"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "assigner"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "author_association" decodeAuthorAssociation)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "commit_id"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "commit_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "dismissed_review"
                decodeIssueEventDismissedReview
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "event" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "issue"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeIssue
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "label" decodeIssueEventLabel)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "lock_reason"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "milestone" decodeIssueEventMilestone)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "performed_via_github_app"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeIntegration
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "project_card" decodeIssueEventProjectCard)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "rename" decodeIssueEventRename)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "requested_reviewer"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "requested_team" decodeTeam)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "review_requester"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeIssueEvent : IssueEvent -> Json.Encode.Value
encodeIssueEvent rec =
    Json.Encode.object
        [ ( "actor"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.actor
          )
        , ( "assignee"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.assignee
          )
        , ( "assigner"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.assigner
          )
        , ( "author_association"
          , encodeAuthorAssociation rec.author_association
          )
        , ( "commit_id"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.commit_id
          )
        , ( "commit_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.commit_url
          )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "dismissed_review"
          , encodeIssueEventDismissedReview rec.dismissed_review
          )
        , ( "event", Json.Encode.string rec.event )
        , ( "id", Json.Encode.int rec.id )
        , ( "issue"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeIssue value
            )
                rec.issue
          )
        , ( "label", encodeIssueEventLabel rec.label )
        , ( "lock_reason"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.lock_reason
          )
        , ( "milestone", encodeIssueEventMilestone rec.milestone )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "performed_via_github_app"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeIntegration value
            )
                rec.performed_via_github_app
          )
        , ( "project_card", encodeIssueEventProjectCard rec.project_card )
        , ( "rename", encodeIssueEventRename rec.rename )
        , ( "requested_reviewer"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.requested_reviewer
          )
        , ( "requested_team", encodeTeam rec.requested_team )
        , ( "review_requester"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.review_requester
          )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias IssueComment =
    { author_association : AuthorAssociation
    , body : String
    , body_html : String
    , body_text : String
    , created_at : String
    , html_url : String
    , id : Int
    , issue_url : String
    , node_id : String
    , performed_via_github_app : Nullable Integration
    , reactions : ReactionRollup
    , updated_at : String
    , url : String
    , user : Nullable SimpleUser
    }


decodeIssueComment : Json.Decode.Decoder IssueComment
decodeIssueComment =
    Json.Decode.succeed
     (\author_association body body_html body_text created_at html_url id issue_url node_id performed_via_github_app reactions updated_at url user ->
         { author_association = author_association
         , body = body
         , body_html = body_html
         , body_text = body_text
         , created_at = created_at
         , html_url = html_url
         , id = id
         , issue_url = issue_url
         , node_id = node_id
         , performed_via_github_app = performed_via_github_app
         , reactions = reactions
         , updated_at = updated_at
         , url = url
         , user = user
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "author_association" decodeAuthorAssociation)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "body" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "body_html" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "body_text" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "issue_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "performed_via_github_app"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeIntegration
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "reactions" decodeReactionRollup)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "user"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )


encodeIssueComment : IssueComment -> Json.Encode.Value
encodeIssueComment rec =
    Json.Encode.object
        [ ( "author_association"
          , encodeAuthorAssociation rec.author_association
          )
        , ( "body", Json.Encode.string rec.body )
        , ( "body_html", Json.Encode.string rec.body_html )
        , ( "body_text", Json.Encode.string rec.body_text )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "id", Json.Encode.int rec.id )
        , ( "issue_url", Json.Encode.string rec.issue_url )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "performed_via_github_app"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeIntegration value
            )
                rec.performed_via_github_app
          )
        , ( "reactions", encodeReactionRollup rec.reactions )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        , ( "url", Json.Encode.string rec.url )
        , ( "user"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.user
          )
        ]


type alias Issue =
    { active_lock_reason : Nullable String
    , assignee : Nullable SimpleUser
    , assignees : Nullable (List SimpleUser)
    , author_association : AuthorAssociation
    , body : Nullable String
    , body_html : String
    , body_text : String
    , closed_at : Nullable String
    , closed_by : Nullable SimpleUser
    , comments : Int
    , comments_url : String
    , created_at : String
    , draft : Bool
    , events_url : String
    , html_url : String
    , id : Int
    , labels : List Json.Encode.Value
    , labels_url : String
    , locked : Bool
    , milestone : Nullable Milestone
    , node_id : String
    , number : Int
    , performed_via_github_app : Nullable Integration
    , pull_request :
        { diff_url : Nullable String
        , html_url : Nullable String
        , merged_at : Nullable String
        , patch_url : Nullable String
        , url : Nullable String
        }
    , reactions : ReactionRollup
    , repository : Repository
    , repository_url : String
    , state : String
    , state_reason : Nullable String
    , timeline_url : String
    , title : String
    , updated_at : String
    , url : String
    , user : Nullable SimpleUser
    }


decodeIssue : Json.Decode.Decoder Issue
decodeIssue =
    Json.Decode.succeed
     (\active_lock_reason assignee assignees author_association body body_html body_text closed_at closed_by comments comments_url created_at draft events_url html_url id labels labels_url locked milestone node_id number performed_via_github_app pull_request reactions repository repository_url state state_reason timeline_url title updated_at url user ->
         { active_lock_reason = active_lock_reason
         , assignee = assignee
         , assignees = assignees
         , author_association = author_association
         , body = body
         , body_html = body_html
         , body_text = body_text
         , closed_at = closed_at
         , closed_by = closed_by
         , comments = comments
         , comments_url = comments_url
         , created_at = created_at
         , draft = draft
         , events_url = events_url
         , html_url = html_url
         , id = id
         , labels = labels
         , labels_url = labels_url
         , locked = locked
         , milestone = milestone
         , node_id = node_id
         , number = number
         , performed_via_github_app = performed_via_github_app
         , pull_request = pull_request
         , reactions = reactions
         , repository = repository
         , repository_url = repository_url
         , state = state
         , state_reason = state_reason
         , timeline_url = timeline_url
         , title = title
         , updated_at = updated_at
         , url = url
         , user = user
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "active_lock_reason"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "assignee"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "assignees"
                (Json.Decode.oneOf
                    [ Json.Decode.map
                        Present
                        (Json.Decode.list decodeSimpleUser)
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "author_association" decodeAuthorAssociation)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "body"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "body_html" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "body_text" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "closed_at"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "closed_by"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "comments" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "comments_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "draft" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "events_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "labels" (Json.Decode.list Json.Decode.value))
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "labels_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "locked" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "milestone"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeMilestone
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "number" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "performed_via_github_app"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeIntegration
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "pull_request"
                (Json.Decode.succeed
                  (\diff_url html_url merged_at patch_url url ->
                      { diff_url = diff_url
                      , html_url = html_url
                      , merged_at = merged_at
                      , patch_url = patch_url
                      , url = url
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "diff_url"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.string
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "html_url"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.string
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "merged_at"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.string
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "patch_url"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.string
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "url"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.string
                                , Json.Decode.null Null
                                ]
                            )
                        )
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "reactions" decodeReactionRollup)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "repository" decodeRepository)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "repository_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "state" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "state_reason"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "timeline_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "title" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "user"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )


encodeIssue : Issue -> Json.Encode.Value
encodeIssue rec =
    Json.Encode.object
        [ ( "active_lock_reason"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.active_lock_reason
          )
        , ( "assignee"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.assignee
          )
        , ( "assignees"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.list encodeSimpleUser value
            )
                rec.assignees
          )
        , ( "author_association"
          , encodeAuthorAssociation rec.author_association
          )
        , ( "body"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.body
          )
        , ( "body_html", Json.Encode.string rec.body_html )
        , ( "body_text", Json.Encode.string rec.body_text )
        , ( "closed_at"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.closed_at
          )
        , ( "closed_by"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.closed_by
          )
        , ( "comments", Json.Encode.int rec.comments )
        , ( "comments_url", Json.Encode.string rec.comments_url )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "draft", Json.Encode.bool rec.draft )
        , ( "events_url", Json.Encode.string rec.events_url )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "id", Json.Encode.int rec.id )
        , ( "labels", Json.Encode.list Basics.identity rec.labels )
        , ( "labels_url", Json.Encode.string rec.labels_url )
        , ( "locked", Json.Encode.bool rec.locked )
        , ( "milestone"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeMilestone value
            )
                rec.milestone
          )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "number", Json.Encode.int rec.number )
        , ( "performed_via_github_app"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeIntegration value
            )
                rec.performed_via_github_app
          )
        , ( "pull_request"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "diff_url"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.string value
                        )
                            rec0.diff_url
                      )
                    , ( "html_url"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.string value
                        )
                            rec0.html_url
                      )
                    , ( "merged_at"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.string value
                        )
                            rec0.merged_at
                      )
                    , ( "patch_url"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.string value
                        )
                            rec0.patch_url
                      )
                    , ( "url"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.string value
                        )
                            rec0.url
                      )
                    ]
            )
                rec.pull_request
          )
        , ( "reactions", encodeReactionRollup rec.reactions )
        , ( "repository", encodeRepository rec.repository )
        , ( "repository_url", Json.Encode.string rec.repository_url )
        , ( "state", Json.Encode.string rec.state )
        , ( "state_reason"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.state_reason
          )
        , ( "timeline_url", Json.Encode.string rec.timeline_url )
        , ( "title", Json.Encode.string rec.title )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        , ( "url", Json.Encode.string rec.url )
        , ( "user"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.user
          )
        ]


type alias InteractionLimitResponse =
    { expires_at : String, limit : InteractionGroup, origin : String }


decodeInteractionLimitResponse : Json.Decode.Decoder InteractionLimitResponse
decodeInteractionLimitResponse =
    Json.Decode.succeed
     (\expires_at limit origin ->
         { expires_at = expires_at, limit = limit, origin = origin }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "expires_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "limit" decodeInteractionGroup)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "origin" Json.Decode.string)


encodeInteractionLimitResponse : InteractionLimitResponse -> Json.Encode.Value
encodeInteractionLimitResponse rec =
    Json.Encode.object
        [ ( "expires_at", Json.Encode.string rec.expires_at )
        , ( "limit", encodeInteractionGroup rec.limit )
        , ( "origin", Json.Encode.string rec.origin )
        ]


type alias InteractionLimit =
    { expiry : InteractionExpiry, limit : InteractionGroup }


decodeInteractionLimit : Json.Decode.Decoder InteractionLimit
decodeInteractionLimit =
    Json.Decode.succeed (\expiry limit -> { expiry = expiry, limit = limit })
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "expiry" decodeInteractionExpiry)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "limit" decodeInteractionGroup)


encodeInteractionLimit : InteractionLimit -> Json.Encode.Value
encodeInteractionLimit rec =
    Json.Encode.object
        [ ( "expiry", encodeInteractionExpiry rec.expiry )
        , ( "limit", encodeInteractionGroup rec.limit )
        ]


type alias InteractionGroup =
    String


decodeInteractionGroup : Json.Decode.Decoder InteractionGroup
decodeInteractionGroup =
    Json.Decode.string


encodeInteractionGroup : InteractionGroup -> Json.Encode.Value
encodeInteractionGroup =
    Json.Encode.string


type alias InteractionExpiry =
    String


decodeInteractionExpiry : Json.Decode.Decoder InteractionExpiry
decodeInteractionExpiry =
    Json.Decode.string


encodeInteractionExpiry : InteractionExpiry -> Json.Encode.Value
encodeInteractionExpiry =
    Json.Encode.string


type alias Integration =
    { client_id : String
    , client_secret : String
    , created_at : String
    , description : Nullable String
    , events : List String
    , external_url : String
    , html_url : String
    , id : Int
    , installations_count : Int
    , name : String
    , node_id : String
    , owner : Nullable SimpleUser
    , pem : String
    , permissions :
        { checks : String
        , contents : String
        , deployments : String
        , issues : String
        , metadata : String
        }
    , slug : String
    , updated_at : String
    , webhook_secret : Nullable String
    }


decodeIntegration : Json.Decode.Decoder Integration
decodeIntegration =
    Json.Decode.succeed
     (\client_id client_secret created_at description events external_url html_url id installations_count name node_id owner pem permissions slug updated_at webhook_secret ->
         { client_id = client_id
         , client_secret = client_secret
         , created_at = created_at
         , description = description
         , events = events
         , external_url = external_url
         , html_url = html_url
         , id = id
         , installations_count = installations_count
         , name = name
         , node_id = node_id
         , owner = owner
         , pem = pem
         , permissions = permissions
         , slug = slug
         , updated_at = updated_at
         , webhook_secret = webhook_secret
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "client_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "client_secret" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "description"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "events" (Json.Decode.list Json.Decode.string))
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "external_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "installations_count" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "owner"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "pem" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "permissions"
                (Json.Decode.succeed
                  (\checks contents deployments issues metadata ->
                      { checks = checks
                      , contents = contents
                      , deployments = deployments
                      , issues = issues
                      , metadata = metadata
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "checks" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "contents" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "deployments" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "issues" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "metadata" Json.Decode.string)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "slug" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "webhook_secret"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )


encodeIntegration : Integration -> Json.Encode.Value
encodeIntegration rec =
    Json.Encode.object
        [ ( "client_id", Json.Encode.string rec.client_id )
        , ( "client_secret", Json.Encode.string rec.client_secret )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "description"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.description
          )
        , ( "events", Json.Encode.list Json.Encode.string rec.events )
        , ( "external_url", Json.Encode.string rec.external_url )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "id", Json.Encode.int rec.id )
        , ( "installations_count", Json.Encode.int rec.installations_count )
        , ( "name", Json.Encode.string rec.name )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "owner"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.owner
          )
        , ( "pem", Json.Encode.string rec.pem )
        , ( "permissions"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "checks", Json.Encode.string rec0.checks )
                    , ( "contents", Json.Encode.string rec0.contents )
                    , ( "deployments", Json.Encode.string rec0.deployments )
                    , ( "issues", Json.Encode.string rec0.issues )
                    , ( "metadata", Json.Encode.string rec0.metadata )
                    ]
            )
                rec.permissions
          )
        , ( "slug", Json.Encode.string rec.slug )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        , ( "webhook_secret"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.webhook_secret
          )
        ]


type alias InstallationToken =
    { expires_at : String
    , has_multiple_single_files : Bool
    , permissions : AppPermissions
    , repositories : List Repository
    , repository_selection : String
    , single_file : String
    , single_file_paths : List String
    , token : String
    }


decodeInstallationToken : Json.Decode.Decoder InstallationToken
decodeInstallationToken =
    Json.Decode.succeed
     (\expires_at has_multiple_single_files permissions repositories repository_selection single_file single_file_paths token ->
         { expires_at = expires_at
         , has_multiple_single_files = has_multiple_single_files
         , permissions = permissions
         , repositories = repositories
         , repository_selection = repository_selection
         , single_file = single_file
         , single_file_paths = single_file_paths
         , token = token
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "expires_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "has_multiple_single_files" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "permissions" decodeAppPermissions)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "repositories"
                (Json.Decode.list decodeRepository)
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "repository_selection" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "single_file" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "single_file_paths"
                (Json.Decode.list Json.Decode.string)
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "token" Json.Decode.string)


encodeInstallationToken : InstallationToken -> Json.Encode.Value
encodeInstallationToken rec =
    Json.Encode.object
        [ ( "expires_at", Json.Encode.string rec.expires_at )
        , ( "has_multiple_single_files"
          , Json.Encode.bool rec.has_multiple_single_files
          )
        , ( "permissions", encodeAppPermissions rec.permissions )
        , ( "repositories", Json.Encode.list encodeRepository rec.repositories )
        , ( "repository_selection"
          , Json.Encode.string rec.repository_selection
          )
        , ( "single_file", Json.Encode.string rec.single_file )
        , ( "single_file_paths"
          , Json.Encode.list Json.Encode.string rec.single_file_paths
          )
        , ( "token", Json.Encode.string rec.token )
        ]


type alias Installation =
    { access_tokens_url : String
    , account : Nullable {}
    , app_id : Int
    , app_slug : String
    , contact_email : Nullable String
    , created_at : String
    , events : List String
    , has_multiple_single_files : Bool
    , html_url : String
    , id : Int
    , permissions : AppPermissions
    , repositories_url : String
    , repository_selection : String
    , single_file_name : Nullable String
    , single_file_paths : List String
    , suspended_at : Nullable String
    , suspended_by : Nullable SimpleUser
    , target_id : Int
    , target_type : String
    , updated_at : String
    }


decodeInstallation : Json.Decode.Decoder Installation
decodeInstallation =
    Json.Decode.succeed
     (\access_tokens_url account app_id app_slug contact_email created_at events has_multiple_single_files html_url id permissions repositories_url repository_selection single_file_name single_file_paths suspended_at suspended_by target_id target_type updated_at ->
         { access_tokens_url = access_tokens_url
         , account = account
         , app_id = app_id
         , app_slug = app_slug
         , contact_email = contact_email
         , created_at = created_at
         , events = events
         , has_multiple_single_files = has_multiple_single_files
         , html_url = html_url
         , id = id
         , permissions = permissions
         , repositories_url = repositories_url
         , repository_selection = repository_selection
         , single_file_name = single_file_name
         , single_file_paths = single_file_paths
         , suspended_at = suspended_at
         , suspended_by = suspended_by
         , target_id = target_id
         , target_type = target_type
         , updated_at = updated_at
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "access_tokens_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "account"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present (Json.Decode.succeed {})
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "app_id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "app_slug" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "contact_email"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "events" (Json.Decode.list Json.Decode.string))
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "has_multiple_single_files" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "permissions" decodeAppPermissions)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "repositories_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "repository_selection" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "single_file_name"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "single_file_paths"
                (Json.Decode.list Json.Decode.string)
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "suspended_at"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "suspended_by"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "target_id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "target_type" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)


encodeInstallation : Installation -> Json.Encode.Value
encodeInstallation rec =
    Json.Encode.object
        [ ( "access_tokens_url", Json.Encode.string rec.access_tokens_url )
        , ( "account"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        (\rec0 -> Json.Encode.object []) value
            )
                rec.account
          )
        , ( "app_id", Json.Encode.int rec.app_id )
        , ( "app_slug", Json.Encode.string rec.app_slug )
        , ( "contact_email"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.contact_email
          )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "events", Json.Encode.list Json.Encode.string rec.events )
        , ( "has_multiple_single_files"
          , Json.Encode.bool rec.has_multiple_single_files
          )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "id", Json.Encode.int rec.id )
        , ( "permissions", encodeAppPermissions rec.permissions )
        , ( "repositories_url", Json.Encode.string rec.repositories_url )
        , ( "repository_selection"
          , Json.Encode.string rec.repository_selection
          )
        , ( "single_file_name"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.single_file_name
          )
        , ( "single_file_paths"
          , Json.Encode.list Json.Encode.string rec.single_file_paths
          )
        , ( "suspended_at"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.suspended_at
          )
        , ( "suspended_by"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.suspended_by
          )
        , ( "target_id", Json.Encode.int rec.target_id )
        , ( "target_type", Json.Encode.string rec.target_type )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        ]


type alias Import =
    { authors_count : Nullable Int
    , authors_url : String
    , commit_count : Nullable Int
    , error_message : Nullable String
    , failed_step : Nullable String
    , has_large_files : Bool
    , html_url : String
    , import_percent : Nullable Int
    , large_files_count : Int
    , large_files_size : Int
    , message : String
    , project_choices :
        List { human_name : String, tfvc_project : String, vcs : String }
    , push_percent : Nullable Int
    , repository_url : String
    , status : String
    , status_text : Nullable String
    , svc_root : String
    , svn_root : String
    , tfvc_project : String
    , url : String
    , use_lfs : Bool
    , vcs : Nullable String
    , vcs_url : String
    }


decodeImport : Json.Decode.Decoder Import
decodeImport =
    Json.Decode.succeed
     (\authors_count authors_url commit_count error_message failed_step has_large_files html_url import_percent large_files_count large_files_size message project_choices push_percent repository_url status status_text svc_root svn_root tfvc_project url use_lfs vcs vcs_url ->
         { authors_count = authors_count
         , authors_url = authors_url
         , commit_count = commit_count
         , error_message = error_message
         , failed_step = failed_step
         , has_large_files = has_large_files
         , html_url = html_url
         , import_percent = import_percent
         , large_files_count = large_files_count
         , large_files_size = large_files_size
         , message = message
         , project_choices = project_choices
         , push_percent = push_percent
         , repository_url = repository_url
         , status = status
         , status_text = status_text
         , svc_root = svc_root
         , svn_root = svn_root
         , tfvc_project = tfvc_project
         , url = url
         , use_lfs = use_lfs
         , vcs = vcs
         , vcs_url = vcs_url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "authors_count"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.int
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "authors_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "commit_count"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.int
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "error_message"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "failed_step"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "has_large_files" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "import_percent"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.int
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "large_files_count" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "large_files_size" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "message" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "project_choices"
                (Json.Decode.list
                    (Json.Decode.succeed
                      (\human_name tfvc_project vcs ->
                          { human_name = human_name
                          , tfvc_project = tfvc_project
                          , vcs = vcs
                          }
                      )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "human_name" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "tfvc_project" Json.Decode.string
                            )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "vcs" Json.Decode.string)
                    )
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "push_percent"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.int
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "repository_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "status" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "status_text"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "svc_root" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "svn_root" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "tfvc_project" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "use_lfs" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "vcs"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "vcs_url" Json.Decode.string)


encodeImport : Import -> Json.Encode.Value
encodeImport rec =
    Json.Encode.object
        [ ( "authors_count"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.int value
            )
                rec.authors_count
          )
        , ( "authors_url", Json.Encode.string rec.authors_url )
        , ( "commit_count"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.int value
            )
                rec.commit_count
          )
        , ( "error_message"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.error_message
          )
        , ( "failed_step"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.failed_step
          )
        , ( "has_large_files", Json.Encode.bool rec.has_large_files )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "import_percent"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.int value
            )
                rec.import_percent
          )
        , ( "large_files_count", Json.Encode.int rec.large_files_count )
        , ( "large_files_size", Json.Encode.int rec.large_files_size )
        , ( "message", Json.Encode.string rec.message )
        , ( "project_choices"
          , Json.Encode.list
                (\rec0 ->
                    Json.Encode.object
                        [ ( "human_name", Json.Encode.string rec0.human_name )
                        , ( "tfvc_project"
                          , Json.Encode.string rec0.tfvc_project
                          )
                        , ( "vcs", Json.Encode.string rec0.vcs )
                        ]
                )
                rec.project_choices
          )
        , ( "push_percent"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.int value
            )
                rec.push_percent
          )
        , ( "repository_url", Json.Encode.string rec.repository_url )
        , ( "status", Json.Encode.string rec.status )
        , ( "status_text"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.status_text
          )
        , ( "svc_root", Json.Encode.string rec.svc_root )
        , ( "svn_root", Json.Encode.string rec.svn_root )
        , ( "tfvc_project", Json.Encode.string rec.tfvc_project )
        , ( "url", Json.Encode.string rec.url )
        , ( "use_lfs", Json.Encode.bool rec.use_lfs )
        , ( "vcs"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.vcs
          )
        , ( "vcs_url", Json.Encode.string rec.vcs_url )
        ]


type alias Hovercard =
    { contexts : List { message : String, octicon : String } }


decodeHovercard : Json.Decode.Decoder Hovercard
decodeHovercard =
    Json.Decode.succeed (\contexts -> { contexts = contexts })
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "contexts"
                (Json.Decode.list
                    (Json.Decode.succeed
                      (\message octicon ->
                          { message = message, octicon = octicon }
                      )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "message" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "octicon" Json.Decode.string)
                    )
                )
            )


encodeHovercard : Hovercard -> Json.Encode.Value
encodeHovercard rec =
    Json.Encode.object
        [ ( "contexts"
          , Json.Encode.list
                (\rec0 ->
                    Json.Encode.object
                        [ ( "message", Json.Encode.string rec0.message )
                        , ( "octicon", Json.Encode.string rec0.octicon )
                        ]
                )
                rec.contexts
          )
        ]


type alias HookResponse =
    { code : Nullable Int, message : Nullable String, status : Nullable String }


decodeHookResponse : Json.Decode.Decoder HookResponse
decodeHookResponse =
    Json.Decode.succeed
     (\code message status ->
         { code = code, message = message, status = status }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "code"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.int
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "message"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "status"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )


encodeHookResponse : HookResponse -> Json.Encode.Value
encodeHookResponse rec =
    Json.Encode.object
        [ ( "code"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.int value
            )
                rec.code
          )
        , ( "message"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.message
          )
        , ( "status"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.status
          )
        ]


type alias HookDeliveryItem =
    { action : Nullable String
    , delivered_at : String
    , duration : Float
    , event : String
    , guid : String
    , id : Int
    , installation_id : Nullable Int
    , redelivery : Bool
    , repository_id : Nullable Int
    , status : String
    , status_code : Int
    }


decodeHookDeliveryItem : Json.Decode.Decoder HookDeliveryItem
decodeHookDeliveryItem =
    Json.Decode.succeed
     (\action delivered_at duration event guid id installation_id redelivery repository_id status status_code ->
         { action = action
         , delivered_at = delivered_at
         , duration = duration
         , event = event
         , guid = guid
         , id = id
         , installation_id = installation_id
         , redelivery = redelivery
         , repository_id = repository_id
         , status = status
         , status_code = status_code
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "action"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "delivered_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "duration" Json.Decode.float)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "event" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "guid" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "installation_id"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.int
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "redelivery" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "repository_id"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.int
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "status" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "status_code" Json.Decode.int)


encodeHookDeliveryItem : HookDeliveryItem -> Json.Encode.Value
encodeHookDeliveryItem rec =
    Json.Encode.object
        [ ( "action"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.action
          )
        , ( "delivered_at", Json.Encode.string rec.delivered_at )
        , ( "duration", Json.Encode.float rec.duration )
        , ( "event", Json.Encode.string rec.event )
        , ( "guid", Json.Encode.string rec.guid )
        , ( "id", Json.Encode.int rec.id )
        , ( "installation_id"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.int value
            )
                rec.installation_id
          )
        , ( "redelivery", Json.Encode.bool rec.redelivery )
        , ( "repository_id"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.int value
            )
                rec.repository_id
          )
        , ( "status", Json.Encode.string rec.status )
        , ( "status_code", Json.Encode.int rec.status_code )
        ]


type alias HookDelivery =
    { action : Nullable String
    , delivered_at : String
    , duration : Float
    , event : String
    , guid : String
    , id : Int
    , installation_id : Nullable Int
    , redelivery : Bool
    , repository_id : Nullable Int
    , request : { headers : Nullable {}, payload : Nullable {} }
    , response : { headers : Nullable {}, payload : Nullable String }
    , status : String
    , status_code : Int
    , url : String
    }


decodeHookDelivery : Json.Decode.Decoder HookDelivery
decodeHookDelivery =
    Json.Decode.succeed
     (\action delivered_at duration event guid id installation_id redelivery repository_id request response status status_code url ->
         { action = action
         , delivered_at = delivered_at
         , duration = duration
         , event = event
         , guid = guid
         , id = id
         , installation_id = installation_id
         , redelivery = redelivery
         , repository_id = repository_id
         , request = request
         , response = response
         , status = status
         , status_code = status_code
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "action"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "delivered_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "duration" Json.Decode.float)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "event" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "guid" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "installation_id"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.int
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "redelivery" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "repository_id"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.int
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "request"
                (Json.Decode.succeed
                  (\headers payload -> { headers = headers, payload = payload })
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "headers"
                            (Json.Decode.oneOf
                                [ Json.Decode.map
                                    Present
                                    (Json.Decode.succeed {})
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "payload"
                            (Json.Decode.oneOf
                                [ Json.Decode.map
                                    Present
                                    (Json.Decode.succeed {})
                                , Json.Decode.null Null
                                ]
                            )
                        )
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "response"
                (Json.Decode.succeed
                  (\headers payload -> { headers = headers, payload = payload })
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "headers"
                            (Json.Decode.oneOf
                                [ Json.Decode.map
                                    Present
                                    (Json.Decode.succeed {})
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "payload"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.string
                                , Json.Decode.null Null
                                ]
                            )
                        )
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "status" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "status_code" Json.Decode.int)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeHookDelivery : HookDelivery -> Json.Encode.Value
encodeHookDelivery rec =
    Json.Encode.object
        [ ( "action"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.action
          )
        , ( "delivered_at", Json.Encode.string rec.delivered_at )
        , ( "duration", Json.Encode.float rec.duration )
        , ( "event", Json.Encode.string rec.event )
        , ( "guid", Json.Encode.string rec.guid )
        , ( "id", Json.Encode.int rec.id )
        , ( "installation_id"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.int value
            )
                rec.installation_id
          )
        , ( "redelivery", Json.Encode.bool rec.redelivery )
        , ( "repository_id"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.int value
            )
                rec.repository_id
          )
        , ( "request"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "headers"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    (\rec_0_0_1_0_0_1_1_1_0_10_1_0_0 ->
                                        Json.Encode.object []
                                    )
                                        value
                        )
                            rec0.headers
                      )
                    , ( "payload"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    (\rec_0_0_1_0_0_2_1_1_0_10_1_0_0 ->
                                        Json.Encode.object []
                                    )
                                        value
                        )
                            rec0.payload
                      )
                    ]
            )
                rec.request
          )
        , ( "response"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "headers"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    (\rec_0_0_1_0_0_1_1_1_0_11_1_0_0 ->
                                        Json.Encode.object []
                                    )
                                        value
                        )
                            rec0.headers
                      )
                    , ( "payload"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.string value
                        )
                            rec0.payload
                      )
                    ]
            )
                rec.response
          )
        , ( "status", Json.Encode.string rec.status )
        , ( "status_code", Json.Encode.int rec.status_code )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias Hook =
    { active : Bool
    , config :
        { content_type : WebhookConfigContentType
        , digest : String
        , email : String
        , insecure_ssl : WebhookConfigInsecureSsl
        , password : String
        , room : String
        , secret : WebhookConfigSecret
        , subdomain : String
        , token : String
        , url : WebhookConfigUrl
        }
    , created_at : String
    , deliveries_url : String
    , events : List String
    , id : Int
    , last_response : HookResponse
    , name : String
    , ping_url : String
    , test_url : String
    , type_ : String
    , updated_at : String
    , url : String
    }


decodeHook : Json.Decode.Decoder Hook
decodeHook =
    Json.Decode.succeed
     (\active config created_at deliveries_url events id last_response name ping_url test_url type_ updated_at url ->
         { active = active
         , config = config
         , created_at = created_at
         , deliveries_url = deliveries_url
         , events = events
         , id = id
         , last_response = last_response
         , name = name
         , ping_url = ping_url
         , test_url = test_url
         , type_ = type_
         , updated_at = updated_at
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "active" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "config"
                (Json.Decode.succeed
                  (\content_type digest email insecure_ssl password room secret subdomain token url ->
                      { content_type = content_type
                      , digest = digest
                      , email = email
                      , insecure_ssl = insecure_ssl
                      , password = password
                      , room = room
                      , secret = secret
                      , subdomain = subdomain
                      , token = token
                      , url = url
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "content_type"
                            decodeWebhookConfigContentType
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "digest" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "email" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "insecure_ssl"
                            decodeWebhookConfigInsecureSsl
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "password" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "room" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "secret" decodeWebhookConfigSecret)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "subdomain" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "token" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "url" decodeWebhookConfigUrl)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "deliveries_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "events" (Json.Decode.list Json.Decode.string))
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "last_response" decodeHookResponse)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "ping_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "test_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "type" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeHook : Hook -> Json.Encode.Value
encodeHook rec =
    Json.Encode.object
        [ ( "active", Json.Encode.bool rec.active )
        , ( "config"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "content_type"
                      , encodeWebhookConfigContentType rec0.content_type
                      )
                    , ( "digest", Json.Encode.string rec0.digest )
                    , ( "email", Json.Encode.string rec0.email )
                    , ( "insecure_ssl"
                      , encodeWebhookConfigInsecureSsl rec0.insecure_ssl
                      )
                    , ( "password", Json.Encode.string rec0.password )
                    , ( "room", Json.Encode.string rec0.room )
                    , ( "secret", encodeWebhookConfigSecret rec0.secret )
                    , ( "subdomain", Json.Encode.string rec0.subdomain )
                    , ( "token", Json.Encode.string rec0.token )
                    , ( "url", encodeWebhookConfigUrl rec0.url )
                    ]
            )
                rec.config
          )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "deliveries_url", Json.Encode.string rec.deliveries_url )
        , ( "events", Json.Encode.list Json.Encode.string rec.events )
        , ( "id", Json.Encode.int rec.id )
        , ( "last_response", encodeHookResponse rec.last_response )
        , ( "name", Json.Encode.string rec.name )
        , ( "ping_url", Json.Encode.string rec.ping_url )
        , ( "test_url", Json.Encode.string rec.test_url )
        , ( "type", Json.Encode.string rec.type_ )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias GpgKey =
    { can_certify : Bool
    , can_encrypt_comms : Bool
    , can_encrypt_storage : Bool
    , can_sign : Bool
    , created_at : String
    , emails : List { email : String, verified : Bool }
    , expires_at : Nullable String
    , id : Int
    , key_id : String
    , name : Nullable String
    , primary_key_id : Nullable Int
    , public_key : String
    , raw_key : Nullable String
    , revoked : Bool
    , subkeys :
        List { can_certify : Bool
        , can_encrypt_comms : Bool
        , can_encrypt_storage : Bool
        , can_sign : Bool
        , created_at : String
        , emails : List Json.Encode.Value
        , expires_at : Nullable String
        , id : Int
        , key_id : String
        , primary_key_id : Int
        , public_key : String
        , raw_key : Nullable String
        , revoked : Bool
        , subkeys : List Json.Encode.Value
        }
    }


decodeGpgKey : Json.Decode.Decoder GpgKey
decodeGpgKey =
    Json.Decode.succeed
     (\can_certify can_encrypt_comms can_encrypt_storage can_sign created_at emails expires_at id key_id name primary_key_id public_key raw_key revoked subkeys ->
         { can_certify = can_certify
         , can_encrypt_comms = can_encrypt_comms
         , can_encrypt_storage = can_encrypt_storage
         , can_sign = can_sign
         , created_at = created_at
         , emails = emails
         , expires_at = expires_at
         , id = id
         , key_id = key_id
         , name = name
         , primary_key_id = primary_key_id
         , public_key = public_key
         , raw_key = raw_key
         , revoked = revoked
         , subkeys = subkeys
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "can_certify" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "can_encrypt_comms" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "can_encrypt_storage" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "can_sign" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "emails"
                (Json.Decode.list
                    (Json.Decode.succeed
                      (\email verified -> { email = email, verified = verified }
                      )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "email" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "verified" Json.Decode.bool)
                    )
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "expires_at"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "key_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "name"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "primary_key_id"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.int
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "public_key" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "raw_key"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "revoked" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "subkeys"
                (Json.Decode.list
                    (Json.Decode.succeed
                      (\can_certify can_encrypt_comms can_encrypt_storage can_sign created_at emails expires_at id key_id primary_key_id public_key raw_key revoked subkeys ->
                          { can_certify = can_certify
                          , can_encrypt_comms = can_encrypt_comms
                          , can_encrypt_storage = can_encrypt_storage
                          , can_sign = can_sign
                          , created_at = created_at
                          , emails = emails
                          , expires_at = expires_at
                          , id = id
                          , key_id = key_id
                          , primary_key_id = primary_key_id
                          , public_key = public_key
                          , raw_key = raw_key
                          , revoked = revoked
                          , subkeys = subkeys
                          }
                      )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "can_certify" Json.Decode.bool)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field
                                "can_encrypt_comms"
                                Json.Decode.bool
                            )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field
                                "can_encrypt_storage"
                                Json.Decode.bool
                            )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "can_sign" Json.Decode.bool)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "created_at" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field
                                "emails"
                                (Json.Decode.list Json.Decode.value)
                            )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field
                                "expires_at"
                                (Json.Decode.oneOf
                                    [ Json.Decode.map Present Json.Decode.string
                                    , Json.Decode.null Null
                                    ]
                                )
                            )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "id" Json.Decode.int)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "key_id" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "primary_key_id" Json.Decode.int)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "public_key" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field
                                "raw_key"
                                (Json.Decode.oneOf
                                    [ Json.Decode.map Present Json.Decode.string
                                    , Json.Decode.null Null
                                    ]
                                )
                            )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "revoked" Json.Decode.bool)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field
                                "subkeys"
                                (Json.Decode.list Json.Decode.value)
                            )
                    )
                )
            )


encodeGpgKey : GpgKey -> Json.Encode.Value
encodeGpgKey rec =
    Json.Encode.object
        [ ( "can_certify", Json.Encode.bool rec.can_certify )
        , ( "can_encrypt_comms", Json.Encode.bool rec.can_encrypt_comms )
        , ( "can_encrypt_storage", Json.Encode.bool rec.can_encrypt_storage )
        , ( "can_sign", Json.Encode.bool rec.can_sign )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "emails"
          , Json.Encode.list
                (\rec0 ->
                    Json.Encode.object
                        [ ( "email", Json.Encode.string rec0.email )
                        , ( "verified", Json.Encode.bool rec0.verified )
                        ]
                )
                rec.emails
          )
        , ( "expires_at"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.expires_at
          )
        , ( "id", Json.Encode.int rec.id )
        , ( "key_id", Json.Encode.string rec.key_id )
        , ( "name"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.name
          )
        , ( "primary_key_id"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.int value
            )
                rec.primary_key_id
          )
        , ( "public_key", Json.Encode.string rec.public_key )
        , ( "raw_key"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.raw_key
          )
        , ( "revoked", Json.Encode.bool rec.revoked )
        , ( "subkeys"
          , Json.Encode.list
                (\rec0 ->
                    Json.Encode.object
                        [ ( "can_certify", Json.Encode.bool rec0.can_certify )
                        , ( "can_encrypt_comms"
                          , Json.Encode.bool rec0.can_encrypt_comms
                          )
                        , ( "can_encrypt_storage"
                          , Json.Encode.bool rec0.can_encrypt_storage
                          )
                        , ( "can_sign", Json.Encode.bool rec0.can_sign )
                        , ( "created_at", Json.Encode.string rec0.created_at )
                        , ( "emails"
                          , Json.Encode.list Basics.identity rec0.emails
                          )
                        , ( "expires_at"
                          , (\nullableValue ->
                                case nullableValue of
                                    Null ->
                                        Json.Encode.null

                                    Present value ->
                                        Json.Encode.string value
                            )
                                rec0.expires_at
                          )
                        , ( "id", Json.Encode.int rec0.id )
                        , ( "key_id", Json.Encode.string rec0.key_id )
                        , ( "primary_key_id"
                          , Json.Encode.int rec0.primary_key_id
                          )
                        , ( "public_key", Json.Encode.string rec0.public_key )
                        , ( "raw_key"
                          , (\nullableValue ->
                                case nullableValue of
                                    Null ->
                                        Json.Encode.null

                                    Present value ->
                                        Json.Encode.string value
                            )
                                rec0.raw_key
                          )
                        , ( "revoked", Json.Encode.bool rec0.revoked )
                        , ( "subkeys"
                          , Json.Encode.list Basics.identity rec0.subkeys
                          )
                        ]
                )
                rec.subkeys
          )
        ]


type alias GitignoreTemplate =
    { name : String, source : String }


decodeGitignoreTemplate : Json.Decode.Decoder GitignoreTemplate
decodeGitignoreTemplate =
    Json.Decode.succeed (\name source -> { name = name, source = source })
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "source" Json.Decode.string)


encodeGitignoreTemplate : GitignoreTemplate -> Json.Encode.Value
encodeGitignoreTemplate rec =
    Json.Encode.object
        [ ( "name", Json.Encode.string rec.name )
        , ( "source", Json.Encode.string rec.source )
        ]


type alias GitUser =
    { date : String, email : String, name : String }


decodeGitUser : Json.Decode.Decoder GitUser
decodeGitUser =
    Json.Decode.succeed
     (\date email name -> { date = date, email = email, name = name })
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "date" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "email" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)


encodeGitUser : GitUser -> Json.Encode.Value
encodeGitUser rec =
    Json.Encode.object
        [ ( "date", Json.Encode.string rec.date )
        , ( "email", Json.Encode.string rec.email )
        , ( "name", Json.Encode.string rec.name )
        ]


type alias GitTree =
    { sha : String
    , tree :
        List { mode : String
        , path : String
        , sha : String
        , size : Int
        , type_ : String
        , url : String
        }
    , truncated : Bool
    , url : String
    }


decodeGitTree : Json.Decode.Decoder GitTree
decodeGitTree =
    Json.Decode.succeed
     (\sha tree truncated url ->
         { sha = sha, tree = tree, truncated = truncated, url = url }
     )
        |> Json.Decode.Extra.andMap (Json.Decode.field "sha" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "tree"
                (Json.Decode.list
                    (Json.Decode.succeed
                      (\mode path sha size type_ url ->
                          { mode = mode
                          , path = path
                          , sha = sha
                          , size = size
                          , type_ = type_
                          , url = url
                          }
                      )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "mode" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "path" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "sha" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "size" Json.Decode.int)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "type" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "url" Json.Decode.string)
                    )
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "truncated" Json.Decode.bool)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeGitTree : GitTree -> Json.Encode.Value
encodeGitTree rec =
    Json.Encode.object
        [ ( "sha", Json.Encode.string rec.sha )
        , ( "tree"
          , Json.Encode.list
                (\rec0 ->
                    Json.Encode.object
                        [ ( "mode", Json.Encode.string rec0.mode )
                        , ( "path", Json.Encode.string rec0.path )
                        , ( "sha", Json.Encode.string rec0.sha )
                        , ( "size", Json.Encode.int rec0.size )
                        , ( "type", Json.Encode.string rec0.type_ )
                        , ( "url", Json.Encode.string rec0.url )
                        ]
                )
                rec.tree
          )
        , ( "truncated", Json.Encode.bool rec.truncated )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias GitTag =
    { message : String
    , node_id : String
    , object : { sha : String, type_ : String, url : String }
    , sha : String
    , tag : String
    , tagger : { date : String, email : String, name : String }
    , url : String
    , verification : Verification
    }


decodeGitTag : Json.Decode.Decoder GitTag
decodeGitTag =
    Json.Decode.succeed
     (\message node_id object sha tag tagger url verification ->
         { message = message
         , node_id = node_id
         , object = object
         , sha = sha
         , tag = tag
         , tagger = tagger
         , url = url
         , verification = verification
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "message" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "object"
                (Json.Decode.succeed
                  (\sha type_ url -> { sha = sha, type_ = type_, url = url })
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "sha" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "type" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "url" Json.Decode.string)
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "sha" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "tag" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "tagger"
                (Json.Decode.succeed
                  (\date email name ->
                      { date = date, email = email, name = name }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "date" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "email" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "name" Json.Decode.string)
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "verification" decodeVerification)


encodeGitTag : GitTag -> Json.Encode.Value
encodeGitTag rec =
    Json.Encode.object
        [ ( "message", Json.Encode.string rec.message )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "object"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "sha", Json.Encode.string rec0.sha )
                    , ( "type", Json.Encode.string rec0.type_ )
                    , ( "url", Json.Encode.string rec0.url )
                    ]
            )
                rec.object
          )
        , ( "sha", Json.Encode.string rec.sha )
        , ( "tag", Json.Encode.string rec.tag )
        , ( "tagger"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "date", Json.Encode.string rec0.date )
                    , ( "email", Json.Encode.string rec0.email )
                    , ( "name", Json.Encode.string rec0.name )
                    ]
            )
                rec.tagger
          )
        , ( "url", Json.Encode.string rec.url )
        , ( "verification", encodeVerification rec.verification )
        ]


type alias GitRef =
    { node_id : String
    , object : { sha : String, type_ : String, url : String }
    , ref : String
    , url : String
    }


decodeGitRef : Json.Decode.Decoder GitRef
decodeGitRef =
    Json.Decode.succeed
     (\node_id object ref url ->
         { node_id = node_id, object = object, ref = ref, url = url }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "object"
                (Json.Decode.succeed
                  (\sha type_ url -> { sha = sha, type_ = type_, url = url })
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "sha" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "type" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "url" Json.Decode.string)
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "ref" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeGitRef : GitRef -> Json.Encode.Value
encodeGitRef rec =
    Json.Encode.object
        [ ( "node_id", Json.Encode.string rec.node_id )
        , ( "object"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "sha", Json.Encode.string rec0.sha )
                    , ( "type", Json.Encode.string rec0.type_ )
                    , ( "url", Json.Encode.string rec0.url )
                    ]
            )
                rec.object
          )
        , ( "ref", Json.Encode.string rec.ref )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias GitCommit =
    { author : { date : String, email : String, name : String }
    , committer : { date : String, email : String, name : String }
    , html_url : String
    , message : String
    , node_id : String
    , parents : List { html_url : String, sha : String, url : String }
    , sha : String
    , tree : { sha : String, url : String }
    , url : String
    , verification :
        { payload : Nullable String
        , reason : String
        , signature : Nullable String
        , verified : Bool
        }
    }


decodeGitCommit : Json.Decode.Decoder GitCommit
decodeGitCommit =
    Json.Decode.succeed
     (\author committer html_url message node_id parents sha tree url verification ->
         { author = author
         , committer = committer
         , html_url = html_url
         , message = message
         , node_id = node_id
         , parents = parents
         , sha = sha
         , tree = tree
         , url = url
         , verification = verification
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "author"
                (Json.Decode.succeed
                  (\date email name ->
                      { date = date, email = email, name = name }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "date" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "email" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "name" Json.Decode.string)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "committer"
                (Json.Decode.succeed
                  (\date email name ->
                      { date = date, email = email, name = name }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "date" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "email" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "name" Json.Decode.string)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "message" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "parents"
                (Json.Decode.list
                    (Json.Decode.succeed
                      (\html_url sha url ->
                          { html_url = html_url, sha = sha, url = url }
                      )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "html_url" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "sha" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "url" Json.Decode.string)
                    )
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "sha" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "tree"
                (Json.Decode.succeed (\sha url -> { sha = sha, url = url })
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "sha" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "url" Json.Decode.string)
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "verification"
                (Json.Decode.succeed
                  (\payload reason signature verified ->
                      { payload = payload
                      , reason = reason
                      , signature = signature
                      , verified = verified
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "payload"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.string
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "reason" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "signature"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.string
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "verified" Json.Decode.bool)
                )
            )


encodeGitCommit : GitCommit -> Json.Encode.Value
encodeGitCommit rec =
    Json.Encode.object
        [ ( "author"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "date", Json.Encode.string rec0.date )
                    , ( "email", Json.Encode.string rec0.email )
                    , ( "name", Json.Encode.string rec0.name )
                    ]
            )
                rec.author
          )
        , ( "committer"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "date", Json.Encode.string rec0.date )
                    , ( "email", Json.Encode.string rec0.email )
                    , ( "name", Json.Encode.string rec0.name )
                    ]
            )
                rec.committer
          )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "message", Json.Encode.string rec.message )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "parents"
          , Json.Encode.list
                (\rec0 ->
                    Json.Encode.object
                        [ ( "html_url", Json.Encode.string rec0.html_url )
                        , ( "sha", Json.Encode.string rec0.sha )
                        , ( "url", Json.Encode.string rec0.url )
                        ]
                )
                rec.parents
          )
        , ( "sha", Json.Encode.string rec.sha )
        , ( "tree"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "sha", Json.Encode.string rec0.sha )
                    , ( "url", Json.Encode.string rec0.url )
                    ]
            )
                rec.tree
          )
        , ( "url", Json.Encode.string rec.url )
        , ( "verification"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "payload"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.string value
                        )
                            rec0.payload
                      )
                    , ( "reason", Json.Encode.string rec0.reason )
                    , ( "signature"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.string value
                        )
                            rec0.signature
                      )
                    , ( "verified", Json.Encode.bool rec0.verified )
                    ]
            )
                rec.verification
          )
        ]


type alias GistSimple =
    { comments : Int
    , comments_url : String
    , commits_url : String
    , created_at : String
    , description : Nullable String
    , files : {}
    , fork_of :
        Nullable { comments : Int
        , comments_url : String
        , commits_url : String
        , created_at : String
        , description : Nullable String
        , files : {}
        , forks : List Json.Encode.Value
        , forks_url : String
        , git_pull_url : String
        , git_push_url : String
        , history : List Json.Encode.Value
        , html_url : String
        , id : String
        , node_id : String
        , owner : Nullable SimpleUser
        , public : Bool
        , truncated : Bool
        , updated_at : String
        , url : String
        , user : Nullable SimpleUser
        }
    , forks :
        Nullable (List { created_at : String
        , id : String
        , updated_at : String
        , url : String
        , user : PublicUser
        })
    , forks_url : String
    , git_pull_url : String
    , git_push_url : String
    , history : Nullable (List GistHistory)
    , html_url : String
    , id : String
    , node_id : String
    , owner : SimpleUser
    , public : Bool
    , truncated : Bool
    , updated_at : String
    , url : String
    , user : Nullable String
    }


decodeGistSimple : Json.Decode.Decoder GistSimple
decodeGistSimple =
    Json.Decode.succeed
     (\comments comments_url commits_url created_at description files fork_of forks forks_url git_pull_url git_push_url history html_url id node_id owner public truncated updated_at url user ->
         { comments = comments
         , comments_url = comments_url
         , commits_url = commits_url
         , created_at = created_at
         , description = description
         , files = files
         , fork_of = fork_of
         , forks = forks
         , forks_url = forks_url
         , git_pull_url = git_pull_url
         , git_push_url = git_push_url
         , history = history
         , html_url = html_url
         , id = id
         , node_id = node_id
         , owner = owner
         , public = public
         , truncated = truncated
         , updated_at = updated_at
         , url = url
         , user = user
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "comments" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "comments_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "commits_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "description"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "files" (Json.Decode.succeed {}))
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "fork_of"
                (Json.Decode.oneOf
                    [ Json.Decode.map
                        Present
                        (Json.Decode.succeed
                          (\comments comments_url commits_url created_at description files forks forks_url git_pull_url git_push_url history html_url id node_id owner public truncated updated_at url user ->
                              { comments = comments
                              , comments_url = comments_url
                              , commits_url = commits_url
                              , created_at = created_at
                              , description = description
                              , files = files
                              , forks = forks
                              , forks_url = forks_url
                              , git_pull_url = git_pull_url
                              , git_push_url = git_push_url
                              , history = history
                              , html_url = html_url
                              , id = id
                              , node_id = node_id
                              , owner = owner
                              , public = public
                              , truncated = truncated
                              , updated_at = updated_at
                              , url = url
                              , user = user
                              }
                          )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "comments" Json.Decode.int)
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "comments_url"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "commits_url"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "created_at"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "description"
                                    (Json.Decode.oneOf
                                        [ Json.Decode.map
                                            Present
                                            Json.Decode.string
                                        , Json.Decode.null Null
                                        ]
                                    )
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "files"
                                    (Json.Decode.succeed {})
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "forks"
                                    (Json.Decode.list Json.Decode.value)
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "forks_url"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "git_pull_url"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "git_push_url"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "history"
                                    (Json.Decode.list Json.Decode.value)
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "html_url" Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "id" Json.Decode.string)
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "node_id" Json.Decode.string)
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "owner"
                                    (Json.Decode.oneOf
                                        [ Json.Decode.map
                                            Present
                                            decodeSimpleUser
                                        , Json.Decode.null Null
                                        ]
                                    )
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "public" Json.Decode.bool)
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "truncated" Json.Decode.bool)
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "updated_at"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "url" Json.Decode.string)
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "user"
                                    (Json.Decode.oneOf
                                        [ Json.Decode.map
                                            Present
                                            decodeSimpleUser
                                        , Json.Decode.null Null
                                        ]
                                    )
                                )
                        )
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "forks"
                (Json.Decode.oneOf
                    [ Json.Decode.map
                        Present
                        (Json.Decode.list
                            (Json.Decode.succeed
                              (\created_at id updated_at url user ->
                                  { created_at = created_at
                                  , id = id
                                  , updated_at = updated_at
                                  , url = url
                                  , user = user
                                  }
                              )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "created_at"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field "id" Json.Decode.string)
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "updated_at"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field "url" Json.Decode.string)
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field "user" decodePublicUser)
                            )
                        )
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "forks_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "git_pull_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "git_push_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "history"
                (Json.Decode.oneOf
                    [ Json.Decode.map
                        Present
                        (Json.Decode.list decodeGistHistory)
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "owner" decodeSimpleUser)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "public" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "truncated" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "user"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )


encodeGistSimple : GistSimple -> Json.Encode.Value
encodeGistSimple rec =
    Json.Encode.object
        [ ( "comments", Json.Encode.int rec.comments )
        , ( "comments_url", Json.Encode.string rec.comments_url )
        , ( "commits_url", Json.Encode.string rec.commits_url )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "description"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.description
          )
        , ( "files", (\rec0 -> Json.Encode.object []) rec.files )
        , ( "fork_of"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        (\rec0 ->
                            Json.Encode.object
                                [ ( "comments", Json.Encode.int rec0.comments )
                                , ( "comments_url"
                                  , Json.Encode.string rec0.comments_url
                                  )
                                , ( "commits_url"
                                  , Json.Encode.string rec0.commits_url
                                  )
                                , ( "created_at"
                                  , Json.Encode.string rec0.created_at
                                  )
                                , ( "description"
                                  , (\nullableValue0 ->
                                        case nullableValue0 of
                                            Null ->
                                                Json.Encode.null

                                            Present value0 ->
                                                Json.Encode.string value0
                                    )
                                        rec0.description
                                  )
                                , ( "files"
                                  , (\rec_0_6_1_1_0_0_1_0_0_7_1_0_0 ->
                                        Json.Encode.object []
                                    )
                                        rec0.files
                                  )
                                , ( "forks"
                                  , Json.Encode.list Basics.identity rec0.forks
                                  )
                                , ( "forks_url"
                                  , Json.Encode.string rec0.forks_url
                                  )
                                , ( "git_pull_url"
                                  , Json.Encode.string rec0.git_pull_url
                                  )
                                , ( "git_push_url"
                                  , Json.Encode.string rec0.git_push_url
                                  )
                                , ( "history"
                                  , Json.Encode.list Basics.identity
                                        rec0.history
                                  )
                                , ( "html_url"
                                  , Json.Encode.string rec0.html_url
                                  )
                                , ( "id", Json.Encode.string rec0.id )
                                , ( "node_id", Json.Encode.string rec0.node_id )
                                , ( "owner"
                                  , (\nullableValue0 ->
                                        case nullableValue0 of
                                            Null ->
                                                Json.Encode.null

                                            Present value0 ->
                                                encodeSimpleUser value0
                                    )
                                        rec0.owner
                                  )
                                , ( "public", Json.Encode.bool rec0.public )
                                , ( "truncated"
                                  , Json.Encode.bool rec0.truncated
                                  )
                                , ( "updated_at"
                                  , Json.Encode.string rec0.updated_at
                                  )
                                , ( "url", Json.Encode.string rec0.url )
                                , ( "user"
                                  , (\nullableValue0 ->
                                        case nullableValue0 of
                                            Null ->
                                                Json.Encode.null

                                            Present value0 ->
                                                encodeSimpleUser value0
                                    )
                                        rec0.user
                                  )
                                ]
                        )
                            value
            )
                rec.fork_of
          )
        , ( "forks"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.list
                            (\rec0 ->
                                Json.Encode.object
                                    [ ( "created_at"
                                      , Json.Encode.string rec0.created_at
                                      )
                                    , ( "id", Json.Encode.string rec0.id )
                                    , ( "updated_at"
                                      , Json.Encode.string rec0.updated_at
                                      )
                                    , ( "url", Json.Encode.string rec0.url )
                                    , ( "user", encodePublicUser rec0.user )
                                    ]
                            )
                            value
            )
                rec.forks
          )
        , ( "forks_url", Json.Encode.string rec.forks_url )
        , ( "git_pull_url", Json.Encode.string rec.git_pull_url )
        , ( "git_push_url", Json.Encode.string rec.git_push_url )
        , ( "history"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.list encodeGistHistory value
            )
                rec.history
          )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "id", Json.Encode.string rec.id )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "owner", encodeSimpleUser rec.owner )
        , ( "public", Json.Encode.bool rec.public )
        , ( "truncated", Json.Encode.bool rec.truncated )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        , ( "url", Json.Encode.string rec.url )
        , ( "user"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.user
          )
        ]


type alias GistHistory =
    { change_status : { additions : Int, deletions : Int, total : Int }
    , committed_at : String
    , url : String
    , user : Nullable SimpleUser
    , version : String
    }


decodeGistHistory : Json.Decode.Decoder GistHistory
decodeGistHistory =
    Json.Decode.succeed
     (\change_status committed_at url user version ->
         { change_status = change_status
         , committed_at = committed_at
         , url = url
         , user = user
         , version = version
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "change_status"
                (Json.Decode.succeed
                  (\additions deletions total ->
                      { additions = additions
                      , deletions = deletions
                      , total = total
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "additions" Json.Decode.int)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "deletions" Json.Decode.int)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total" Json.Decode.int)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "committed_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "user"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "version" Json.Decode.string)


encodeGistHistory : GistHistory -> Json.Encode.Value
encodeGistHistory rec =
    Json.Encode.object
        [ ( "change_status"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "additions", Json.Encode.int rec0.additions )
                    , ( "deletions", Json.Encode.int rec0.deletions )
                    , ( "total", Json.Encode.int rec0.total )
                    ]
            )
                rec.change_status
          )
        , ( "committed_at", Json.Encode.string rec.committed_at )
        , ( "url", Json.Encode.string rec.url )
        , ( "user"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.user
          )
        , ( "version", Json.Encode.string rec.version )
        ]


type alias GistCommit =
    { change_status : { additions : Int, deletions : Int, total : Int }
    , committed_at : String
    , url : String
    , user : Nullable SimpleUser
    , version : String
    }


decodeGistCommit : Json.Decode.Decoder GistCommit
decodeGistCommit =
    Json.Decode.succeed
     (\change_status committed_at url user version ->
         { change_status = change_status
         , committed_at = committed_at
         , url = url
         , user = user
         , version = version
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "change_status"
                (Json.Decode.succeed
                  (\additions deletions total ->
                      { additions = additions
                      , deletions = deletions
                      , total = total
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "additions" Json.Decode.int)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "deletions" Json.Decode.int)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total" Json.Decode.int)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "committed_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "user"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "version" Json.Decode.string)


encodeGistCommit : GistCommit -> Json.Encode.Value
encodeGistCommit rec =
    Json.Encode.object
        [ ( "change_status"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "additions", Json.Encode.int rec0.additions )
                    , ( "deletions", Json.Encode.int rec0.deletions )
                    , ( "total", Json.Encode.int rec0.total )
                    ]
            )
                rec.change_status
          )
        , ( "committed_at", Json.Encode.string rec.committed_at )
        , ( "url", Json.Encode.string rec.url )
        , ( "user"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.user
          )
        , ( "version", Json.Encode.string rec.version )
        ]


type alias GistComment =
    { author_association : AuthorAssociation
    , body : String
    , created_at : String
    , id : Int
    , node_id : String
    , updated_at : String
    , url : String
    , user : Nullable SimpleUser
    }


decodeGistComment : Json.Decode.Decoder GistComment
decodeGistComment =
    Json.Decode.succeed
     (\author_association body created_at id node_id updated_at url user ->
         { author_association = author_association
         , body = body
         , created_at = created_at
         , id = id
         , node_id = node_id
         , updated_at = updated_at
         , url = url
         , user = user
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "author_association" decodeAuthorAssociation)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "body" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "user"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )


encodeGistComment : GistComment -> Json.Encode.Value
encodeGistComment rec =
    Json.Encode.object
        [ ( "author_association"
          , encodeAuthorAssociation rec.author_association
          )
        , ( "body", Json.Encode.string rec.body )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "id", Json.Encode.int rec.id )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        , ( "url", Json.Encode.string rec.url )
        , ( "user"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.user
          )
        ]


type alias FullRepository =
    { allow_auto_merge : Bool
    , allow_forking : Bool
    , allow_merge_commit : Bool
    , allow_rebase_merge : Bool
    , allow_squash_merge : Bool
    , allow_update_branch : Bool
    , anonymous_access_enabled : Bool
    , archive_url : String
    , archived : Bool
    , assignees_url : String
    , blobs_url : String
    , branches_url : String
    , clone_url : String
    , code_of_conduct : CodeOfConductSimple
    , collaborators_url : String
    , comments_url : String
    , commits_url : String
    , compare_url : String
    , contents_url : String
    , contributors_url : String
    , created_at : String
    , default_branch : String
    , delete_branch_on_merge : Bool
    , deployments_url : String
    , description : Nullable String
    , disabled : Bool
    , downloads_url : String
    , events_url : String
    , fork : Bool
    , forks : Int
    , forks_count : Int
    , forks_url : String
    , full_name : String
    , git_commits_url : String
    , git_refs_url : String
    , git_tags_url : String
    , git_url : String
    , has_downloads : Bool
    , has_issues : Bool
    , has_pages : Bool
    , has_projects : Bool
    , has_wiki : Bool
    , homepage : Nullable String
    , hooks_url : String
    , html_url : String
    , id : Int
    , is_template : Bool
    , issue_comment_url : String
    , issue_events_url : String
    , issues_url : String
    , keys_url : String
    , labels_url : String
    , language : Nullable String
    , languages_url : String
    , license : Nullable LicenseSimple
    , master_branch : String
    , merge_commit_message : String
    , merge_commit_title : String
    , merges_url : String
    , milestones_url : String
    , mirror_url : Nullable String
    , name : String
    , network_count : Int
    , node_id : String
    , notifications_url : String
    , open_issues : Int
    , open_issues_count : Int
    , organization : Nullable SimpleUser
    , owner : SimpleUser
    , parent : Repository
    , permissions :
        { admin : Bool
        , maintain : Bool
        , pull : Bool
        , push : Bool
        , triage : Bool
        }
    , private : Bool
    , pulls_url : String
    , pushed_at : String
    , releases_url : String
    , security_and_analysis : SecurityAndAnalysis
    , size : Int
    , source : Repository
    , squash_merge_commit_message : String
    , squash_merge_commit_title : String
    , ssh_url : String
    , stargazers_count : Int
    , stargazers_url : String
    , statuses_url : String
    , subscribers_count : Int
    , subscribers_url : String
    , subscription_url : String
    , svn_url : String
    , tags_url : String
    , teams_url : String
    , temp_clone_token : Nullable String
    , template_repository : Nullable Repository
    , topics : List String
    , trees_url : String
    , updated_at : String
    , url : String
    , use_squash_pr_title_as_default : Bool
    , visibility : String
    , watchers : Int
    , watchers_count : Int
    , web_commit_signoff_required : Bool
    }


decodeFullRepository : Json.Decode.Decoder FullRepository
decodeFullRepository =
    Json.Decode.succeed
     (\allow_auto_merge allow_forking allow_merge_commit allow_rebase_merge allow_squash_merge allow_update_branch anonymous_access_enabled archive_url archived assignees_url blobs_url branches_url clone_url code_of_conduct collaborators_url comments_url commits_url compare_url contents_url contributors_url created_at default_branch delete_branch_on_merge deployments_url description disabled downloads_url events_url fork forks forks_count forks_url full_name git_commits_url git_refs_url git_tags_url git_url has_downloads has_issues has_pages has_projects has_wiki homepage hooks_url html_url id is_template issue_comment_url issue_events_url issues_url keys_url labels_url language languages_url license master_branch merge_commit_message merge_commit_title merges_url milestones_url mirror_url name network_count node_id notifications_url open_issues open_issues_count organization owner parent permissions private pulls_url pushed_at releases_url security_and_analysis size source squash_merge_commit_message squash_merge_commit_title ssh_url stargazers_count stargazers_url statuses_url subscribers_count subscribers_url subscription_url svn_url tags_url teams_url temp_clone_token template_repository topics trees_url updated_at url use_squash_pr_title_as_default visibility watchers watchers_count web_commit_signoff_required ->
         { allow_auto_merge = allow_auto_merge
         , allow_forking = allow_forking
         , allow_merge_commit = allow_merge_commit
         , allow_rebase_merge = allow_rebase_merge
         , allow_squash_merge = allow_squash_merge
         , allow_update_branch = allow_update_branch
         , anonymous_access_enabled = anonymous_access_enabled
         , archive_url = archive_url
         , archived = archived
         , assignees_url = assignees_url
         , blobs_url = blobs_url
         , branches_url = branches_url
         , clone_url = clone_url
         , code_of_conduct = code_of_conduct
         , collaborators_url = collaborators_url
         , comments_url = comments_url
         , commits_url = commits_url
         , compare_url = compare_url
         , contents_url = contents_url
         , contributors_url = contributors_url
         , created_at = created_at
         , default_branch = default_branch
         , delete_branch_on_merge = delete_branch_on_merge
         , deployments_url = deployments_url
         , description = description
         , disabled = disabled
         , downloads_url = downloads_url
         , events_url = events_url
         , fork = fork
         , forks = forks
         , forks_count = forks_count
         , forks_url = forks_url
         , full_name = full_name
         , git_commits_url = git_commits_url
         , git_refs_url = git_refs_url
         , git_tags_url = git_tags_url
         , git_url = git_url
         , has_downloads = has_downloads
         , has_issues = has_issues
         , has_pages = has_pages
         , has_projects = has_projects
         , has_wiki = has_wiki
         , homepage = homepage
         , hooks_url = hooks_url
         , html_url = html_url
         , id = id
         , is_template = is_template
         , issue_comment_url = issue_comment_url
         , issue_events_url = issue_events_url
         , issues_url = issues_url
         , keys_url = keys_url
         , labels_url = labels_url
         , language = language
         , languages_url = languages_url
         , license = license
         , master_branch = master_branch
         , merge_commit_message = merge_commit_message
         , merge_commit_title = merge_commit_title
         , merges_url = merges_url
         , milestones_url = milestones_url
         , mirror_url = mirror_url
         , name = name
         , network_count = network_count
         , node_id = node_id
         , notifications_url = notifications_url
         , open_issues = open_issues
         , open_issues_count = open_issues_count
         , organization = organization
         , owner = owner
         , parent = parent
         , permissions = permissions
         , private = private
         , pulls_url = pulls_url
         , pushed_at = pushed_at
         , releases_url = releases_url
         , security_and_analysis = security_and_analysis
         , size = size
         , source = source
         , squash_merge_commit_message = squash_merge_commit_message
         , squash_merge_commit_title = squash_merge_commit_title
         , ssh_url = ssh_url
         , stargazers_count = stargazers_count
         , stargazers_url = stargazers_url
         , statuses_url = statuses_url
         , subscribers_count = subscribers_count
         , subscribers_url = subscribers_url
         , subscription_url = subscription_url
         , svn_url = svn_url
         , tags_url = tags_url
         , teams_url = teams_url
         , temp_clone_token = temp_clone_token
         , template_repository = template_repository
         , topics = topics
         , trees_url = trees_url
         , updated_at = updated_at
         , url = url
         , use_squash_pr_title_as_default = use_squash_pr_title_as_default
         , visibility = visibility
         , watchers = watchers
         , watchers_count = watchers_count
         , web_commit_signoff_required = web_commit_signoff_required
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "allow_auto_merge" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "allow_forking" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "allow_merge_commit" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "allow_rebase_merge" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "allow_squash_merge" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "allow_update_branch" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "anonymous_access_enabled" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "archive_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "archived" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "assignees_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "blobs_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "branches_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "clone_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "code_of_conduct" decodeCodeOfConductSimple)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "collaborators_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "comments_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "commits_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "compare_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "contents_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "contributors_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "default_branch" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "delete_branch_on_merge" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "deployments_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "description"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "disabled" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "downloads_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "events_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "fork" Json.Decode.bool)
        |> Json.Decode.Extra.andMap (Json.Decode.field "forks" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "forks_count" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "forks_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "full_name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "git_commits_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "git_refs_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "git_tags_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "git_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "has_downloads" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "has_issues" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "has_pages" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "has_projects" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "has_wiki" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "homepage"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "hooks_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "is_template" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "issue_comment_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "issue_events_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "issues_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "keys_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "labels_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "language"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "languages_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "license"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeLicenseSimple
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "master_branch" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "merge_commit_message" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "merge_commit_title" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "merges_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "milestones_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "mirror_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "network_count" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "notifications_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "open_issues" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "open_issues_count" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "organization"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "owner" decodeSimpleUser)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "parent" decodeRepository)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "permissions"
                (Json.Decode.succeed
                  (\admin maintain pull push triage ->
                      { admin = admin
                      , maintain = maintain
                      , pull = pull
                      , push = push
                      , triage = triage
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "admin" Json.Decode.bool)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "maintain" Json.Decode.bool)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "pull" Json.Decode.bool)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "push" Json.Decode.bool)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "triage" Json.Decode.bool)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "private" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "pulls_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "pushed_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "releases_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "security_and_analysis" decodeSecurityAndAnalysis
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "size" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "source" decodeRepository)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "squash_merge_commit_message" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "squash_merge_commit_title" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "ssh_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "stargazers_count" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "stargazers_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "statuses_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "subscribers_count" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "subscribers_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "subscription_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "svn_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "tags_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "teams_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "temp_clone_token"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "template_repository"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeRepository
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "topics" (Json.Decode.list Json.Decode.string))
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "trees_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "use_squash_pr_title_as_default" Json.Decode.bool
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "visibility" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "watchers" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "watchers_count" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "web_commit_signoff_required" Json.Decode.bool)


encodeFullRepository : FullRepository -> Json.Encode.Value
encodeFullRepository rec =
    Json.Encode.object
        [ ( "allow_auto_merge", Json.Encode.bool rec.allow_auto_merge )
        , ( "allow_forking", Json.Encode.bool rec.allow_forking )
        , ( "allow_merge_commit", Json.Encode.bool rec.allow_merge_commit )
        , ( "allow_rebase_merge", Json.Encode.bool rec.allow_rebase_merge )
        , ( "allow_squash_merge", Json.Encode.bool rec.allow_squash_merge )
        , ( "allow_update_branch", Json.Encode.bool rec.allow_update_branch )
        , ( "anonymous_access_enabled"
          , Json.Encode.bool rec.anonymous_access_enabled
          )
        , ( "archive_url", Json.Encode.string rec.archive_url )
        , ( "archived", Json.Encode.bool rec.archived )
        , ( "assignees_url", Json.Encode.string rec.assignees_url )
        , ( "blobs_url", Json.Encode.string rec.blobs_url )
        , ( "branches_url", Json.Encode.string rec.branches_url )
        , ( "clone_url", Json.Encode.string rec.clone_url )
        , ( "code_of_conduct", encodeCodeOfConductSimple rec.code_of_conduct )
        , ( "collaborators_url", Json.Encode.string rec.collaborators_url )
        , ( "comments_url", Json.Encode.string rec.comments_url )
        , ( "commits_url", Json.Encode.string rec.commits_url )
        , ( "compare_url", Json.Encode.string rec.compare_url )
        , ( "contents_url", Json.Encode.string rec.contents_url )
        , ( "contributors_url", Json.Encode.string rec.contributors_url )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "default_branch", Json.Encode.string rec.default_branch )
        , ( "delete_branch_on_merge"
          , Json.Encode.bool rec.delete_branch_on_merge
          )
        , ( "deployments_url", Json.Encode.string rec.deployments_url )
        , ( "description"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.description
          )
        , ( "disabled", Json.Encode.bool rec.disabled )
        , ( "downloads_url", Json.Encode.string rec.downloads_url )
        , ( "events_url", Json.Encode.string rec.events_url )
        , ( "fork", Json.Encode.bool rec.fork )
        , ( "forks", Json.Encode.int rec.forks )
        , ( "forks_count", Json.Encode.int rec.forks_count )
        , ( "forks_url", Json.Encode.string rec.forks_url )
        , ( "full_name", Json.Encode.string rec.full_name )
        , ( "git_commits_url", Json.Encode.string rec.git_commits_url )
        , ( "git_refs_url", Json.Encode.string rec.git_refs_url )
        , ( "git_tags_url", Json.Encode.string rec.git_tags_url )
        , ( "git_url", Json.Encode.string rec.git_url )
        , ( "has_downloads", Json.Encode.bool rec.has_downloads )
        , ( "has_issues", Json.Encode.bool rec.has_issues )
        , ( "has_pages", Json.Encode.bool rec.has_pages )
        , ( "has_projects", Json.Encode.bool rec.has_projects )
        , ( "has_wiki", Json.Encode.bool rec.has_wiki )
        , ( "homepage"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.homepage
          )
        , ( "hooks_url", Json.Encode.string rec.hooks_url )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "id", Json.Encode.int rec.id )
        , ( "is_template", Json.Encode.bool rec.is_template )
        , ( "issue_comment_url", Json.Encode.string rec.issue_comment_url )
        , ( "issue_events_url", Json.Encode.string rec.issue_events_url )
        , ( "issues_url", Json.Encode.string rec.issues_url )
        , ( "keys_url", Json.Encode.string rec.keys_url )
        , ( "labels_url", Json.Encode.string rec.labels_url )
        , ( "language"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.language
          )
        , ( "languages_url", Json.Encode.string rec.languages_url )
        , ( "license"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeLicenseSimple value
            )
                rec.license
          )
        , ( "master_branch", Json.Encode.string rec.master_branch )
        , ( "merge_commit_message"
          , Json.Encode.string rec.merge_commit_message
          )
        , ( "merge_commit_title", Json.Encode.string rec.merge_commit_title )
        , ( "merges_url", Json.Encode.string rec.merges_url )
        , ( "milestones_url", Json.Encode.string rec.milestones_url )
        , ( "mirror_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.mirror_url
          )
        , ( "name", Json.Encode.string rec.name )
        , ( "network_count", Json.Encode.int rec.network_count )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "notifications_url", Json.Encode.string rec.notifications_url )
        , ( "open_issues", Json.Encode.int rec.open_issues )
        , ( "open_issues_count", Json.Encode.int rec.open_issues_count )
        , ( "organization"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.organization
          )
        , ( "owner", encodeSimpleUser rec.owner )
        , ( "parent", encodeRepository rec.parent )
        , ( "permissions"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "admin", Json.Encode.bool rec0.admin )
                    , ( "maintain", Json.Encode.bool rec0.maintain )
                    , ( "pull", Json.Encode.bool rec0.pull )
                    , ( "push", Json.Encode.bool rec0.push )
                    , ( "triage", Json.Encode.bool rec0.triage )
                    ]
            )
                rec.permissions
          )
        , ( "private", Json.Encode.bool rec.private )
        , ( "pulls_url", Json.Encode.string rec.pulls_url )
        , ( "pushed_at", Json.Encode.string rec.pushed_at )
        , ( "releases_url", Json.Encode.string rec.releases_url )
        , ( "security_and_analysis"
          , encodeSecurityAndAnalysis rec.security_and_analysis
          )
        , ( "size", Json.Encode.int rec.size )
        , ( "source", encodeRepository rec.source )
        , ( "squash_merge_commit_message"
          , Json.Encode.string rec.squash_merge_commit_message
          )
        , ( "squash_merge_commit_title"
          , Json.Encode.string rec.squash_merge_commit_title
          )
        , ( "ssh_url", Json.Encode.string rec.ssh_url )
        , ( "stargazers_count", Json.Encode.int rec.stargazers_count )
        , ( "stargazers_url", Json.Encode.string rec.stargazers_url )
        , ( "statuses_url", Json.Encode.string rec.statuses_url )
        , ( "subscribers_count", Json.Encode.int rec.subscribers_count )
        , ( "subscribers_url", Json.Encode.string rec.subscribers_url )
        , ( "subscription_url", Json.Encode.string rec.subscription_url )
        , ( "svn_url", Json.Encode.string rec.svn_url )
        , ( "tags_url", Json.Encode.string rec.tags_url )
        , ( "teams_url", Json.Encode.string rec.teams_url )
        , ( "temp_clone_token"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.temp_clone_token
          )
        , ( "template_repository"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeRepository value
            )
                rec.template_repository
          )
        , ( "topics", Json.Encode.list Json.Encode.string rec.topics )
        , ( "trees_url", Json.Encode.string rec.trees_url )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        , ( "url", Json.Encode.string rec.url )
        , ( "use_squash_pr_title_as_default"
          , Json.Encode.bool rec.use_squash_pr_title_as_default
          )
        , ( "visibility", Json.Encode.string rec.visibility )
        , ( "watchers", Json.Encode.int rec.watchers )
        , ( "watchers_count", Json.Encode.int rec.watchers_count )
        , ( "web_commit_signoff_required"
          , Json.Encode.bool rec.web_commit_signoff_required
          )
        ]


type alias FileCommit =
    { commit :
        { author : { date : String, email : String, name : String }
        , committer : { date : String, email : String, name : String }
        , html_url : String
        , message : String
        , node_id : String
        , parents : List { html_url : String, sha : String, url : String }
        , sha : String
        , tree : { sha : String, url : String }
        , url : String
        , verification :
            { payload : Nullable String
            , reason : String
            , signature : Nullable String
            , verified : Bool
            }
        }
    , content :
        Nullable { _links : { git : String, html : String, self : String }
        , download_url : String
        , git_url : String
        , html_url : String
        , name : String
        , path : String
        , sha : String
        , size : Int
        , type_ : String
        , url : String
        }
    }


decodeFileCommit : Json.Decode.Decoder FileCommit
decodeFileCommit =
    Json.Decode.succeed
     (\commit content -> { commit = commit, content = content })
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "commit"
                (Json.Decode.succeed
                  (\author committer html_url message node_id parents sha tree url verification ->
                      { author = author
                      , committer = committer
                      , html_url = html_url
                      , message = message
                      , node_id = node_id
                      , parents = parents
                      , sha = sha
                      , tree = tree
                      , url = url
                      , verification = verification
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "author"
                            (Json.Decode.succeed
                              (\date email name ->
                                  { date = date, email = email, name = name }
                              )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field "date" Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "email"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field "name" Json.Decode.string
                                    )
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "committer"
                            (Json.Decode.succeed
                              (\date email name ->
                                  { date = date, email = email, name = name }
                              )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field "date" Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "email"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field "name" Json.Decode.string
                                    )
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "html_url" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "message" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "node_id" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "parents"
                            (Json.Decode.list
                                (Json.Decode.succeed
                                  (\html_url sha url ->
                                      { html_url = html_url
                                      , sha = sha
                                      , url = url
                                      }
                                  )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "html_url"
                                            Json.Decode.string
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "sha"
                                            Json.Decode.string
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "url"
                                            Json.Decode.string
                                        )
                                )
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "sha" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "tree"
                            (Json.Decode.succeed
                              (\sha url -> { sha = sha, url = url })
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field "sha" Json.Decode.string)
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field "url" Json.Decode.string)
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "url" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "verification"
                            (Json.Decode.succeed
                              (\payload reason signature verified ->
                                  { payload = payload
                                  , reason = reason
                                  , signature = signature
                                  , verified = verified
                                  }
                              )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "payload"
                                        (Json.Decode.oneOf
                                            [ Json.Decode.map
                                                Present
                                                Json.Decode.string
                                            , Json.Decode.null Null
                                            ]
                                        )
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "reason"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "signature"
                                        (Json.Decode.oneOf
                                            [ Json.Decode.map
                                                Present
                                                Json.Decode.string
                                            , Json.Decode.null Null
                                            ]
                                        )
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "verified"
                                        Json.Decode.bool
                                    )
                            )
                        )
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "content"
                (Json.Decode.oneOf
                    [ Json.Decode.map
                        Present
                        (Json.Decode.succeed
                          (\_links download_url git_url html_url name path sha size type_ url ->
                              { _links = _links
                              , download_url = download_url
                              , git_url = git_url
                              , html_url = html_url
                              , name = name
                              , path = path
                              , sha = sha
                              , size = size
                              , type_ = type_
                              , url = url
                              }
                          )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "_links"
                                    (Json.Decode.succeed
                                      (\git html self ->
                                          { git = git
                                          , html = html
                                          , self = self
                                          }
                                      )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "git"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "html"
                                                Json.Decode.string
                                            )
                                        |> Json.Decode.Extra.andMap
                                            (Json.Decode.field
                                                "self"
                                                Json.Decode.string
                                            )
                                    )
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "download_url"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "git_url" Json.Decode.string)
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "html_url" Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "name" Json.Decode.string)
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "path" Json.Decode.string)
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "sha" Json.Decode.string)
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "size" Json.Decode.int)
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "type" Json.Decode.string)
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "url" Json.Decode.string)
                        )
                    , Json.Decode.null Null
                    ]
                )
            )


encodeFileCommit : FileCommit -> Json.Encode.Value
encodeFileCommit rec =
    Json.Encode.object
        [ ( "commit"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "author"
                      , (\rec_0_1_1_1_0_1_1_0_0 ->
                            Json.Encode.object
                                [ ( "date"
                                  , Json.Encode.string
                                        rec_0_1_1_1_0_1_1_0_0.date
                                  )
                                , ( "email"
                                  , Json.Encode.string
                                        rec_0_1_1_1_0_1_1_0_0.email
                                  )
                                , ( "name"
                                  , Json.Encode.string
                                        rec_0_1_1_1_0_1_1_0_0.name
                                  )
                                ]
                        )
                            rec0.author
                      )
                    , ( "committer"
                      , (\rec_0_2_1_1_0_1_1_0_0 ->
                            Json.Encode.object
                                [ ( "date"
                                  , Json.Encode.string
                                        rec_0_2_1_1_0_1_1_0_0.date
                                  )
                                , ( "email"
                                  , Json.Encode.string
                                        rec_0_2_1_1_0_1_1_0_0.email
                                  )
                                , ( "name"
                                  , Json.Encode.string
                                        rec_0_2_1_1_0_1_1_0_0.name
                                  )
                                ]
                        )
                            rec0.committer
                      )
                    , ( "html_url", Json.Encode.string rec0.html_url )
                    , ( "message", Json.Encode.string rec0.message )
                    , ( "node_id", Json.Encode.string rec0.node_id )
                    , ( "parents"
                      , Json.Encode.list
                            (\rec_1_0_6_1_1_0_1_1_0_0 ->
                                Json.Encode.object
                                    [ ( "html_url"
                                      , Json.Encode.string
                                            rec_1_0_6_1_1_0_1_1_0_0.html_url
                                      )
                                    , ( "sha"
                                      , Json.Encode.string
                                            rec_1_0_6_1_1_0_1_1_0_0.sha
                                      )
                                    , ( "url"
                                      , Json.Encode.string
                                            rec_1_0_6_1_1_0_1_1_0_0.url
                                      )
                                    ]
                            )
                            rec0.parents
                      )
                    , ( "sha", Json.Encode.string rec0.sha )
                    , ( "tree"
                      , (\rec_0_8_1_1_0_1_1_0_0 ->
                            Json.Encode.object
                                [ ( "sha"
                                  , Json.Encode.string rec_0_8_1_1_0_1_1_0_0.sha
                                  )
                                , ( "url"
                                  , Json.Encode.string rec_0_8_1_1_0_1_1_0_0.url
                                  )
                                ]
                        )
                            rec0.tree
                      )
                    , ( "url", Json.Encode.string rec0.url )
                    , ( "verification"
                      , (\rec_0_10_1_1_0_1_1_0_0 ->
                            Json.Encode.object
                                [ ( "payload"
                                  , (\nullableValue ->
                                        case nullableValue of
                                            Null ->
                                                Json.Encode.null

                                            Present value ->
                                                Json.Encode.string value
                                    )
                                        rec_0_10_1_1_0_1_1_0_0.payload
                                  )
                                , ( "reason"
                                  , Json.Encode.string
                                        rec_0_10_1_1_0_1_1_0_0.reason
                                  )
                                , ( "signature"
                                  , (\nullableValue ->
                                        case nullableValue of
                                            Null ->
                                                Json.Encode.null

                                            Present value ->
                                                Json.Encode.string value
                                    )
                                        rec_0_10_1_1_0_1_1_0_0.signature
                                  )
                                , ( "verified"
                                  , Json.Encode.bool
                                        rec_0_10_1_1_0_1_1_0_0.verified
                                  )
                                ]
                        )
                            rec0.verification
                      )
                    ]
            )
                rec.commit
          )
        , ( "content"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        (\rec0 ->
                            Json.Encode.object
                                [ ( "_links"
                                  , (\rec_0_1_1_1_0_0_1_0_0_2_1_0_0 ->
                                        Json.Encode.object
                                            [ ( "git"
                                              , Json.Encode.string
                                                    rec_0_1_1_1_0_0_1_0_0_2_1_0_0.git
                                              )
                                            , ( "html"
                                              , Json.Encode.string
                                                    rec_0_1_1_1_0_0_1_0_0_2_1_0_0.html
                                              )
                                            , ( "self"
                                              , Json.Encode.string
                                                    rec_0_1_1_1_0_0_1_0_0_2_1_0_0.self
                                              )
                                            ]
                                    )
                                        rec0._links
                                  )
                                , ( "download_url"
                                  , Json.Encode.string rec0.download_url
                                  )
                                , ( "git_url", Json.Encode.string rec0.git_url )
                                , ( "html_url"
                                  , Json.Encode.string rec0.html_url
                                  )
                                , ( "name", Json.Encode.string rec0.name )
                                , ( "path", Json.Encode.string rec0.path )
                                , ( "sha", Json.Encode.string rec0.sha )
                                , ( "size", Json.Encode.int rec0.size )
                                , ( "type", Json.Encode.string rec0.type_ )
                                , ( "url", Json.Encode.string rec0.url )
                                ]
                        )
                            value
            )
                rec.content
          )
        ]


type alias Feed =
    { _links :
        { current_user : LinkWithType
        , current_user_actor : LinkWithType
        , current_user_organization : LinkWithType
        , current_user_organizations : List LinkWithType
        , current_user_public : LinkWithType
        , security_advisories : LinkWithType
        , timeline : LinkWithType
        , user : LinkWithType
        }
    , current_user_actor_url : String
    , current_user_organization_url : String
    , current_user_organization_urls : List String
    , current_user_public_url : String
    , current_user_url : String
    , security_advisories_url : String
    , timeline_url : String
    , user_url : String
    }


decodeFeed : Json.Decode.Decoder Feed
decodeFeed =
    Json.Decode.succeed
     (\_links current_user_actor_url current_user_organization_url current_user_organization_urls current_user_public_url current_user_url security_advisories_url timeline_url user_url ->
         { _links = _links
         , current_user_actor_url = current_user_actor_url
         , current_user_organization_url = current_user_organization_url
         , current_user_organization_urls = current_user_organization_urls
         , current_user_public_url = current_user_public_url
         , current_user_url = current_user_url
         , security_advisories_url = security_advisories_url
         , timeline_url = timeline_url
         , user_url = user_url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "_links"
                (Json.Decode.succeed
                  (\current_user current_user_actor current_user_organization current_user_organizations current_user_public security_advisories timeline user ->
                      { current_user = current_user
                      , current_user_actor = current_user_actor
                      , current_user_organization = current_user_organization
                      , current_user_organizations = current_user_organizations
                      , current_user_public = current_user_public
                      , security_advisories = security_advisories
                      , timeline = timeline
                      , user = user
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "current_user" decodeLinkWithType)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "current_user_actor"
                            decodeLinkWithType
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "current_user_organization"
                            decodeLinkWithType
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "current_user_organizations"
                            (Json.Decode.list decodeLinkWithType)
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "current_user_public"
                            decodeLinkWithType
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "security_advisories"
                            decodeLinkWithType
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "timeline" decodeLinkWithType)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "user" decodeLinkWithType)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "current_user_actor_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "current_user_organization_url"
                Json.Decode.string
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "current_user_organization_urls"
                (Json.Decode.list Json.Decode.string)
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "current_user_public_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "current_user_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "security_advisories_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "timeline_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "user_url" Json.Decode.string)


encodeFeed : Feed -> Json.Encode.Value
encodeFeed rec =
    Json.Encode.object
        [ ( "_links"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "current_user", encodeLinkWithType rec0.current_user )
                    , ( "current_user_actor"
                      , encodeLinkWithType rec0.current_user_actor
                      )
                    , ( "current_user_organization"
                      , encodeLinkWithType rec0.current_user_organization
                      )
                    , ( "current_user_organizations"
                      , Json.Encode.list encodeLinkWithType
                            rec0.current_user_organizations
                      )
                    , ( "current_user_public"
                      , encodeLinkWithType rec0.current_user_public
                      )
                    , ( "security_advisories"
                      , encodeLinkWithType rec0.security_advisories
                      )
                    , ( "timeline", encodeLinkWithType rec0.timeline )
                    , ( "user", encodeLinkWithType rec0.user )
                    ]
            )
                rec._links
          )
        , ( "current_user_actor_url"
          , Json.Encode.string rec.current_user_actor_url
          )
        , ( "current_user_organization_url"
          , Json.Encode.string rec.current_user_organization_url
          )
        , ( "current_user_organization_urls"
          , Json.Encode.list Json.Encode.string
                rec.current_user_organization_urls
          )
        , ( "current_user_public_url"
          , Json.Encode.string rec.current_user_public_url
          )
        , ( "current_user_url", Json.Encode.string rec.current_user_url )
        , ( "security_advisories_url"
          , Json.Encode.string rec.security_advisories_url
          )
        , ( "timeline_url", Json.Encode.string rec.timeline_url )
        , ( "user_url", Json.Encode.string rec.user_url )
        ]


type alias Event =
    { actor : Actor
    , created_at : Nullable String
    , id : String
    , org : Actor
    , payload :
        { action : String
        , comment : IssueComment
        , issue : Issue
        , pages :
            List { action : String
            , html_url : String
            , page_name : String
            , sha : String
            , summary : Nullable String
            , title : String
            }
        }
    , public : Bool
    , repo : { id : Int, name : String, url : String }
    , type_ : Nullable String
    }


decodeEvent : Json.Decode.Decoder Event
decodeEvent =
    Json.Decode.succeed
     (\actor created_at id org payload public repo type_ ->
         { actor = actor
         , created_at = created_at
         , id = id
         , org = org
         , payload = payload
         , public = public
         , repo = repo
         , type_ = type_
         }
     )
        |> Json.Decode.Extra.andMap (Json.Decode.field "actor" decodeActor)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "created_at"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "org" decodeActor)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "payload"
                (Json.Decode.succeed
                  (\action comment issue pages ->
                      { action = action
                      , comment = comment
                      , issue = issue
                      , pages = pages
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "action" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "comment" decodeIssueComment)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "issue" decodeIssue)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "pages"
                            (Json.Decode.list
                                (Json.Decode.succeed
                                  (\action html_url page_name sha summary title ->
                                      { action = action
                                      , html_url = html_url
                                      , page_name = page_name
                                      , sha = sha
                                      , summary = summary
                                      , title = title
                                      }
                                  )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "action"
                                            Json.Decode.string
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "html_url"
                                            Json.Decode.string
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "page_name"
                                            Json.Decode.string
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "sha"
                                            Json.Decode.string
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "summary"
                                            (Json.Decode.oneOf
                                                [ Json.Decode.map
                                                    Present
                                                    Json.Decode.string
                                                , Json.Decode.null Null
                                                ]
                                            )
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "title"
                                            Json.Decode.string
                                        )
                                )
                            )
                        )
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "public" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "repo"
                (Json.Decode.succeed
                  (\id name url -> { id = id, name = name, url = url })
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "id" Json.Decode.int)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "name" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "url" Json.Decode.string)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "type"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )


encodeEvent : Event -> Json.Encode.Value
encodeEvent rec =
    Json.Encode.object
        [ ( "actor", encodeActor rec.actor )
        , ( "created_at"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.created_at
          )
        , ( "id", Json.Encode.string rec.id )
        , ( "org", encodeActor rec.org )
        , ( "payload"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "action", Json.Encode.string rec0.action )
                    , ( "comment", encodeIssueComment rec0.comment )
                    , ( "issue", encodeIssue rec0.issue )
                    , ( "pages"
                      , Json.Encode.list
                            (\rec_1_0_4_1_1_0_5_1_0_0 ->
                                Json.Encode.object
                                    [ ( "action"
                                      , Json.Encode.string
                                            rec_1_0_4_1_1_0_5_1_0_0.action
                                      )
                                    , ( "html_url"
                                      , Json.Encode.string
                                            rec_1_0_4_1_1_0_5_1_0_0.html_url
                                      )
                                    , ( "page_name"
                                      , Json.Encode.string
                                            rec_1_0_4_1_1_0_5_1_0_0.page_name
                                      )
                                    , ( "sha"
                                      , Json.Encode.string
                                            rec_1_0_4_1_1_0_5_1_0_0.sha
                                      )
                                    , ( "summary"
                                      , (\nullableValue ->
                                            case nullableValue of
                                                Null ->
                                                    Json.Encode.null

                                                Present value ->
                                                    Json.Encode.string value
                                        )
                                            rec_1_0_4_1_1_0_5_1_0_0.summary
                                      )
                                    , ( "title"
                                      , Json.Encode.string
                                            rec_1_0_4_1_1_0_5_1_0_0.title
                                      )
                                    ]
                            )
                            rec0.pages
                      )
                    ]
            )
                rec.payload
          )
        , ( "public", Json.Encode.bool rec.public )
        , ( "repo"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "id", Json.Encode.int rec0.id )
                    , ( "name", Json.Encode.string rec0.name )
                    , ( "url", Json.Encode.string rec0.url )
                    ]
            )
                rec.repo
          )
        , ( "type"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.type_
          )
        ]


type alias EnvironmentApprovals =
    { comment : String
    , environments :
        List { created_at : String
        , html_url : String
        , id : Int
        , name : String
        , node_id : String
        , updated_at : String
        , url : String
        }
    , state : String
    , user : SimpleUser
    }


decodeEnvironmentApprovals : Json.Decode.Decoder EnvironmentApprovals
decodeEnvironmentApprovals =
    Json.Decode.succeed
     (\comment environments state user ->
         { comment = comment
         , environments = environments
         , state = state
         , user = user
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "comment" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "environments"
                (Json.Decode.list
                    (Json.Decode.succeed
                      (\created_at html_url id name node_id updated_at url ->
                          { created_at = created_at
                          , html_url = html_url
                          , id = id
                          , name = name
                          , node_id = node_id
                          , updated_at = updated_at
                          , url = url
                          }
                      )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "created_at" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "html_url" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "id" Json.Decode.int)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "name" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "node_id" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "updated_at" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "url" Json.Decode.string)
                    )
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "state" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "user" decodeSimpleUser)


encodeEnvironmentApprovals : EnvironmentApprovals -> Json.Encode.Value
encodeEnvironmentApprovals rec =
    Json.Encode.object
        [ ( "comment", Json.Encode.string rec.comment )
        , ( "environments"
          , Json.Encode.list
                (\rec0 ->
                    Json.Encode.object
                        [ ( "created_at", Json.Encode.string rec0.created_at )
                        , ( "html_url", Json.Encode.string rec0.html_url )
                        , ( "id", Json.Encode.int rec0.id )
                        , ( "name", Json.Encode.string rec0.name )
                        , ( "node_id", Json.Encode.string rec0.node_id )
                        , ( "updated_at", Json.Encode.string rec0.updated_at )
                        , ( "url", Json.Encode.string rec0.url )
                        ]
                )
                rec.environments
          )
        , ( "state", Json.Encode.string rec.state )
        , ( "user", encodeSimpleUser rec.user )
        ]


type alias Environment =
    { created_at : String
    , deployment_branch_policy : DeploymentBranchPolicySettings
    , html_url : String
    , id : Int
    , name : String
    , node_id : String
    , protection_rules :
        List (EnumThree { id : Int
        , node_id : String
        , type_ : String
        , wait_timer : WaitTimer
        } { id : Int
        , node_id : String
        , reviewers :
            List { reviewer : EnumTwo SimpleUser Team
            , type_ : DeploymentReviewerType
            }
        , type_ : String
        } { id : Int, node_id : String, type_ : String })
    , updated_at : String
    , url : String
    }


decodeEnvironment : Json.Decode.Decoder Environment
decodeEnvironment =
    Json.Decode.succeed
     (\created_at deployment_branch_policy html_url id name node_id protection_rules updated_at url ->
         { created_at = created_at
         , deployment_branch_policy = deployment_branch_policy
         , html_url = html_url
         , id = id
         , name = name
         , node_id = node_id
         , protection_rules = protection_rules
         , updated_at = updated_at
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "deployment_branch_policy"
                decodeDeploymentBranchPolicySettings
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "protection_rules"
                (Json.Decode.list
                    (Debug.todo "Enum decoder not implemented yet")
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeEnvironment : Environment -> Json.Encode.Value
encodeEnvironment rec =
    Json.Encode.object
        [ ( "created_at", Json.Encode.string rec.created_at )
        , ( "deployment_branch_policy"
          , encodeDeploymentBranchPolicySettings rec.deployment_branch_policy
          )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "id", Json.Encode.int rec.id )
        , ( "name", Json.Encode.string rec.name )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "protection_rules"
          , Json.Encode.list (Debug.todo "encoder for enum not implemented")
                rec.protection_rules
          )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias Enterprise =
    { avatar_url : String
    , created_at : Nullable String
    , description : Nullable String
    , html_url : String
    , id : Int
    , name : String
    , node_id : String
    , slug : String
    , updated_at : Nullable String
    , website_url : Nullable String
    }


decodeEnterprise : Json.Decode.Decoder Enterprise
decodeEnterprise =
    Json.Decode.succeed
     (\avatar_url created_at description html_url id name node_id slug updated_at website_url ->
         { avatar_url = avatar_url
         , created_at = created_at
         , description = description
         , html_url = html_url
         , id = id
         , name = name
         , node_id = node_id
         , slug = slug
         , updated_at = updated_at
         , website_url = website_url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "avatar_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "created_at"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "description"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "slug" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "updated_at"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "website_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )


encodeEnterprise : Enterprise -> Json.Encode.Value
encodeEnterprise rec =
    Json.Encode.object
        [ ( "avatar_url", Json.Encode.string rec.avatar_url )
        , ( "created_at"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.created_at
          )
        , ( "description"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.description
          )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "id", Json.Encode.int rec.id )
        , ( "name", Json.Encode.string rec.name )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "slug", Json.Encode.string rec.slug )
        , ( "updated_at"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.updated_at
          )
        , ( "website_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.website_url
          )
        ]


type alias EnabledRepositories =
    String


decodeEnabledRepositories : Json.Decode.Decoder EnabledRepositories
decodeEnabledRepositories =
    Json.Decode.string


encodeEnabledRepositories : EnabledRepositories -> Json.Encode.Value
encodeEnabledRepositories =
    Json.Encode.string


type alias EnabledOrganizations =
    String


decodeEnabledOrganizations : Json.Decode.Decoder EnabledOrganizations
decodeEnabledOrganizations =
    Json.Decode.string


encodeEnabledOrganizations : EnabledOrganizations -> Json.Encode.Value
encodeEnabledOrganizations =
    Json.Encode.string


type alias EmptyObject =
    {}


decodeEmptyObject : Json.Decode.Decoder EmptyObject
decodeEmptyObject =
    Json.Decode.succeed {}


encodeEmptyObject : EmptyObject -> Json.Encode.Value
encodeEmptyObject rec =
    Json.Encode.object []


type alias Email =
    { email : String
    , primary : Bool
    , verified : Bool
    , visibility : Nullable String
    }


decodeEmail : Json.Decode.Decoder Email
decodeEmail =
    Json.Decode.succeed
     (\email primary verified visibility ->
         { email = email
         , primary = primary
         , verified = verified
         , visibility = visibility
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "email" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "primary" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "verified" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "visibility"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )


encodeEmail : Email -> Json.Encode.Value
encodeEmail rec =
    Json.Encode.object
        [ ( "email", Json.Encode.string rec.email )
        , ( "primary", Json.Encode.bool rec.primary )
        , ( "verified", Json.Encode.bool rec.verified )
        , ( "visibility"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.visibility
          )
        ]


type alias DiffEntry =
    { additions : Int
    , blob_url : String
    , changes : Int
    , contents_url : String
    , deletions : Int
    , filename : String
    , patch : String
    , previous_filename : String
    , raw_url : String
    , sha : String
    , status : String
    }


decodeDiffEntry : Json.Decode.Decoder DiffEntry
decodeDiffEntry =
    Json.Decode.succeed
     (\additions blob_url changes contents_url deletions filename patch previous_filename raw_url sha status ->
         { additions = additions
         , blob_url = blob_url
         , changes = changes
         , contents_url = contents_url
         , deletions = deletions
         , filename = filename
         , patch = patch
         , previous_filename = previous_filename
         , raw_url = raw_url
         , sha = sha
         , status = status
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "additions" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "blob_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "changes" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "contents_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "deletions" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "filename" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "patch" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "previous_filename" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "raw_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "sha" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "status" Json.Decode.string)


encodeDiffEntry : DiffEntry -> Json.Encode.Value
encodeDiffEntry rec =
    Json.Encode.object
        [ ( "additions", Json.Encode.int rec.additions )
        , ( "blob_url", Json.Encode.string rec.blob_url )
        , ( "changes", Json.Encode.int rec.changes )
        , ( "contents_url", Json.Encode.string rec.contents_url )
        , ( "deletions", Json.Encode.int rec.deletions )
        , ( "filename", Json.Encode.string rec.filename )
        , ( "patch", Json.Encode.string rec.patch )
        , ( "previous_filename", Json.Encode.string rec.previous_filename )
        , ( "raw_url", Json.Encode.string rec.raw_url )
        , ( "sha", Json.Encode.string rec.sha )
        , ( "status", Json.Encode.string rec.status )
        ]


type alias DeploymentStatus =
    { created_at : String
    , creator : Nullable SimpleUser
    , deployment_url : String
    , description : String
    , environment : String
    , environment_url : String
    , id : Int
    , log_url : String
    , node_id : String
    , performed_via_github_app : Nullable Integration
    , repository_url : String
    , state : String
    , target_url : String
    , updated_at : String
    , url : String
    }


decodeDeploymentStatus : Json.Decode.Decoder DeploymentStatus
decodeDeploymentStatus =
    Json.Decode.succeed
     (\created_at creator deployment_url description environment environment_url id log_url node_id performed_via_github_app repository_url state target_url updated_at url ->
         { created_at = created_at
         , creator = creator
         , deployment_url = deployment_url
         , description = description
         , environment = environment
         , environment_url = environment_url
         , id = id
         , log_url = log_url
         , node_id = node_id
         , performed_via_github_app = performed_via_github_app
         , repository_url = repository_url
         , state = state
         , target_url = target_url
         , updated_at = updated_at
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "creator"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "deployment_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "description" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "environment" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "environment_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "log_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "performed_via_github_app"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeIntegration
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "repository_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "state" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "target_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeDeploymentStatus : DeploymentStatus -> Json.Encode.Value
encodeDeploymentStatus rec =
    Json.Encode.object
        [ ( "created_at", Json.Encode.string rec.created_at )
        , ( "creator"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.creator
          )
        , ( "deployment_url", Json.Encode.string rec.deployment_url )
        , ( "description", Json.Encode.string rec.description )
        , ( "environment", Json.Encode.string rec.environment )
        , ( "environment_url", Json.Encode.string rec.environment_url )
        , ( "id", Json.Encode.int rec.id )
        , ( "log_url", Json.Encode.string rec.log_url )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "performed_via_github_app"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeIntegration value
            )
                rec.performed_via_github_app
          )
        , ( "repository_url", Json.Encode.string rec.repository_url )
        , ( "state", Json.Encode.string rec.state )
        , ( "target_url", Json.Encode.string rec.target_url )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias DeploymentSimple =
    { created_at : String
    , description : Nullable String
    , environment : String
    , id : Int
    , node_id : String
    , original_environment : String
    , performed_via_github_app : Nullable Integration
    , production_environment : Bool
    , repository_url : String
    , statuses_url : String
    , task : String
    , transient_environment : Bool
    , updated_at : String
    , url : String
    }


decodeDeploymentSimple : Json.Decode.Decoder DeploymentSimple
decodeDeploymentSimple =
    Json.Decode.succeed
     (\created_at description environment id node_id original_environment performed_via_github_app production_environment repository_url statuses_url task transient_environment updated_at url ->
         { created_at = created_at
         , description = description
         , environment = environment
         , id = id
         , node_id = node_id
         , original_environment = original_environment
         , performed_via_github_app = performed_via_github_app
         , production_environment = production_environment
         , repository_url = repository_url
         , statuses_url = statuses_url
         , task = task
         , transient_environment = transient_environment
         , updated_at = updated_at
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "description"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "environment" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "original_environment" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "performed_via_github_app"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeIntegration
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "production_environment" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "repository_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "statuses_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "task" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "transient_environment" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeDeploymentSimple : DeploymentSimple -> Json.Encode.Value
encodeDeploymentSimple rec =
    Json.Encode.object
        [ ( "created_at", Json.Encode.string rec.created_at )
        , ( "description"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.description
          )
        , ( "environment", Json.Encode.string rec.environment )
        , ( "id", Json.Encode.int rec.id )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "original_environment"
          , Json.Encode.string rec.original_environment
          )
        , ( "performed_via_github_app"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeIntegration value
            )
                rec.performed_via_github_app
          )
        , ( "production_environment"
          , Json.Encode.bool rec.production_environment
          )
        , ( "repository_url", Json.Encode.string rec.repository_url )
        , ( "statuses_url", Json.Encode.string rec.statuses_url )
        , ( "task", Json.Encode.string rec.task )
        , ( "transient_environment"
          , Json.Encode.bool rec.transient_environment
          )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias DeploymentReviewerType =
    String


decodeDeploymentReviewerType : Json.Decode.Decoder DeploymentReviewerType
decodeDeploymentReviewerType =
    Json.Decode.string


encodeDeploymentReviewerType : DeploymentReviewerType -> Json.Encode.Value
encodeDeploymentReviewerType =
    Json.Encode.string


type alias DeploymentBranchPolicySettings =
    Nullable { custom_branch_policies : Bool, protected_branches : Bool }


decodeDeploymentBranchPolicySettings :
    Json.Decode.Decoder DeploymentBranchPolicySettings
decodeDeploymentBranchPolicySettings =
    Json.Decode.oneOf
        [ Json.Decode.map
            Present
            (Json.Decode.succeed
              (\custom_branch_policies protected_branches ->
                  { custom_branch_policies = custom_branch_policies
                  , protected_branches = protected_branches
                  }
              )
                |> Json.Decode.Extra.andMap
                    (Json.Decode.field "custom_branch_policies" Json.Decode.bool
                    )
                |> Json.Decode.Extra.andMap
                    (Json.Decode.field "protected_branches" Json.Decode.bool)
            )
        , Json.Decode.null Null
        ]


encodeDeploymentBranchPolicySettings :
    DeploymentBranchPolicySettings -> Json.Encode.Value
encodeDeploymentBranchPolicySettings nullableValue =
    case nullableValue of
        Null ->
            Json.Encode.null

        Present value ->
            (\rec ->
                Json.Encode.object
                    [ ( "custom_branch_policies"
                      , Json.Encode.bool rec.custom_branch_policies
                      )
                    , ( "protected_branches"
                      , Json.Encode.bool rec.protected_branches
                      )
                    ]
            )
                value


type alias DeploymentBranchPolicyNamePattern =
    { name : String }


decodeDeploymentBranchPolicyNamePattern :
    Json.Decode.Decoder DeploymentBranchPolicyNamePattern
decodeDeploymentBranchPolicyNamePattern =
    Json.Decode.succeed (\name -> { name = name })
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)


encodeDeploymentBranchPolicyNamePattern :
    DeploymentBranchPolicyNamePattern -> Json.Encode.Value
encodeDeploymentBranchPolicyNamePattern rec =
    Json.Encode.object [ ( "name", Json.Encode.string rec.name ) ]


type alias DeploymentBranchPolicy =
    { id : Int, name : String, node_id : String }


decodeDeploymentBranchPolicy : Json.Decode.Decoder DeploymentBranchPolicy
decodeDeploymentBranchPolicy =
    Json.Decode.succeed
     (\id name node_id -> { id = id, name = name, node_id = node_id })
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)


encodeDeploymentBranchPolicy : DeploymentBranchPolicy -> Json.Encode.Value
encodeDeploymentBranchPolicy rec =
    Json.Encode.object
        [ ( "id", Json.Encode.int rec.id )
        , ( "name", Json.Encode.string rec.name )
        , ( "node_id", Json.Encode.string rec.node_id )
        ]


type alias Deployment =
    { created_at : String
    , creator : Nullable SimpleUser
    , description : Nullable String
    , environment : String
    , id : Int
    , node_id : String
    , original_environment : String
    , payload : Json.Encode.Value
    , performed_via_github_app : Nullable Integration
    , production_environment : Bool
    , ref : String
    , repository_url : String
    , sha : String
    , statuses_url : String
    , task : String
    , transient_environment : Bool
    , updated_at : String
    , url : String
    }


decodeDeployment : Json.Decode.Decoder Deployment
decodeDeployment =
    Json.Decode.succeed
     (\created_at creator description environment id node_id original_environment payload performed_via_github_app production_environment ref repository_url sha statuses_url task transient_environment updated_at url ->
         { created_at = created_at
         , creator = creator
         , description = description
         , environment = environment
         , id = id
         , node_id = node_id
         , original_environment = original_environment
         , payload = payload
         , performed_via_github_app = performed_via_github_app
         , production_environment = production_environment
         , ref = ref
         , repository_url = repository_url
         , sha = sha
         , statuses_url = statuses_url
         , task = task
         , transient_environment = transient_environment
         , updated_at = updated_at
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "creator"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "description"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "environment" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "original_environment" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "payload" Json.Decode.value)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "performed_via_github_app"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeIntegration
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "production_environment" Json.Decode.bool)
        |> Json.Decode.Extra.andMap (Json.Decode.field "ref" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "repository_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "sha" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "statuses_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "task" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "transient_environment" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeDeployment : Deployment -> Json.Encode.Value
encodeDeployment rec =
    Json.Encode.object
        [ ( "created_at", Json.Encode.string rec.created_at )
        , ( "creator"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.creator
          )
        , ( "description"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.description
          )
        , ( "environment", Json.Encode.string rec.environment )
        , ( "id", Json.Encode.int rec.id )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "original_environment"
          , Json.Encode.string rec.original_environment
          )
        , ( "payload", Basics.identity rec.payload )
        , ( "performed_via_github_app"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeIntegration value
            )
                rec.performed_via_github_app
          )
        , ( "production_environment"
          , Json.Encode.bool rec.production_environment
          )
        , ( "ref", Json.Encode.string rec.ref )
        , ( "repository_url", Json.Encode.string rec.repository_url )
        , ( "sha", Json.Encode.string rec.sha )
        , ( "statuses_url", Json.Encode.string rec.statuses_url )
        , ( "task", Json.Encode.string rec.task )
        , ( "transient_environment"
          , Json.Encode.bool rec.transient_environment
          )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias DeployKey =
    { added_by : Nullable String
    , created_at : String
    , id : Int
    , key : String
    , last_used : Nullable String
    , read_only : Bool
    , title : String
    , url : String
    , verified : Bool
    }


decodeDeployKey : Json.Decode.Decoder DeployKey
decodeDeployKey =
    Json.Decode.succeed
     (\added_by created_at id key last_used read_only title url verified ->
         { added_by = added_by
         , created_at = created_at
         , id = id
         , key = key
         , last_used = last_used
         , read_only = read_only
         , title = title
         , url = url
         , verified = verified
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "added_by"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap (Json.Decode.field "key" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "last_used"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "read_only" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "title" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "verified" Json.Decode.bool)


encodeDeployKey : DeployKey -> Json.Encode.Value
encodeDeployKey rec =
    Json.Encode.object
        [ ( "added_by"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.added_by
          )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "id", Json.Encode.int rec.id )
        , ( "key", Json.Encode.string rec.key )
        , ( "last_used"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.last_used
          )
        , ( "read_only", Json.Encode.bool rec.read_only )
        , ( "title", Json.Encode.string rec.title )
        , ( "url", Json.Encode.string rec.url )
        , ( "verified", Json.Encode.bool rec.verified )
        ]


type alias DependencyGraphDiff =
    List { change_type : String
    , ecosystem : String
    , license : Nullable String
    , manifest : String
    , name : String
    , package_url : Nullable String
    , scope : String
    , source_repository_url : Nullable String
    , version : String
    , vulnerabilities :
        List { advisory_ghsa_id : String
        , advisory_summary : String
        , advisory_url : String
        , severity : String
        }
    }


decodeDependencyGraphDiff : Json.Decode.Decoder DependencyGraphDiff
decodeDependencyGraphDiff =
    Json.Decode.list
        (Json.Decode.succeed
          (\change_type ecosystem license manifest name package_url scope source_repository_url version vulnerabilities ->
              { change_type = change_type
              , ecosystem = ecosystem
              , license = license
              , manifest = manifest
              , name = name
              , package_url = package_url
              , scope = scope
              , source_repository_url = source_repository_url
              , version = version
              , vulnerabilities = vulnerabilities
              }
          )
            |> Json.Decode.Extra.andMap
                (Json.Decode.field "change_type" Json.Decode.string)
            |> Json.Decode.Extra.andMap
                (Json.Decode.field "ecosystem" Json.Decode.string)
            |> Json.Decode.Extra.andMap
                (Json.Decode.field
                    "license"
                    (Json.Decode.oneOf
                        [ Json.Decode.map Present Json.Decode.string
                        , Json.Decode.null Null
                        ]
                    )
                )
            |> Json.Decode.Extra.andMap
                (Json.Decode.field "manifest" Json.Decode.string)
            |> Json.Decode.Extra.andMap
                (Json.Decode.field "name" Json.Decode.string)
            |> Json.Decode.Extra.andMap
                (Json.Decode.field
                    "package_url"
                    (Json.Decode.oneOf
                        [ Json.Decode.map Present Json.Decode.string
                        , Json.Decode.null Null
                        ]
                    )
                )
            |> Json.Decode.Extra.andMap
                (Json.Decode.field "scope" Json.Decode.string)
            |> Json.Decode.Extra.andMap
                (Json.Decode.field
                    "source_repository_url"
                    (Json.Decode.oneOf
                        [ Json.Decode.map Present Json.Decode.string
                        , Json.Decode.null Null
                        ]
                    )
                )
            |> Json.Decode.Extra.andMap
                (Json.Decode.field "version" Json.Decode.string)
            |> Json.Decode.Extra.andMap
                (Json.Decode.field
                    "vulnerabilities"
                    (Json.Decode.list
                        (Json.Decode.succeed
                          (\advisory_ghsa_id advisory_summary advisory_url severity ->
                              { advisory_ghsa_id = advisory_ghsa_id
                              , advisory_summary = advisory_summary
                              , advisory_url = advisory_url
                              , severity = severity
                              }
                          )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "advisory_ghsa_id"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "advisory_summary"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "advisory_url"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "severity" Json.Decode.string
                                )
                        )
                    )
                )
        )


encodeDependencyGraphDiff : DependencyGraphDiff -> Json.Encode.Value
encodeDependencyGraphDiff =
    Json.Encode.list
        (\rec ->
            Json.Encode.object
                [ ( "change_type", Json.Encode.string rec.change_type )
                , ( "ecosystem", Json.Encode.string rec.ecosystem )
                , ( "license"
                  , (\nullableValue ->
                        case nullableValue of
                            Null ->
                                Json.Encode.null

                            Present value ->
                                Json.Encode.string value
                    )
                        rec.license
                  )
                , ( "manifest", Json.Encode.string rec.manifest )
                , ( "name", Json.Encode.string rec.name )
                , ( "package_url"
                  , (\nullableValue ->
                        case nullableValue of
                            Null ->
                                Json.Encode.null

                            Present value ->
                                Json.Encode.string value
                    )
                        rec.package_url
                  )
                , ( "scope", Json.Encode.string rec.scope )
                , ( "source_repository_url"
                  , (\nullableValue ->
                        case nullableValue of
                            Null ->
                                Json.Encode.null

                            Present value ->
                                Json.Encode.string value
                    )
                        rec.source_repository_url
                  )
                , ( "version", Json.Encode.string rec.version )
                , ( "vulnerabilities"
                  , Json.Encode.list
                        (\rec0 ->
                            Json.Encode.object
                                [ ( "advisory_ghsa_id"
                                  , Json.Encode.string rec0.advisory_ghsa_id
                                  )
                                , ( "advisory_summary"
                                  , Json.Encode.string rec0.advisory_summary
                                  )
                                , ( "advisory_url"
                                  , Json.Encode.string rec0.advisory_url
                                  )
                                , ( "severity"
                                  , Json.Encode.string rec0.severity
                                  )
                                ]
                        )
                        rec.vulnerabilities
                  )
                ]
        )


type alias Dependency =
    { dependencies : List String
    , metadata : Metadata
    , package_url : String
    , relationship : String
    , scope : String
    }


decodeDependency : Json.Decode.Decoder Dependency
decodeDependency =
    Json.Decode.succeed
     (\dependencies metadata package_url relationship scope ->
         { dependencies = dependencies
         , metadata = metadata
         , package_url = package_url
         , relationship = relationship
         , scope = scope
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "dependencies"
                (Json.Decode.list Json.Decode.string)
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "metadata" decodeMetadata)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "package_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "relationship" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "scope" Json.Decode.string)


encodeDependency : Dependency -> Json.Encode.Value
encodeDependency rec =
    Json.Encode.object
        [ ( "dependencies"
          , Json.Encode.list Json.Encode.string rec.dependencies
          )
        , ( "metadata", encodeMetadata rec.metadata )
        , ( "package_url", Json.Encode.string rec.package_url )
        , ( "relationship", Json.Encode.string rec.relationship )
        , ( "scope", Json.Encode.string rec.scope )
        ]


type alias DependabotSecret =
    { created_at : String, name : String, updated_at : String }


decodeDependabotSecret : Json.Decode.Decoder DependabotSecret
decodeDependabotSecret =
    Json.Decode.succeed
     (\created_at name updated_at ->
         { created_at = created_at, name = name, updated_at = updated_at }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)


encodeDependabotSecret : DependabotSecret -> Json.Encode.Value
encodeDependabotSecret rec =
    Json.Encode.object
        [ ( "created_at", Json.Encode.string rec.created_at )
        , ( "name", Json.Encode.string rec.name )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        ]


type alias DependabotPublicKey =
    { key : String, key_id : String }


decodeDependabotPublicKey : Json.Decode.Decoder DependabotPublicKey
decodeDependabotPublicKey =
    Json.Decode.succeed (\key key_id -> { key = key, key_id = key_id })
        |> Json.Decode.Extra.andMap (Json.Decode.field "key" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "key_id" Json.Decode.string)


encodeDependabotPublicKey : DependabotPublicKey -> Json.Encode.Value
encodeDependabotPublicKey rec =
    Json.Encode.object
        [ ( "key", Json.Encode.string rec.key )
        , ( "key_id", Json.Encode.string rec.key_id )
        ]


type alias DependabotAlertSecurityVulnerability =
    { first_patched_version : Nullable { identifier : String }
    , package : DependabotAlertPackage
    , severity : String
    , vulnerable_version_range : String
    }


decodeDependabotAlertSecurityVulnerability :
    Json.Decode.Decoder DependabotAlertSecurityVulnerability
decodeDependabotAlertSecurityVulnerability =
    Json.Decode.succeed
     (\first_patched_version package severity vulnerable_version_range ->
         { first_patched_version = first_patched_version
         , package = package
         , severity = severity
         , vulnerable_version_range = vulnerable_version_range
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "first_patched_version"
                (Json.Decode.oneOf
                    [ Json.Decode.map
                        Present
                        (Json.Decode.succeed
                            (\identifier -> { identifier = identifier })
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "identifier"
                                    Json.Decode.string
                                )
                        )
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "package" decodeDependabotAlertPackage)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "severity" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "vulnerable_version_range" Json.Decode.string)


encodeDependabotAlertSecurityVulnerability :
    DependabotAlertSecurityVulnerability -> Json.Encode.Value
encodeDependabotAlertSecurityVulnerability rec =
    Json.Encode.object
        [ ( "first_patched_version"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        (\rec0 ->
                            Json.Encode.object
                                [ ( "identifier"
                                  , Json.Encode.string rec0.identifier
                                  )
                                ]
                        )
                            value
            )
                rec.first_patched_version
          )
        , ( "package", encodeDependabotAlertPackage rec.package )
        , ( "severity", Json.Encode.string rec.severity )
        , ( "vulnerable_version_range"
          , Json.Encode.string rec.vulnerable_version_range
          )
        ]


type alias DependabotAlertSecurityAdvisory =
    { cve_id : Nullable String
    , cvss : { score : Float, vector_string : Nullable String }
    , cwes : List { cwe_id : String, name : String }
    , description : String
    , ghsa_id : String
    , identifiers : List { type_ : String, value : String }
    , published_at : String
    , references : List { url : String }
    , severity : String
    , summary : String
    , updated_at : String
    , vulnerabilities : List DependabotAlertSecurityVulnerability
    , withdrawn_at : Nullable String
    }


decodeDependabotAlertSecurityAdvisory :
    Json.Decode.Decoder DependabotAlertSecurityAdvisory
decodeDependabotAlertSecurityAdvisory =
    Json.Decode.succeed
     (\cve_id cvss cwes description ghsa_id identifiers published_at references severity summary updated_at vulnerabilities withdrawn_at ->
         { cve_id = cve_id
         , cvss = cvss
         , cwes = cwes
         , description = description
         , ghsa_id = ghsa_id
         , identifiers = identifiers
         , published_at = published_at
         , references = references
         , severity = severity
         , summary = summary
         , updated_at = updated_at
         , vulnerabilities = vulnerabilities
         , withdrawn_at = withdrawn_at
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "cve_id"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "cvss"
                (Json.Decode.succeed
                  (\score vector_string ->
                      { score = score, vector_string = vector_string }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "score" Json.Decode.float)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "vector_string"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.string
                                , Json.Decode.null Null
                                ]
                            )
                        )
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "cwes"
                (Json.Decode.list
                    (Json.Decode.succeed
                      (\cwe_id name -> { cwe_id = cwe_id, name = name })
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "cwe_id" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "name" Json.Decode.string)
                    )
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "description" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "ghsa_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "identifiers"
                (Json.Decode.list
                    (Json.Decode.succeed
                      (\type_ value -> { type_ = type_, value = value })
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "type" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "value" Json.Decode.string)
                    )
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "published_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "references"
                (Json.Decode.list
                    (Json.Decode.succeed (\url -> { url = url })
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "url" Json.Decode.string)
                    )
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "severity" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "summary" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "vulnerabilities"
                (Json.Decode.list decodeDependabotAlertSecurityVulnerability)
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "withdrawn_at"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )


encodeDependabotAlertSecurityAdvisory :
    DependabotAlertSecurityAdvisory -> Json.Encode.Value
encodeDependabotAlertSecurityAdvisory rec =
    Json.Encode.object
        [ ( "cve_id"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.cve_id
          )
        , ( "cvss"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "score", Json.Encode.float rec0.score )
                    , ( "vector_string"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.string value
                        )
                            rec0.vector_string
                      )
                    ]
            )
                rec.cvss
          )
        , ( "cwes"
          , Json.Encode.list
                (\rec0 ->
                    Json.Encode.object
                        [ ( "cwe_id", Json.Encode.string rec0.cwe_id )
                        , ( "name", Json.Encode.string rec0.name )
                        ]
                )
                rec.cwes
          )
        , ( "description", Json.Encode.string rec.description )
        , ( "ghsa_id", Json.Encode.string rec.ghsa_id )
        , ( "identifiers"
          , Json.Encode.list
                (\rec0 ->
                    Json.Encode.object
                        [ ( "type", Json.Encode.string rec0.type_ )
                        , ( "value", Json.Encode.string rec0.value )
                        ]
                )
                rec.identifiers
          )
        , ( "published_at", Json.Encode.string rec.published_at )
        , ( "references"
          , Json.Encode.list
                (\rec0 ->
                    Json.Encode.object
                        [ ( "url", Json.Encode.string rec0.url ) ]
                )
                rec.references
          )
        , ( "severity", Json.Encode.string rec.severity )
        , ( "summary", Json.Encode.string rec.summary )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        , ( "vulnerabilities"
          , Json.Encode.list encodeDependabotAlertSecurityVulnerability
                rec.vulnerabilities
          )
        , ( "withdrawn_at"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.withdrawn_at
          )
        ]


type alias DependabotAlertPackage =
    { ecosystem : String, name : String }


decodeDependabotAlertPackage : Json.Decode.Decoder DependabotAlertPackage
decodeDependabotAlertPackage =
    Json.Decode.succeed
     (\ecosystem name -> { ecosystem = ecosystem, name = name })
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "ecosystem" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)


encodeDependabotAlertPackage : DependabotAlertPackage -> Json.Encode.Value
encodeDependabotAlertPackage rec =
    Json.Encode.object
        [ ( "ecosystem", Json.Encode.string rec.ecosystem )
        , ( "name", Json.Encode.string rec.name )
        ]


type alias DependabotAlert =
    { created_at : AlertCreatedAt
    , dependency :
        { manifest_path : String
        , package : DependabotAlertPackage
        , scope : Nullable String
        }
    , dismissed_at : AlertDismissedAt
    , dismissed_by : Nullable SimpleUser
    , dismissed_comment : Nullable String
    , dismissed_reason : Nullable String
    , fixed_at : AlertFixedAt
    , html_url : AlertHtmlUrl
    , number : AlertNumber
    , security_advisory : DependabotAlertSecurityAdvisory
    , security_vulnerability : DependabotAlertSecurityVulnerability
    , state : String
    , updated_at : AlertUpdatedAt
    , url : AlertUrl
    }


decodeDependabotAlert : Json.Decode.Decoder DependabotAlert
decodeDependabotAlert =
    Json.Decode.succeed
     (\created_at dependency dismissed_at dismissed_by dismissed_comment dismissed_reason fixed_at html_url number security_advisory security_vulnerability state updated_at url ->
         { created_at = created_at
         , dependency = dependency
         , dismissed_at = dismissed_at
         , dismissed_by = dismissed_by
         , dismissed_comment = dismissed_comment
         , dismissed_reason = dismissed_reason
         , fixed_at = fixed_at
         , html_url = html_url
         , number = number
         , security_advisory = security_advisory
         , security_vulnerability = security_vulnerability
         , state = state
         , updated_at = updated_at
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" decodeAlertCreatedAt)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "dependency"
                (Json.Decode.succeed
                  (\manifest_path package scope ->
                      { manifest_path = manifest_path
                      , package = package
                      , scope = scope
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "manifest_path" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "package"
                            decodeDependabotAlertPackage
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "scope"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.string
                                , Json.Decode.null Null
                                ]
                            )
                        )
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "dismissed_at" decodeAlertDismissedAt)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "dismissed_by"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "dismissed_comment"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "dismissed_reason"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "fixed_at" decodeAlertFixedAt)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" decodeAlertHtmlUrl)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "number" decodeAlertNumber)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "security_advisory"
                decodeDependabotAlertSecurityAdvisory
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "security_vulnerability"
                decodeDependabotAlertSecurityVulnerability
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "state" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" decodeAlertUpdatedAt)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" decodeAlertUrl)


encodeDependabotAlert : DependabotAlert -> Json.Encode.Value
encodeDependabotAlert rec =
    Json.Encode.object
        [ ( "created_at", encodeAlertCreatedAt rec.created_at )
        , ( "dependency"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "manifest_path", Json.Encode.string rec0.manifest_path )
                    , ( "package", encodeDependabotAlertPackage rec0.package )
                    , ( "scope"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.string value
                        )
                            rec0.scope
                      )
                    ]
            )
                rec.dependency
          )
        , ( "dismissed_at", encodeAlertDismissedAt rec.dismissed_at )
        , ( "dismissed_by"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.dismissed_by
          )
        , ( "dismissed_comment"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.dismissed_comment
          )
        , ( "dismissed_reason"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.dismissed_reason
          )
        , ( "fixed_at", encodeAlertFixedAt rec.fixed_at )
        , ( "html_url", encodeAlertHtmlUrl rec.html_url )
        , ( "number", encodeAlertNumber rec.number )
        , ( "security_advisory"
          , encodeDependabotAlertSecurityAdvisory rec.security_advisory
          )
        , ( "security_vulnerability"
          , encodeDependabotAlertSecurityVulnerability
                rec.security_vulnerability
          )
        , ( "state", Json.Encode.string rec.state )
        , ( "updated_at", encodeAlertUpdatedAt rec.updated_at )
        , ( "url", encodeAlertUrl rec.url )
        ]


type alias DemilestonedIssueEvent =
    { actor : SimpleUser
    , commit_id : Nullable String
    , commit_url : Nullable String
    , created_at : String
    , event : String
    , id : Int
    , milestone : { title : String }
    , node_id : String
    , performed_via_github_app : Nullable Integration
    , url : String
    }


decodeDemilestonedIssueEvent : Json.Decode.Decoder DemilestonedIssueEvent
decodeDemilestonedIssueEvent =
    Json.Decode.succeed
     (\actor commit_id commit_url created_at event id milestone node_id performed_via_github_app url ->
         { actor = actor
         , commit_id = commit_id
         , commit_url = commit_url
         , created_at = created_at
         , event = event
         , id = id
         , milestone = milestone
         , node_id = node_id
         , performed_via_github_app = performed_via_github_app
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap (Json.Decode.field "actor" decodeSimpleUser)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "commit_id"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "commit_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "event" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "milestone"
                (Json.Decode.succeed (\title -> { title = title })
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "title" Json.Decode.string)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "performed_via_github_app"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeIntegration
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeDemilestonedIssueEvent : DemilestonedIssueEvent -> Json.Encode.Value
encodeDemilestonedIssueEvent rec =
    Json.Encode.object
        [ ( "actor", encodeSimpleUser rec.actor )
        , ( "commit_id"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.commit_id
          )
        , ( "commit_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.commit_url
          )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "event", Json.Encode.string rec.event )
        , ( "id", Json.Encode.int rec.id )
        , ( "milestone"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "title", Json.Encode.string rec0.title ) ]
            )
                rec.milestone
          )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "performed_via_github_app"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeIntegration value
            )
                rec.performed_via_github_app
          )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias ConvertedNoteToIssueIssueEvent =
    { actor : SimpleUser
    , commit_id : Nullable String
    , commit_url : Nullable String
    , created_at : String
    , event : String
    , id : Int
    , node_id : String
    , performed_via_github_app : Integration
    , project_card :
        { column_name : String
        , id : Int
        , previous_column_name : String
        , project_id : Int
        , project_url : String
        , url : String
        }
    , url : String
    }


decodeConvertedNoteToIssueIssueEvent :
    Json.Decode.Decoder ConvertedNoteToIssueIssueEvent
decodeConvertedNoteToIssueIssueEvent =
    Json.Decode.succeed
     (\actor commit_id commit_url created_at event id node_id performed_via_github_app project_card url ->
         { actor = actor
         , commit_id = commit_id
         , commit_url = commit_url
         , created_at = created_at
         , event = event
         , id = id
         , node_id = node_id
         , performed_via_github_app = performed_via_github_app
         , project_card = project_card
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap (Json.Decode.field "actor" decodeSimpleUser)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "commit_id"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "commit_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "event" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "performed_via_github_app" decodeIntegration)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "project_card"
                (Json.Decode.succeed
                  (\column_name id previous_column_name project_id project_url url ->
                      { column_name = column_name
                      , id = id
                      , previous_column_name = previous_column_name
                      , project_id = project_id
                      , project_url = project_url
                      , url = url
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "column_name" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "id" Json.Decode.int)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "previous_column_name"
                            Json.Decode.string
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "project_id" Json.Decode.int)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "project_url" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "url" Json.Decode.string)
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeConvertedNoteToIssueIssueEvent :
    ConvertedNoteToIssueIssueEvent -> Json.Encode.Value
encodeConvertedNoteToIssueIssueEvent rec =
    Json.Encode.object
        [ ( "actor", encodeSimpleUser rec.actor )
        , ( "commit_id"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.commit_id
          )
        , ( "commit_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.commit_url
          )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "event", Json.Encode.string rec.event )
        , ( "id", Json.Encode.int rec.id )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "performed_via_github_app"
          , encodeIntegration rec.performed_via_github_app
          )
        , ( "project_card"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "column_name", Json.Encode.string rec0.column_name )
                    , ( "id", Json.Encode.int rec0.id )
                    , ( "previous_column_name"
                      , Json.Encode.string rec0.previous_column_name
                      )
                    , ( "project_id", Json.Encode.int rec0.project_id )
                    , ( "project_url", Json.Encode.string rec0.project_url )
                    , ( "url", Json.Encode.string rec0.url )
                    ]
            )
                rec.project_card
          )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias ContributorActivity =
    { author : Nullable SimpleUser
    , total : Int
    , weeks : List { a : Int, c : Int, d : Int, w : Int }
    }


decodeContributorActivity : Json.Decode.Decoder ContributorActivity
decodeContributorActivity =
    Json.Decode.succeed
     (\author total weeks -> { author = author, total = total, weeks = weeks })
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "author"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "total" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "weeks"
                (Json.Decode.list
                    (Json.Decode.succeed
                      (\a c d w -> { a = a, c = c, d = d, w = w })
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "a" Json.Decode.int)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "c" Json.Decode.int)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "d" Json.Decode.int)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "w" Json.Decode.int)
                    )
                )
            )


encodeContributorActivity : ContributorActivity -> Json.Encode.Value
encodeContributorActivity rec =
    Json.Encode.object
        [ ( "author"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.author
          )
        , ( "total", Json.Encode.int rec.total )
        , ( "weeks"
          , Json.Encode.list
                (\rec0 ->
                    Json.Encode.object
                        [ ( "a", Json.Encode.int rec0.a )
                        , ( "c", Json.Encode.int rec0.c )
                        , ( "d", Json.Encode.int rec0.d )
                        , ( "w", Json.Encode.int rec0.w )
                        ]
                )
                rec.weeks
          )
        ]


type alias Contributor =
    { avatar_url : String
    , contributions : Int
    , email : String
    , events_url : String
    , followers_url : String
    , following_url : String
    , gists_url : String
    , gravatar_id : Nullable String
    , html_url : String
    , id : Int
    , login : String
    , name : String
    , node_id : String
    , organizations_url : String
    , received_events_url : String
    , repos_url : String
    , site_admin : Bool
    , starred_url : String
    , subscriptions_url : String
    , type_ : String
    , url : String
    }


decodeContributor : Json.Decode.Decoder Contributor
decodeContributor =
    Json.Decode.succeed
     (\avatar_url contributions email events_url followers_url following_url gists_url gravatar_id html_url id login name node_id organizations_url received_events_url repos_url site_admin starred_url subscriptions_url type_ url ->
         { avatar_url = avatar_url
         , contributions = contributions
         , email = email
         , events_url = events_url
         , followers_url = followers_url
         , following_url = following_url
         , gists_url = gists_url
         , gravatar_id = gravatar_id
         , html_url = html_url
         , id = id
         , login = login
         , name = name
         , node_id = node_id
         , organizations_url = organizations_url
         , received_events_url = received_events_url
         , repos_url = repos_url
         , site_admin = site_admin
         , starred_url = starred_url
         , subscriptions_url = subscriptions_url
         , type_ = type_
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "avatar_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "contributions" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "email" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "events_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "followers_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "following_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "gists_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "gravatar_id"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "login" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "organizations_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "received_events_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "repos_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "site_admin" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "starred_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "subscriptions_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "type" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeContributor : Contributor -> Json.Encode.Value
encodeContributor rec =
    Json.Encode.object
        [ ( "avatar_url", Json.Encode.string rec.avatar_url )
        , ( "contributions", Json.Encode.int rec.contributions )
        , ( "email", Json.Encode.string rec.email )
        , ( "events_url", Json.Encode.string rec.events_url )
        , ( "followers_url", Json.Encode.string rec.followers_url )
        , ( "following_url", Json.Encode.string rec.following_url )
        , ( "gists_url", Json.Encode.string rec.gists_url )
        , ( "gravatar_id"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.gravatar_id
          )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "id", Json.Encode.int rec.id )
        , ( "login", Json.Encode.string rec.login )
        , ( "name", Json.Encode.string rec.name )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "organizations_url", Json.Encode.string rec.organizations_url )
        , ( "received_events_url", Json.Encode.string rec.received_events_url )
        , ( "repos_url", Json.Encode.string rec.repos_url )
        , ( "site_admin", Json.Encode.bool rec.site_admin )
        , ( "starred_url", Json.Encode.string rec.starred_url )
        , ( "subscriptions_url", Json.Encode.string rec.subscriptions_url )
        , ( "type", Json.Encode.string rec.type_ )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias ContentTree =
    { _links : { git : Nullable String, html : Nullable String, self : String }
    , download_url : Nullable String
    , entries :
        List { _links :
            { git : Nullable String, html : Nullable String, self : String }
        , content : String
        , download_url : Nullable String
        , git_url : Nullable String
        , html_url : Nullable String
        , name : String
        , path : String
        , sha : String
        , size : Int
        , type_ : String
        , url : String
        }
    , git_url : Nullable String
    , html_url : Nullable String
    , name : String
    , path : String
    , sha : String
    , size : Int
    , type_ : String
    , url : String
    }


decodeContentTree : Json.Decode.Decoder ContentTree
decodeContentTree =
    Json.Decode.succeed
     (\_links download_url entries git_url html_url name path sha size type_ url ->
         { _links = _links
         , download_url = download_url
         , entries = entries
         , git_url = git_url
         , html_url = html_url
         , name = name
         , path = path
         , sha = sha
         , size = size
         , type_ = type_
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "_links"
                (Json.Decode.succeed
                  (\git html self -> { git = git, html = html, self = self })
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "git"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.string
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "html"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.string
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "self" Json.Decode.string)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "download_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "entries"
                (Json.Decode.list
                    (Json.Decode.succeed
                      (\_links content download_url git_url html_url name path sha size type_ url ->
                          { _links = _links
                          , content = content
                          , download_url = download_url
                          , git_url = git_url
                          , html_url = html_url
                          , name = name
                          , path = path
                          , sha = sha
                          , size = size
                          , type_ = type_
                          , url = url
                          }
                      )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field
                                "_links"
                                (Json.Decode.succeed
                                  (\git html self ->
                                      { git = git, html = html, self = self }
                                  )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "git"
                                            (Json.Decode.oneOf
                                                [ Json.Decode.map
                                                    Present
                                                    Json.Decode.string
                                                , Json.Decode.null Null
                                                ]
                                            )
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "html"
                                            (Json.Decode.oneOf
                                                [ Json.Decode.map
                                                    Present
                                                    Json.Decode.string
                                                , Json.Decode.null Null
                                                ]
                                            )
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "self"
                                            Json.Decode.string
                                        )
                                )
                            )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "content" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field
                                "download_url"
                                (Json.Decode.oneOf
                                    [ Json.Decode.map Present Json.Decode.string
                                    , Json.Decode.null Null
                                    ]
                                )
                            )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field
                                "git_url"
                                (Json.Decode.oneOf
                                    [ Json.Decode.map Present Json.Decode.string
                                    , Json.Decode.null Null
                                    ]
                                )
                            )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field
                                "html_url"
                                (Json.Decode.oneOf
                                    [ Json.Decode.map Present Json.Decode.string
                                    , Json.Decode.null Null
                                    ]
                                )
                            )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "name" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "path" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "sha" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "size" Json.Decode.int)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "type" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "url" Json.Decode.string)
                    )
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "git_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "html_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "path" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "sha" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "size" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "type" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeContentTree : ContentTree -> Json.Encode.Value
encodeContentTree rec =
    Json.Encode.object
        [ ( "_links"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "git"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.string value
                        )
                            rec0.git
                      )
                    , ( "html"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.string value
                        )
                            rec0.html
                      )
                    , ( "self", Json.Encode.string rec0.self )
                    ]
            )
                rec._links
          )
        , ( "download_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.download_url
          )
        , ( "entries"
          , Json.Encode.list
                (\rec0 ->
                    Json.Encode.object
                        [ ( "_links"
                          , (\rec_0_1_1_1_1_0_3_1_0_0 ->
                                Json.Encode.object
                                    [ ( "git"
                                      , (\nullableValue ->
                                            case nullableValue of
                                                Null ->
                                                    Json.Encode.null

                                                Present value ->
                                                    Json.Encode.string value
                                        )
                                            rec_0_1_1_1_1_0_3_1_0_0.git
                                      )
                                    , ( "html"
                                      , (\nullableValue ->
                                            case nullableValue of
                                                Null ->
                                                    Json.Encode.null

                                                Present value ->
                                                    Json.Encode.string value
                                        )
                                            rec_0_1_1_1_1_0_3_1_0_0.html
                                      )
                                    , ( "self"
                                      , Json.Encode.string
                                            rec_0_1_1_1_1_0_3_1_0_0.self
                                      )
                                    ]
                            )
                                rec0._links
                          )
                        , ( "content", Json.Encode.string rec0.content )
                        , ( "download_url"
                          , (\nullableValue ->
                                case nullableValue of
                                    Null ->
                                        Json.Encode.null

                                    Present value ->
                                        Json.Encode.string value
                            )
                                rec0.download_url
                          )
                        , ( "git_url"
                          , (\nullableValue ->
                                case nullableValue of
                                    Null ->
                                        Json.Encode.null

                                    Present value ->
                                        Json.Encode.string value
                            )
                                rec0.git_url
                          )
                        , ( "html_url"
                          , (\nullableValue ->
                                case nullableValue of
                                    Null ->
                                        Json.Encode.null

                                    Present value ->
                                        Json.Encode.string value
                            )
                                rec0.html_url
                          )
                        , ( "name", Json.Encode.string rec0.name )
                        , ( "path", Json.Encode.string rec0.path )
                        , ( "sha", Json.Encode.string rec0.sha )
                        , ( "size", Json.Encode.int rec0.size )
                        , ( "type", Json.Encode.string rec0.type_ )
                        , ( "url", Json.Encode.string rec0.url )
                        ]
                )
                rec.entries
          )
        , ( "git_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.git_url
          )
        , ( "html_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.html_url
          )
        , ( "name", Json.Encode.string rec.name )
        , ( "path", Json.Encode.string rec.path )
        , ( "sha", Json.Encode.string rec.sha )
        , ( "size", Json.Encode.int rec.size )
        , ( "type", Json.Encode.string rec.type_ )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias ContentTraffic =
    { count : Int, path : String, title : String, uniques : Int }


decodeContentTraffic : Json.Decode.Decoder ContentTraffic
decodeContentTraffic =
    Json.Decode.succeed
     (\count path title uniques ->
         { count = count, path = path, title = title, uniques = uniques }
     )
        |> Json.Decode.Extra.andMap (Json.Decode.field "count" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "path" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "title" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "uniques" Json.Decode.int)


encodeContentTraffic : ContentTraffic -> Json.Encode.Value
encodeContentTraffic rec =
    Json.Encode.object
        [ ( "count", Json.Encode.int rec.count )
        , ( "path", Json.Encode.string rec.path )
        , ( "title", Json.Encode.string rec.title )
        , ( "uniques", Json.Encode.int rec.uniques )
        ]


type alias ContentSymlink =
    { _links : { git : Nullable String, html : Nullable String, self : String }
    , download_url : Nullable String
    , git_url : Nullable String
    , html_url : Nullable String
    , name : String
    , path : String
    , sha : String
    , size : Int
    , target : String
    , type_ : String
    , url : String
    }


decodeContentSymlink : Json.Decode.Decoder ContentSymlink
decodeContentSymlink =
    Json.Decode.succeed
     (\_links download_url git_url html_url name path sha size target type_ url ->
         { _links = _links
         , download_url = download_url
         , git_url = git_url
         , html_url = html_url
         , name = name
         , path = path
         , sha = sha
         , size = size
         , target = target
         , type_ = type_
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "_links"
                (Json.Decode.succeed
                  (\git html self -> { git = git, html = html, self = self })
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "git"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.string
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "html"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.string
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "self" Json.Decode.string)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "download_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "git_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "html_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "path" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "sha" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "size" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "target" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "type" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeContentSymlink : ContentSymlink -> Json.Encode.Value
encodeContentSymlink rec =
    Json.Encode.object
        [ ( "_links"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "git"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.string value
                        )
                            rec0.git
                      )
                    , ( "html"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.string value
                        )
                            rec0.html
                      )
                    , ( "self", Json.Encode.string rec0.self )
                    ]
            )
                rec._links
          )
        , ( "download_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.download_url
          )
        , ( "git_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.git_url
          )
        , ( "html_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.html_url
          )
        , ( "name", Json.Encode.string rec.name )
        , ( "path", Json.Encode.string rec.path )
        , ( "sha", Json.Encode.string rec.sha )
        , ( "size", Json.Encode.int rec.size )
        , ( "target", Json.Encode.string rec.target )
        , ( "type", Json.Encode.string rec.type_ )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias ContentSubmodule =
    { _links : { git : Nullable String, html : Nullable String, self : String }
    , download_url : Nullable String
    , git_url : Nullable String
    , html_url : Nullable String
    , name : String
    , path : String
    , sha : String
    , size : Int
    , submodule_git_url : String
    , type_ : String
    , url : String
    }


decodeContentSubmodule : Json.Decode.Decoder ContentSubmodule
decodeContentSubmodule =
    Json.Decode.succeed
     (\_links download_url git_url html_url name path sha size submodule_git_url type_ url ->
         { _links = _links
         , download_url = download_url
         , git_url = git_url
         , html_url = html_url
         , name = name
         , path = path
         , sha = sha
         , size = size
         , submodule_git_url = submodule_git_url
         , type_ = type_
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "_links"
                (Json.Decode.succeed
                  (\git html self -> { git = git, html = html, self = self })
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "git"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.string
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "html"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.string
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "self" Json.Decode.string)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "download_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "git_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "html_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "path" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "sha" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "size" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "submodule_git_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "type" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeContentSubmodule : ContentSubmodule -> Json.Encode.Value
encodeContentSubmodule rec =
    Json.Encode.object
        [ ( "_links"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "git"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.string value
                        )
                            rec0.git
                      )
                    , ( "html"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.string value
                        )
                            rec0.html
                      )
                    , ( "self", Json.Encode.string rec0.self )
                    ]
            )
                rec._links
          )
        , ( "download_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.download_url
          )
        , ( "git_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.git_url
          )
        , ( "html_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.html_url
          )
        , ( "name", Json.Encode.string rec.name )
        , ( "path", Json.Encode.string rec.path )
        , ( "sha", Json.Encode.string rec.sha )
        , ( "size", Json.Encode.int rec.size )
        , ( "submodule_git_url", Json.Encode.string rec.submodule_git_url )
        , ( "type", Json.Encode.string rec.type_ )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias ContentFile =
    { _links : { git : Nullable String, html : Nullable String, self : String }
    , content : String
    , download_url : Nullable String
    , encoding : String
    , git_url : Nullable String
    , html_url : Nullable String
    , name : String
    , path : String
    , sha : String
    , size : Int
    , submodule_git_url : String
    , target : String
    , type_ : String
    , url : String
    }


decodeContentFile : Json.Decode.Decoder ContentFile
decodeContentFile =
    Json.Decode.succeed
     (\_links content download_url encoding git_url html_url name path sha size submodule_git_url target type_ url ->
         { _links = _links
         , content = content
         , download_url = download_url
         , encoding = encoding
         , git_url = git_url
         , html_url = html_url
         , name = name
         , path = path
         , sha = sha
         , size = size
         , submodule_git_url = submodule_git_url
         , target = target
         , type_ = type_
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "_links"
                (Json.Decode.succeed
                  (\git html self -> { git = git, html = html, self = self })
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "git"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.string
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "html"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.string
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "self" Json.Decode.string)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "content" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "download_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "encoding" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "git_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "html_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "path" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "sha" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "size" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "submodule_git_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "target" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "type" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeContentFile : ContentFile -> Json.Encode.Value
encodeContentFile rec =
    Json.Encode.object
        [ ( "_links"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "git"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.string value
                        )
                            rec0.git
                      )
                    , ( "html"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.string value
                        )
                            rec0.html
                      )
                    , ( "self", Json.Encode.string rec0.self )
                    ]
            )
                rec._links
          )
        , ( "content", Json.Encode.string rec.content )
        , ( "download_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.download_url
          )
        , ( "encoding", Json.Encode.string rec.encoding )
        , ( "git_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.git_url
          )
        , ( "html_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.html_url
          )
        , ( "name", Json.Encode.string rec.name )
        , ( "path", Json.Encode.string rec.path )
        , ( "sha", Json.Encode.string rec.sha )
        , ( "size", Json.Encode.int rec.size )
        , ( "submodule_git_url", Json.Encode.string rec.submodule_git_url )
        , ( "target", Json.Encode.string rec.target )
        , ( "type", Json.Encode.string rec.type_ )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias ContentDirectory =
    List { _links :
        { git : Nullable String, html : Nullable String, self : String }
    , content : String
    , download_url : Nullable String
    , git_url : Nullable String
    , html_url : Nullable String
    , name : String
    , path : String
    , sha : String
    , size : Int
    , type_ : String
    , url : String
    }


decodeContentDirectory : Json.Decode.Decoder ContentDirectory
decodeContentDirectory =
    Json.Decode.list
        (Json.Decode.succeed
          (\_links content download_url git_url html_url name path sha size type_ url ->
              { _links = _links
              , content = content
              , download_url = download_url
              , git_url = git_url
              , html_url = html_url
              , name = name
              , path = path
              , sha = sha
              , size = size
              , type_ = type_
              , url = url
              }
          )
            |> Json.Decode.Extra.andMap
                (Json.Decode.field
                    "_links"
                    (Json.Decode.succeed
                      (\git html self -> { git = git, html = html, self = self }
                      )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field
                                "git"
                                (Json.Decode.oneOf
                                    [ Json.Decode.map Present Json.Decode.string
                                    , Json.Decode.null Null
                                    ]
                                )
                            )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field
                                "html"
                                (Json.Decode.oneOf
                                    [ Json.Decode.map Present Json.Decode.string
                                    , Json.Decode.null Null
                                    ]
                                )
                            )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "self" Json.Decode.string)
                    )
                )
            |> Json.Decode.Extra.andMap
                (Json.Decode.field "content" Json.Decode.string)
            |> Json.Decode.Extra.andMap
                (Json.Decode.field
                    "download_url"
                    (Json.Decode.oneOf
                        [ Json.Decode.map Present Json.Decode.string
                        , Json.Decode.null Null
                        ]
                    )
                )
            |> Json.Decode.Extra.andMap
                (Json.Decode.field
                    "git_url"
                    (Json.Decode.oneOf
                        [ Json.Decode.map Present Json.Decode.string
                        , Json.Decode.null Null
                        ]
                    )
                )
            |> Json.Decode.Extra.andMap
                (Json.Decode.field
                    "html_url"
                    (Json.Decode.oneOf
                        [ Json.Decode.map Present Json.Decode.string
                        , Json.Decode.null Null
                        ]
                    )
                )
            |> Json.Decode.Extra.andMap
                (Json.Decode.field "name" Json.Decode.string)
            |> Json.Decode.Extra.andMap
                (Json.Decode.field "path" Json.Decode.string)
            |> Json.Decode.Extra.andMap
                (Json.Decode.field "sha" Json.Decode.string)
            |> Json.Decode.Extra.andMap
                (Json.Decode.field "size" Json.Decode.int)
            |> Json.Decode.Extra.andMap
                (Json.Decode.field "type" Json.Decode.string)
            |> Json.Decode.Extra.andMap
                (Json.Decode.field "url" Json.Decode.string)
        )


encodeContentDirectory : ContentDirectory -> Json.Encode.Value
encodeContentDirectory =
    Json.Encode.list
        (\rec ->
            Json.Encode.object
                [ ( "_links"
                  , (\rec0 ->
                        Json.Encode.object
                            [ ( "git"
                              , (\nullableValue ->
                                    case nullableValue of
                                        Null ->
                                            Json.Encode.null

                                        Present value ->
                                            Json.Encode.string value
                                )
                                    rec0.git
                              )
                            , ( "html"
                              , (\nullableValue ->
                                    case nullableValue of
                                        Null ->
                                            Json.Encode.null

                                        Present value ->
                                            Json.Encode.string value
                                )
                                    rec0.html
                              )
                            , ( "self", Json.Encode.string rec0.self )
                            ]
                    )
                        rec._links
                  )
                , ( "content", Json.Encode.string rec.content )
                , ( "download_url"
                  , (\nullableValue ->
                        case nullableValue of
                            Null ->
                                Json.Encode.null

                            Present value ->
                                Json.Encode.string value
                    )
                        rec.download_url
                  )
                , ( "git_url"
                  , (\nullableValue ->
                        case nullableValue of
                            Null ->
                                Json.Encode.null

                            Present value ->
                                Json.Encode.string value
                    )
                        rec.git_url
                  )
                , ( "html_url"
                  , (\nullableValue ->
                        case nullableValue of
                            Null ->
                                Json.Encode.null

                            Present value ->
                                Json.Encode.string value
                    )
                        rec.html_url
                  )
                , ( "name", Json.Encode.string rec.name )
                , ( "path", Json.Encode.string rec.path )
                , ( "sha", Json.Encode.string rec.sha )
                , ( "size", Json.Encode.int rec.size )
                , ( "type", Json.Encode.string rec.type_ )
                , ( "url", Json.Encode.string rec.url )
                ]
        )


type alias CommunityProfile =
    { content_reports_enabled : Bool
    , description : Nullable String
    , documentation : Nullable String
    , files :
        { code_of_conduct : Nullable CodeOfConductSimple
        , code_of_conduct_file : Nullable CommunityHealthFile
        , contributing : Nullable CommunityHealthFile
        , issue_template : Nullable CommunityHealthFile
        , license : Nullable LicenseSimple
        , pull_request_template : Nullable CommunityHealthFile
        , readme : Nullable CommunityHealthFile
        }
    , health_percentage : Int
    , updated_at : Nullable String
    }


decodeCommunityProfile : Json.Decode.Decoder CommunityProfile
decodeCommunityProfile =
    Json.Decode.succeed
     (\content_reports_enabled description documentation files health_percentage updated_at ->
         { content_reports_enabled = content_reports_enabled
         , description = description
         , documentation = documentation
         , files = files
         , health_percentage = health_percentage
         , updated_at = updated_at
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "content_reports_enabled" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "description"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "documentation"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "files"
                (Json.Decode.succeed
                  (\code_of_conduct code_of_conduct_file contributing issue_template license pull_request_template readme ->
                      { code_of_conduct = code_of_conduct
                      , code_of_conduct_file = code_of_conduct_file
                      , contributing = contributing
                      , issue_template = issue_template
                      , license = license
                      , pull_request_template = pull_request_template
                      , readme = readme
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "code_of_conduct"
                            (Json.Decode.oneOf
                                [ Json.Decode.map
                                    Present
                                    decodeCodeOfConductSimple
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "code_of_conduct_file"
                            (Json.Decode.oneOf
                                [ Json.Decode.map
                                    Present
                                    decodeCommunityHealthFile
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "contributing"
                            (Json.Decode.oneOf
                                [ Json.Decode.map
                                    Present
                                    decodeCommunityHealthFile
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "issue_template"
                            (Json.Decode.oneOf
                                [ Json.Decode.map
                                    Present
                                    decodeCommunityHealthFile
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "license"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present decodeLicenseSimple
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "pull_request_template"
                            (Json.Decode.oneOf
                                [ Json.Decode.map
                                    Present
                                    decodeCommunityHealthFile
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "readme"
                            (Json.Decode.oneOf
                                [ Json.Decode.map
                                    Present
                                    decodeCommunityHealthFile
                                , Json.Decode.null Null
                                ]
                            )
                        )
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "health_percentage" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "updated_at"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )


encodeCommunityProfile : CommunityProfile -> Json.Encode.Value
encodeCommunityProfile rec =
    Json.Encode.object
        [ ( "content_reports_enabled"
          , Json.Encode.bool rec.content_reports_enabled
          )
        , ( "description"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.description
          )
        , ( "documentation"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.documentation
          )
        , ( "files"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "code_of_conduct"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    encodeCodeOfConductSimple value
                        )
                            rec0.code_of_conduct
                      )
                    , ( "code_of_conduct_file"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    encodeCommunityHealthFile value
                        )
                            rec0.code_of_conduct_file
                      )
                    , ( "contributing"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    encodeCommunityHealthFile value
                        )
                            rec0.contributing
                      )
                    , ( "issue_template"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    encodeCommunityHealthFile value
                        )
                            rec0.issue_template
                      )
                    , ( "license"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    encodeLicenseSimple value
                        )
                            rec0.license
                      )
                    , ( "pull_request_template"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    encodeCommunityHealthFile value
                        )
                            rec0.pull_request_template
                      )
                    , ( "readme"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    encodeCommunityHealthFile value
                        )
                            rec0.readme
                      )
                    ]
            )
                rec.files
          )
        , ( "health_percentage", Json.Encode.int rec.health_percentage )
        , ( "updated_at"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.updated_at
          )
        ]


type alias CommunityHealthFile =
    { html_url : String, url : String }


decodeCommunityHealthFile : Json.Decode.Decoder CommunityHealthFile
decodeCommunityHealthFile =
    Json.Decode.succeed (\html_url url -> { html_url = html_url, url = url })
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeCommunityHealthFile : CommunityHealthFile -> Json.Encode.Value
encodeCommunityHealthFile rec =
    Json.Encode.object
        [ ( "html_url", Json.Encode.string rec.html_url )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias CommitSearchResultItem =
    { author : Nullable SimpleUser
    , comments_url : String
    , commit :
        { author : { date : String, email : String, name : String }
        , comment_count : Int
        , committer : Nullable GitUser
        , message : String
        , tree : { sha : String, url : String }
        , url : String
        , verification : Verification
        }
    , committer : Nullable GitUser
    , html_url : String
    , node_id : String
    , parents : List { html_url : String, sha : String, url : String }
    , repository : MinimalRepository
    , score : Float
    , sha : String
    , text_matches : SearchResultTextMatches
    , url : String
    }


decodeCommitSearchResultItem : Json.Decode.Decoder CommitSearchResultItem
decodeCommitSearchResultItem =
    Json.Decode.succeed
     (\author comments_url commit committer html_url node_id parents repository score sha text_matches url ->
         { author = author
         , comments_url = comments_url
         , commit = commit
         , committer = committer
         , html_url = html_url
         , node_id = node_id
         , parents = parents
         , repository = repository
         , score = score
         , sha = sha
         , text_matches = text_matches
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "author"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "comments_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "commit"
                (Json.Decode.succeed
                  (\author comment_count committer message tree url verification ->
                      { author = author
                      , comment_count = comment_count
                      , committer = committer
                      , message = message
                      , tree = tree
                      , url = url
                      , verification = verification
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "author"
                            (Json.Decode.succeed
                              (\date email name ->
                                  { date = date, email = email, name = name }
                              )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field "date" Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field
                                        "email"
                                        Json.Decode.string
                                    )
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field "name" Json.Decode.string
                                    )
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "comment_count" Json.Decode.int)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "committer"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present decodeGitUser
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "message" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "tree"
                            (Json.Decode.succeed
                              (\sha url -> { sha = sha, url = url })
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field "sha" Json.Decode.string)
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field "url" Json.Decode.string)
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "url" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "verification" decodeVerification)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "committer"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeGitUser
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "parents"
                (Json.Decode.list
                    (Json.Decode.succeed
                      (\html_url sha url ->
                          { html_url = html_url, sha = sha, url = url }
                      )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "html_url" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "sha" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "url" Json.Decode.string)
                    )
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "repository" decodeMinimalRepository)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "score" Json.Decode.float)
        |> Json.Decode.Extra.andMap (Json.Decode.field "sha" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "text_matches" decodeSearchResultTextMatches)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeCommitSearchResultItem : CommitSearchResultItem -> Json.Encode.Value
encodeCommitSearchResultItem rec =
    Json.Encode.object
        [ ( "author"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.author
          )
        , ( "comments_url", Json.Encode.string rec.comments_url )
        , ( "commit"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "author"
                      , (\rec_0_1_1_1_0_3_1_0_0 ->
                            Json.Encode.object
                                [ ( "date"
                                  , Json.Encode.string
                                        rec_0_1_1_1_0_3_1_0_0.date
                                  )
                                , ( "email"
                                  , Json.Encode.string
                                        rec_0_1_1_1_0_3_1_0_0.email
                                  )
                                , ( "name"
                                  , Json.Encode.string
                                        rec_0_1_1_1_0_3_1_0_0.name
                                  )
                                ]
                        )
                            rec0.author
                      )
                    , ( "comment_count", Json.Encode.int rec0.comment_count )
                    , ( "committer"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    encodeGitUser value
                        )
                            rec0.committer
                      )
                    , ( "message", Json.Encode.string rec0.message )
                    , ( "tree"
                      , (\rec_0_5_1_1_0_3_1_0_0 ->
                            Json.Encode.object
                                [ ( "sha"
                                  , Json.Encode.string rec_0_5_1_1_0_3_1_0_0.sha
                                  )
                                , ( "url"
                                  , Json.Encode.string rec_0_5_1_1_0_3_1_0_0.url
                                  )
                                ]
                        )
                            rec0.tree
                      )
                    , ( "url", Json.Encode.string rec0.url )
                    , ( "verification", encodeVerification rec0.verification )
                    ]
            )
                rec.commit
          )
        , ( "committer"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeGitUser value
            )
                rec.committer
          )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "parents"
          , Json.Encode.list
                (\rec0 ->
                    Json.Encode.object
                        [ ( "html_url", Json.Encode.string rec0.html_url )
                        , ( "sha", Json.Encode.string rec0.sha )
                        , ( "url", Json.Encode.string rec0.url )
                        ]
                )
                rec.parents
          )
        , ( "repository", encodeMinimalRepository rec.repository )
        , ( "score", Json.Encode.float rec.score )
        , ( "sha", Json.Encode.string rec.sha )
        , ( "text_matches", encodeSearchResultTextMatches rec.text_matches )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias CommitComparison =
    { ahead_by : Int
    , base_commit : Commit
    , behind_by : Int
    , commits : List Commit
    , diff_url : String
    , files : List DiffEntry
    , html_url : String
    , merge_base_commit : Commit
    , patch_url : String
    , permalink_url : String
    , status : String
    , total_commits : Int
    , url : String
    }


decodeCommitComparison : Json.Decode.Decoder CommitComparison
decodeCommitComparison =
    Json.Decode.succeed
     (\ahead_by base_commit behind_by commits diff_url files html_url merge_base_commit patch_url permalink_url status total_commits url ->
         { ahead_by = ahead_by
         , base_commit = base_commit
         , behind_by = behind_by
         , commits = commits
         , diff_url = diff_url
         , files = files
         , html_url = html_url
         , merge_base_commit = merge_base_commit
         , patch_url = patch_url
         , permalink_url = permalink_url
         , status = status
         , total_commits = total_commits
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "ahead_by" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "base_commit" decodeCommit)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "behind_by" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "commits" (Json.Decode.list decodeCommit))
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "diff_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "files" (Json.Decode.list decodeDiffEntry))
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "merge_base_commit" decodeCommit)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "patch_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "permalink_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "status" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "total_commits" Json.Decode.int)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeCommitComparison : CommitComparison -> Json.Encode.Value
encodeCommitComparison rec =
    Json.Encode.object
        [ ( "ahead_by", Json.Encode.int rec.ahead_by )
        , ( "base_commit", encodeCommit rec.base_commit )
        , ( "behind_by", Json.Encode.int rec.behind_by )
        , ( "commits", Json.Encode.list encodeCommit rec.commits )
        , ( "diff_url", Json.Encode.string rec.diff_url )
        , ( "files", Json.Encode.list encodeDiffEntry rec.files )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "merge_base_commit", encodeCommit rec.merge_base_commit )
        , ( "patch_url", Json.Encode.string rec.patch_url )
        , ( "permalink_url", Json.Encode.string rec.permalink_url )
        , ( "status", Json.Encode.string rec.status )
        , ( "total_commits", Json.Encode.int rec.total_commits )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias CommitComment =
    { author_association : AuthorAssociation
    , body : String
    , commit_id : String
    , created_at : String
    , html_url : String
    , id : Int
    , line : Nullable Int
    , node_id : String
    , path : Nullable String
    , position : Nullable Int
    , reactions : ReactionRollup
    , updated_at : String
    , url : String
    , user : Nullable SimpleUser
    }


decodeCommitComment : Json.Decode.Decoder CommitComment
decodeCommitComment =
    Json.Decode.succeed
     (\author_association body commit_id created_at html_url id line node_id path position reactions updated_at url user ->
         { author_association = author_association
         , body = body
         , commit_id = commit_id
         , created_at = created_at
         , html_url = html_url
         , id = id
         , line = line
         , node_id = node_id
         , path = path
         , position = position
         , reactions = reactions
         , updated_at = updated_at
         , url = url
         , user = user
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "author_association" decodeAuthorAssociation)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "body" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "commit_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "line"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.int
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "path"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "position"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.int
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "reactions" decodeReactionRollup)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "user"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )


encodeCommitComment : CommitComment -> Json.Encode.Value
encodeCommitComment rec =
    Json.Encode.object
        [ ( "author_association"
          , encodeAuthorAssociation rec.author_association
          )
        , ( "body", Json.Encode.string rec.body )
        , ( "commit_id", Json.Encode.string rec.commit_id )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "id", Json.Encode.int rec.id )
        , ( "line"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.int value
            )
                rec.line
          )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "path"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.path
          )
        , ( "position"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.int value
            )
                rec.position
          )
        , ( "reactions", encodeReactionRollup rec.reactions )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        , ( "url", Json.Encode.string rec.url )
        , ( "user"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.user
          )
        ]


type alias CommitActivity =
    { days : List Int, total : Int, week : Int }


decodeCommitActivity : Json.Decode.Decoder CommitActivity
decodeCommitActivity =
    Json.Decode.succeed
     (\days total week -> { days = days, total = total, week = week })
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "days" (Json.Decode.list Json.Decode.int))
        |> Json.Decode.Extra.andMap (Json.Decode.field "total" Json.Decode.int)
        |> Json.Decode.Extra.andMap (Json.Decode.field "week" Json.Decode.int)


encodeCommitActivity : CommitActivity -> Json.Encode.Value
encodeCommitActivity rec =
    Json.Encode.object
        [ ( "days", Json.Encode.list Json.Encode.int rec.days )
        , ( "total", Json.Encode.int rec.total )
        , ( "week", Json.Encode.int rec.week )
        ]


type alias Commit =
    { author : Nullable SimpleUser
    , comments_url : String
    , commit :
        { author : Nullable GitUser
        , comment_count : Int
        , committer : Nullable GitUser
        , message : String
        , tree : { sha : String, url : String }
        , url : String
        , verification : Verification
        }
    , committer : Nullable SimpleUser
    , files : List DiffEntry
    , html_url : String
    , node_id : String
    , parents : List { html_url : String, sha : String, url : String }
    , sha : String
    , stats : { additions : Int, deletions : Int, total : Int }
    , url : String
    }


decodeCommit : Json.Decode.Decoder Commit
decodeCommit =
    Json.Decode.succeed
     (\author comments_url commit committer files html_url node_id parents sha stats url ->
         { author = author
         , comments_url = comments_url
         , commit = commit
         , committer = committer
         , files = files
         , html_url = html_url
         , node_id = node_id
         , parents = parents
         , sha = sha
         , stats = stats
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "author"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "comments_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "commit"
                (Json.Decode.succeed
                  (\author comment_count committer message tree url verification ->
                      { author = author
                      , comment_count = comment_count
                      , committer = committer
                      , message = message
                      , tree = tree
                      , url = url
                      , verification = verification
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "author"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present decodeGitUser
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "comment_count" Json.Decode.int)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "committer"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present decodeGitUser
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "message" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "tree"
                            (Json.Decode.succeed
                              (\sha url -> { sha = sha, url = url })
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field "sha" Json.Decode.string)
                                |> Json.Decode.Extra.andMap
                                    (Json.Decode.field "url" Json.Decode.string)
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "url" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "verification" decodeVerification)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "committer"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "files" (Json.Decode.list decodeDiffEntry))
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "parents"
                (Json.Decode.list
                    (Json.Decode.succeed
                      (\html_url sha url ->
                          { html_url = html_url, sha = sha, url = url }
                      )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "html_url" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "sha" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "url" Json.Decode.string)
                    )
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "sha" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "stats"
                (Json.Decode.succeed
                  (\additions deletions total ->
                      { additions = additions
                      , deletions = deletions
                      , total = total
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "additions" Json.Decode.int)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "deletions" Json.Decode.int)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total" Json.Decode.int)
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeCommit : Commit -> Json.Encode.Value
encodeCommit rec =
    Json.Encode.object
        [ ( "author"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.author
          )
        , ( "comments_url", Json.Encode.string rec.comments_url )
        , ( "commit"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "author"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    encodeGitUser value
                        )
                            rec0.author
                      )
                    , ( "comment_count", Json.Encode.int rec0.comment_count )
                    , ( "committer"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    encodeGitUser value
                        )
                            rec0.committer
                      )
                    , ( "message", Json.Encode.string rec0.message )
                    , ( "tree"
                      , (\rec_0_5_1_1_0_3_1_0_0 ->
                            Json.Encode.object
                                [ ( "sha"
                                  , Json.Encode.string rec_0_5_1_1_0_3_1_0_0.sha
                                  )
                                , ( "url"
                                  , Json.Encode.string rec_0_5_1_1_0_3_1_0_0.url
                                  )
                                ]
                        )
                            rec0.tree
                      )
                    , ( "url", Json.Encode.string rec0.url )
                    , ( "verification", encodeVerification rec0.verification )
                    ]
            )
                rec.commit
          )
        , ( "committer"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.committer
          )
        , ( "files", Json.Encode.list encodeDiffEntry rec.files )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "parents"
          , Json.Encode.list
                (\rec0 ->
                    Json.Encode.object
                        [ ( "html_url", Json.Encode.string rec0.html_url )
                        , ( "sha", Json.Encode.string rec0.sha )
                        , ( "url", Json.Encode.string rec0.url )
                        ]
                )
                rec.parents
          )
        , ( "sha", Json.Encode.string rec.sha )
        , ( "stats"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "additions", Json.Encode.int rec0.additions )
                    , ( "deletions", Json.Encode.int rec0.deletions )
                    , ( "total", Json.Encode.int rec0.total )
                    ]
            )
                rec.stats
          )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias CombinedCommitStatus =
    { commit_url : String
    , repository : MinimalRepository
    , sha : String
    , state : String
    , statuses : List SimpleCommitStatus
    , total_count : Int
    , url : String
    }


decodeCombinedCommitStatus : Json.Decode.Decoder CombinedCommitStatus
decodeCombinedCommitStatus =
    Json.Decode.succeed
     (\commit_url repository sha state statuses total_count url ->
         { commit_url = commit_url
         , repository = repository
         , sha = sha
         , state = state
         , statuses = statuses
         , total_count = total_count
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "commit_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "repository" decodeMinimalRepository)
        |> Json.Decode.Extra.andMap (Json.Decode.field "sha" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "state" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "statuses"
                (Json.Decode.list decodeSimpleCommitStatus)
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "total_count" Json.Decode.int)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeCombinedCommitStatus : CombinedCommitStatus -> Json.Encode.Value
encodeCombinedCommitStatus rec =
    Json.Encode.object
        [ ( "commit_url", Json.Encode.string rec.commit_url )
        , ( "repository", encodeMinimalRepository rec.repository )
        , ( "sha", Json.Encode.string rec.sha )
        , ( "state", Json.Encode.string rec.state )
        , ( "statuses", Json.Encode.list encodeSimpleCommitStatus rec.statuses )
        , ( "total_count", Json.Encode.int rec.total_count )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias CombinedBillingUsage =
    { days_left_in_billing_cycle : Int
    , estimated_paid_storage_for_month : Int
    , estimated_storage_for_month : Int
    }


decodeCombinedBillingUsage : Json.Decode.Decoder CombinedBillingUsage
decodeCombinedBillingUsage =
    Json.Decode.succeed
     (\days_left_in_billing_cycle estimated_paid_storage_for_month estimated_storage_for_month ->
         { days_left_in_billing_cycle = days_left_in_billing_cycle
         , estimated_paid_storage_for_month = estimated_paid_storage_for_month
         , estimated_storage_for_month = estimated_storage_for_month
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "days_left_in_billing_cycle" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "estimated_paid_storage_for_month"
                Json.Decode.int
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "estimated_storage_for_month" Json.Decode.int)


encodeCombinedBillingUsage : CombinedBillingUsage -> Json.Encode.Value
encodeCombinedBillingUsage rec =
    Json.Encode.object
        [ ( "days_left_in_billing_cycle"
          , Json.Encode.int rec.days_left_in_billing_cycle
          )
        , ( "estimated_paid_storage_for_month"
          , Json.Encode.int rec.estimated_paid_storage_for_month
          )
        , ( "estimated_storage_for_month"
          , Json.Encode.int rec.estimated_storage_for_month
          )
        ]


type alias Collaborator =
    { avatar_url : String
    , email : Nullable String
    , events_url : String
    , followers_url : String
    , following_url : String
    , gists_url : String
    , gravatar_id : Nullable String
    , html_url : String
    , id : Int
    , login : String
    , name : Nullable String
    , node_id : String
    , organizations_url : String
    , permissions :
        { admin : Bool
        , maintain : Bool
        , pull : Bool
        , push : Bool
        , triage : Bool
        }
    , received_events_url : String
    , repos_url : String
    , role_name : String
    , site_admin : Bool
    , starred_url : String
    , subscriptions_url : String
    , type_ : String
    , url : String
    }


decodeCollaborator : Json.Decode.Decoder Collaborator
decodeCollaborator =
    Json.Decode.succeed
     (\avatar_url email events_url followers_url following_url gists_url gravatar_id html_url id login name node_id organizations_url permissions received_events_url repos_url role_name site_admin starred_url subscriptions_url type_ url ->
         { avatar_url = avatar_url
         , email = email
         , events_url = events_url
         , followers_url = followers_url
         , following_url = following_url
         , gists_url = gists_url
         , gravatar_id = gravatar_id
         , html_url = html_url
         , id = id
         , login = login
         , name = name
         , node_id = node_id
         , organizations_url = organizations_url
         , permissions = permissions
         , received_events_url = received_events_url
         , repos_url = repos_url
         , role_name = role_name
         , site_admin = site_admin
         , starred_url = starred_url
         , subscriptions_url = subscriptions_url
         , type_ = type_
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "avatar_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "email"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "events_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "followers_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "following_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "gists_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "gravatar_id"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "login" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "name"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "organizations_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "permissions"
                (Json.Decode.succeed
                  (\admin maintain pull push triage ->
                      { admin = admin
                      , maintain = maintain
                      , pull = pull
                      , push = push
                      , triage = triage
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "admin" Json.Decode.bool)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "maintain" Json.Decode.bool)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "pull" Json.Decode.bool)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "push" Json.Decode.bool)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "triage" Json.Decode.bool)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "received_events_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "repos_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "role_name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "site_admin" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "starred_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "subscriptions_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "type" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeCollaborator : Collaborator -> Json.Encode.Value
encodeCollaborator rec =
    Json.Encode.object
        [ ( "avatar_url", Json.Encode.string rec.avatar_url )
        , ( "email"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.email
          )
        , ( "events_url", Json.Encode.string rec.events_url )
        , ( "followers_url", Json.Encode.string rec.followers_url )
        , ( "following_url", Json.Encode.string rec.following_url )
        , ( "gists_url", Json.Encode.string rec.gists_url )
        , ( "gravatar_id"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.gravatar_id
          )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "id", Json.Encode.int rec.id )
        , ( "login", Json.Encode.string rec.login )
        , ( "name"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.name
          )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "organizations_url", Json.Encode.string rec.organizations_url )
        , ( "permissions"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "admin", Json.Encode.bool rec0.admin )
                    , ( "maintain", Json.Encode.bool rec0.maintain )
                    , ( "pull", Json.Encode.bool rec0.pull )
                    , ( "push", Json.Encode.bool rec0.push )
                    , ( "triage", Json.Encode.bool rec0.triage )
                    ]
            )
                rec.permissions
          )
        , ( "received_events_url", Json.Encode.string rec.received_events_url )
        , ( "repos_url", Json.Encode.string rec.repos_url )
        , ( "role_name", Json.Encode.string rec.role_name )
        , ( "site_admin", Json.Encode.bool rec.site_admin )
        , ( "starred_url", Json.Encode.string rec.starred_url )
        , ( "subscriptions_url", Json.Encode.string rec.subscriptions_url )
        , ( "type", Json.Encode.string rec.type_ )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias CodespacesUserPublicKey =
    { key : String, key_id : String }


decodeCodespacesUserPublicKey : Json.Decode.Decoder CodespacesUserPublicKey
decodeCodespacesUserPublicKey =
    Json.Decode.succeed (\key key_id -> { key = key, key_id = key_id })
        |> Json.Decode.Extra.andMap (Json.Decode.field "key" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "key_id" Json.Decode.string)


encodeCodespacesUserPublicKey : CodespacesUserPublicKey -> Json.Encode.Value
encodeCodespacesUserPublicKey rec =
    Json.Encode.object
        [ ( "key", Json.Encode.string rec.key )
        , ( "key_id", Json.Encode.string rec.key_id )
        ]


type alias CodespacesSecret =
    { created_at : String
    , name : String
    , selected_repositories_url : String
    , updated_at : String
    , visibility : String
    }


decodeCodespacesSecret : Json.Decode.Decoder CodespacesSecret
decodeCodespacesSecret =
    Json.Decode.succeed
     (\created_at name selected_repositories_url updated_at visibility ->
         { created_at = created_at
         , name = name
         , selected_repositories_url = selected_repositories_url
         , updated_at = updated_at
         , visibility = visibility
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "selected_repositories_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "visibility" Json.Decode.string)


encodeCodespacesSecret : CodespacesSecret -> Json.Encode.Value
encodeCodespacesSecret rec =
    Json.Encode.object
        [ ( "created_at", Json.Encode.string rec.created_at )
        , ( "name", Json.Encode.string rec.name )
        , ( "selected_repositories_url"
          , Json.Encode.string rec.selected_repositories_url
          )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        , ( "visibility", Json.Encode.string rec.visibility )
        ]


type alias CodespacesPublicKey =
    { created_at : String
    , id : Int
    , key : String
    , key_id : String
    , title : String
    , url : String
    }


decodeCodespacesPublicKey : Json.Decode.Decoder CodespacesPublicKey
decodeCodespacesPublicKey =
    Json.Decode.succeed
     (\created_at id key key_id title url ->
         { created_at = created_at
         , id = id
         , key = key
         , key_id = key_id
         , title = title
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap (Json.Decode.field "key" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "key_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "title" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeCodespacesPublicKey : CodespacesPublicKey -> Json.Encode.Value
encodeCodespacesPublicKey rec =
    Json.Encode.object
        [ ( "created_at", Json.Encode.string rec.created_at )
        , ( "id", Json.Encode.int rec.id )
        , ( "key", Json.Encode.string rec.key )
        , ( "key_id", Json.Encode.string rec.key_id )
        , ( "title", Json.Encode.string rec.title )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias CodespacesOrgSecret =
    { created_at : String
    , name : String
    , selected_repositories_url : String
    , updated_at : String
    , visibility : String
    }


decodeCodespacesOrgSecret : Json.Decode.Decoder CodespacesOrgSecret
decodeCodespacesOrgSecret =
    Json.Decode.succeed
     (\created_at name selected_repositories_url updated_at visibility ->
         { created_at = created_at
         , name = name
         , selected_repositories_url = selected_repositories_url
         , updated_at = updated_at
         , visibility = visibility
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "selected_repositories_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "visibility" Json.Decode.string)


encodeCodespacesOrgSecret : CodespacesOrgSecret -> Json.Encode.Value
encodeCodespacesOrgSecret rec =
    Json.Encode.object
        [ ( "created_at", Json.Encode.string rec.created_at )
        , ( "name", Json.Encode.string rec.name )
        , ( "selected_repositories_url"
          , Json.Encode.string rec.selected_repositories_url
          )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        , ( "visibility", Json.Encode.string rec.visibility )
        ]


type alias CodespaceMachine =
    { cpus : Int
    , display_name : String
    , memory_in_bytes : Int
    , name : String
    , operating_system : String
    , prebuild_availability : Nullable String
    , storage_in_bytes : Int
    }


decodeCodespaceMachine : Json.Decode.Decoder CodespaceMachine
decodeCodespaceMachine =
    Json.Decode.succeed
     (\cpus display_name memory_in_bytes name operating_system prebuild_availability storage_in_bytes ->
         { cpus = cpus
         , display_name = display_name
         , memory_in_bytes = memory_in_bytes
         , name = name
         , operating_system = operating_system
         , prebuild_availability = prebuild_availability
         , storage_in_bytes = storage_in_bytes
         }
     )
        |> Json.Decode.Extra.andMap (Json.Decode.field "cpus" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "display_name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "memory_in_bytes" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "operating_system" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "prebuild_availability"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "storage_in_bytes" Json.Decode.int)


encodeCodespaceMachine : CodespaceMachine -> Json.Encode.Value
encodeCodespaceMachine rec =
    Json.Encode.object
        [ ( "cpus", Json.Encode.int rec.cpus )
        , ( "display_name", Json.Encode.string rec.display_name )
        , ( "memory_in_bytes", Json.Encode.int rec.memory_in_bytes )
        , ( "name", Json.Encode.string rec.name )
        , ( "operating_system", Json.Encode.string rec.operating_system )
        , ( "prebuild_availability"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.prebuild_availability
          )
        , ( "storage_in_bytes", Json.Encode.int rec.storage_in_bytes )
        ]


type alias CodespaceExportDetails =
    { branch : Nullable String
    , completed_at : Nullable String
    , export_url : String
    , html_url : Nullable String
    , id : String
    , sha : Nullable String
    , state : Nullable String
    }


decodeCodespaceExportDetails : Json.Decode.Decoder CodespaceExportDetails
decodeCodespaceExportDetails =
    Json.Decode.succeed
     (\branch completed_at export_url html_url id sha state ->
         { branch = branch
         , completed_at = completed_at
         , export_url = export_url
         , html_url = html_url
         , id = id
         , sha = sha
         , state = state
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "branch"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "completed_at"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "export_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "html_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "sha"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "state"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )


encodeCodespaceExportDetails : CodespaceExportDetails -> Json.Encode.Value
encodeCodespaceExportDetails rec =
    Json.Encode.object
        [ ( "branch"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.branch
          )
        , ( "completed_at"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.completed_at
          )
        , ( "export_url", Json.Encode.string rec.export_url )
        , ( "html_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.html_url
          )
        , ( "id", Json.Encode.string rec.id )
        , ( "sha"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.sha
          )
        , ( "state"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.state
          )
        ]


type alias Codespace =
    { billable_owner : SimpleUser
    , created_at : String
    , devcontainer_path : Nullable String
    , display_name : Nullable String
    , environment_id : Nullable String
    , git_status :
        { ahead : Int
        , behind : Int
        , has_uncommitted_changes : Bool
        , has_unpushed_changes : Bool
        , ref : String
        }
    , id : Int
    , idle_timeout_minutes : Nullable Int
    , idle_timeout_notice : Nullable String
    , last_known_stop_notice : Nullable String
    , last_used_at : String
    , location : String
    , machine : Nullable CodespaceMachine
    , machines_url : String
    , name : String
    , owner : SimpleUser
    , pending_operation : Nullable Bool
    , pending_operation_disabled_reason : Nullable String
    , prebuild : Nullable Bool
    , pulls_url : Nullable String
    , recent_folders : List String
    , repository : MinimalRepository
    , retention_expires_at : Nullable String
    , retention_period_minutes : Nullable Int
    , runtime_constraints :
        { allowed_port_privacy_settings : Nullable (List String) }
    , start_url : String
    , state : String
    , stop_url : String
    , updated_at : String
    , url : String
    , web_url : String
    }


decodeCodespace : Json.Decode.Decoder Codespace
decodeCodespace =
    Json.Decode.succeed
     (\billable_owner created_at devcontainer_path display_name environment_id git_status id idle_timeout_minutes idle_timeout_notice last_known_stop_notice last_used_at location machine machines_url name owner pending_operation pending_operation_disabled_reason prebuild pulls_url recent_folders repository retention_expires_at retention_period_minutes runtime_constraints start_url state stop_url updated_at url web_url ->
         { billable_owner = billable_owner
         , created_at = created_at
         , devcontainer_path = devcontainer_path
         , display_name = display_name
         , environment_id = environment_id
         , git_status = git_status
         , id = id
         , idle_timeout_minutes = idle_timeout_minutes
         , idle_timeout_notice = idle_timeout_notice
         , last_known_stop_notice = last_known_stop_notice
         , last_used_at = last_used_at
         , location = location
         , machine = machine
         , machines_url = machines_url
         , name = name
         , owner = owner
         , pending_operation = pending_operation
         , pending_operation_disabled_reason = pending_operation_disabled_reason
         , prebuild = prebuild
         , pulls_url = pulls_url
         , recent_folders = recent_folders
         , repository = repository
         , retention_expires_at = retention_expires_at
         , retention_period_minutes = retention_period_minutes
         , runtime_constraints = runtime_constraints
         , start_url = start_url
         , state = state
         , stop_url = stop_url
         , updated_at = updated_at
         , url = url
         , web_url = web_url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "billable_owner" decodeSimpleUser)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "devcontainer_path"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "display_name"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "environment_id"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "git_status"
                (Json.Decode.succeed
                  (\ahead behind has_uncommitted_changes has_unpushed_changes ref ->
                      { ahead = ahead
                      , behind = behind
                      , has_uncommitted_changes = has_uncommitted_changes
                      , has_unpushed_changes = has_unpushed_changes
                      , ref = ref
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "ahead" Json.Decode.int)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "behind" Json.Decode.int)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "has_uncommitted_changes"
                            Json.Decode.bool
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "has_unpushed_changes"
                            Json.Decode.bool
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "ref" Json.Decode.string)
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "idle_timeout_minutes"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.int
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "idle_timeout_notice"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "last_known_stop_notice"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "last_used_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "location" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "machine"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeCodespaceMachine
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "machines_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "owner" decodeSimpleUser)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "pending_operation"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.bool
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "pending_operation_disabled_reason"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "prebuild"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.bool
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "pulls_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "recent_folders"
                (Json.Decode.list Json.Decode.string)
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "repository" decodeMinimalRepository)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "retention_expires_at"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "retention_period_minutes"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.int
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "runtime_constraints"
                (Json.Decode.succeed
                    (\allowed_port_privacy_settings ->
                        { allowed_port_privacy_settings =
                            allowed_port_privacy_settings
                        }
                    )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "allowed_port_privacy_settings"
                            (Json.Decode.oneOf
                                [ Json.Decode.map
                                    Present
                                    (Json.Decode.list Json.Decode.string)
                                , Json.Decode.null Null
                                ]
                            )
                        )
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "start_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "state" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "stop_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "web_url" Json.Decode.string)


encodeCodespace : Codespace -> Json.Encode.Value
encodeCodespace rec =
    Json.Encode.object
        [ ( "billable_owner", encodeSimpleUser rec.billable_owner )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "devcontainer_path"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.devcontainer_path
          )
        , ( "display_name"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.display_name
          )
        , ( "environment_id"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.environment_id
          )
        , ( "git_status"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "ahead", Json.Encode.int rec0.ahead )
                    , ( "behind", Json.Encode.int rec0.behind )
                    , ( "has_uncommitted_changes"
                      , Json.Encode.bool rec0.has_uncommitted_changes
                      )
                    , ( "has_unpushed_changes"
                      , Json.Encode.bool rec0.has_unpushed_changes
                      )
                    , ( "ref", Json.Encode.string rec0.ref )
                    ]
            )
                rec.git_status
          )
        , ( "id", Json.Encode.int rec.id )
        , ( "idle_timeout_minutes"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.int value
            )
                rec.idle_timeout_minutes
          )
        , ( "idle_timeout_notice"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.idle_timeout_notice
          )
        , ( "last_known_stop_notice"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.last_known_stop_notice
          )
        , ( "last_used_at", Json.Encode.string rec.last_used_at )
        , ( "location", Json.Encode.string rec.location )
        , ( "machine"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeCodespaceMachine value
            )
                rec.machine
          )
        , ( "machines_url", Json.Encode.string rec.machines_url )
        , ( "name", Json.Encode.string rec.name )
        , ( "owner", encodeSimpleUser rec.owner )
        , ( "pending_operation"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.bool value
            )
                rec.pending_operation
          )
        , ( "pending_operation_disabled_reason"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.pending_operation_disabled_reason
          )
        , ( "prebuild"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.bool value
            )
                rec.prebuild
          )
        , ( "pulls_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.pulls_url
          )
        , ( "recent_folders"
          , Json.Encode.list Json.Encode.string rec.recent_folders
          )
        , ( "repository", encodeMinimalRepository rec.repository )
        , ( "retention_expires_at"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.retention_expires_at
          )
        , ( "retention_period_minutes"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.int value
            )
                rec.retention_period_minutes
          )
        , ( "runtime_constraints"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "allowed_port_privacy_settings"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.list Json.Encode.string value
                        )
                            rec0.allowed_port_privacy_settings
                      )
                    ]
            )
                rec.runtime_constraints
          )
        , ( "start_url", Json.Encode.string rec.start_url )
        , ( "state", Json.Encode.string rec.state )
        , ( "stop_url", Json.Encode.string rec.stop_url )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        , ( "url", Json.Encode.string rec.url )
        , ( "web_url", Json.Encode.string rec.web_url )
        ]


type alias CodeownersErrors =
    { errors :
        List { column : Int
        , kind : String
        , line : Int
        , message : String
        , path : String
        , source : String
        , suggestion : Nullable String
        }
    }


decodeCodeownersErrors : Json.Decode.Decoder CodeownersErrors
decodeCodeownersErrors =
    Json.Decode.succeed (\errors -> { errors = errors })
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "errors"
                (Json.Decode.list
                    (Json.Decode.succeed
                      (\column kind line message path source suggestion ->
                          { column = column
                          , kind = kind
                          , line = line
                          , message = message
                          , path = path
                          , source = source
                          , suggestion = suggestion
                          }
                      )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "column" Json.Decode.int)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "kind" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "line" Json.Decode.int)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "message" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "path" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "source" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field
                                "suggestion"
                                (Json.Decode.oneOf
                                    [ Json.Decode.map Present Json.Decode.string
                                    , Json.Decode.null Null
                                    ]
                                )
                            )
                    )
                )
            )


encodeCodeownersErrors : CodeownersErrors -> Json.Encode.Value
encodeCodeownersErrors rec =
    Json.Encode.object
        [ ( "errors"
          , Json.Encode.list
                (\rec0 ->
                    Json.Encode.object
                        [ ( "column", Json.Encode.int rec0.column )
                        , ( "kind", Json.Encode.string rec0.kind )
                        , ( "line", Json.Encode.int rec0.line )
                        , ( "message", Json.Encode.string rec0.message )
                        , ( "path", Json.Encode.string rec0.path )
                        , ( "source", Json.Encode.string rec0.source )
                        , ( "suggestion"
                          , (\nullableValue ->
                                case nullableValue of
                                    Null ->
                                        Json.Encode.null

                                    Present value ->
                                        Json.Encode.string value
                            )
                                rec0.suggestion
                          )
                        ]
                )
                rec.errors
          )
        ]


type alias CodeSearchResultItem =
    { file_size : Int
    , git_url : String
    , html_url : String
    , language : Nullable String
    , last_modified_at : String
    , line_numbers : List String
    , name : String
    , path : String
    , repository : MinimalRepository
    , score : Float
    , sha : String
    , text_matches : SearchResultTextMatches
    , url : String
    }


decodeCodeSearchResultItem : Json.Decode.Decoder CodeSearchResultItem
decodeCodeSearchResultItem =
    Json.Decode.succeed
     (\file_size git_url html_url language last_modified_at line_numbers name path repository score sha text_matches url ->
         { file_size = file_size
         , git_url = git_url
         , html_url = html_url
         , language = language
         , last_modified_at = last_modified_at
         , line_numbers = line_numbers
         , name = name
         , path = path
         , repository = repository
         , score = score
         , sha = sha
         , text_matches = text_matches
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "file_size" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "git_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "language"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "last_modified_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "line_numbers"
                (Json.Decode.list Json.Decode.string)
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "path" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "repository" decodeMinimalRepository)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "score" Json.Decode.float)
        |> Json.Decode.Extra.andMap (Json.Decode.field "sha" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "text_matches" decodeSearchResultTextMatches)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeCodeSearchResultItem : CodeSearchResultItem -> Json.Encode.Value
encodeCodeSearchResultItem rec =
    Json.Encode.object
        [ ( "file_size", Json.Encode.int rec.file_size )
        , ( "git_url", Json.Encode.string rec.git_url )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "language"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.language
          )
        , ( "last_modified_at", Json.Encode.string rec.last_modified_at )
        , ( "line_numbers"
          , Json.Encode.list Json.Encode.string rec.line_numbers
          )
        , ( "name", Json.Encode.string rec.name )
        , ( "path", Json.Encode.string rec.path )
        , ( "repository", encodeMinimalRepository rec.repository )
        , ( "score", Json.Encode.float rec.score )
        , ( "sha", Json.Encode.string rec.sha )
        , ( "text_matches", encodeSearchResultTextMatches rec.text_matches )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias CodeScanningSarifsStatus =
    { analyses_url : Nullable String
    , errors : Nullable (List String)
    , processing_status : String
    }


decodeCodeScanningSarifsStatus : Json.Decode.Decoder CodeScanningSarifsStatus
decodeCodeScanningSarifsStatus =
    Json.Decode.succeed
     (\analyses_url errors processing_status ->
         { analyses_url = analyses_url
         , errors = errors
         , processing_status = processing_status
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "analyses_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "errors"
                (Json.Decode.oneOf
                    [ Json.Decode.map
                        Present
                        (Json.Decode.list Json.Decode.string)
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "processing_status" Json.Decode.string)


encodeCodeScanningSarifsStatus : CodeScanningSarifsStatus -> Json.Encode.Value
encodeCodeScanningSarifsStatus rec =
    Json.Encode.object
        [ ( "analyses_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.analyses_url
          )
        , ( "errors"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.list Json.Encode.string value
            )
                rec.errors
          )
        , ( "processing_status", Json.Encode.string rec.processing_status )
        ]


type alias CodeScanningSarifsReceipt =
    { id : CodeScanningAnalysisSarifId, url : String }


decodeCodeScanningSarifsReceipt : Json.Decode.Decoder CodeScanningSarifsReceipt
decodeCodeScanningSarifsReceipt =
    Json.Decode.succeed (\id url -> { id = id, url = url })
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "id" decodeCodeScanningAnalysisSarifId)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeCodeScanningSarifsReceipt : CodeScanningSarifsReceipt -> Json.Encode.Value
encodeCodeScanningSarifsReceipt rec =
    Json.Encode.object
        [ ( "id", encodeCodeScanningAnalysisSarifId rec.id )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias CodeScanningRef =
    String


decodeCodeScanningRef : Json.Decode.Decoder CodeScanningRef
decodeCodeScanningRef =
    Json.Decode.string


encodeCodeScanningRef : CodeScanningRef -> Json.Encode.Value
encodeCodeScanningRef =
    Json.Encode.string


type alias CodeScanningOrganizationAlertItems =
    { created_at : AlertCreatedAt
    , dismissed_at : AlertDismissedAt
    , dismissed_by : Nullable SimpleUser
    , dismissed_comment : CodeScanningAlertDismissedComment
    , dismissed_reason : CodeScanningAlertDismissedReason
    , fixed_at : AlertFixedAt
    , html_url : AlertHtmlUrl
    , instances_url : AlertInstancesUrl
    , most_recent_instance : CodeScanningAlertInstance
    , number : AlertNumber
    , repository : SimpleRepository
    , rule : CodeScanningAlertRule
    , state : CodeScanningAlertState
    , tool : CodeScanningAnalysisTool
    , updated_at : AlertUpdatedAt
    , url : AlertUrl
    }


decodeCodeScanningOrganizationAlertItems :
    Json.Decode.Decoder CodeScanningOrganizationAlertItems
decodeCodeScanningOrganizationAlertItems =
    Json.Decode.succeed
     (\created_at dismissed_at dismissed_by dismissed_comment dismissed_reason fixed_at html_url instances_url most_recent_instance number repository rule state tool updated_at url ->
         { created_at = created_at
         , dismissed_at = dismissed_at
         , dismissed_by = dismissed_by
         , dismissed_comment = dismissed_comment
         , dismissed_reason = dismissed_reason
         , fixed_at = fixed_at
         , html_url = html_url
         , instances_url = instances_url
         , most_recent_instance = most_recent_instance
         , number = number
         , repository = repository
         , rule = rule
         , state = state
         , tool = tool
         , updated_at = updated_at
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" decodeAlertCreatedAt)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "dismissed_at" decodeAlertDismissedAt)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "dismissed_by"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "dismissed_comment"
                decodeCodeScanningAlertDismissedComment
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "dismissed_reason"
                decodeCodeScanningAlertDismissedReason
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "fixed_at" decodeAlertFixedAt)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" decodeAlertHtmlUrl)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "instances_url" decodeAlertInstancesUrl)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "most_recent_instance"
                decodeCodeScanningAlertInstance
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "number" decodeAlertNumber)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "repository" decodeSimpleRepository)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "rule" decodeCodeScanningAlertRule)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "state" decodeCodeScanningAlertState)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "tool" decodeCodeScanningAnalysisTool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" decodeAlertUpdatedAt)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" decodeAlertUrl)


encodeCodeScanningOrganizationAlertItems :
    CodeScanningOrganizationAlertItems -> Json.Encode.Value
encodeCodeScanningOrganizationAlertItems rec =
    Json.Encode.object
        [ ( "created_at", encodeAlertCreatedAt rec.created_at )
        , ( "dismissed_at", encodeAlertDismissedAt rec.dismissed_at )
        , ( "dismissed_by"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.dismissed_by
          )
        , ( "dismissed_comment"
          , encodeCodeScanningAlertDismissedComment rec.dismissed_comment
          )
        , ( "dismissed_reason"
          , encodeCodeScanningAlertDismissedReason rec.dismissed_reason
          )
        , ( "fixed_at", encodeAlertFixedAt rec.fixed_at )
        , ( "html_url", encodeAlertHtmlUrl rec.html_url )
        , ( "instances_url", encodeAlertInstancesUrl rec.instances_url )
        , ( "most_recent_instance"
          , encodeCodeScanningAlertInstance rec.most_recent_instance
          )
        , ( "number", encodeAlertNumber rec.number )
        , ( "repository", encodeSimpleRepository rec.repository )
        , ( "rule", encodeCodeScanningAlertRule rec.rule )
        , ( "state", encodeCodeScanningAlertState rec.state )
        , ( "tool", encodeCodeScanningAnalysisTool rec.tool )
        , ( "updated_at", encodeAlertUpdatedAt rec.updated_at )
        , ( "url", encodeAlertUrl rec.url )
        ]


type alias CodeScanningCodeqlDatabase =
    { content_type : String
    , created_at : String
    , id : Int
    , language : String
    , name : String
    , size : Int
    , updated_at : String
    , uploader : SimpleUser
    , url : String
    }


decodeCodeScanningCodeqlDatabase :
    Json.Decode.Decoder CodeScanningCodeqlDatabase
decodeCodeScanningCodeqlDatabase =
    Json.Decode.succeed
     (\content_type created_at id language name size updated_at uploader url ->
         { content_type = content_type
         , created_at = created_at
         , id = id
         , language = language
         , name = name
         , size = size
         , updated_at = updated_at
         , uploader = uploader
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "content_type" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "language" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "size" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "uploader" decodeSimpleUser)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeCodeScanningCodeqlDatabase :
    CodeScanningCodeqlDatabase -> Json.Encode.Value
encodeCodeScanningCodeqlDatabase rec =
    Json.Encode.object
        [ ( "content_type", Json.Encode.string rec.content_type )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "id", Json.Encode.int rec.id )
        , ( "language", Json.Encode.string rec.language )
        , ( "name", Json.Encode.string rec.name )
        , ( "size", Json.Encode.int rec.size )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        , ( "uploader", encodeSimpleUser rec.uploader )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias CodeScanningAnalysisUrl =
    String


decodeCodeScanningAnalysisUrl : Json.Decode.Decoder CodeScanningAnalysisUrl
decodeCodeScanningAnalysisUrl =
    Json.Decode.string


encodeCodeScanningAnalysisUrl : CodeScanningAnalysisUrl -> Json.Encode.Value
encodeCodeScanningAnalysisUrl =
    Json.Encode.string


type alias CodeScanningAnalysisToolVersion =
    Nullable String


decodeCodeScanningAnalysisToolVersion :
    Json.Decode.Decoder CodeScanningAnalysisToolVersion
decodeCodeScanningAnalysisToolVersion =
    Json.Decode.oneOf
        [ Json.Decode.map Present Json.Decode.string, Json.Decode.null Null ]


encodeCodeScanningAnalysisToolVersion :
    CodeScanningAnalysisToolVersion -> Json.Encode.Value
encodeCodeScanningAnalysisToolVersion nullableValue =
    case nullableValue of
        Null ->
            Json.Encode.null

        Present value ->
            Json.Encode.string value


type alias CodeScanningAnalysisToolName =
    String


decodeCodeScanningAnalysisToolName :
    Json.Decode.Decoder CodeScanningAnalysisToolName
decodeCodeScanningAnalysisToolName =
    Json.Decode.string


encodeCodeScanningAnalysisToolName :
    CodeScanningAnalysisToolName -> Json.Encode.Value
encodeCodeScanningAnalysisToolName =
    Json.Encode.string


type alias CodeScanningAnalysisToolGuid =
    Nullable String


decodeCodeScanningAnalysisToolGuid :
    Json.Decode.Decoder CodeScanningAnalysisToolGuid
decodeCodeScanningAnalysisToolGuid =
    Json.Decode.oneOf
        [ Json.Decode.map Present Json.Decode.string, Json.Decode.null Null ]


encodeCodeScanningAnalysisToolGuid :
    CodeScanningAnalysisToolGuid -> Json.Encode.Value
encodeCodeScanningAnalysisToolGuid nullableValue =
    case nullableValue of
        Null ->
            Json.Encode.null

        Present value ->
            Json.Encode.string value


type alias CodeScanningAnalysisTool =
    { guid : CodeScanningAnalysisToolGuid
    , name : CodeScanningAnalysisToolName
    , version : CodeScanningAnalysisToolVersion
    }


decodeCodeScanningAnalysisTool : Json.Decode.Decoder CodeScanningAnalysisTool
decodeCodeScanningAnalysisTool =
    Json.Decode.succeed
     (\guid name version -> { guid = guid, name = name, version = version })
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "guid" decodeCodeScanningAnalysisToolGuid)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" decodeCodeScanningAnalysisToolName)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "version" decodeCodeScanningAnalysisToolVersion)


encodeCodeScanningAnalysisTool : CodeScanningAnalysisTool -> Json.Encode.Value
encodeCodeScanningAnalysisTool rec =
    Json.Encode.object
        [ ( "guid", encodeCodeScanningAnalysisToolGuid rec.guid )
        , ( "name", encodeCodeScanningAnalysisToolName rec.name )
        , ( "version", encodeCodeScanningAnalysisToolVersion rec.version )
        ]


type alias CodeScanningAnalysisSarifId =
    String


decodeCodeScanningAnalysisSarifId :
    Json.Decode.Decoder CodeScanningAnalysisSarifId
decodeCodeScanningAnalysisSarifId =
    Json.Decode.string


encodeCodeScanningAnalysisSarifId :
    CodeScanningAnalysisSarifId -> Json.Encode.Value
encodeCodeScanningAnalysisSarifId =
    Json.Encode.string


type alias CodeScanningAnalysisSarifFile =
    String


decodeCodeScanningAnalysisSarifFile :
    Json.Decode.Decoder CodeScanningAnalysisSarifFile
decodeCodeScanningAnalysisSarifFile =
    Json.Decode.string


encodeCodeScanningAnalysisSarifFile :
    CodeScanningAnalysisSarifFile -> Json.Encode.Value
encodeCodeScanningAnalysisSarifFile =
    Json.Encode.string


type alias CodeScanningAnalysisEnvironment =
    String


decodeCodeScanningAnalysisEnvironment :
    Json.Decode.Decoder CodeScanningAnalysisEnvironment
decodeCodeScanningAnalysisEnvironment =
    Json.Decode.string


encodeCodeScanningAnalysisEnvironment :
    CodeScanningAnalysisEnvironment -> Json.Encode.Value
encodeCodeScanningAnalysisEnvironment =
    Json.Encode.string


type alias CodeScanningAnalysisDeletion =
    { confirm_delete_url : Nullable String
    , next_analysis_url : Nullable String
    }


decodeCodeScanningAnalysisDeletion :
    Json.Decode.Decoder CodeScanningAnalysisDeletion
decodeCodeScanningAnalysisDeletion =
    Json.Decode.succeed
     (\confirm_delete_url next_analysis_url ->
         { confirm_delete_url = confirm_delete_url
         , next_analysis_url = next_analysis_url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "confirm_delete_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "next_analysis_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )


encodeCodeScanningAnalysisDeletion :
    CodeScanningAnalysisDeletion -> Json.Encode.Value
encodeCodeScanningAnalysisDeletion rec =
    Json.Encode.object
        [ ( "confirm_delete_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.confirm_delete_url
          )
        , ( "next_analysis_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.next_analysis_url
          )
        ]


type alias CodeScanningAnalysisCreatedAt =
    String


decodeCodeScanningAnalysisCreatedAt :
    Json.Decode.Decoder CodeScanningAnalysisCreatedAt
decodeCodeScanningAnalysisCreatedAt =
    Json.Decode.string


encodeCodeScanningAnalysisCreatedAt :
    CodeScanningAnalysisCreatedAt -> Json.Encode.Value
encodeCodeScanningAnalysisCreatedAt =
    Json.Encode.string


type alias CodeScanningAnalysisCommitSha =
    String


decodeCodeScanningAnalysisCommitSha :
    Json.Decode.Decoder CodeScanningAnalysisCommitSha
decodeCodeScanningAnalysisCommitSha =
    Json.Decode.string


encodeCodeScanningAnalysisCommitSha :
    CodeScanningAnalysisCommitSha -> Json.Encode.Value
encodeCodeScanningAnalysisCommitSha =
    Json.Encode.string


type alias CodeScanningAnalysisCategory =
    String


decodeCodeScanningAnalysisCategory :
    Json.Decode.Decoder CodeScanningAnalysisCategory
decodeCodeScanningAnalysisCategory =
    Json.Decode.string


encodeCodeScanningAnalysisCategory :
    CodeScanningAnalysisCategory -> Json.Encode.Value
encodeCodeScanningAnalysisCategory =
    Json.Encode.string


type alias CodeScanningAnalysisAnalysisKey =
    String


decodeCodeScanningAnalysisAnalysisKey :
    Json.Decode.Decoder CodeScanningAnalysisAnalysisKey
decodeCodeScanningAnalysisAnalysisKey =
    Json.Decode.string


encodeCodeScanningAnalysisAnalysisKey :
    CodeScanningAnalysisAnalysisKey -> Json.Encode.Value
encodeCodeScanningAnalysisAnalysisKey =
    Json.Encode.string


type alias CodeScanningAnalysis =
    { analysis_key : CodeScanningAnalysisAnalysisKey
    , category : CodeScanningAnalysisCategory
    , commit_sha : CodeScanningAnalysisCommitSha
    , created_at : CodeScanningAnalysisCreatedAt
    , deletable : Bool
    , environment : CodeScanningAnalysisEnvironment
    , error : String
    , id : Int
    , ref : CodeScanningRef
    , results_count : Int
    , rules_count : Int
    , sarif_id : CodeScanningAnalysisSarifId
    , tool : CodeScanningAnalysisTool
    , url : CodeScanningAnalysisUrl
    , warning : String
    }


decodeCodeScanningAnalysis : Json.Decode.Decoder CodeScanningAnalysis
decodeCodeScanningAnalysis =
    Json.Decode.succeed
     (\analysis_key category commit_sha created_at deletable environment error id ref results_count rules_count sarif_id tool url warning ->
         { analysis_key = analysis_key
         , category = category
         , commit_sha = commit_sha
         , created_at = created_at
         , deletable = deletable
         , environment = environment
         , error = error
         , id = id
         , ref = ref
         , results_count = results_count
         , rules_count = rules_count
         , sarif_id = sarif_id
         , tool = tool
         , url = url
         , warning = warning
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "analysis_key"
                decodeCodeScanningAnalysisAnalysisKey
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "category" decodeCodeScanningAnalysisCategory)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "commit_sha" decodeCodeScanningAnalysisCommitSha)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" decodeCodeScanningAnalysisCreatedAt)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "deletable" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "environment"
                decodeCodeScanningAnalysisEnvironment
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "error" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "ref" decodeCodeScanningRef)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "results_count" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "rules_count" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "sarif_id" decodeCodeScanningAnalysisSarifId)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "tool" decodeCodeScanningAnalysisTool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "url" decodeCodeScanningAnalysisUrl)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "warning" Json.Decode.string)


encodeCodeScanningAnalysis : CodeScanningAnalysis -> Json.Encode.Value
encodeCodeScanningAnalysis rec =
    Json.Encode.object
        [ ( "analysis_key"
          , encodeCodeScanningAnalysisAnalysisKey rec.analysis_key
          )
        , ( "category", encodeCodeScanningAnalysisCategory rec.category )
        , ( "commit_sha", encodeCodeScanningAnalysisCommitSha rec.commit_sha )
        , ( "created_at", encodeCodeScanningAnalysisCreatedAt rec.created_at )
        , ( "deletable", Json.Encode.bool rec.deletable )
        , ( "environment"
          , encodeCodeScanningAnalysisEnvironment rec.environment
          )
        , ( "error", Json.Encode.string rec.error )
        , ( "id", Json.Encode.int rec.id )
        , ( "ref", encodeCodeScanningRef rec.ref )
        , ( "results_count", Json.Encode.int rec.results_count )
        , ( "rules_count", Json.Encode.int rec.rules_count )
        , ( "sarif_id", encodeCodeScanningAnalysisSarifId rec.sarif_id )
        , ( "tool", encodeCodeScanningAnalysisTool rec.tool )
        , ( "url", encodeCodeScanningAnalysisUrl rec.url )
        , ( "warning", Json.Encode.string rec.warning )
        ]


type alias CodeScanningAlertState =
    String


decodeCodeScanningAlertState : Json.Decode.Decoder CodeScanningAlertState
decodeCodeScanningAlertState =
    Json.Decode.string


encodeCodeScanningAlertState : CodeScanningAlertState -> Json.Encode.Value
encodeCodeScanningAlertState =
    Json.Encode.string


type alias CodeScanningAlertSetState =
    String


decodeCodeScanningAlertSetState : Json.Decode.Decoder CodeScanningAlertSetState
decodeCodeScanningAlertSetState =
    Json.Decode.string


encodeCodeScanningAlertSetState : CodeScanningAlertSetState -> Json.Encode.Value
encodeCodeScanningAlertSetState =
    Json.Encode.string


type alias CodeScanningAlertRuleSummary =
    { description : String
    , id : Nullable String
    , name : String
    , severity : Nullable String
    , tags : Nullable (List String)
    }


decodeCodeScanningAlertRuleSummary :
    Json.Decode.Decoder CodeScanningAlertRuleSummary
decodeCodeScanningAlertRuleSummary =
    Json.Decode.succeed
     (\description id name severity tags ->
         { description = description
         , id = id
         , name = name
         , severity = severity
         , tags = tags
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "description" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "id"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "severity"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "tags"
                (Json.Decode.oneOf
                    [ Json.Decode.map
                        Present
                        (Json.Decode.list Json.Decode.string)
                    , Json.Decode.null Null
                    ]
                )
            )


encodeCodeScanningAlertRuleSummary :
    CodeScanningAlertRuleSummary -> Json.Encode.Value
encodeCodeScanningAlertRuleSummary rec =
    Json.Encode.object
        [ ( "description", Json.Encode.string rec.description )
        , ( "id"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.id
          )
        , ( "name", Json.Encode.string rec.name )
        , ( "severity"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.severity
          )
        , ( "tags"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.list Json.Encode.string value
            )
                rec.tags
          )
        ]


type alias CodeScanningAlertRule =
    { description : String
    , full_description : String
    , help : Nullable String
    , help_uri : Nullable String
    , id : Nullable String
    , name : String
    , security_severity_level : Nullable String
    , severity : Nullable String
    , tags : Nullable (List String)
    }


decodeCodeScanningAlertRule : Json.Decode.Decoder CodeScanningAlertRule
decodeCodeScanningAlertRule =
    Json.Decode.succeed
     (\description full_description help help_uri id name security_severity_level severity tags ->
         { description = description
         , full_description = full_description
         , help = help
         , help_uri = help_uri
         , id = id
         , name = name
         , security_severity_level = security_severity_level
         , severity = severity
         , tags = tags
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "description" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "full_description" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "help"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "help_uri"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "id"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "security_severity_level"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "severity"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "tags"
                (Json.Decode.oneOf
                    [ Json.Decode.map
                        Present
                        (Json.Decode.list Json.Decode.string)
                    , Json.Decode.null Null
                    ]
                )
            )


encodeCodeScanningAlertRule : CodeScanningAlertRule -> Json.Encode.Value
encodeCodeScanningAlertRule rec =
    Json.Encode.object
        [ ( "description", Json.Encode.string rec.description )
        , ( "full_description", Json.Encode.string rec.full_description )
        , ( "help"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.help
          )
        , ( "help_uri"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.help_uri
          )
        , ( "id"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.id
          )
        , ( "name", Json.Encode.string rec.name )
        , ( "security_severity_level"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.security_severity_level
          )
        , ( "severity"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.severity
          )
        , ( "tags"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.list Json.Encode.string value
            )
                rec.tags
          )
        ]


type alias CodeScanningAlertLocation =
    { end_column : Int
    , end_line : Int
    , path : String
    , start_column : Int
    , start_line : Int
    }


decodeCodeScanningAlertLocation : Json.Decode.Decoder CodeScanningAlertLocation
decodeCodeScanningAlertLocation =
    Json.Decode.succeed
     (\end_column end_line path start_column start_line ->
         { end_column = end_column
         , end_line = end_line
         , path = path
         , start_column = start_column
         , start_line = start_line
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "end_column" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "end_line" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "path" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "start_column" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "start_line" Json.Decode.int)


encodeCodeScanningAlertLocation : CodeScanningAlertLocation -> Json.Encode.Value
encodeCodeScanningAlertLocation rec =
    Json.Encode.object
        [ ( "end_column", Json.Encode.int rec.end_column )
        , ( "end_line", Json.Encode.int rec.end_line )
        , ( "path", Json.Encode.string rec.path )
        , ( "start_column", Json.Encode.int rec.start_column )
        , ( "start_line", Json.Encode.int rec.start_line )
        ]


type alias CodeScanningAlertItems =
    { created_at : AlertCreatedAt
    , dismissed_at : AlertDismissedAt
    , dismissed_by : Nullable SimpleUser
    , dismissed_comment : CodeScanningAlertDismissedComment
    , dismissed_reason : CodeScanningAlertDismissedReason
    , fixed_at : AlertFixedAt
    , html_url : AlertHtmlUrl
    , instances_url : AlertInstancesUrl
    , most_recent_instance : CodeScanningAlertInstance
    , number : AlertNumber
    , rule : CodeScanningAlertRuleSummary
    , state : CodeScanningAlertState
    , tool : CodeScanningAnalysisTool
    , updated_at : AlertUpdatedAt
    , url : AlertUrl
    }


decodeCodeScanningAlertItems : Json.Decode.Decoder CodeScanningAlertItems
decodeCodeScanningAlertItems =
    Json.Decode.succeed
     (\created_at dismissed_at dismissed_by dismissed_comment dismissed_reason fixed_at html_url instances_url most_recent_instance number rule state tool updated_at url ->
         { created_at = created_at
         , dismissed_at = dismissed_at
         , dismissed_by = dismissed_by
         , dismissed_comment = dismissed_comment
         , dismissed_reason = dismissed_reason
         , fixed_at = fixed_at
         , html_url = html_url
         , instances_url = instances_url
         , most_recent_instance = most_recent_instance
         , number = number
         , rule = rule
         , state = state
         , tool = tool
         , updated_at = updated_at
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" decodeAlertCreatedAt)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "dismissed_at" decodeAlertDismissedAt)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "dismissed_by"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "dismissed_comment"
                decodeCodeScanningAlertDismissedComment
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "dismissed_reason"
                decodeCodeScanningAlertDismissedReason
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "fixed_at" decodeAlertFixedAt)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" decodeAlertHtmlUrl)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "instances_url" decodeAlertInstancesUrl)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "most_recent_instance"
                decodeCodeScanningAlertInstance
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "number" decodeAlertNumber)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "rule" decodeCodeScanningAlertRuleSummary)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "state" decodeCodeScanningAlertState)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "tool" decodeCodeScanningAnalysisTool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" decodeAlertUpdatedAt)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" decodeAlertUrl)


encodeCodeScanningAlertItems : CodeScanningAlertItems -> Json.Encode.Value
encodeCodeScanningAlertItems rec =
    Json.Encode.object
        [ ( "created_at", encodeAlertCreatedAt rec.created_at )
        , ( "dismissed_at", encodeAlertDismissedAt rec.dismissed_at )
        , ( "dismissed_by"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.dismissed_by
          )
        , ( "dismissed_comment"
          , encodeCodeScanningAlertDismissedComment rec.dismissed_comment
          )
        , ( "dismissed_reason"
          , encodeCodeScanningAlertDismissedReason rec.dismissed_reason
          )
        , ( "fixed_at", encodeAlertFixedAt rec.fixed_at )
        , ( "html_url", encodeAlertHtmlUrl rec.html_url )
        , ( "instances_url", encodeAlertInstancesUrl rec.instances_url )
        , ( "most_recent_instance"
          , encodeCodeScanningAlertInstance rec.most_recent_instance
          )
        , ( "number", encodeAlertNumber rec.number )
        , ( "rule", encodeCodeScanningAlertRuleSummary rec.rule )
        , ( "state", encodeCodeScanningAlertState rec.state )
        , ( "tool", encodeCodeScanningAnalysisTool rec.tool )
        , ( "updated_at", encodeAlertUpdatedAt rec.updated_at )
        , ( "url", encodeAlertUrl rec.url )
        ]


type alias CodeScanningAlertInstance =
    { analysis_key : CodeScanningAnalysisAnalysisKey
    , category : CodeScanningAnalysisCategory
    , classifications : List CodeScanningAlertClassification
    , commit_sha : String
    , environment : CodeScanningAlertEnvironment
    , html_url : String
    , location : CodeScanningAlertLocation
    , message : { text : String }
    , ref : CodeScanningRef
    , state : CodeScanningAlertState
    }


decodeCodeScanningAlertInstance : Json.Decode.Decoder CodeScanningAlertInstance
decodeCodeScanningAlertInstance =
    Json.Decode.succeed
     (\analysis_key category classifications commit_sha environment html_url location message ref state ->
         { analysis_key = analysis_key
         , category = category
         , classifications = classifications
         , commit_sha = commit_sha
         , environment = environment
         , html_url = html_url
         , location = location
         , message = message
         , ref = ref
         , state = state
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "analysis_key"
                decodeCodeScanningAnalysisAnalysisKey
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "category" decodeCodeScanningAnalysisCategory)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "classifications"
                (Json.Decode.list decodeCodeScanningAlertClassification)
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "commit_sha" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "environment" decodeCodeScanningAlertEnvironment)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "location" decodeCodeScanningAlertLocation)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "message"
                (Json.Decode.succeed (\text -> { text = text })
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "text" Json.Decode.string)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "ref" decodeCodeScanningRef)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "state" decodeCodeScanningAlertState)


encodeCodeScanningAlertInstance : CodeScanningAlertInstance -> Json.Encode.Value
encodeCodeScanningAlertInstance rec =
    Json.Encode.object
        [ ( "analysis_key"
          , encodeCodeScanningAnalysisAnalysisKey rec.analysis_key
          )
        , ( "category", encodeCodeScanningAnalysisCategory rec.category )
        , ( "classifications"
          , Json.Encode.list encodeCodeScanningAlertClassification
                rec.classifications
          )
        , ( "commit_sha", Json.Encode.string rec.commit_sha )
        , ( "environment", encodeCodeScanningAlertEnvironment rec.environment )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "location", encodeCodeScanningAlertLocation rec.location )
        , ( "message"
          , (\rec0 ->
                Json.Encode.object [ ( "text", Json.Encode.string rec0.text ) ]
            )
                rec.message
          )
        , ( "ref", encodeCodeScanningRef rec.ref )
        , ( "state", encodeCodeScanningAlertState rec.state )
        ]


type alias CodeScanningAlertEnvironment =
    String


decodeCodeScanningAlertEnvironment :
    Json.Decode.Decoder CodeScanningAlertEnvironment
decodeCodeScanningAlertEnvironment =
    Json.Decode.string


encodeCodeScanningAlertEnvironment :
    CodeScanningAlertEnvironment -> Json.Encode.Value
encodeCodeScanningAlertEnvironment =
    Json.Encode.string


type alias CodeScanningAlertDismissedReason =
    Nullable String


decodeCodeScanningAlertDismissedReason :
    Json.Decode.Decoder CodeScanningAlertDismissedReason
decodeCodeScanningAlertDismissedReason =
    Json.Decode.oneOf
        [ Json.Decode.map Present Json.Decode.string, Json.Decode.null Null ]


encodeCodeScanningAlertDismissedReason :
    CodeScanningAlertDismissedReason -> Json.Encode.Value
encodeCodeScanningAlertDismissedReason nullableValue =
    case nullableValue of
        Null ->
            Json.Encode.null

        Present value ->
            Json.Encode.string value


type alias CodeScanningAlertDismissedComment =
    Nullable String


decodeCodeScanningAlertDismissedComment :
    Json.Decode.Decoder CodeScanningAlertDismissedComment
decodeCodeScanningAlertDismissedComment =
    Json.Decode.oneOf
        [ Json.Decode.map Present Json.Decode.string, Json.Decode.null Null ]


encodeCodeScanningAlertDismissedComment :
    CodeScanningAlertDismissedComment -> Json.Encode.Value
encodeCodeScanningAlertDismissedComment nullableValue =
    case nullableValue of
        Null ->
            Json.Encode.null

        Present value ->
            Json.Encode.string value


type alias CodeScanningAlertClassification =
    Nullable String


decodeCodeScanningAlertClassification :
    Json.Decode.Decoder CodeScanningAlertClassification
decodeCodeScanningAlertClassification =
    Json.Decode.oneOf
        [ Json.Decode.map Present Json.Decode.string, Json.Decode.null Null ]


encodeCodeScanningAlertClassification :
    CodeScanningAlertClassification -> Json.Encode.Value
encodeCodeScanningAlertClassification nullableValue =
    case nullableValue of
        Null ->
            Json.Encode.null

        Present value ->
            Json.Encode.string value


type alias CodeScanningAlert =
    { created_at : AlertCreatedAt
    , dismissed_at : AlertDismissedAt
    , dismissed_by : Nullable SimpleUser
    , dismissed_comment : CodeScanningAlertDismissedComment
    , dismissed_reason : CodeScanningAlertDismissedReason
    , fixed_at : AlertFixedAt
    , html_url : AlertHtmlUrl
    , instances_url : AlertInstancesUrl
    , most_recent_instance : CodeScanningAlertInstance
    , number : AlertNumber
    , rule : CodeScanningAlertRule
    , state : CodeScanningAlertState
    , tool : CodeScanningAnalysisTool
    , updated_at : AlertUpdatedAt
    , url : AlertUrl
    }


decodeCodeScanningAlert : Json.Decode.Decoder CodeScanningAlert
decodeCodeScanningAlert =
    Json.Decode.succeed
     (\created_at dismissed_at dismissed_by dismissed_comment dismissed_reason fixed_at html_url instances_url most_recent_instance number rule state tool updated_at url ->
         { created_at = created_at
         , dismissed_at = dismissed_at
         , dismissed_by = dismissed_by
         , dismissed_comment = dismissed_comment
         , dismissed_reason = dismissed_reason
         , fixed_at = fixed_at
         , html_url = html_url
         , instances_url = instances_url
         , most_recent_instance = most_recent_instance
         , number = number
         , rule = rule
         , state = state
         , tool = tool
         , updated_at = updated_at
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" decodeAlertCreatedAt)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "dismissed_at" decodeAlertDismissedAt)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "dismissed_by"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "dismissed_comment"
                decodeCodeScanningAlertDismissedComment
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "dismissed_reason"
                decodeCodeScanningAlertDismissedReason
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "fixed_at" decodeAlertFixedAt)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" decodeAlertHtmlUrl)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "instances_url" decodeAlertInstancesUrl)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "most_recent_instance"
                decodeCodeScanningAlertInstance
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "number" decodeAlertNumber)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "rule" decodeCodeScanningAlertRule)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "state" decodeCodeScanningAlertState)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "tool" decodeCodeScanningAnalysisTool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" decodeAlertUpdatedAt)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" decodeAlertUrl)


encodeCodeScanningAlert : CodeScanningAlert -> Json.Encode.Value
encodeCodeScanningAlert rec =
    Json.Encode.object
        [ ( "created_at", encodeAlertCreatedAt rec.created_at )
        , ( "dismissed_at", encodeAlertDismissedAt rec.dismissed_at )
        , ( "dismissed_by"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.dismissed_by
          )
        , ( "dismissed_comment"
          , encodeCodeScanningAlertDismissedComment rec.dismissed_comment
          )
        , ( "dismissed_reason"
          , encodeCodeScanningAlertDismissedReason rec.dismissed_reason
          )
        , ( "fixed_at", encodeAlertFixedAt rec.fixed_at )
        , ( "html_url", encodeAlertHtmlUrl rec.html_url )
        , ( "instances_url", encodeAlertInstancesUrl rec.instances_url )
        , ( "most_recent_instance"
          , encodeCodeScanningAlertInstance rec.most_recent_instance
          )
        , ( "number", encodeAlertNumber rec.number )
        , ( "rule", encodeCodeScanningAlertRule rec.rule )
        , ( "state", encodeCodeScanningAlertState rec.state )
        , ( "tool", encodeCodeScanningAnalysisTool rec.tool )
        , ( "updated_at", encodeAlertUpdatedAt rec.updated_at )
        , ( "url", encodeAlertUrl rec.url )
        ]


type alias CodeOfConductSimple =
    { html_url : Nullable String, key : String, name : String, url : String }


decodeCodeOfConductSimple : Json.Decode.Decoder CodeOfConductSimple
decodeCodeOfConductSimple =
    Json.Decode.succeed
     (\html_url key name url ->
         { html_url = html_url, key = key, name = name, url = url }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "html_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "key" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeCodeOfConductSimple : CodeOfConductSimple -> Json.Encode.Value
encodeCodeOfConductSimple rec =
    Json.Encode.object
        [ ( "html_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.html_url
          )
        , ( "key", Json.Encode.string rec.key )
        , ( "name", Json.Encode.string rec.name )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias CodeOfConduct =
    { body : String
    , html_url : Nullable String
    , key : String
    , name : String
    , url : String
    }


decodeCodeOfConduct : Json.Decode.Decoder CodeOfConduct
decodeCodeOfConduct =
    Json.Decode.succeed
     (\body html_url key name url ->
         { body = body, html_url = html_url, key = key, name = name, url = url }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "body" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "html_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "key" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeCodeOfConduct : CodeOfConduct -> Json.Encode.Value
encodeCodeOfConduct rec =
    Json.Encode.object
        [ ( "body", Json.Encode.string rec.body )
        , ( "html_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.html_url
          )
        , ( "key", Json.Encode.string rec.key )
        , ( "name", Json.Encode.string rec.name )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias CodeFrequencyStat =
    List Int


decodeCodeFrequencyStat : Json.Decode.Decoder CodeFrequencyStat
decodeCodeFrequencyStat =
    Json.Decode.list Json.Decode.int


encodeCodeFrequencyStat : CodeFrequencyStat -> Json.Encode.Value
encodeCodeFrequencyStat =
    Json.Encode.list Json.Encode.int


type alias CloneTraffic =
    { clones : List Traffic, count : Int, uniques : Int }


decodeCloneTraffic : Json.Decode.Decoder CloneTraffic
decodeCloneTraffic =
    Json.Decode.succeed
     (\clones count uniques ->
         { clones = clones, count = count, uniques = uniques }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "clones" (Json.Decode.list decodeTraffic))
        |> Json.Decode.Extra.andMap (Json.Decode.field "count" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "uniques" Json.Decode.int)


encodeCloneTraffic : CloneTraffic -> Json.Encode.Value
encodeCloneTraffic rec =
    Json.Encode.object
        [ ( "clones", Json.Encode.list encodeTraffic rec.clones )
        , ( "count", Json.Encode.int rec.count )
        , ( "uniques", Json.Encode.int rec.uniques )
        ]


type alias CheckSuitePreference =
    { preferences :
        { auto_trigger_checks : List { app_id : Int, setting : Bool } }
    , repository : MinimalRepository
    }


decodeCheckSuitePreference : Json.Decode.Decoder CheckSuitePreference
decodeCheckSuitePreference =
    Json.Decode.succeed
     (\preferences repository ->
         { preferences = preferences, repository = repository }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "preferences"
                (Json.Decode.succeed
                    (\auto_trigger_checks ->
                        { auto_trigger_checks = auto_trigger_checks }
                    )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "auto_trigger_checks"
                            (Json.Decode.list
                                (Json.Decode.succeed
                                  (\app_id setting ->
                                      { app_id = app_id, setting = setting }
                                  )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "app_id"
                                            Json.Decode.int
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "setting"
                                            Json.Decode.bool
                                        )
                                )
                            )
                        )
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "repository" decodeMinimalRepository)


encodeCheckSuitePreference : CheckSuitePreference -> Json.Encode.Value
encodeCheckSuitePreference rec =
    Json.Encode.object
        [ ( "preferences"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "auto_trigger_checks"
                      , Json.Encode.list
                            (\rec_1_0_1_1_1_0_1_1_0_0 ->
                                Json.Encode.object
                                    [ ( "app_id"
                                      , Json.Encode.int
                                            rec_1_0_1_1_1_0_1_1_0_0.app_id
                                      )
                                    , ( "setting"
                                      , Json.Encode.bool
                                            rec_1_0_1_1_1_0_1_1_0_0.setting
                                      )
                                    ]
                            )
                            rec0.auto_trigger_checks
                      )
                    ]
            )
                rec.preferences
          )
        , ( "repository", encodeMinimalRepository rec.repository )
        ]


type alias CheckSuite =
    { after : Nullable String
    , app : Nullable Integration
    , before : Nullable String
    , check_runs_url : String
    , conclusion : Nullable String
    , created_at : Nullable String
    , head_branch : Nullable String
    , head_commit : SimpleCommit
    , head_sha : String
    , id : Int
    , latest_check_runs_count : Int
    , node_id : String
    , pull_requests : Nullable (List PullRequestMinimal)
    , repository : MinimalRepository
    , rerequestable : Bool
    , runs_rerequestable : Bool
    , status : Nullable String
    , updated_at : Nullable String
    , url : Nullable String
    }


decodeCheckSuite : Json.Decode.Decoder CheckSuite
decodeCheckSuite =
    Json.Decode.succeed
     (\after app before check_runs_url conclusion created_at head_branch head_commit head_sha id latest_check_runs_count node_id pull_requests repository rerequestable runs_rerequestable status updated_at url ->
         { after = after
         , app = app
         , before = before
         , check_runs_url = check_runs_url
         , conclusion = conclusion
         , created_at = created_at
         , head_branch = head_branch
         , head_commit = head_commit
         , head_sha = head_sha
         , id = id
         , latest_check_runs_count = latest_check_runs_count
         , node_id = node_id
         , pull_requests = pull_requests
         , repository = repository
         , rerequestable = rerequestable
         , runs_rerequestable = runs_rerequestable
         , status = status
         , updated_at = updated_at
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "after"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "app"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeIntegration
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "before"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "check_runs_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "conclusion"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "created_at"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "head_branch"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "head_commit" decodeSimpleCommit)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "head_sha" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "latest_check_runs_count" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "pull_requests"
                (Json.Decode.oneOf
                    [ Json.Decode.map
                        Present
                        (Json.Decode.list decodePullRequestMinimal)
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "repository" decodeMinimalRepository)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "rerequestable" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "runs_rerequestable" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "status"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "updated_at"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )


encodeCheckSuite : CheckSuite -> Json.Encode.Value
encodeCheckSuite rec =
    Json.Encode.object
        [ ( "after"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.after
          )
        , ( "app"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeIntegration value
            )
                rec.app
          )
        , ( "before"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.before
          )
        , ( "check_runs_url", Json.Encode.string rec.check_runs_url )
        , ( "conclusion"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.conclusion
          )
        , ( "created_at"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.created_at
          )
        , ( "head_branch"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.head_branch
          )
        , ( "head_commit", encodeSimpleCommit rec.head_commit )
        , ( "head_sha", Json.Encode.string rec.head_sha )
        , ( "id", Json.Encode.int rec.id )
        , ( "latest_check_runs_count"
          , Json.Encode.int rec.latest_check_runs_count
          )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "pull_requests"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.list encodePullRequestMinimal value
            )
                rec.pull_requests
          )
        , ( "repository", encodeMinimalRepository rec.repository )
        , ( "rerequestable", Json.Encode.bool rec.rerequestable )
        , ( "runs_rerequestable", Json.Encode.bool rec.runs_rerequestable )
        , ( "status"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.status
          )
        , ( "updated_at"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.updated_at
          )
        , ( "url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.url
          )
        ]


type alias CheckRun =
    { app : Nullable Integration
    , check_suite : Nullable { id : Int }
    , completed_at : Nullable String
    , conclusion : Nullable String
    , deployment : DeploymentSimple
    , details_url : Nullable String
    , external_id : Nullable String
    , head_sha : String
    , html_url : Nullable String
    , id : Int
    , name : String
    , node_id : String
    , output :
        { annotations_count : Int
        , annotations_url : String
        , summary : Nullable String
        , text : Nullable String
        , title : Nullable String
        }
    , pull_requests : List PullRequestMinimal
    , started_at : Nullable String
    , status : String
    , url : String
    }


decodeCheckRun : Json.Decode.Decoder CheckRun
decodeCheckRun =
    Json.Decode.succeed
     (\app check_suite completed_at conclusion deployment details_url external_id head_sha html_url id name node_id output pull_requests started_at status url ->
         { app = app
         , check_suite = check_suite
         , completed_at = completed_at
         , conclusion = conclusion
         , deployment = deployment
         , details_url = details_url
         , external_id = external_id
         , head_sha = head_sha
         , html_url = html_url
         , id = id
         , name = name
         , node_id = node_id
         , output = output
         , pull_requests = pull_requests
         , started_at = started_at
         , status = status
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "app"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeIntegration
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "check_suite"
                (Json.Decode.oneOf
                    [ Json.Decode.map
                        Present
                        (Json.Decode.succeed (\id -> { id = id })
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "id" Json.Decode.int)
                        )
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "completed_at"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "conclusion"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "deployment" decodeDeploymentSimple)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "details_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "external_id"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "head_sha" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "html_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "output"
                (Json.Decode.succeed
                  (\annotations_count annotations_url summary text title ->
                      { annotations_count = annotations_count
                      , annotations_url = annotations_url
                      , summary = summary
                      , text = text
                      , title = title
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "annotations_count" Json.Decode.int)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "annotations_url" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "summary"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.string
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "text"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.string
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "title"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.string
                                , Json.Decode.null Null
                                ]
                            )
                        )
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "pull_requests"
                (Json.Decode.list decodePullRequestMinimal)
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "started_at"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "status" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeCheckRun : CheckRun -> Json.Encode.Value
encodeCheckRun rec =
    Json.Encode.object
        [ ( "app"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeIntegration value
            )
                rec.app
          )
        , ( "check_suite"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        (\rec0 ->
                            Json.Encode.object
                                [ ( "id", Json.Encode.int rec0.id ) ]
                        )
                            value
            )
                rec.check_suite
          )
        , ( "completed_at"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.completed_at
          )
        , ( "conclusion"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.conclusion
          )
        , ( "deployment", encodeDeploymentSimple rec.deployment )
        , ( "details_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.details_url
          )
        , ( "external_id"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.external_id
          )
        , ( "head_sha", Json.Encode.string rec.head_sha )
        , ( "html_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.html_url
          )
        , ( "id", Json.Encode.int rec.id )
        , ( "name", Json.Encode.string rec.name )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "output"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "annotations_count"
                      , Json.Encode.int rec0.annotations_count
                      )
                    , ( "annotations_url"
                      , Json.Encode.string rec0.annotations_url
                      )
                    , ( "summary"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.string value
                        )
                            rec0.summary
                      )
                    , ( "text"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.string value
                        )
                            rec0.text
                      )
                    , ( "title"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.string value
                        )
                            rec0.title
                      )
                    ]
            )
                rec.output
          )
        , ( "pull_requests"
          , Json.Encode.list encodePullRequestMinimal rec.pull_requests
          )
        , ( "started_at"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.started_at
          )
        , ( "status", Json.Encode.string rec.status )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias CheckAnnotation =
    { annotation_level : Nullable String
    , blob_href : String
    , end_column : Nullable Int
    , end_line : Int
    , message : Nullable String
    , path : String
    , raw_details : Nullable String
    , start_column : Nullable Int
    , start_line : Int
    , title : Nullable String
    }


decodeCheckAnnotation : Json.Decode.Decoder CheckAnnotation
decodeCheckAnnotation =
    Json.Decode.succeed
     (\annotation_level blob_href end_column end_line message path raw_details start_column start_line title ->
         { annotation_level = annotation_level
         , blob_href = blob_href
         , end_column = end_column
         , end_line = end_line
         , message = message
         , path = path
         , raw_details = raw_details
         , start_column = start_column
         , start_line = start_line
         , title = title
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "annotation_level"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "blob_href" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "end_column"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.int
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "end_line" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "message"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "path" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "raw_details"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "start_column"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.int
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "start_line" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "title"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )


encodeCheckAnnotation : CheckAnnotation -> Json.Encode.Value
encodeCheckAnnotation rec =
    Json.Encode.object
        [ ( "annotation_level"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.annotation_level
          )
        , ( "blob_href", Json.Encode.string rec.blob_href )
        , ( "end_column"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.int value
            )
                rec.end_column
          )
        , ( "end_line", Json.Encode.int rec.end_line )
        , ( "message"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.message
          )
        , ( "path", Json.Encode.string rec.path )
        , ( "raw_details"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.raw_details
          )
        , ( "start_column"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.int value
            )
                rec.start_column
          )
        , ( "start_line", Json.Encode.int rec.start_line )
        , ( "title"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.title
          )
        ]


type alias BranchWithProtection =
    { _links : { html : String, self : String }
    , commit : Commit
    , name : String
    , pattern : String
    , protected : Bool
    , protection : BranchProtection
    , protection_url : String
    , required_approving_review_count : Int
    }


decodeBranchWithProtection : Json.Decode.Decoder BranchWithProtection
decodeBranchWithProtection =
    Json.Decode.succeed
     (\_links commit name pattern protected protection protection_url required_approving_review_count ->
         { _links = _links
         , commit = commit
         , name = name
         , pattern = pattern
         , protected = protected
         , protection = protection
         , protection_url = protection_url
         , required_approving_review_count = required_approving_review_count
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "_links"
                (Json.Decode.succeed
                  (\html self -> { html = html, self = self })
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "html" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "self" Json.Decode.string)
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "commit" decodeCommit)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "pattern" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "protected" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "protection" decodeBranchProtection)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "protection_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "required_approving_review_count" Json.Decode.int
            )


encodeBranchWithProtection : BranchWithProtection -> Json.Encode.Value
encodeBranchWithProtection rec =
    Json.Encode.object
        [ ( "_links"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "html", Json.Encode.string rec0.html )
                    , ( "self", Json.Encode.string rec0.self )
                    ]
            )
                rec._links
          )
        , ( "commit", encodeCommit rec.commit )
        , ( "name", Json.Encode.string rec.name )
        , ( "pattern", Json.Encode.string rec.pattern )
        , ( "protected", Json.Encode.bool rec.protected )
        , ( "protection", encodeBranchProtection rec.protection )
        , ( "protection_url", Json.Encode.string rec.protection_url )
        , ( "required_approving_review_count"
          , Json.Encode.int rec.required_approving_review_count
          )
        ]


type alias BranchShort =
    { commit : { sha : String, url : String }, name : String, protected : Bool }


decodeBranchShort : Json.Decode.Decoder BranchShort
decodeBranchShort =
    Json.Decode.succeed
     (\commit name protected ->
         { commit = commit, name = name, protected = protected }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "commit"
                (Json.Decode.succeed (\sha url -> { sha = sha, url = url })
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "sha" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "url" Json.Decode.string)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "protected" Json.Decode.bool)


encodeBranchShort : BranchShort -> Json.Encode.Value
encodeBranchShort rec =
    Json.Encode.object
        [ ( "commit"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "sha", Json.Encode.string rec0.sha )
                    , ( "url", Json.Encode.string rec0.url )
                    ]
            )
                rec.commit
          )
        , ( "name", Json.Encode.string rec.name )
        , ( "protected", Json.Encode.bool rec.protected )
        ]


type alias BranchRestrictionPolicy =
    { apps :
        List { created_at : String
        , description : String
        , events : List String
        , external_url : String
        , html_url : String
        , id : Int
        , name : String
        , node_id : String
        , owner :
            { avatar_url : String
            , description : String
            , events_url : String
            , followers_url : String
            , following_url : String
            , gists_url : String
            , gravatar_id : String
            , hooks_url : String
            , html_url : String
            , id : Int
            , issues_url : String
            , login : String
            , members_url : String
            , node_id : String
            , organizations_url : String
            , public_members_url : String
            , received_events_url : String
            , repos_url : String
            , site_admin : Bool
            , starred_url : String
            , subscriptions_url : String
            , type_ : String
            , url : String
            }
        , permissions :
            { contents : String
            , issues : String
            , metadata : String
            , single_file : String
            }
        , slug : String
        , updated_at : String
        }
    , apps_url : String
    , teams :
        List { description : Nullable String
        , html_url : String
        , id : Int
        , members_url : String
        , name : String
        , node_id : String
        , parent : Nullable String
        , permission : String
        , privacy : String
        , repositories_url : String
        , slug : String
        , url : String
        }
    , teams_url : String
    , url : String
    , users :
        List { avatar_url : String
        , events_url : String
        , followers_url : String
        , following_url : String
        , gists_url : String
        , gravatar_id : String
        , html_url : String
        , id : Int
        , login : String
        , node_id : String
        , organizations_url : String
        , received_events_url : String
        , repos_url : String
        , site_admin : Bool
        , starred_url : String
        , subscriptions_url : String
        , type_ : String
        , url : String
        }
    , users_url : String
    }


decodeBranchRestrictionPolicy : Json.Decode.Decoder BranchRestrictionPolicy
decodeBranchRestrictionPolicy =
    Json.Decode.succeed
     (\apps apps_url teams teams_url url users users_url ->
         { apps = apps
         , apps_url = apps_url
         , teams = teams
         , teams_url = teams_url
         , url = url
         , users = users
         , users_url = users_url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "apps"
                (Json.Decode.list
                    (Json.Decode.succeed
                      (\created_at description events external_url html_url id name node_id owner permissions slug updated_at ->
                          { created_at = created_at
                          , description = description
                          , events = events
                          , external_url = external_url
                          , html_url = html_url
                          , id = id
                          , name = name
                          , node_id = node_id
                          , owner = owner
                          , permissions = permissions
                          , slug = slug
                          , updated_at = updated_at
                          }
                      )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "created_at" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "description" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field
                                "events"
                                (Json.Decode.list Json.Decode.string)
                            )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "external_url" Json.Decode.string
                            )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "html_url" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "id" Json.Decode.int)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "name" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "node_id" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field
                                "owner"
                                (Json.Decode.succeed
                                  (\avatar_url description events_url followers_url following_url gists_url gravatar_id hooks_url html_url id issues_url login members_url node_id organizations_url public_members_url received_events_url repos_url site_admin starred_url subscriptions_url type_ url ->
                                      { avatar_url = avatar_url
                                      , description = description
                                      , events_url = events_url
                                      , followers_url = followers_url
                                      , following_url = following_url
                                      , gists_url = gists_url
                                      , gravatar_id = gravatar_id
                                      , hooks_url = hooks_url
                                      , html_url = html_url
                                      , id = id
                                      , issues_url = issues_url
                                      , login = login
                                      , members_url = members_url
                                      , node_id = node_id
                                      , organizations_url = organizations_url
                                      , public_members_url = public_members_url
                                      , received_events_url =
                                          received_events_url
                                      , repos_url = repos_url
                                      , site_admin = site_admin
                                      , starred_url = starred_url
                                      , subscriptions_url = subscriptions_url
                                      , type_ = type_
                                      , url = url
                                      }
                                  )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "avatar_url"
                                            Json.Decode.string
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "description"
                                            Json.Decode.string
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "events_url"
                                            Json.Decode.string
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "followers_url"
                                            Json.Decode.string
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "following_url"
                                            Json.Decode.string
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "gists_url"
                                            Json.Decode.string
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "gravatar_id"
                                            Json.Decode.string
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "hooks_url"
                                            Json.Decode.string
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "html_url"
                                            Json.Decode.string
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field "id" Json.Decode.int)
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "issues_url"
                                            Json.Decode.string
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "login"
                                            Json.Decode.string
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "members_url"
                                            Json.Decode.string
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "node_id"
                                            Json.Decode.string
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "organizations_url"
                                            Json.Decode.string
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "public_members_url"
                                            Json.Decode.string
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "received_events_url"
                                            Json.Decode.string
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "repos_url"
                                            Json.Decode.string
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "site_admin"
                                            Json.Decode.bool
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "starred_url"
                                            Json.Decode.string
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "subscriptions_url"
                                            Json.Decode.string
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "type"
                                            Json.Decode.string
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "url"
                                            Json.Decode.string
                                        )
                                )
                            )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field
                                "permissions"
                                (Json.Decode.succeed
                                  (\contents issues metadata single_file ->
                                      { contents = contents
                                      , issues = issues
                                      , metadata = metadata
                                      , single_file = single_file
                                      }
                                  )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "contents"
                                            Json.Decode.string
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "issues"
                                            Json.Decode.string
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "metadata"
                                            Json.Decode.string
                                        )
                                    |> Json.Decode.Extra.andMap
                                        (Json.Decode.field
                                            "single_file"
                                            Json.Decode.string
                                        )
                                )
                            )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "slug" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "updated_at" Json.Decode.string)
                    )
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "apps_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "teams"
                (Json.Decode.list
                    (Json.Decode.succeed
                      (\description html_url id members_url name node_id parent permission privacy repositories_url slug url ->
                          { description = description
                          , html_url = html_url
                          , id = id
                          , members_url = members_url
                          , name = name
                          , node_id = node_id
                          , parent = parent
                          , permission = permission
                          , privacy = privacy
                          , repositories_url = repositories_url
                          , slug = slug
                          , url = url
                          }
                      )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field
                                "description"
                                (Json.Decode.oneOf
                                    [ Json.Decode.map Present Json.Decode.string
                                    , Json.Decode.null Null
                                    ]
                                )
                            )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "html_url" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "id" Json.Decode.int)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "members_url" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "name" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "node_id" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field
                                "parent"
                                (Json.Decode.oneOf
                                    [ Json.Decode.map Present Json.Decode.string
                                    , Json.Decode.null Null
                                    ]
                                )
                            )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "permission" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "privacy" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field
                                "repositories_url"
                                Json.Decode.string
                            )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "slug" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "url" Json.Decode.string)
                    )
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "teams_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "users"
                (Json.Decode.list
                    (Json.Decode.succeed
                      (\avatar_url events_url followers_url following_url gists_url gravatar_id html_url id login node_id organizations_url received_events_url repos_url site_admin starred_url subscriptions_url type_ url ->
                          { avatar_url = avatar_url
                          , events_url = events_url
                          , followers_url = followers_url
                          , following_url = following_url
                          , gists_url = gists_url
                          , gravatar_id = gravatar_id
                          , html_url = html_url
                          , id = id
                          , login = login
                          , node_id = node_id
                          , organizations_url = organizations_url
                          , received_events_url = received_events_url
                          , repos_url = repos_url
                          , site_admin = site_admin
                          , starred_url = starred_url
                          , subscriptions_url = subscriptions_url
                          , type_ = type_
                          , url = url
                          }
                      )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "avatar_url" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "events_url" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field
                                "followers_url"
                                Json.Decode.string
                            )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field
                                "following_url"
                                Json.Decode.string
                            )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "gists_url" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "gravatar_id" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "html_url" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "id" Json.Decode.int)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "login" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "node_id" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field
                                "organizations_url"
                                Json.Decode.string
                            )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field
                                "received_events_url"
                                Json.Decode.string
                            )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "repos_url" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "site_admin" Json.Decode.bool)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "starred_url" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field
                                "subscriptions_url"
                                Json.Decode.string
                            )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "type" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "url" Json.Decode.string)
                    )
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "users_url" Json.Decode.string)


encodeBranchRestrictionPolicy : BranchRestrictionPolicy -> Json.Encode.Value
encodeBranchRestrictionPolicy rec =
    Json.Encode.object
        [ ( "apps"
          , Json.Encode.list
                (\rec0 ->
                    Json.Encode.object
                        [ ( "created_at", Json.Encode.string rec0.created_at )
                        , ( "description", Json.Encode.string rec0.description )
                        , ( "events"
                          , Json.Encode.list Json.Encode.string rec0.events
                          )
                        , ( "external_url"
                          , Json.Encode.string rec0.external_url
                          )
                        , ( "html_url", Json.Encode.string rec0.html_url )
                        , ( "id", Json.Encode.int rec0.id )
                        , ( "name", Json.Encode.string rec0.name )
                        , ( "node_id", Json.Encode.string rec0.node_id )
                        , ( "owner"
                          , (\rec_0_9_1_1_1_0_1_1_0_0 ->
                                Json.Encode.object
                                    [ ( "avatar_url"
                                      , Json.Encode.string
                                            rec_0_9_1_1_1_0_1_1_0_0.avatar_url
                                      )
                                    , ( "description"
                                      , Json.Encode.string
                                            rec_0_9_1_1_1_0_1_1_0_0.description
                                      )
                                    , ( "events_url"
                                      , Json.Encode.string
                                            rec_0_9_1_1_1_0_1_1_0_0.events_url
                                      )
                                    , ( "followers_url"
                                      , Json.Encode.string
                                            rec_0_9_1_1_1_0_1_1_0_0.followers_url
                                      )
                                    , ( "following_url"
                                      , Json.Encode.string
                                            rec_0_9_1_1_1_0_1_1_0_0.following_url
                                      )
                                    , ( "gists_url"
                                      , Json.Encode.string
                                            rec_0_9_1_1_1_0_1_1_0_0.gists_url
                                      )
                                    , ( "gravatar_id"
                                      , Json.Encode.string
                                            rec_0_9_1_1_1_0_1_1_0_0.gravatar_id
                                      )
                                    , ( "hooks_url"
                                      , Json.Encode.string
                                            rec_0_9_1_1_1_0_1_1_0_0.hooks_url
                                      )
                                    , ( "html_url"
                                      , Json.Encode.string
                                            rec_0_9_1_1_1_0_1_1_0_0.html_url
                                      )
                                    , ( "id"
                                      , Json.Encode.int
                                            rec_0_9_1_1_1_0_1_1_0_0.id
                                      )
                                    , ( "issues_url"
                                      , Json.Encode.string
                                            rec_0_9_1_1_1_0_1_1_0_0.issues_url
                                      )
                                    , ( "login"
                                      , Json.Encode.string
                                            rec_0_9_1_1_1_0_1_1_0_0.login
                                      )
                                    , ( "members_url"
                                      , Json.Encode.string
                                            rec_0_9_1_1_1_0_1_1_0_0.members_url
                                      )
                                    , ( "node_id"
                                      , Json.Encode.string
                                            rec_0_9_1_1_1_0_1_1_0_0.node_id
                                      )
                                    , ( "organizations_url"
                                      , Json.Encode.string
                                            rec_0_9_1_1_1_0_1_1_0_0.organizations_url
                                      )
                                    , ( "public_members_url"
                                      , Json.Encode.string
                                            rec_0_9_1_1_1_0_1_1_0_0.public_members_url
                                      )
                                    , ( "received_events_url"
                                      , Json.Encode.string
                                            rec_0_9_1_1_1_0_1_1_0_0.received_events_url
                                      )
                                    , ( "repos_url"
                                      , Json.Encode.string
                                            rec_0_9_1_1_1_0_1_1_0_0.repos_url
                                      )
                                    , ( "site_admin"
                                      , Json.Encode.bool
                                            rec_0_9_1_1_1_0_1_1_0_0.site_admin
                                      )
                                    , ( "starred_url"
                                      , Json.Encode.string
                                            rec_0_9_1_1_1_0_1_1_0_0.starred_url
                                      )
                                    , ( "subscriptions_url"
                                      , Json.Encode.string
                                            rec_0_9_1_1_1_0_1_1_0_0.subscriptions_url
                                      )
                                    , ( "type"
                                      , Json.Encode.string
                                            rec_0_9_1_1_1_0_1_1_0_0.type_
                                      )
                                    , ( "url"
                                      , Json.Encode.string
                                            rec_0_9_1_1_1_0_1_1_0_0.url
                                      )
                                    ]
                            )
                                rec0.owner
                          )
                        , ( "permissions"
                          , (\rec_0_10_1_1_1_0_1_1_0_0 ->
                                Json.Encode.object
                                    [ ( "contents"
                                      , Json.Encode.string
                                            rec_0_10_1_1_1_0_1_1_0_0.contents
                                      )
                                    , ( "issues"
                                      , Json.Encode.string
                                            rec_0_10_1_1_1_0_1_1_0_0.issues
                                      )
                                    , ( "metadata"
                                      , Json.Encode.string
                                            rec_0_10_1_1_1_0_1_1_0_0.metadata
                                      )
                                    , ( "single_file"
                                      , Json.Encode.string
                                            rec_0_10_1_1_1_0_1_1_0_0.single_file
                                      )
                                    ]
                            )
                                rec0.permissions
                          )
                        , ( "slug", Json.Encode.string rec0.slug )
                        , ( "updated_at", Json.Encode.string rec0.updated_at )
                        ]
                )
                rec.apps
          )
        , ( "apps_url", Json.Encode.string rec.apps_url )
        , ( "teams"
          , Json.Encode.list
                (\rec0 ->
                    Json.Encode.object
                        [ ( "description"
                          , (\nullableValue ->
                                case nullableValue of
                                    Null ->
                                        Json.Encode.null

                                    Present value ->
                                        Json.Encode.string value
                            )
                                rec0.description
                          )
                        , ( "html_url", Json.Encode.string rec0.html_url )
                        , ( "id", Json.Encode.int rec0.id )
                        , ( "members_url", Json.Encode.string rec0.members_url )
                        , ( "name", Json.Encode.string rec0.name )
                        , ( "node_id", Json.Encode.string rec0.node_id )
                        , ( "parent"
                          , (\nullableValue ->
                                case nullableValue of
                                    Null ->
                                        Json.Encode.null

                                    Present value ->
                                        Json.Encode.string value
                            )
                                rec0.parent
                          )
                        , ( "permission", Json.Encode.string rec0.permission )
                        , ( "privacy", Json.Encode.string rec0.privacy )
                        , ( "repositories_url"
                          , Json.Encode.string rec0.repositories_url
                          )
                        , ( "slug", Json.Encode.string rec0.slug )
                        , ( "url", Json.Encode.string rec0.url )
                        ]
                )
                rec.teams
          )
        , ( "teams_url", Json.Encode.string rec.teams_url )
        , ( "url", Json.Encode.string rec.url )
        , ( "users"
          , Json.Encode.list
                (\rec0 ->
                    Json.Encode.object
                        [ ( "avatar_url", Json.Encode.string rec0.avatar_url )
                        , ( "events_url", Json.Encode.string rec0.events_url )
                        , ( "followers_url"
                          , Json.Encode.string rec0.followers_url
                          )
                        , ( "following_url"
                          , Json.Encode.string rec0.following_url
                          )
                        , ( "gists_url", Json.Encode.string rec0.gists_url )
                        , ( "gravatar_id", Json.Encode.string rec0.gravatar_id )
                        , ( "html_url", Json.Encode.string rec0.html_url )
                        , ( "id", Json.Encode.int rec0.id )
                        , ( "login", Json.Encode.string rec0.login )
                        , ( "node_id", Json.Encode.string rec0.node_id )
                        , ( "organizations_url"
                          , Json.Encode.string rec0.organizations_url
                          )
                        , ( "received_events_url"
                          , Json.Encode.string rec0.received_events_url
                          )
                        , ( "repos_url", Json.Encode.string rec0.repos_url )
                        , ( "site_admin", Json.Encode.bool rec0.site_admin )
                        , ( "starred_url", Json.Encode.string rec0.starred_url )
                        , ( "subscriptions_url"
                          , Json.Encode.string rec0.subscriptions_url
                          )
                        , ( "type", Json.Encode.string rec0.type_ )
                        , ( "url", Json.Encode.string rec0.url )
                        ]
                )
                rec.users
          )
        , ( "users_url", Json.Encode.string rec.users_url )
        ]


type alias BranchProtection =
    { allow_deletions : { enabled : Bool }
    , allow_force_pushes : { enabled : Bool }
    , block_creations : { enabled : Bool }
    , enabled : Bool
    , enforce_admins : ProtectedBranchAdminEnforced
    , name : String
    , protection_url : String
    , required_conversation_resolution : { enabled : Bool }
    , required_linear_history : { enabled : Bool }
    , required_pull_request_reviews : ProtectedBranchPullRequestReview
    , required_signatures : { enabled : Bool, url : String }
    , required_status_checks : ProtectedBranchRequiredStatusCheck
    , restrictions : BranchRestrictionPolicy
    , url : String
    }


decodeBranchProtection : Json.Decode.Decoder BranchProtection
decodeBranchProtection =
    Json.Decode.succeed
     (\allow_deletions allow_force_pushes block_creations enabled enforce_admins name protection_url required_conversation_resolution required_linear_history required_pull_request_reviews required_signatures required_status_checks restrictions url ->
         { allow_deletions = allow_deletions
         , allow_force_pushes = allow_force_pushes
         , block_creations = block_creations
         , enabled = enabled
         , enforce_admins = enforce_admins
         , name = name
         , protection_url = protection_url
         , required_conversation_resolution = required_conversation_resolution
         , required_linear_history = required_linear_history
         , required_pull_request_reviews = required_pull_request_reviews
         , required_signatures = required_signatures
         , required_status_checks = required_status_checks
         , restrictions = restrictions
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "allow_deletions"
                (Json.Decode.succeed (\enabled -> { enabled = enabled })
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "enabled" Json.Decode.bool)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "allow_force_pushes"
                (Json.Decode.succeed (\enabled -> { enabled = enabled })
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "enabled" Json.Decode.bool)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "block_creations"
                (Json.Decode.succeed (\enabled -> { enabled = enabled })
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "enabled" Json.Decode.bool)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "enabled" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "enforce_admins"
                decodeProtectedBranchAdminEnforced
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "protection_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "required_conversation_resolution"
                (Json.Decode.succeed (\enabled -> { enabled = enabled })
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "enabled" Json.Decode.bool)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "required_linear_history"
                (Json.Decode.succeed (\enabled -> { enabled = enabled })
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "enabled" Json.Decode.bool)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "required_pull_request_reviews"
                decodeProtectedBranchPullRequestReview
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "required_signatures"
                (Json.Decode.succeed
                  (\enabled url -> { enabled = enabled, url = url })
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "enabled" Json.Decode.bool)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "url" Json.Decode.string)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "required_status_checks"
                decodeProtectedBranchRequiredStatusCheck
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "restrictions" decodeBranchRestrictionPolicy)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeBranchProtection : BranchProtection -> Json.Encode.Value
encodeBranchProtection rec =
    Json.Encode.object
        [ ( "allow_deletions"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "enabled", Json.Encode.bool rec0.enabled ) ]
            )
                rec.allow_deletions
          )
        , ( "allow_force_pushes"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "enabled", Json.Encode.bool rec0.enabled ) ]
            )
                rec.allow_force_pushes
          )
        , ( "block_creations"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "enabled", Json.Encode.bool rec0.enabled ) ]
            )
                rec.block_creations
          )
        , ( "enabled", Json.Encode.bool rec.enabled )
        , ( "enforce_admins"
          , encodeProtectedBranchAdminEnforced rec.enforce_admins
          )
        , ( "name", Json.Encode.string rec.name )
        , ( "protection_url", Json.Encode.string rec.protection_url )
        , ( "required_conversation_resolution"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "enabled", Json.Encode.bool rec0.enabled ) ]
            )
                rec.required_conversation_resolution
          )
        , ( "required_linear_history"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "enabled", Json.Encode.bool rec0.enabled ) ]
            )
                rec.required_linear_history
          )
        , ( "required_pull_request_reviews"
          , encodeProtectedBranchPullRequestReview
                rec.required_pull_request_reviews
          )
        , ( "required_signatures"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "enabled", Json.Encode.bool rec0.enabled )
                    , ( "url", Json.Encode.string rec0.url )
                    ]
            )
                rec.required_signatures
          )
        , ( "required_status_checks"
          , encodeProtectedBranchRequiredStatusCheck rec.required_status_checks
          )
        , ( "restrictions", encodeBranchRestrictionPolicy rec.restrictions )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias Blob =
    { content : String
    , encoding : String
    , highlighted_content : String
    , node_id : String
    , sha : String
    , size : Nullable Int
    , url : String
    }


decodeBlob : Json.Decode.Decoder Blob
decodeBlob =
    Json.Decode.succeed
     (\content encoding highlighted_content node_id sha size url ->
         { content = content
         , encoding = encoding
         , highlighted_content = highlighted_content
         , node_id = node_id
         , sha = sha
         , size = size
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "content" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "encoding" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "highlighted_content" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "sha" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "size"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.int
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeBlob : Blob -> Json.Encode.Value
encodeBlob rec =
    Json.Encode.object
        [ ( "content", Json.Encode.string rec.content )
        , ( "encoding", Json.Encode.string rec.encoding )
        , ( "highlighted_content", Json.Encode.string rec.highlighted_content )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "sha", Json.Encode.string rec.sha )
        , ( "size"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.int value
            )
                rec.size
          )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias BasicError =
    { documentation_url : String
    , message : String
    , status : String
    , url : String
    }


decodeBasicError : Json.Decode.Decoder BasicError
decodeBasicError =
    Json.Decode.succeed
     (\documentation_url message status url ->
         { documentation_url = documentation_url
         , message = message
         , status = status
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "documentation_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "message" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "status" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeBasicError : BasicError -> Json.Encode.Value
encodeBasicError rec =
    Json.Encode.object
        [ ( "documentation_url", Json.Encode.string rec.documentation_url )
        , ( "message", Json.Encode.string rec.message )
        , ( "status", Json.Encode.string rec.status )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias BaseGist =
    { comments : Int
    , comments_url : String
    , commits_url : String
    , created_at : String
    , description : Nullable String
    , files : {}
    , forks : List Json.Encode.Value
    , forks_url : String
    , git_pull_url : String
    , git_push_url : String
    , history : List Json.Encode.Value
    , html_url : String
    , id : String
    , node_id : String
    , owner : SimpleUser
    , public : Bool
    , truncated : Bool
    , updated_at : String
    , url : String
    , user : Nullable SimpleUser
    }


decodeBaseGist : Json.Decode.Decoder BaseGist
decodeBaseGist =
    Json.Decode.succeed
     (\comments comments_url commits_url created_at description files forks forks_url git_pull_url git_push_url history html_url id node_id owner public truncated updated_at url user ->
         { comments = comments
         , comments_url = comments_url
         , commits_url = commits_url
         , created_at = created_at
         , description = description
         , files = files
         , forks = forks
         , forks_url = forks_url
         , git_pull_url = git_pull_url
         , git_push_url = git_push_url
         , history = history
         , html_url = html_url
         , id = id
         , node_id = node_id
         , owner = owner
         , public = public
         , truncated = truncated
         , updated_at = updated_at
         , url = url
         , user = user
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "comments" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "comments_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "commits_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "description"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "files" (Json.Decode.succeed {}))
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "forks" (Json.Decode.list Json.Decode.value))
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "forks_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "git_pull_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "git_push_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "history" (Json.Decode.list Json.Decode.value))
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "html_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "owner" decodeSimpleUser)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "public" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "truncated" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "user"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )


encodeBaseGist : BaseGist -> Json.Encode.Value
encodeBaseGist rec =
    Json.Encode.object
        [ ( "comments", Json.Encode.int rec.comments )
        , ( "comments_url", Json.Encode.string rec.comments_url )
        , ( "commits_url", Json.Encode.string rec.commits_url )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "description"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.description
          )
        , ( "files", (\rec0 -> Json.Encode.object []) rec.files )
        , ( "forks", Json.Encode.list Basics.identity rec.forks )
        , ( "forks_url", Json.Encode.string rec.forks_url )
        , ( "git_pull_url", Json.Encode.string rec.git_pull_url )
        , ( "git_push_url", Json.Encode.string rec.git_push_url )
        , ( "history", Json.Encode.list Basics.identity rec.history )
        , ( "html_url", Json.Encode.string rec.html_url )
        , ( "id", Json.Encode.string rec.id )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "owner", encodeSimpleUser rec.owner )
        , ( "public", Json.Encode.bool rec.public )
        , ( "truncated", Json.Encode.bool rec.truncated )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        , ( "url", Json.Encode.string rec.url )
        , ( "user"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.user
          )
        ]


type alias Autolink =
    { id : Int
    , is_alphanumeric : Bool
    , key_prefix : String
    , url_template : String
    }


decodeAutolink : Json.Decode.Decoder Autolink
decodeAutolink =
    Json.Decode.succeed
     (\id is_alphanumeric key_prefix url_template ->
         { id = id
         , is_alphanumeric = is_alphanumeric
         , key_prefix = key_prefix
         , url_template = url_template
         }
     )
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "is_alphanumeric" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "key_prefix" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "url_template" Json.Decode.string)


encodeAutolink : Autolink -> Json.Encode.Value
encodeAutolink rec =
    Json.Encode.object
        [ ( "id", Json.Encode.int rec.id )
        , ( "is_alphanumeric", Json.Encode.bool rec.is_alphanumeric )
        , ( "key_prefix", Json.Encode.string rec.key_prefix )
        , ( "url_template", Json.Encode.string rec.url_template )
        ]


type alias AutoMerge =
    Nullable { commit_message : String
    , commit_title : String
    , enabled_by : SimpleUser
    , merge_method : String
    }


decodeAutoMerge : Json.Decode.Decoder AutoMerge
decodeAutoMerge =
    Json.Decode.oneOf
        [ Json.Decode.map
            Present
            (Json.Decode.succeed
              (\commit_message commit_title enabled_by merge_method ->
                  { commit_message = commit_message
                  , commit_title = commit_title
                  , enabled_by = enabled_by
                  , merge_method = merge_method
                  }
              )
                |> Json.Decode.Extra.andMap
                    (Json.Decode.field "commit_message" Json.Decode.string)
                |> Json.Decode.Extra.andMap
                    (Json.Decode.field "commit_title" Json.Decode.string)
                |> Json.Decode.Extra.andMap
                    (Json.Decode.field "enabled_by" decodeSimpleUser)
                |> Json.Decode.Extra.andMap
                    (Json.Decode.field "merge_method" Json.Decode.string)
            )
        , Json.Decode.null Null
        ]


encodeAutoMerge : AutoMerge -> Json.Encode.Value
encodeAutoMerge nullableValue =
    case nullableValue of
        Null ->
            Json.Encode.null

        Present value ->
            (\rec ->
                Json.Encode.object
                    [ ( "commit_message"
                      , Json.Encode.string rec.commit_message
                      )
                    , ( "commit_title", Json.Encode.string rec.commit_title )
                    , ( "enabled_by", encodeSimpleUser rec.enabled_by )
                    , ( "merge_method", Json.Encode.string rec.merge_method )
                    ]
            )
                value


type alias Authorization =
    { app : { client_id : String, name : String, url : String }
    , created_at : String
    , expires_at : Nullable String
    , fingerprint : Nullable String
    , hashed_token : Nullable String
    , id : Int
    , installation : Nullable ScopedInstallation
    , note : Nullable String
    , note_url : Nullable String
    , scopes : Nullable (List String)
    , token : String
    , token_last_eight : Nullable String
    , updated_at : String
    , url : String
    , user : Nullable SimpleUser
    }


decodeAuthorization : Json.Decode.Decoder Authorization
decodeAuthorization =
    Json.Decode.succeed
     (\app created_at expires_at fingerprint hashed_token id installation note note_url scopes token token_last_eight updated_at url user ->
         { app = app
         , created_at = created_at
         , expires_at = expires_at
         , fingerprint = fingerprint
         , hashed_token = hashed_token
         , id = id
         , installation = installation
         , note = note
         , note_url = note_url
         , scopes = scopes
         , token = token
         , token_last_eight = token_last_eight
         , updated_at = updated_at
         , url = url
         , user = user
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "app"
                (Json.Decode.succeed
                  (\client_id name url ->
                      { client_id = client_id, name = name, url = url }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "client_id" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "name" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "url" Json.Decode.string)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "expires_at"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "fingerprint"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "hashed_token"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "installation"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeScopedInstallation
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "note"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "note_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "scopes"
                (Json.Decode.oneOf
                    [ Json.Decode.map
                        Present
                        (Json.Decode.list Json.Decode.string)
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "token" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "token_last_eight"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "user"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeSimpleUser
                    , Json.Decode.null Null
                    ]
                )
            )


encodeAuthorization : Authorization -> Json.Encode.Value
encodeAuthorization rec =
    Json.Encode.object
        [ ( "app"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "client_id", Json.Encode.string rec0.client_id )
                    , ( "name", Json.Encode.string rec0.name )
                    , ( "url", Json.Encode.string rec0.url )
                    ]
            )
                rec.app
          )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "expires_at"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.expires_at
          )
        , ( "fingerprint"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.fingerprint
          )
        , ( "hashed_token"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.hashed_token
          )
        , ( "id", Json.Encode.int rec.id )
        , ( "installation"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeScopedInstallation value
            )
                rec.installation
          )
        , ( "note"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.note
          )
        , ( "note_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.note_url
          )
        , ( "scopes"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.list Json.Encode.string value
            )
                rec.scopes
          )
        , ( "token", Json.Encode.string rec.token )
        , ( "token_last_eight"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.token_last_eight
          )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        , ( "url", Json.Encode.string rec.url )
        , ( "user"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeSimpleUser value
            )
                rec.user
          )
        ]


type alias AuthorAssociation =
    String


decodeAuthorAssociation : Json.Decode.Decoder AuthorAssociation
decodeAuthorAssociation =
    Json.Decode.string


encodeAuthorAssociation : AuthorAssociation -> Json.Encode.Value
encodeAuthorAssociation =
    Json.Encode.string


type alias AuthenticationToken =
    { expires_at : String
    , permissions : {}
    , repositories : List Repository
    , repository_selection : String
    , single_file : Nullable String
    , token : String
    }


decodeAuthenticationToken : Json.Decode.Decoder AuthenticationToken
decodeAuthenticationToken =
    Json.Decode.succeed
     (\expires_at permissions repositories repository_selection single_file token ->
         { expires_at = expires_at
         , permissions = permissions
         , repositories = repositories
         , repository_selection = repository_selection
         , single_file = single_file
         , token = token
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "expires_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "permissions" (Json.Decode.succeed {}))
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "repositories"
                (Json.Decode.list decodeRepository)
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "repository_selection" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "single_file"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "token" Json.Decode.string)


encodeAuthenticationToken : AuthenticationToken -> Json.Encode.Value
encodeAuthenticationToken rec =
    Json.Encode.object
        [ ( "expires_at", Json.Encode.string rec.expires_at )
        , ( "permissions", (\rec0 -> Json.Encode.object []) rec.permissions )
        , ( "repositories", Json.Encode.list encodeRepository rec.repositories )
        , ( "repository_selection"
          , Json.Encode.string rec.repository_selection
          )
        , ( "single_file"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.single_file
          )
        , ( "token", Json.Encode.string rec.token )
        ]


type alias AssignedIssueEvent =
    { actor : SimpleUser
    , assignee : SimpleUser
    , assigner : SimpleUser
    , commit_id : Nullable String
    , commit_url : Nullable String
    , created_at : String
    , event : String
    , id : Int
    , node_id : String
    , performed_via_github_app : Integration
    , url : String
    }


decodeAssignedIssueEvent : Json.Decode.Decoder AssignedIssueEvent
decodeAssignedIssueEvent =
    Json.Decode.succeed
     (\actor assignee assigner commit_id commit_url created_at event id node_id performed_via_github_app url ->
         { actor = actor
         , assignee = assignee
         , assigner = assigner
         , commit_id = commit_id
         , commit_url = commit_url
         , created_at = created_at
         , event = event
         , id = id
         , node_id = node_id
         , performed_via_github_app = performed_via_github_app
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap (Json.Decode.field "actor" decodeSimpleUser)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "assignee" decodeSimpleUser)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "assigner" decodeSimpleUser)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "commit_id"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "commit_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "event" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "performed_via_github_app" decodeIntegration)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeAssignedIssueEvent : AssignedIssueEvent -> Json.Encode.Value
encodeAssignedIssueEvent rec =
    Json.Encode.object
        [ ( "actor", encodeSimpleUser rec.actor )
        , ( "assignee", encodeSimpleUser rec.assignee )
        , ( "assigner", encodeSimpleUser rec.assigner )
        , ( "commit_id"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.commit_id
          )
        , ( "commit_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.commit_url
          )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "event", Json.Encode.string rec.event )
        , ( "id", Json.Encode.int rec.id )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "performed_via_github_app"
          , encodeIntegration rec.performed_via_github_app
          )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias Artifact =
    { archive_download_url : String
    , created_at : Nullable String
    , expired : Bool
    , expires_at : Nullable String
    , id : Int
    , name : String
    , node_id : String
    , size_in_bytes : Int
    , updated_at : Nullable String
    , url : String
    , workflow_run :
        Nullable { head_branch : String
        , head_repository_id : Int
        , head_sha : String
        , id : Int
        , repository_id : Int
        }
    }


decodeArtifact : Json.Decode.Decoder Artifact
decodeArtifact =
    Json.Decode.succeed
     (\archive_download_url created_at expired expires_at id name node_id size_in_bytes updated_at url workflow_run ->
         { archive_download_url = archive_download_url
         , created_at = created_at
         , expired = expired
         , expires_at = expires_at
         , id = id
         , name = name
         , node_id = node_id
         , size_in_bytes = size_in_bytes
         , updated_at = updated_at
         , url = url
         , workflow_run = workflow_run
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "archive_download_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "created_at"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "expired" Json.Decode.bool)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "expires_at"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "size_in_bytes" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "updated_at"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "workflow_run"
                (Json.Decode.oneOf
                    [ Json.Decode.map
                        Present
                        (Json.Decode.succeed
                          (\head_branch head_repository_id head_sha id repository_id ->
                              { head_branch = head_branch
                              , head_repository_id = head_repository_id
                              , head_sha = head_sha
                              , id = id
                              , repository_id = repository_id
                              }
                          )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "head_branch"
                                    Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "head_repository_id"
                                    Json.Decode.int
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "head_sha" Json.Decode.string
                                )
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field "id" Json.Decode.int)
                            |> Json.Decode.Extra.andMap
                                (Json.Decode.field
                                    "repository_id"
                                    Json.Decode.int
                                )
                        )
                    , Json.Decode.null Null
                    ]
                )
            )


encodeArtifact : Artifact -> Json.Encode.Value
encodeArtifact rec =
    Json.Encode.object
        [ ( "archive_download_url"
          , Json.Encode.string rec.archive_download_url
          )
        , ( "created_at"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.created_at
          )
        , ( "expired", Json.Encode.bool rec.expired )
        , ( "expires_at"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.expires_at
          )
        , ( "id", Json.Encode.int rec.id )
        , ( "name", Json.Encode.string rec.name )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "size_in_bytes", Json.Encode.int rec.size_in_bytes )
        , ( "updated_at"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.updated_at
          )
        , ( "url", Json.Encode.string rec.url )
        , ( "workflow_run"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        (\rec0 ->
                            Json.Encode.object
                                [ ( "head_branch"
                                  , Json.Encode.string rec0.head_branch
                                  )
                                , ( "head_repository_id"
                                  , Json.Encode.int rec0.head_repository_id
                                  )
                                , ( "head_sha"
                                  , Json.Encode.string rec0.head_sha
                                  )
                                , ( "id", Json.Encode.int rec0.id )
                                , ( "repository_id"
                                  , Json.Encode.int rec0.repository_id
                                  )
                                ]
                        )
                            value
            )
                rec.workflow_run
          )
        ]


type alias AppPermissions =
    { actions : String
    , administration : String
    , checks : String
    , contents : String
    , deployments : String
    , environments : String
    , issues : String
    , members : String
    , metadata : String
    , organization_administration : String
    , organization_custom_roles : String
    , organization_hooks : String
    , organization_packages : String
    , organization_plan : String
    , organization_projects : String
    , organization_secrets : String
    , organization_self_hosted_runners : String
    , organization_user_blocking : String
    , packages : String
    , pages : String
    , pull_requests : String
    , repository_hooks : String
    , repository_projects : String
    , secret_scanning_alerts : String
    , secrets : String
    , security_events : String
    , single_file : String
    , statuses : String
    , team_discussions : String
    , vulnerability_alerts : String
    , workflows : String
    }


decodeAppPermissions : Json.Decode.Decoder AppPermissions
decodeAppPermissions =
    Json.Decode.succeed
     (\actions administration checks contents deployments environments issues members metadata organization_administration organization_custom_roles organization_hooks organization_packages organization_plan organization_projects organization_secrets organization_self_hosted_runners organization_user_blocking packages pages pull_requests repository_hooks repository_projects secret_scanning_alerts secrets security_events single_file statuses team_discussions vulnerability_alerts workflows ->
         { actions = actions
         , administration = administration
         , checks = checks
         , contents = contents
         , deployments = deployments
         , environments = environments
         , issues = issues
         , members = members
         , metadata = metadata
         , organization_administration = organization_administration
         , organization_custom_roles = organization_custom_roles
         , organization_hooks = organization_hooks
         , organization_packages = organization_packages
         , organization_plan = organization_plan
         , organization_projects = organization_projects
         , organization_secrets = organization_secrets
         , organization_self_hosted_runners = organization_self_hosted_runners
         , organization_user_blocking = organization_user_blocking
         , packages = packages
         , pages = pages
         , pull_requests = pull_requests
         , repository_hooks = repository_hooks
         , repository_projects = repository_projects
         , secret_scanning_alerts = secret_scanning_alerts
         , secrets = secrets
         , security_events = security_events
         , single_file = single_file
         , statuses = statuses
         , team_discussions = team_discussions
         , vulnerability_alerts = vulnerability_alerts
         , workflows = workflows
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "actions" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "administration" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "checks" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "contents" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "deployments" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "environments" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "issues" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "members" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "metadata" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "organization_administration" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "organization_custom_roles" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "organization_hooks" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "organization_packages" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "organization_plan" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "organization_projects" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "organization_secrets" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "organization_self_hosted_runners"
                Json.Decode.string
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "organization_user_blocking" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "packages" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "pages" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "pull_requests" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "repository_hooks" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "repository_projects" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "secret_scanning_alerts" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "secrets" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "security_events" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "single_file" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "statuses" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "team_discussions" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "vulnerability_alerts" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "workflows" Json.Decode.string)


encodeAppPermissions : AppPermissions -> Json.Encode.Value
encodeAppPermissions rec =
    Json.Encode.object
        [ ( "actions", Json.Encode.string rec.actions )
        , ( "administration", Json.Encode.string rec.administration )
        , ( "checks", Json.Encode.string rec.checks )
        , ( "contents", Json.Encode.string rec.contents )
        , ( "deployments", Json.Encode.string rec.deployments )
        , ( "environments", Json.Encode.string rec.environments )
        , ( "issues", Json.Encode.string rec.issues )
        , ( "members", Json.Encode.string rec.members )
        , ( "metadata", Json.Encode.string rec.metadata )
        , ( "organization_administration"
          , Json.Encode.string rec.organization_administration
          )
        , ( "organization_custom_roles"
          , Json.Encode.string rec.organization_custom_roles
          )
        , ( "organization_hooks", Json.Encode.string rec.organization_hooks )
        , ( "organization_packages"
          , Json.Encode.string rec.organization_packages
          )
        , ( "organization_plan", Json.Encode.string rec.organization_plan )
        , ( "organization_projects"
          , Json.Encode.string rec.organization_projects
          )
        , ( "organization_secrets"
          , Json.Encode.string rec.organization_secrets
          )
        , ( "organization_self_hosted_runners"
          , Json.Encode.string rec.organization_self_hosted_runners
          )
        , ( "organization_user_blocking"
          , Json.Encode.string rec.organization_user_blocking
          )
        , ( "packages", Json.Encode.string rec.packages )
        , ( "pages", Json.Encode.string rec.pages )
        , ( "pull_requests", Json.Encode.string rec.pull_requests )
        , ( "repository_hooks", Json.Encode.string rec.repository_hooks )
        , ( "repository_projects", Json.Encode.string rec.repository_projects )
        , ( "secret_scanning_alerts"
          , Json.Encode.string rec.secret_scanning_alerts
          )
        , ( "secrets", Json.Encode.string rec.secrets )
        , ( "security_events", Json.Encode.string rec.security_events )
        , ( "single_file", Json.Encode.string rec.single_file )
        , ( "statuses", Json.Encode.string rec.statuses )
        , ( "team_discussions", Json.Encode.string rec.team_discussions )
        , ( "vulnerability_alerts"
          , Json.Encode.string rec.vulnerability_alerts
          )
        , ( "workflows", Json.Encode.string rec.workflows )
        ]


type alias ApiOverview =
    { actions : List String
    , api : List String
    , dependabot : List String
    , git : List String
    , hooks : List String
    , importer : List String
    , packages : List String
    , pages : List String
    , ssh_key_fingerprints :
        { sHA256_DSA : String
        , sHA256_ECDSA : String
        , sHA256_ED25519 : String
        , sHA256_RSA : String
        }
    , ssh_keys : List String
    , verifiable_password_authentication : Bool
    , web : List String
    }


decodeApiOverview : Json.Decode.Decoder ApiOverview
decodeApiOverview =
    Json.Decode.succeed
     (\actions api dependabot git hooks importer packages pages ssh_key_fingerprints ssh_keys verifiable_password_authentication web ->
         { actions = actions
         , api = api
         , dependabot = dependabot
         , git = git
         , hooks = hooks
         , importer = importer
         , packages = packages
         , pages = pages
         , ssh_key_fingerprints = ssh_key_fingerprints
         , ssh_keys = ssh_keys
         , verifiable_password_authentication =
             verifiable_password_authentication
         , web = web
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "actions" (Json.Decode.list Json.Decode.string))
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "api" (Json.Decode.list Json.Decode.string))
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "dependabot"
                (Json.Decode.list Json.Decode.string)
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "git" (Json.Decode.list Json.Decode.string))
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "hooks" (Json.Decode.list Json.Decode.string))
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "importer" (Json.Decode.list Json.Decode.string))
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "packages" (Json.Decode.list Json.Decode.string))
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "pages" (Json.Decode.list Json.Decode.string))
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "ssh_key_fingerprints"
                (Json.Decode.succeed
                  (\sHA256_DSA sHA256_ECDSA sHA256_ED25519 sHA256_RSA ->
                      { sHA256_DSA = sHA256_DSA
                      , sHA256_ECDSA = sHA256_ECDSA
                      , sHA256_ED25519 = sHA256_ED25519
                      , sHA256_RSA = sHA256_RSA
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "SHA256_DSA" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "SHA256_ECDSA" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "SHA256_ED25519" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "SHA256_RSA" Json.Decode.string)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "ssh_keys" (Json.Decode.list Json.Decode.string))
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "verifiable_password_authentication"
                Json.Decode.bool
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "web" (Json.Decode.list Json.Decode.string))


encodeApiOverview : ApiOverview -> Json.Encode.Value
encodeApiOverview rec =
    Json.Encode.object
        [ ( "actions", Json.Encode.list Json.Encode.string rec.actions )
        , ( "api", Json.Encode.list Json.Encode.string rec.api )
        , ( "dependabot", Json.Encode.list Json.Encode.string rec.dependabot )
        , ( "git", Json.Encode.list Json.Encode.string rec.git )
        , ( "hooks", Json.Encode.list Json.Encode.string rec.hooks )
        , ( "importer", Json.Encode.list Json.Encode.string rec.importer )
        , ( "packages", Json.Encode.list Json.Encode.string rec.packages )
        , ( "pages", Json.Encode.list Json.Encode.string rec.pages )
        , ( "ssh_key_fingerprints"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "SHA256_DSA", Json.Encode.string rec0.sHA256_DSA )
                    , ( "SHA256_ECDSA", Json.Encode.string rec0.sHA256_ECDSA )
                    , ( "SHA256_ED25519"
                      , Json.Encode.string rec0.sHA256_ED25519
                      )
                    , ( "SHA256_RSA", Json.Encode.string rec0.sHA256_RSA )
                    ]
            )
                rec.ssh_key_fingerprints
          )
        , ( "ssh_keys", Json.Encode.list Json.Encode.string rec.ssh_keys )
        , ( "verifiable_password_authentication"
          , Json.Encode.bool rec.verifiable_password_authentication
          )
        , ( "web", Json.Encode.list Json.Encode.string rec.web )
        ]


type alias AllowedActions =
    String


decodeAllowedActions : Json.Decode.Decoder AllowedActions
decodeAllowedActions =
    Json.Decode.string


encodeAllowedActions : AllowedActions -> Json.Encode.Value
encodeAllowedActions =
    Json.Encode.string


type alias AlertUrl =
    String


decodeAlertUrl : Json.Decode.Decoder AlertUrl
decodeAlertUrl =
    Json.Decode.string


encodeAlertUrl : AlertUrl -> Json.Encode.Value
encodeAlertUrl =
    Json.Encode.string


type alias AlertUpdatedAt =
    String


decodeAlertUpdatedAt : Json.Decode.Decoder AlertUpdatedAt
decodeAlertUpdatedAt =
    Json.Decode.string


encodeAlertUpdatedAt : AlertUpdatedAt -> Json.Encode.Value
encodeAlertUpdatedAt =
    Json.Encode.string


type alias AlertNumber =
    Int


decodeAlertNumber : Json.Decode.Decoder AlertNumber
decodeAlertNumber =
    Json.Decode.int


encodeAlertNumber : AlertNumber -> Json.Encode.Value
encodeAlertNumber =
    Json.Encode.int


type alias AlertInstancesUrl =
    String


decodeAlertInstancesUrl : Json.Decode.Decoder AlertInstancesUrl
decodeAlertInstancesUrl =
    Json.Decode.string


encodeAlertInstancesUrl : AlertInstancesUrl -> Json.Encode.Value
encodeAlertInstancesUrl =
    Json.Encode.string


type alias AlertHtmlUrl =
    String


decodeAlertHtmlUrl : Json.Decode.Decoder AlertHtmlUrl
decodeAlertHtmlUrl =
    Json.Decode.string


encodeAlertHtmlUrl : AlertHtmlUrl -> Json.Encode.Value
encodeAlertHtmlUrl =
    Json.Encode.string


type alias AlertFixedAt =
    Nullable String


decodeAlertFixedAt : Json.Decode.Decoder AlertFixedAt
decodeAlertFixedAt =
    Json.Decode.oneOf
        [ Json.Decode.map Present Json.Decode.string, Json.Decode.null Null ]


encodeAlertFixedAt : AlertFixedAt -> Json.Encode.Value
encodeAlertFixedAt nullableValue =
    case nullableValue of
        Null ->
            Json.Encode.null

        Present value ->
            Json.Encode.string value


type alias AlertDismissedAt =
    Nullable String


decodeAlertDismissedAt : Json.Decode.Decoder AlertDismissedAt
decodeAlertDismissedAt =
    Json.Decode.oneOf
        [ Json.Decode.map Present Json.Decode.string, Json.Decode.null Null ]


encodeAlertDismissedAt : AlertDismissedAt -> Json.Encode.Value
encodeAlertDismissedAt nullableValue =
    case nullableValue of
        Null ->
            Json.Encode.null

        Present value ->
            Json.Encode.string value


type alias AlertCreatedAt =
    String


decodeAlertCreatedAt : Json.Decode.Decoder AlertCreatedAt
decodeAlertCreatedAt =
    Json.Decode.string


encodeAlertCreatedAt : AlertCreatedAt -> Json.Encode.Value
encodeAlertCreatedAt =
    Json.Encode.string


type alias AdvancedSecurityActiveCommittersUser =
    { last_pushed_date : String, user_login : String }


decodeAdvancedSecurityActiveCommittersUser :
    Json.Decode.Decoder AdvancedSecurityActiveCommittersUser
decodeAdvancedSecurityActiveCommittersUser =
    Json.Decode.succeed
     (\last_pushed_date user_login ->
         { last_pushed_date = last_pushed_date, user_login = user_login }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "last_pushed_date" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "user_login" Json.Decode.string)


encodeAdvancedSecurityActiveCommittersUser :
    AdvancedSecurityActiveCommittersUser -> Json.Encode.Value
encodeAdvancedSecurityActiveCommittersUser rec =
    Json.Encode.object
        [ ( "last_pushed_date", Json.Encode.string rec.last_pushed_date )
        , ( "user_login", Json.Encode.string rec.user_login )
        ]


type alias AdvancedSecurityActiveCommittersRepository =
    { advanced_security_committers : Int
    , advanced_security_committers_breakdown :
        List AdvancedSecurityActiveCommittersUser
    , name : String
    }


decodeAdvancedSecurityActiveCommittersRepository :
    Json.Decode.Decoder AdvancedSecurityActiveCommittersRepository
decodeAdvancedSecurityActiveCommittersRepository =
    Json.Decode.succeed
     (\advanced_security_committers advanced_security_committers_breakdown name ->
         { advanced_security_committers = advanced_security_committers
         , advanced_security_committers_breakdown =
             advanced_security_committers_breakdown
         , name = name
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "advanced_security_committers" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "advanced_security_committers_breakdown"
                (Json.Decode.list decodeAdvancedSecurityActiveCommittersUser)
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)


encodeAdvancedSecurityActiveCommittersRepository :
    AdvancedSecurityActiveCommittersRepository -> Json.Encode.Value
encodeAdvancedSecurityActiveCommittersRepository rec =
    Json.Encode.object
        [ ( "advanced_security_committers"
          , Json.Encode.int rec.advanced_security_committers
          )
        , ( "advanced_security_committers_breakdown"
          , Json.Encode.list encodeAdvancedSecurityActiveCommittersUser
                rec.advanced_security_committers_breakdown
          )
        , ( "name", Json.Encode.string rec.name )
        ]


type alias AdvancedSecurityActiveCommitters =
    { repositories : List AdvancedSecurityActiveCommittersRepository
    , total_advanced_security_committers : Int
    , total_count : Int
    }


decodeAdvancedSecurityActiveCommitters :
    Json.Decode.Decoder AdvancedSecurityActiveCommitters
decodeAdvancedSecurityActiveCommitters =
    Json.Decode.succeed
     (\repositories total_advanced_security_committers total_count ->
         { repositories = repositories
         , total_advanced_security_committers =
             total_advanced_security_committers
         , total_count = total_count
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "repositories"
                (Json.Decode.list
                    decodeAdvancedSecurityActiveCommittersRepository
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "total_advanced_security_committers"
                Json.Decode.int
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "total_count" Json.Decode.int)


encodeAdvancedSecurityActiveCommitters :
    AdvancedSecurityActiveCommitters -> Json.Encode.Value
encodeAdvancedSecurityActiveCommitters rec =
    Json.Encode.object
        [ ( "repositories"
          , Json.Encode.list encodeAdvancedSecurityActiveCommittersRepository
                rec.repositories
          )
        , ( "total_advanced_security_committers"
          , Json.Encode.int rec.total_advanced_security_committers
          )
        , ( "total_count", Json.Encode.int rec.total_count )
        ]


type alias AddedToProjectIssueEvent =
    { actor : SimpleUser
    , commit_id : Nullable String
    , commit_url : Nullable String
    , created_at : String
    , event : String
    , id : Int
    , node_id : String
    , performed_via_github_app : Nullable Integration
    , project_card :
        { column_name : String
        , id : Int
        , previous_column_name : String
        , project_id : Int
        , project_url : String
        , url : String
        }
    , url : String
    }


decodeAddedToProjectIssueEvent : Json.Decode.Decoder AddedToProjectIssueEvent
decodeAddedToProjectIssueEvent =
    Json.Decode.succeed
     (\actor commit_id commit_url created_at event id node_id performed_via_github_app project_card url ->
         { actor = actor
         , commit_id = commit_id
         , commit_url = commit_url
         , created_at = created_at
         , event = event
         , id = id
         , node_id = node_id
         , performed_via_github_app = performed_via_github_app
         , project_card = project_card
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap (Json.Decode.field "actor" decodeSimpleUser)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "commit_id"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "commit_url"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "event" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "node_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "performed_via_github_app"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present decodeIntegration
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "project_card"
                (Json.Decode.succeed
                  (\column_name id previous_column_name project_id project_url url ->
                      { column_name = column_name
                      , id = id
                      , previous_column_name = previous_column_name
                      , project_id = project_id
                      , project_url = project_url
                      , url = url
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "column_name" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "id" Json.Decode.int)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "previous_column_name"
                            Json.Decode.string
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "project_id" Json.Decode.int)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "project_url" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "url" Json.Decode.string)
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeAddedToProjectIssueEvent : AddedToProjectIssueEvent -> Json.Encode.Value
encodeAddedToProjectIssueEvent rec =
    Json.Encode.object
        [ ( "actor", encodeSimpleUser rec.actor )
        , ( "commit_id"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.commit_id
          )
        , ( "commit_url"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.commit_url
          )
        , ( "created_at", Json.Encode.string rec.created_at )
        , ( "event", Json.Encode.string rec.event )
        , ( "id", Json.Encode.int rec.id )
        , ( "node_id", Json.Encode.string rec.node_id )
        , ( "performed_via_github_app"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        encodeIntegration value
            )
                rec.performed_via_github_app
          )
        , ( "project_card"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "column_name", Json.Encode.string rec0.column_name )
                    , ( "id", Json.Encode.int rec0.id )
                    , ( "previous_column_name"
                      , Json.Encode.string rec0.previous_column_name
                      )
                    , ( "project_id", Json.Encode.int rec0.project_id )
                    , ( "project_url", Json.Encode.string rec0.project_url )
                    , ( "url", Json.Encode.string rec0.url )
                    ]
            )
                rec.project_card
          )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias Actor =
    { avatar_url : String
    , display_login : String
    , gravatar_id : Nullable String
    , id : Int
    , login : String
    , url : String
    }


decodeActor : Json.Decode.Decoder Actor
decodeActor =
    Json.Decode.succeed
     (\avatar_url display_login gravatar_id id login url ->
         { avatar_url = avatar_url
         , display_login = display_login
         , gravatar_id = gravatar_id
         , id = id
         , login = login
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "avatar_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "display_login" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "gravatar_id"
                (Json.Decode.oneOf
                    [ Json.Decode.map Present Json.Decode.string
                    , Json.Decode.null Null
                    ]
                )
            )
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "login" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeActor : Actor -> Json.Encode.Value
encodeActor rec =
    Json.Encode.object
        [ ( "avatar_url", Json.Encode.string rec.avatar_url )
        , ( "display_login", Json.Encode.string rec.display_login )
        , ( "gravatar_id"
          , (\nullableValue ->
                case nullableValue of
                    Null ->
                        Json.Encode.null

                    Present value ->
                        Json.Encode.string value
            )
                rec.gravatar_id
          )
        , ( "id", Json.Encode.int rec.id )
        , ( "login", Json.Encode.string rec.login )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias ActionsWorkflowAccessToRepository =
    { access_level : String }


decodeActionsWorkflowAccessToRepository :
    Json.Decode.Decoder ActionsWorkflowAccessToRepository
decodeActionsWorkflowAccessToRepository =
    Json.Decode.succeed (\access_level -> { access_level = access_level })
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "access_level" Json.Decode.string)


encodeActionsWorkflowAccessToRepository :
    ActionsWorkflowAccessToRepository -> Json.Encode.Value
encodeActionsWorkflowAccessToRepository rec =
    Json.Encode.object
        [ ( "access_level", Json.Encode.string rec.access_level ) ]


type alias ActionsSetDefaultWorkflowPermissions =
    { can_approve_pull_request_reviews : ActionsCanApprovePullRequestReviews
    , default_workflow_permissions : ActionsDefaultWorkflowPermissions
    }


decodeActionsSetDefaultWorkflowPermissions :
    Json.Decode.Decoder ActionsSetDefaultWorkflowPermissions
decodeActionsSetDefaultWorkflowPermissions =
    Json.Decode.succeed
     (\can_approve_pull_request_reviews default_workflow_permissions ->
         { can_approve_pull_request_reviews = can_approve_pull_request_reviews
         , default_workflow_permissions = default_workflow_permissions
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "can_approve_pull_request_reviews"
                decodeActionsCanApprovePullRequestReviews
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "default_workflow_permissions"
                decodeActionsDefaultWorkflowPermissions
            )


encodeActionsSetDefaultWorkflowPermissions :
    ActionsSetDefaultWorkflowPermissions -> Json.Encode.Value
encodeActionsSetDefaultWorkflowPermissions rec =
    Json.Encode.object
        [ ( "can_approve_pull_request_reviews"
          , encodeActionsCanApprovePullRequestReviews
                rec.can_approve_pull_request_reviews
          )
        , ( "default_workflow_permissions"
          , encodeActionsDefaultWorkflowPermissions
                rec.default_workflow_permissions
          )
        ]


type alias ActionsSecret =
    { created_at : String, name : String, updated_at : String }


decodeActionsSecret : Json.Decode.Decoder ActionsSecret
decodeActionsSecret =
    Json.Decode.succeed
     (\created_at name updated_at ->
         { created_at = created_at, name = name, updated_at = updated_at }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "name" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "updated_at" Json.Decode.string)


encodeActionsSecret : ActionsSecret -> Json.Encode.Value
encodeActionsSecret rec =
    Json.Encode.object
        [ ( "created_at", Json.Encode.string rec.created_at )
        , ( "name", Json.Encode.string rec.name )
        , ( "updated_at", Json.Encode.string rec.updated_at )
        ]


type alias ActionsRepositoryPermissions =
    { allowed_actions : AllowedActions
    , enabled : ActionsEnabled
    , selected_actions_url : SelectedActionsUrl
    }


decodeActionsRepositoryPermissions :
    Json.Decode.Decoder ActionsRepositoryPermissions
decodeActionsRepositoryPermissions =
    Json.Decode.succeed
     (\allowed_actions enabled selected_actions_url ->
         { allowed_actions = allowed_actions
         , enabled = enabled
         , selected_actions_url = selected_actions_url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "allowed_actions" decodeAllowedActions)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "enabled" decodeActionsEnabled)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "selected_actions_url" decodeSelectedActionsUrl)


encodeActionsRepositoryPermissions :
    ActionsRepositoryPermissions -> Json.Encode.Value
encodeActionsRepositoryPermissions rec =
    Json.Encode.object
        [ ( "allowed_actions", encodeAllowedActions rec.allowed_actions )
        , ( "enabled", encodeActionsEnabled rec.enabled )
        , ( "selected_actions_url"
          , encodeSelectedActionsUrl rec.selected_actions_url
          )
        ]


type alias ActionsPublicKey =
    { created_at : String
    , id : Int
    , key : String
    , key_id : String
    , title : String
    , url : String
    }


decodeActionsPublicKey : Json.Decode.Decoder ActionsPublicKey
decodeActionsPublicKey =
    Json.Decode.succeed
     (\created_at id key key_id title url ->
         { created_at = created_at
         , id = id
         , key = key
         , key_id = key_id
         , title = title
         , url = url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "created_at" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "id" Json.Decode.int)
        |> Json.Decode.Extra.andMap (Json.Decode.field "key" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "key_id" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "title" Json.Decode.string)
        |> Json.Decode.Extra.andMap (Json.Decode.field "url" Json.Decode.string)


encodeActionsPublicKey : ActionsPublicKey -> Json.Encode.Value
encodeActionsPublicKey rec =
    Json.Encode.object
        [ ( "created_at", Json.Encode.string rec.created_at )
        , ( "id", Json.Encode.int rec.id )
        , ( "key", Json.Encode.string rec.key )
        , ( "key_id", Json.Encode.string rec.key_id )
        , ( "title", Json.Encode.string rec.title )
        , ( "url", Json.Encode.string rec.url )
        ]


type alias ActionsOrganizationPermissions =
    { allowed_actions : AllowedActions
    , enabled_repositories : EnabledRepositories
    , selected_actions_url : SelectedActionsUrl
    , selected_repositories_url : String
    }


decodeActionsOrganizationPermissions :
    Json.Decode.Decoder ActionsOrganizationPermissions
decodeActionsOrganizationPermissions =
    Json.Decode.succeed
     (\allowed_actions enabled_repositories selected_actions_url selected_repositories_url ->
         { allowed_actions = allowed_actions
         , enabled_repositories = enabled_repositories
         , selected_actions_url = selected_actions_url
         , selected_repositories_url = selected_repositories_url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "allowed_actions" decodeAllowedActions)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "enabled_repositories" decodeEnabledRepositories)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "selected_actions_url" decodeSelectedActionsUrl)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "selected_repositories_url" Json.Decode.string)


encodeActionsOrganizationPermissions :
    ActionsOrganizationPermissions -> Json.Encode.Value
encodeActionsOrganizationPermissions rec =
    Json.Encode.object
        [ ( "allowed_actions", encodeAllowedActions rec.allowed_actions )
        , ( "enabled_repositories"
          , encodeEnabledRepositories rec.enabled_repositories
          )
        , ( "selected_actions_url"
          , encodeSelectedActionsUrl rec.selected_actions_url
          )
        , ( "selected_repositories_url"
          , Json.Encode.string rec.selected_repositories_url
          )
        ]


type alias ActionsGetDefaultWorkflowPermissions =
    { can_approve_pull_request_reviews : ActionsCanApprovePullRequestReviews
    , default_workflow_permissions : ActionsDefaultWorkflowPermissions
    }


decodeActionsGetDefaultWorkflowPermissions :
    Json.Decode.Decoder ActionsGetDefaultWorkflowPermissions
decodeActionsGetDefaultWorkflowPermissions =
    Json.Decode.succeed
     (\can_approve_pull_request_reviews default_workflow_permissions ->
         { can_approve_pull_request_reviews = can_approve_pull_request_reviews
         , default_workflow_permissions = default_workflow_permissions
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "can_approve_pull_request_reviews"
                decodeActionsCanApprovePullRequestReviews
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "default_workflow_permissions"
                decodeActionsDefaultWorkflowPermissions
            )


encodeActionsGetDefaultWorkflowPermissions :
    ActionsGetDefaultWorkflowPermissions -> Json.Encode.Value
encodeActionsGetDefaultWorkflowPermissions rec =
    Json.Encode.object
        [ ( "can_approve_pull_request_reviews"
          , encodeActionsCanApprovePullRequestReviews
                rec.can_approve_pull_request_reviews
          )
        , ( "default_workflow_permissions"
          , encodeActionsDefaultWorkflowPermissions
                rec.default_workflow_permissions
          )
        ]


type alias ActionsEnterprisePermissions =
    { allowed_actions : AllowedActions
    , enabled_organizations : EnabledOrganizations
    , selected_actions_url : SelectedActionsUrl
    , selected_organizations_url : String
    }


decodeActionsEnterprisePermissions :
    Json.Decode.Decoder ActionsEnterprisePermissions
decodeActionsEnterprisePermissions =
    Json.Decode.succeed
     (\allowed_actions enabled_organizations selected_actions_url selected_organizations_url ->
         { allowed_actions = allowed_actions
         , enabled_organizations = enabled_organizations
         , selected_actions_url = selected_actions_url
         , selected_organizations_url = selected_organizations_url
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "allowed_actions" decodeAllowedActions)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "enabled_organizations"
                decodeEnabledOrganizations
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "selected_actions_url" decodeSelectedActionsUrl)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "selected_organizations_url" Json.Decode.string)


encodeActionsEnterprisePermissions :
    ActionsEnterprisePermissions -> Json.Encode.Value
encodeActionsEnterprisePermissions rec =
    Json.Encode.object
        [ ( "allowed_actions", encodeAllowedActions rec.allowed_actions )
        , ( "enabled_organizations"
          , encodeEnabledOrganizations rec.enabled_organizations
          )
        , ( "selected_actions_url"
          , encodeSelectedActionsUrl rec.selected_actions_url
          )
        , ( "selected_organizations_url"
          , Json.Encode.string rec.selected_organizations_url
          )
        ]


type alias ActionsEnabled =
    Bool


decodeActionsEnabled : Json.Decode.Decoder ActionsEnabled
decodeActionsEnabled =
    Json.Decode.bool


encodeActionsEnabled : ActionsEnabled -> Json.Encode.Value
encodeActionsEnabled =
    Json.Encode.bool


type alias ActionsDefaultWorkflowPermissions =
    String


decodeActionsDefaultWorkflowPermissions :
    Json.Decode.Decoder ActionsDefaultWorkflowPermissions
decodeActionsDefaultWorkflowPermissions =
    Json.Decode.string


encodeActionsDefaultWorkflowPermissions :
    ActionsDefaultWorkflowPermissions -> Json.Encode.Value
encodeActionsDefaultWorkflowPermissions =
    Json.Encode.string


type alias ActionsCanApprovePullRequestReviews =
    Bool


decodeActionsCanApprovePullRequestReviews :
    Json.Decode.Decoder ActionsCanApprovePullRequestReviews
decodeActionsCanApprovePullRequestReviews =
    Json.Decode.bool


encodeActionsCanApprovePullRequestReviews :
    ActionsCanApprovePullRequestReviews -> Json.Encode.Value
encodeActionsCanApprovePullRequestReviews =
    Json.Encode.bool


type alias ActionsCacheUsageOrgEnterprise =
    { total_active_caches_count : Int, total_active_caches_size_in_bytes : Int }


decodeActionsCacheUsageOrgEnterprise :
    Json.Decode.Decoder ActionsCacheUsageOrgEnterprise
decodeActionsCacheUsageOrgEnterprise =
    Json.Decode.succeed
     (\total_active_caches_count total_active_caches_size_in_bytes ->
         { total_active_caches_count = total_active_caches_count
         , total_active_caches_size_in_bytes = total_active_caches_size_in_bytes
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "total_active_caches_count" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "total_active_caches_size_in_bytes"
                Json.Decode.int
            )


encodeActionsCacheUsageOrgEnterprise :
    ActionsCacheUsageOrgEnterprise -> Json.Encode.Value
encodeActionsCacheUsageOrgEnterprise rec =
    Json.Encode.object
        [ ( "total_active_caches_count"
          , Json.Encode.int rec.total_active_caches_count
          )
        , ( "total_active_caches_size_in_bytes"
          , Json.Encode.int rec.total_active_caches_size_in_bytes
          )
        ]


type alias ActionsCacheUsageByRepository =
    { active_caches_count : Int
    , active_caches_size_in_bytes : Int
    , full_name : String
    }


decodeActionsCacheUsageByRepository :
    Json.Decode.Decoder ActionsCacheUsageByRepository
decodeActionsCacheUsageByRepository =
    Json.Decode.succeed
     (\active_caches_count active_caches_size_in_bytes full_name ->
         { active_caches_count = active_caches_count
         , active_caches_size_in_bytes = active_caches_size_in_bytes
         , full_name = full_name
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "active_caches_count" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "active_caches_size_in_bytes" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "full_name" Json.Decode.string)


encodeActionsCacheUsageByRepository :
    ActionsCacheUsageByRepository -> Json.Encode.Value
encodeActionsCacheUsageByRepository rec =
    Json.Encode.object
        [ ( "active_caches_count", Json.Encode.int rec.active_caches_count )
        , ( "active_caches_size_in_bytes"
          , Json.Encode.int rec.active_caches_size_in_bytes
          )
        , ( "full_name", Json.Encode.string rec.full_name )
        ]


type alias ActionsCacheList =
    { actions_caches :
        List { created_at : String
        , id : Int
        , key : String
        , last_accessed_at : String
        , ref : String
        , size_in_bytes : Int
        , version : String
        }
    , total_count : Int
    }


decodeActionsCacheList : Json.Decode.Decoder ActionsCacheList
decodeActionsCacheList =
    Json.Decode.succeed
     (\actions_caches total_count ->
         { actions_caches = actions_caches, total_count = total_count }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "actions_caches"
                (Json.Decode.list
                    (Json.Decode.succeed
                      (\created_at id key last_accessed_at ref size_in_bytes version ->
                          { created_at = created_at
                          , id = id
                          , key = key
                          , last_accessed_at = last_accessed_at
                          , ref = ref
                          , size_in_bytes = size_in_bytes
                          , version = version
                          }
                      )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "created_at" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "id" Json.Decode.int)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "key" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field
                                "last_accessed_at"
                                Json.Decode.string
                            )
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "ref" Json.Decode.string)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "size_in_bytes" Json.Decode.int)
                        |> Json.Decode.Extra.andMap
                            (Json.Decode.field "version" Json.Decode.string)
                    )
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "total_count" Json.Decode.int)


encodeActionsCacheList : ActionsCacheList -> Json.Encode.Value
encodeActionsCacheList rec =
    Json.Encode.object
        [ ( "actions_caches"
          , Json.Encode.list
                (\rec0 ->
                    Json.Encode.object
                        [ ( "created_at", Json.Encode.string rec0.created_at )
                        , ( "id", Json.Encode.int rec0.id )
                        , ( "key", Json.Encode.string rec0.key )
                        , ( "last_accessed_at"
                          , Json.Encode.string rec0.last_accessed_at
                          )
                        , ( "ref", Json.Encode.string rec0.ref )
                        , ( "size_in_bytes"
                          , Json.Encode.int rec0.size_in_bytes
                          )
                        , ( "version", Json.Encode.string rec0.version )
                        ]
                )
                rec.actions_caches
          )
        , ( "total_count", Json.Encode.int rec.total_count )
        ]


type alias ActionsBillingUsage =
    { included_minutes : Int
    , minutes_used_breakdown :
        { mACOS : Int
        , uBUNTU : Int
        , wINDOWS : Int
        , total : Int
        , ubuntu_16_core : Int
        , ubuntu_32_core : Int
        , ubuntu_4_core : Int
        , ubuntu_64_core : Int
        , ubuntu_8_core : Int
        , windows_16_core : Int
        , windows_32_core : Int
        , windows_4_core : Int
        , windows_64_core : Int
        , windows_8_core : Int
        }
    , total_minutes_used : Int
    , total_paid_minutes_used : Int
    }


decodeActionsBillingUsage : Json.Decode.Decoder ActionsBillingUsage
decodeActionsBillingUsage =
    Json.Decode.succeed
     (\included_minutes minutes_used_breakdown total_minutes_used total_paid_minutes_used ->
         { included_minutes = included_minutes
         , minutes_used_breakdown = minutes_used_breakdown
         , total_minutes_used = total_minutes_used
         , total_paid_minutes_used = total_paid_minutes_used
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "included_minutes" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "minutes_used_breakdown"
                (Json.Decode.succeed
                  (\mACOS uBUNTU wINDOWS total ubuntu_16_core ubuntu_32_core ubuntu_4_core ubuntu_64_core ubuntu_8_core windows_16_core windows_32_core windows_4_core windows_64_core windows_8_core ->
                      { mACOS = mACOS
                      , uBUNTU = uBUNTU
                      , wINDOWS = wINDOWS
                      , total = total
                      , ubuntu_16_core = ubuntu_16_core
                      , ubuntu_32_core = ubuntu_32_core
                      , ubuntu_4_core = ubuntu_4_core
                      , ubuntu_64_core = ubuntu_64_core
                      , ubuntu_8_core = ubuntu_8_core
                      , windows_16_core = windows_16_core
                      , windows_32_core = windows_32_core
                      , windows_4_core = windows_4_core
                      , windows_64_core = windows_64_core
                      , windows_8_core = windows_8_core
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "MACOS" Json.Decode.int)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "UBUNTU" Json.Decode.int)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "WINDOWS" Json.Decode.int)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "total" Json.Decode.int)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "ubuntu_16_core" Json.Decode.int)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "ubuntu_32_core" Json.Decode.int)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "ubuntu_4_core" Json.Decode.int)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "ubuntu_64_core" Json.Decode.int)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "ubuntu_8_core" Json.Decode.int)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "windows_16_core" Json.Decode.int)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "windows_32_core" Json.Decode.int)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "windows_4_core" Json.Decode.int)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "windows_64_core" Json.Decode.int)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "windows_8_core" Json.Decode.int)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "total_minutes_used" Json.Decode.int)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "total_paid_minutes_used" Json.Decode.int)


encodeActionsBillingUsage : ActionsBillingUsage -> Json.Encode.Value
encodeActionsBillingUsage rec =
    Json.Encode.object
        [ ( "included_minutes", Json.Encode.int rec.included_minutes )
        , ( "minutes_used_breakdown"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "MACOS", Json.Encode.int rec0.mACOS )
                    , ( "UBUNTU", Json.Encode.int rec0.uBUNTU )
                    , ( "WINDOWS", Json.Encode.int rec0.wINDOWS )
                    , ( "total", Json.Encode.int rec0.total )
                    , ( "ubuntu_16_core", Json.Encode.int rec0.ubuntu_16_core )
                    , ( "ubuntu_32_core", Json.Encode.int rec0.ubuntu_32_core )
                    , ( "ubuntu_4_core", Json.Encode.int rec0.ubuntu_4_core )
                    , ( "ubuntu_64_core", Json.Encode.int rec0.ubuntu_64_core )
                    , ( "ubuntu_8_core", Json.Encode.int rec0.ubuntu_8_core )
                    , ( "windows_16_core"
                      , Json.Encode.int rec0.windows_16_core
                      )
                    , ( "windows_32_core"
                      , Json.Encode.int rec0.windows_32_core
                      )
                    , ( "windows_4_core", Json.Encode.int rec0.windows_4_core )
                    , ( "windows_64_core"
                      , Json.Encode.int rec0.windows_64_core
                      )
                    , ( "windows_8_core", Json.Encode.int rec0.windows_8_core )
                    ]
            )
                rec.minutes_used_breakdown
          )
        , ( "total_minutes_used", Json.Encode.int rec.total_minutes_used )
        , ( "total_paid_minutes_used"
          , Json.Encode.int rec.total_paid_minutes_used
          )
        ]


type alias ValidationFailedSimple =
    ValidationErrorSimple


decodeValidationFailedSimple : Json.Decode.Decoder ValidationFailedSimple
decodeValidationFailedSimple =
    decodeValidationErrorSimple


encodeValidationFailedSimple : ValidationFailedSimple -> Json.Encode.Value
encodeValidationFailedSimple =
    encodeValidationErrorSimple


type alias ValidationFailed =
    ValidationError


decodeValidationFailed : Json.Decode.Decoder ValidationFailed
decodeValidationFailed =
    decodeValidationError


encodeValidationFailed : ValidationFailed -> Json.Encode.Value
encodeValidationFailed =
    encodeValidationError


type alias TemporaryRedirect =
    BasicError


decodeTemporaryRedirect : Json.Decode.Decoder TemporaryRedirect
decodeTemporaryRedirect =
    decodeBasicError


encodeTemporaryRedirect : TemporaryRedirect -> Json.Encode.Value
encodeTemporaryRedirect =
    encodeBasicError


type alias ServiceUnavailable =
    { code : String, documentation_url : String, message : String }


decodeServiceUnavailable : Json.Decode.Decoder ServiceUnavailable
decodeServiceUnavailable =
    Json.Decode.succeed
     (\code documentation_url message ->
         { code = code
         , documentation_url = documentation_url
         , message = message
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "code" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "documentation_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "message" Json.Decode.string)


encodeServiceUnavailable : ServiceUnavailable -> Json.Encode.Value
encodeServiceUnavailable rec =
    Json.Encode.object
        [ ( "code", Json.Encode.string rec.code )
        , ( "documentation_url", Json.Encode.string rec.documentation_url )
        , ( "message", Json.Encode.string rec.message )
        ]


type alias RequiresAuthentication =
    BasicError


decodeRequiresAuthentication : Json.Decode.Decoder RequiresAuthentication
decodeRequiresAuthentication =
    decodeBasicError


encodeRequiresAuthentication : RequiresAuthentication -> Json.Encode.Value
encodeRequiresAuthentication =
    encodeBasicError


type alias NotFound =
    BasicError


decodeNotFound : Json.Decode.Decoder NotFound
decodeNotFound =
    decodeBasicError


encodeNotFound : NotFound -> Json.Encode.Value
encodeNotFound =
    encodeBasicError


type alias MovedPermanently =
    BasicError


decodeMovedPermanently : Json.Decode.Decoder MovedPermanently
decodeMovedPermanently =
    decodeBasicError


encodeMovedPermanently : MovedPermanently -> Json.Encode.Value
encodeMovedPermanently =
    encodeBasicError


type alias InternalError =
    BasicError


decodeInternalError : Json.Decode.Decoder InternalError
decodeInternalError =
    decodeBasicError


encodeInternalError : InternalError -> Json.Encode.Value
encodeInternalError =
    encodeBasicError


type alias Gone =
    BasicError


decodeGone : Json.Decode.Decoder Gone
decodeGone =
    decodeBasicError


encodeGone : Gone -> Json.Encode.Value
encodeGone =
    encodeBasicError


type alias ForbiddenGist =
    { block :
        { created_at : String, html_url : Nullable String, reason : String }
    , documentation_url : String
    , message : String
    }


decodeForbiddenGist : Json.Decode.Decoder ForbiddenGist
decodeForbiddenGist =
    Json.Decode.succeed
     (\block documentation_url message ->
         { block = block
         , documentation_url = documentation_url
         , message = message
         }
     )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field
                "block"
                (Json.Decode.succeed
                  (\created_at html_url reason ->
                      { created_at = created_at
                      , html_url = html_url
                      , reason = reason
                      }
                  )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "created_at" Json.Decode.string)
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field
                            "html_url"
                            (Json.Decode.oneOf
                                [ Json.Decode.map Present Json.Decode.string
                                , Json.Decode.null Null
                                ]
                            )
                        )
                    |> Json.Decode.Extra.andMap
                        (Json.Decode.field "reason" Json.Decode.string)
                )
            )
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "documentation_url" Json.Decode.string)
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "message" Json.Decode.string)


encodeForbiddenGist : ForbiddenGist -> Json.Encode.Value
encodeForbiddenGist rec =
    Json.Encode.object
        [ ( "block"
          , (\rec0 ->
                Json.Encode.object
                    [ ( "created_at", Json.Encode.string rec0.created_at )
                    , ( "html_url"
                      , (\nullableValue ->
                            case nullableValue of
                                Null ->
                                    Json.Encode.null

                                Present value ->
                                    Json.Encode.string value
                        )
                            rec0.html_url
                      )
                    , ( "reason", Json.Encode.string rec0.reason )
                    ]
            )
                rec.block
          )
        , ( "documentation_url", Json.Encode.string rec.documentation_url )
        , ( "message", Json.Encode.string rec.message )
        ]


type alias Forbidden =
    BasicError


decodeForbidden : Json.Decode.Decoder Forbidden
decodeForbidden =
    decodeBasicError


encodeForbidden : Forbidden -> Json.Encode.Value
encodeForbidden =
    encodeBasicError


type alias Conflict =
    BasicError


decodeConflict : Json.Decode.Decoder Conflict
decodeConflict =
    decodeBasicError


encodeConflict : Conflict -> Json.Encode.Value
encodeConflict =
    encodeBasicError


type alias CodeScanningForbiddenWrite =
    BasicError


decodeCodeScanningForbiddenWrite :
    Json.Decode.Decoder CodeScanningForbiddenWrite
decodeCodeScanningForbiddenWrite =
    decodeBasicError


encodeCodeScanningForbiddenWrite :
    CodeScanningForbiddenWrite -> Json.Encode.Value
encodeCodeScanningForbiddenWrite =
    encodeBasicError


type alias CodeScanningForbiddenRead =
    BasicError


decodeCodeScanningForbiddenRead : Json.Decode.Decoder CodeScanningForbiddenRead
decodeCodeScanningForbiddenRead =
    decodeBasicError


encodeCodeScanningForbiddenRead : CodeScanningForbiddenRead -> Json.Encode.Value
encodeCodeScanningForbiddenRead =
    encodeBasicError


type alias BadRequest =
    BasicError


decodeBadRequest : Json.Decode.Decoder BadRequest
decodeBadRequest =
    decodeBasicError


encodeBadRequest : BadRequest -> Json.Encode.Value
encodeBadRequest =
    encodeBasicError


type alias ActionsRunnerLabelsReadonly =
    { labels : List RunnerLabel, total_count : Int }


decodeActionsRunnerLabelsReadonly :
    Json.Decode.Decoder ActionsRunnerLabelsReadonly
decodeActionsRunnerLabelsReadonly =
    Json.Decode.succeed
     (\labels total_count -> { labels = labels, total_count = total_count })
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "labels" (Json.Decode.list decodeRunnerLabel))
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "total_count" Json.Decode.int)


encodeActionsRunnerLabelsReadonly :
    ActionsRunnerLabelsReadonly -> Json.Encode.Value
encodeActionsRunnerLabelsReadonly rec =
    Json.Encode.object
        [ ( "labels", Json.Encode.list encodeRunnerLabel rec.labels )
        , ( "total_count", Json.Encode.int rec.total_count )
        ]


type alias ActionsRunnerLabels =
    { labels : List RunnerLabel, total_count : Int }


decodeActionsRunnerLabels : Json.Decode.Decoder ActionsRunnerLabels
decodeActionsRunnerLabels =
    Json.Decode.succeed
     (\labels total_count -> { labels = labels, total_count = total_count })
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "labels" (Json.Decode.list decodeRunnerLabel))
        |> Json.Decode.Extra.andMap
            (Json.Decode.field "total_count" Json.Decode.int)


encodeActionsRunnerLabels : ActionsRunnerLabels -> Json.Encode.Value
encodeActionsRunnerLabels rec =
    Json.Encode.object
        [ ( "labels", Json.Encode.list encodeRunnerLabel rec.labels )
        , ( "total_count", Json.Encode.int rec.total_count )
        ]


type alias Accepted =
    {}


decodeAccepted : Json.Decode.Decoder Accepted
decodeAccepted =
    Json.Decode.succeed {}


encodeAccepted : Accepted -> Json.Encode.Value
encodeAccepted rec =
    Json.Encode.object []


type EnumTwo one two
    = EnumTwoOne one
    | EnumTwoTwo two


type EnumThree one two three
    = EnumThreeOne one
    | EnumThreeTwo two
    | EnumThreeThree three


type EnumFifteen one two three four five six seven eight nine ten eleven twelve thirteen fourteen fifteen
    = EnumFifteenOne one
    | EnumFifteenTwo two
    | EnumFifteenThree three
    | EnumFifteenFour four
    | EnumFifteenFive five
    | EnumFifteenSix six
    | EnumFifteenSeven seven
    | EnumFifteenEight eight
    | EnumFifteenNine nine
    | EnumFifteenTen ten
    | EnumFifteenEleven eleven
    | EnumFifteenTwelve twelve
    | EnumFifteenThirteen thirteen
    | EnumFifteenFourteen fourteen
    | EnumFifteenFifteen fifteen


