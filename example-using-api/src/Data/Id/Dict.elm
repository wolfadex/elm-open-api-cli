module Data.Id.Dict exposing
    ( empty, singleton, insert, update, remove
    , IdDict
    , MessageIdDict
    , ThreadIdDict
    , UserIdDict
    , keys, values, toList, fromList
    , isEmpty, member, get, size
    , map, foldl, foldr, filter, partition
    )

{-| Dict types keyed by an opaque Id.

Mostly generated by miniBill/elm-generic-dict.


## Build

@docs empty, singleton, insert, update, remove


## Dictionaries

@docs IdDict

@docs MessageIdDict
@docs ThreadIdDict
@docs UserIdDict


## Lists

@docs keys, values, toList, fromList


## Query

@docs isEmpty, member, get, size


## Transform

@docs map, foldl, foldr, filter, partition

-}

import Data.Id as Id exposing (Id)
import Data.Id.Internal as Internal
import Dict


type alias MessageIdDict v =
    IdDict Internal.MessageTag v


type alias ThreadIdDict v =
    IdDict Internal.ThreadTag v


type alias UserIdDict v =
    IdDict Internal.UserTag v


type IdDict tag v
    = IdDict (Dict.Dict String ( Id tag, v ))


empty : IdDict tag v
empty =
    IdDict Dict.empty


singleton : Id tag -> v -> IdDict tag v
singleton key value =
    IdDict (Dict.singleton (Id.toString key) ( key, value ))


insert : Id tag -> v -> IdDict tag v -> IdDict tag v
insert key value d =
    case d of
        IdDict dict ->
            IdDict (Dict.insert (Id.toString key) ( key, value ) dict)


update : Id tag -> (Maybe b -> Maybe b) -> IdDict tag b -> IdDict tag b
update key f d =
    case d of
        IdDict dict ->
            IdDict
                (Dict.update
                    (Data.Id.toString key)
                    (\updateUnpack ->
                        Maybe.map
                            (Tuple.pair key)
                            (f (Maybe.map Tuple.second updateUnpack))
                    )
                    dict
                )


remove : Id tag -> IdDict tag v -> IdDict tag v
remove key d =
    case d of
        IdDict dict ->
            IdDict (Dict.remove (Data.Id.toString key) dict)


isEmpty : IdDict tag v -> Bool
isEmpty d =
    case d of
        IdDict dict ->
            Dict.isEmpty dict


member : Id tag -> IdDict tag v -> Bool
member key d =
    case d of
        IdDict dict ->
            Dict.member (Data.Id.toString key) dict


get : Id tag -> IdDict tag b -> Maybe b
get key d =
    case d of
        IdDict dict ->
            Maybe.map Tuple.second (Dict.get (Data.Id.toString key) dict)


size : IdDict tag v -> Int
size d =
    case d of
        IdDict dict ->
            Dict.size dict


keys : IdDict tag v -> List (Id tag)
keys d =
    case d of
        IdDict dict ->
            List.map Tuple.first (Dict.values dict)


values : IdDict tag v -> List v
values d =
    case d of
        IdDict dict ->
            List.map Tuple.second (Dict.values dict)


toList : IdDict tag v -> List ( Id tag, v )
toList d =
    case d of
        IdDict dict ->
            Dict.values dict


fromList : List ( Id tag, v ) -> IdDict tag v
fromList l =
    IdDict
        (Dict.fromList
            (List.map
                (\e ->
                    let
                        ( k, _ ) =
                            e
                    in
                    ( Data.Id.toString k, e )
                )
                l
            )
        )


map : (Id tag -> a -> b) -> IdDict tag a -> IdDict tag b
map f d =
    case d of
        IdDict dict ->
            IdDict
                (Dict.map
                    (\_ ->
                        \unpack ->
                            let
                                ( k, a ) =
                                    unpack
                            in
                            ( k, f k a )
                    )
                    dict
                )


foldl : (Id tag -> v -> b -> b) -> b -> IdDict tag v -> b
foldl f b0 d =
    case d of
        IdDict dict ->
            Dict.foldl
                (\_ kv b ->
                    let
                        ( k, v ) =
                            kv
                    in
                    f k v b
                )
                b0
                dict


foldr : (Id tag -> v -> b -> b) -> b -> IdDict tag v -> b
foldr f b0 d =
    case d of
        IdDict dict ->
            Dict.foldr
                (\_ kv b ->
                    let
                        ( k, v ) =
                            kv
                    in
                    f k v b
                )
                b0
                dict


filter : (Id tag -> v -> Bool) -> IdDict tag v -> IdDict tag v
filter f d =
    IdDict
        (case d of
            IdDict dict ->
                Dict.filter
                    (\_ ->
                        \unpack ->
                            let
                                ( k, v ) =
                                    unpack
                            in
                            f k v
                    )
                    dict
        )


partition :
    (Id tag -> v -> Bool)
    -> IdDict tag v
    -> ( IdDict tag v, IdDict tag v )
partition f d =
    case d of
        IdDict dict ->
            Tuple.mapBoth
                IdDict
                IdDict
                (Dict.partition
                    (\_ ->
                        \unpack ->
                            let
                                ( k, v ) =
                                    unpack
                            in
                            f k v
                    )
                    dict
                )
